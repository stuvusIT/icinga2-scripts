#!/usr/bin/env python2
# -*- coding: utf-8 -*-

# Copyright (C) 2013-2015 Matthias Bolte <matthias@tinkerforge.com>
#
# Version 2.1.23
#
# Redistribution and use in source and binary forms of this file,
# with or without modification, are permitted. See the Creative
# Commons Zero (CC0 1.0) License for more details.

import sys
import os
import signal
import time
import shlex
import socket
import select
import threading
import subprocess
import textwrap

# error codes are also used as exit codes, valid values are [1..255]
ERROR_INTERRUPTED = 1
ERROR_SYNTAX_ERROR = 2
ERROR_PYTHON_VERSION = 21
ERROR_ARGPARSE_MISSING = 22
ERROR_SOCKET_ERROR = 23
ERROR_OTHER_EXCEPTION = 24
ERROR_INVALID_PLACEHOLDER = 25
ERROR_AUTHENTICATION_ERROR = 26
ERROR_OUTPUT_NOT_ESCAPABLE_ERROR = 27
IPCONNECTION_ERROR_OFFSET = 200

listen_mode = False
enable_host = True
enable_port = True
enable_execute = True
line_separator = '\n'
group_terminator = '\n'

# set from environment variable
dry_run = False

def fatal_error(message, exit_code):
	sys.stderr.write('tinkerforge: error: {0}\n'.format(message))
	sys.exit(exit_code)

if sys.hexversion < 0x02060000:
	fatal_error('requiring python 2.6 or newer', ERROR_PYTHON_VERSION)

try:
	import argparse
except ImportError:
	fatal_error('requiring python argparse module', ERROR_ARGPARSE_MISSING)

class Context(object):
	abort = False
	async_exception = None

	host = None
	port = None
	secret = None
	item_separator = None
	group_separator = None
	array_ellipsis = None
	no_escaped_input = None
	no_escaped_output = None
	no_symbolic_input = None
	no_symbolic_output = None
	timeout = None
	duration = None
	uid = None

	def output(self, string):
		sys.stdout.write(string)

	def duplicate(self):
		ctx = Context()

		ctx.host = self.host
		ctx.port = self.port
		ctx.secret = self.secret
		ctx.item_separator = self.item_separator
		ctx.group_separator = self.group_separator
		ctx.array_ellipsis = self.array_ellipsis
		ctx.no_escaped_input = self.no_escaped_input
		ctx.no_escaped_output = self.no_escaped_output
		ctx.no_symbolic_input = self.no_symbolic_input
		ctx.no_symbolic_output = self.no_symbolic_output
		ctx.timeout = self.timeout
		ctx.duration = self.duration
		ctx.uid = self.uid

		return ctx

class ParserExit(Exception):
	pass

class FatalError(Exception):
	def __init__(self, message, exit_code):
		Exception.__init__(self, message)

		self.exit_code = exit_code
		self.message = message

class Formatter(argparse.HelpFormatter):
	def _fill_text(self, text, width, indent):
		ps = []

		for p in text.split('\n'):
			ps.append(textwrap.fill(p, width, initial_indent=indent, subsequent_indent=indent))

		return '\n'.join(ps)

class Parser(argparse.ArgumentParser):
	def __init__(self, ctx, prog, description=None, epilog=None):
		if not listen_mode:
			if len(prog) > 0:
				prog = 'tinkerforge ' + prog
			else:
				prog = 'tinkerforge'

		argparse.ArgumentParser.__init__(self, prog=prog, add_help=False, description=description, epilog=epilog, formatter_class=Formatter)

		self.ctx = ctx
		self.ctx.current_parser = self

		self.add_argument('--help', action='help', help='show this help message and exit')

	def _print_message(self, message, file=None):
		if message:
			self.ctx.output(message)

	def exit(self, status=0, message=None):
		if status == 0:
			if message:
				self.ctx.output(message)

			raise ParserExit
		else:
			if not message:
				message = 'unknown error'

			raise FatalError(message, ERROR_OTHER_EXCEPTION)

	def error(self, message):
		if not listen_mode:
			self.print_usage(sys.stderr)

		raise FatalError(message, ERROR_SYNTAX_ERROR)

class ParserWithExecute(Parser):
	def __init__(self, ctx, prog):
		Parser.__init__(self, ctx, prog)

		if enable_execute:
			self.add_argument('--execute', type=str, help='shell command line to execute for each incoming response', metavar='<command>')

	def parse_args(self, args):
		namespace = argparse.Namespace()

		if not enable_execute:
			setattr(namespace, 'execute', None)

		return Parser.parse_args(self, args, namespace)

class ParserWithExpectResponse(Parser):
	def __init__(self, ctx, prog):
		Parser.__init__(self, ctx, prog)

		self.add_argument('--expect-response', action='store_true', help='request response and wait for it')

def handle_ipcon_exceptions(ipcon, function):
	try:
		function(ipcon)
	except Error as e:
		raise FatalError(e.description, IPCONNECTION_ERROR_OFFSET - e.value)
	except socket.error as e:
		raise FatalError(str(e), ERROR_SOCKET_ERROR)
	except Exception as e:
		raise FatalError(str(e), ERROR_OTHER_EXCEPTION)
	finally:
		try:
			ipcon.disconnect()
		except:
			pass

def authenticate(ipcon, secret, message):
	# don't auto-reconnect on authentication error
	ipcon.set_auto_reconnect(False)

	try:
		ipcon.authenticate(secret)
	except:
		raise FatalError(message, ERROR_AUTHENTICATION_ERROR)

	ipcon.set_auto_reconnect(True)

def connect_ipcon_and_call(ctx, function, timeout=None):
	def function_wrapper(ipcon):
		if timeout != None:
			ipcon.set_timeout(timeout)

		ipcon.connect(ctx.host, ctx.port)

		if len(ctx.secret) > 0:
			def callback(connect_reason):
				if connect_reason == IPConnection.CONNECT_REASON_AUTO_RECONNECT:
					try:
						authenticate(ipcon, ctx.secret, 'could not authenticate after auto-reconnect')
					except FatalError as e:
						ctx.async_exception = e

			ipcon.register_callback(IPConnection.CALLBACK_CONNECTED, callback)
			authenticate(ipcon, ctx.secret, 'could not authenticate')

		function(ipcon)

	handle_ipcon_exceptions(IPConnection(), function_wrapper)

def call_generic(ctx, name, functions, argv):
	if listen_mode:
		prefix = ''
	else:
		prefix = 'tinkerforge '

	# FIXME: add description
	parser = Parser(ctx, 'call ' + name, epilog="try '{0}call {1} dummy <function> --help' for function specific help.".format(prefix, name))
	function_choices = sorted(functions.keys())

	class ListFunctionsAction(argparse.Action):
		def __call__(self, parser, namespace, values, option_string=None):
			ctx.output(line_separator.join(function_choices) + group_terminator)
			raise ParserExit()

	parser.add_argument('--list-functions', action=ListFunctionsAction, nargs=0, help='show functions of {0} and exit'.format(name))
	parser.add_argument('uid', type=convert_base58, help='uid of a ' + name, metavar='<uid>')
	parser.add_argument('function', choices=function_choices, help='{' + ', '.join(function_choices) + '}', metavar='<function>')
	parser.add_argument('args', nargs=argparse.REMAINDER, help='function specific arguments', metavar='<args>')

	args = parser.parse_args(argv)

	ctx.uid = args.uid

	functions[args.function](ctx, args.args)

def dispatch_generic(ctx, name, callbacks, argv):
	if listen_mode:
		prefix = ''
	else:
		prefix = 'tinkerforge '

	# FIXME: add description
	parser = Parser(ctx, 'dispatch ' + name, epilog="try '{0}dispatch {1} dummy <callback> --help' for callback specific help.".format(prefix, name))
	callback_choices = sorted(callbacks.keys())

	class ListCallbacksAction(argparse.Action):
		def __call__(self, parser, namespace, values, option_string=None):
			ctx.output(line_separator.join(callback_choices) + group_terminator)
			raise ParserExit()

	parser.add_argument('--list-callbacks', action=ListCallbacksAction, nargs=0, help='show callbacks of {0} and exit'.format(name))
	parser.add_argument('uid', type=convert_base58, help='uid of a ' + name, metavar='<uid>')
	parser.add_argument('callback', choices=callback_choices, help='{' + ', '.join(callback_choices) + '}', metavar='<callback>')
	parser.add_argument('args', nargs=argparse.REMAINDER, help='callback specific arguments', metavar='<args>')

	args = parser.parse_args(argv)

	ctx.uid = args.uid

	callbacks[args.callback](ctx, args.args)

def device_call(ctx, device_class, function_id, request_data, format_in,
                format_out, command, expect_response, names, symbols):
	if dry_run:
		return

	if command != None:
		def handle_response(values):
			execute_response(ctx, command, names, values)
	else:
		def handle_response(values):
			output_response(ctx, names, values)

	def function(ipcon):
		device = device_class(ctx.uid, ipcon)

		if expect_response:
			device.set_response_expected(function_id, True)

		response = ipcon.send_request(device, function_id, request_data, format_in, format_out)

		if response != None:
			if len(names) == 1:
				response = (response,)

			response = format_escaped_output(ctx, format_symbolic_output(ctx, response, symbols))

			handle_response(response)
		elif listen_mode:
			ctx.output(group_terminator)

	connect_ipcon_and_call(ctx, function, ctx.timeout / 1000.0)

def device_stream_call(ctx, device_class, function_id, direction, request_data,
                       high_level_roles_in, high_level_roles_out, low_level_roles_in,
                       low_level_roles_out, format_in, format_out, command,
                       expect_response, names, symbols, chunk_padding, chunk_cardinality,
                       chunk_max_offset, short_write, single_read, fixed_length):
	if dry_run:
		return

	normal_level_request_data = [data for role, data in zip(high_level_roles_in, request_data) if role == None]

	if command != None:
		def handle_response(values):
			execute_response(ctx, command, names, values)
	else:
		def handle_response(values):
			output_response(ctx, names, values)

	def function(ipcon):
		device = device_class(ctx.uid, ipcon)

		if expect_response:
			device.set_response_expected(function_id, True)

		if direction == 'in':
			def create_low_level_request_data(stream_length, stream_chunk_offset, stream_chunk_data):
				low_level_request_data = []
				normal_level_request_data_iter = iter(normal_level_request_data)

				for role in low_level_roles_in:
					if role == None:
						low_level_request_data.append(next(normal_level_request_data_iter))
					elif role == 'stream_length':
						low_level_request_data.append(stream_length)
					elif role == 'stream_chunk_offset':
						low_level_request_data.append(stream_chunk_offset)
					elif role == 'stream_chunk_data':
						low_level_request_data.append(stream_chunk_data)

				return low_level_request_data

			stream_data_index = high_level_roles_in.index('stream_data')
			stream_data = request_data[stream_data_index]
			stream_length = len(stream_data)
			stream_chunk_offset = 0

			if short_write:
				stream_chunk_written_index = None if len(low_level_roles_out) == 1 else low_level_roles_out.index('stream_chunk_written')
				stream_written = 0

			if stream_length == 0:
				stream_chunk_data = [chunk_padding] * chunk_cardinality
				low_level_request_data = create_low_level_request_data(stream_length, stream_chunk_offset, stream_chunk_data)

				response = ipcon.send_request(device, function_id, low_level_request_data, format_in, format_out)

				if short_write:
					if stream_chunk_written_index == None:
						stream_written = response
					else:
						stream_written = response[stream_chunk_written_index]
			else:
				while stream_chunk_offset < stream_length:
					stream_chunk_data = create_chunk_data(stream_data, stream_chunk_offset, chunk_cardinality, chunk_padding)
					low_level_request_data = create_low_level_request_data(stream_length, stream_chunk_offset, stream_chunk_data)

					response = ipcon.send_request(device, function_id, low_level_request_data, format_in, format_out)

					if short_write:
						if stream_chunk_written_index == None:
							stream_chunk_written = response
						else:
							stream_chunk_written = response[stream_chunk_written_index]

						stream_written += stream_chunk_written

						if stream_chunk_written < chunk_cardinality:
							break # either last chunk or short write

					stream_chunk_offset += chunk_cardinality

			if short_write:
				if not isinstance(response, tuple):
					response = (response,)

				normal_level_response_iter = (data for role, data in zip(low_level_roles_out, response) if role == None)
				high_level_response = []

				for role in high_level_roles_out:
					if role == None:
						high_level_response.append(next(normal_level_response_iter))
					elif role == 'stream_written':
						high_level_response.append(stream_written)

				if len(high_level_response) == 1:
					response = high_level_response[0]
				else:
					response = tuple(high_level_response)
		else: # out
			low_level_response = ipcon.send_request(device, function_id, normal_level_request_data, format_in, format_out)

			if fixed_length == None:
				stream_length_index = low_level_roles_out.index('stream_length')
				stream_length = low_level_response[stream_length_index]
			else:
				stream_length_index = None
				stream_length = fixed_length

			if not single_read:
				stream_chunk_offset_index = low_level_roles_out.index('stream_chunk_offset')
				stream_chunk_offset = low_level_response[stream_chunk_offset_index]
			else:
				stream_chunk_offset_index = None
				stream_chunk_offset = 0

			stream_chunk_data_index = low_level_roles_out.index('stream_chunk_data')
			stream_chunk_data = low_level_response[stream_chunk_data_index]

			if fixed_length != None and stream_chunk_offset == chunk_max_offset:
				stream_length = 0
				stream_out_of_sync = False
				stream_data = ()
			else:
				stream_out_of_sync = stream_chunk_offset != 0
				stream_data = stream_chunk_data

			while not stream_out_of_sync and len(stream_data) < stream_length:
				low_level_response = ipcon.send_request(device, function_id, normal_level_request_data, format_in, format_out)

				if stream_length_index != None:
					stream_length = low_level_response[stream_length_index]

				if stream_chunk_offset_index != None:
					stream_chunk_offset = low_level_response[stream_chunk_offset_index]

				stream_chunk_data = low_level_response[stream_chunk_data_index]
				stream_out_of_sync = stream_chunk_offset != len(stream_data)
				stream_data += stream_chunk_data

			if stream_out_of_sync: # discard remaining stream to bring it back in-sync
				while stream_chunk_offset + chunk_cardinality < stream_length:
					low_level_response = ipcon.send_request(device, function_id, normal_level_request_data, format_in, format_out)

					if stream_length_index != None:
						stream_length = low_level_response[stream_length_index]

					if stream_chunk_offset_index != None:
						stream_chunk_offset = low_level_response[stream_chunk_offset_index]

					stream_chunk_data = low_level_response[stream_chunk_data_index]

				raise Error(Error.STREAM_OUT_OF_SYNC, 'Stream is out-of-sync')

			normal_level_response_iter = (data for role, data in zip(low_level_roles_out, low_level_response) if role == None)
			high_level_response = []

			for role in high_level_roles_out:
				if role == None:
					high_level_response.append(next(normal_level_response_iter))
				elif role == 'stream_data':
					high_level_response.append(stream_data[:stream_length])

			if len(high_level_response) == 1:
				response = high_level_response[0]
			else:
				response = tuple(high_level_response)

		if response != None:
			if len(names) == 1:
				response = (response,)

			response = format_escaped_output(ctx, format_symbolic_output(ctx, response, symbols))

			handle_response(response)
		elif listen_mode:
			ctx.output(group_terminator)

	connect_ipcon_and_call(ctx, function, ctx.timeout / 1000.0)

def device_dispatch(ctx, device_class, function_id, command, names, symbols):
	if dry_run:
		while True:
			time.sleep(0.5)

		return

	if command != None:
		def callback(*values):
			values = format_escaped_output(ctx, format_symbolic_output(ctx, values, symbols))

			execute_response(ctx, command, names, values)
	else:
		is_first_callback = [True]

		def callback(*values):
			if len(names) > 1 and not listen_mode:
				if is_first_callback[0]:
					is_first_callback[0] = False
				else:
					ctx.output(ctx.group_separator)

			values = format_escaped_output(ctx, format_symbolic_output(ctx, values, symbols))

			output_response(ctx, names, values)

	def function(ipcon):
		device = device_class(ctx.uid, ipcon)

		if ctx.duration == 0:
			exit_flag = [False]

			def callback_wrapper(*args, **kwargs):
				if not exit_flag[0]:
					callback(*args, **kwargs)
					exit_flag[0] = True

			device.registered_callbacks[function_id] = callback_wrapper

			while not exit_flag[0] and not ctx.abort:
				time.sleep(0.1)

				if ctx.async_exception != None:
					raise ctx.async_exception
		elif ctx.duration < 0:
			device.registered_callbacks[function_id] = callback

			while not ctx.abort:
				time.sleep(1)

				if ctx.async_exception != None:
					raise ctx.async_exception
		else:
			device.registered_callbacks[function_id] = callback

			# FIXME: if duration is large then it would be better to sleep
			#        in multiple steps here
			time.sleep(ctx.duration / 1000.0)

			# FIXME: only checking for an exception after the complete sleep
			#        is not good, sleep in shorter steps here to check for
			#        exception more often
			if ctx.async_exception != None:
				raise ctx.async_exception

	connect_ipcon_and_call(ctx, function)

# length > 0 means fixed-length, length < 0 means maximum of dynamic-length
def get_array_type_name(ctx, name, length):
	if length < 0:
		return '{0}{1}{0}{1}..'.format(name, ctx.item_separator)
	elif length <= 5:
		return ctx.item_separator.join([name] * length)
	else:
		return '{0}{1}{0}{1}..{2}x..{1}{0}'.format(name, ctx.item_separator, length - 3)

def format_symbolic_output(ctx, values, symbols):
	if ctx.no_symbolic_output:
		return values

	translated_values = []

	for value, symbol in zip(values, symbols):
		if symbol != None:
			try:
				translated_values.append(symbol[value])
			except KeyError:
				translated_values.append(value)
		else:
			translated_values.append(value)

	return tuple(translated_values)

def format_escaped_output(ctx, values):
	if ctx.no_escaped_output:
		return values

	translated_values = []

	for value in values:
		if type(value) == tuple:
			translated_items = []

			for item in value:
				if type(item) == str:
					try:
						translated_items.append(item.encode('string-escape'))
					except ValueError:
						message = 'output not escapable: %r' % item
						raise FatalError(message, ERROR_OUTPUT_NOT_ESCAPABLE_ERROR)
				else:
					translated_items.append(item)

			translated_values.append(tuple(translated_items))
		elif type(value) == str:
			try:
				translated_values.append(value.encode('string-escape'))
			except ValueError:
				message = 'output not escapable: %r' % value
				raise FatalError(message, ERROR_OUTPUT_NOT_ESCAPABLE_ERROR)
		else:
			translated_values.append(value)

	return tuple(translated_values)

def convert_base58(string):
	try:
		base58decode(string)
	except:
		msg = 'invalid base58 value: %r' % string
		raise argparse.ArgumentTypeError(msg)

	return string

convert_base58.__name__ = 'base58'

def create_char_converter(ctx):
	def convert_char(string):
		if not ctx.no_escaped_input:
			try:
				string = string.decode('string-escape')
			except ValueError:
				msg = 'invalid escape sequence: %r' % string
				raise argparse.ArgumentTypeError(msg)

		if len(string) != 1:
			msg = 'invalid char value: %r' % string
			raise argparse.ArgumentTypeError(msg)

		return string

	convert_char.__name__ = 'char'

	return convert_char

def convert_int(string):
	try:
		return int(string, base=0)
	except (ValueError, TypeError):
		msg = 'invalid int value: %r' % string
		raise argparse.ArgumentTypeError(msg)

convert_int.__name__ = 'int'

def convert_bool(string):
	value = string.lower()

	if value == 'true':
		return True
	elif value == 'false':
		return False
	else:
		msg = 'invalid bool value: %r' % string
		raise argparse.ArgumentTypeError(msg)

convert_bool.__name__ = 'bool'

def create_string_converter(ctx, type_, length):
	def convert_string(string):
		if not ctx.no_escaped_input:
			try:
				string = string.decode('string-escape')
			except ValueError:
				msg = 'invalid escape sequence: %r' % string
				raise argparse.ArgumentTypeError(msg)

		try:
			value = type_(string)
		except (ValueError, TypeError):
			name = getattr(type, '__name__', repr(type_))
			msg = 'invalid %s value: %r' % (name, string)
			raise argparse.ArgumentTypeError(msg)

		if len(value) > length:
			msg = 'string value is too long: %r' % value
			raise argparse.ArgumentTypeError(msg)

		return value

	convert_string.__name__ = 'string'

	return convert_string

def create_symbol_converter(ctx, type_, symbols, strict=False):
	def convert_symbol(string):
		if not ctx.no_symbolic_input:
			try:
				return symbols[string]
			except KeyError:
				pass

		try:
			value = type_(string)
		except (ValueError, TypeError):
			name = getattr(type_, '__name__', repr(type_))
			msg = 'invalid %s value: %r' % (name, string)
			raise argparse.ArgumentTypeError(msg)

		if strict and value not in symbols.values():
			name = getattr(type_, '__name__', repr(type_))
			msg = '%s value is out-of-range: %r' % (name, string)
			raise argparse.ArgumentTypeError(msg)

		return value

	convert_symbol.__name__ = getattr(type_, '__name__', repr(type_))

	return convert_symbol

# length > 0 means fixed-length, length < 0 means maximum of dynamic-length
def create_array_converter(ctx, type_, default_item, length):
	assert length != 0

	def convert_array(string):
		items = string.split(ctx.item_separator)

		if length > 0 and len(ctx.array_ellipsis) > 0 and len(items) > 0 and items[-1] == ctx.array_ellipsis:
			if default_item == None:
				name = getattr(type_, '__name__', repr(type_))
				msg = 'array ellipsis not supported for %s value: %r' % (get_array_type_name(ctx, name, length), string)
				raise argparse.ArgumentTypeError(msg)

			items = items[:-1] + [default_item] * (length - len(items) + 1)

		array = []

		for item in items:
			try:
				value = type_(item)
			except (ValueError, TypeError, argparse.ArgumentTypeError):
				name = getattr(type_, '__name__', repr(type_))
				msg = 'invalid %s value: %r' % (get_array_type_name(ctx, name, length), string)
				raise argparse.ArgumentTypeError(msg)

			array.append(value)

		if (length > 0 and len(array) != length) or \
		   (length < 0 and (len(array) < 1 or len(array) > -length)):
			name = getattr(type_, '__name__', repr(type_))
			msg = 'invalid %s value: %r' % (get_array_type_name(ctx, name, length), string)
			raise argparse.ArgumentTypeError(msg)

		return array

	name = getattr(type_, '__name__', repr(type_))
	convert_array.__name__ = get_array_type_name(ctx, name, length)

	return convert_array

def execute_response(ctx, command, names, values):
	formatted_values = {}

	class Tuple(tuple):
		def __init__(self, *args):
			tuple.__init__(self, *args)

		def __str__(self):
			return ctx.item_separator.join(map(str, self))

	for name, value in zip(names, values):
		if type(value) == tuple:
			formatted_values[name] = Tuple(value)
		elif type(value) == bool:
			formatted_values[name] = str(value).lower()
		else:
			formatted_values[name] = value

	try:
		formatted_command = command.format(**formatted_values)
	except KeyError as e:
		message = 'invalid placeholder %s in format: %s' % (str(e), command)
		raise FatalError(message, ERROR_INVALID_PLACEHOLDER)
	except Exception as e:
		message = '%s: %s' % (str(e), command)
		raise FatalError(message, ERROR_OTHER_EXCEPTION)

	try:
		if listen_mode:
			try:
				output = subprocess.check_output(formatted_command, stderr=subprocess.STDOUT, shell=True)
			except subprocess.CalledProcessError as e:
				output = e.output

			ctx.output(output)
		else:
			subprocess.call(formatted_command, shell=True)
	except Exception as e:
		message = '%s: %s' % (str(e), formatted_command)
		raise FatalError(message, ERROR_OTHER_EXCEPTION)

def output_response(ctx, names, values):
	lines = []

	for name, value in zip(names, values):
		if type(value) == tuple:
			lines.append('{0}={1}'.format(name, ctx.item_separator.join(map(str, value))))
		elif type(value) == bool:
			lines.append('{0}={1}'.format(name, str(value).lower()))
		else:
			lines.append('{0}={1}'.format(name, value))

	ctx.output(line_separator.join(lines) + group_terminator)

def common_get_identity(ctx, prog_prefix, device_class, argv):
	parser = ParserWithExecute(ctx, prog_prefix + ' get-identity')

	args = parser.parse_args(argv)

	device_call(ctx, device_class, 255, (), '', '8s 8s c 3B 3B H', args.execute, False,
	            ['uid', 'connected-uid', 'position', 'hardware-version', 'firmware-version', 'device-identifier'],
	            [None, None, None, None, None, device_identifier_symbols])



# -*- coding: utf-8 -*-
# Copyright (C) 2012-2015, 2017, 2019 Matthias Bolte <matthias@tinkerforge.com>
# Copyright (C) 2011-2012 Olaf LÃ¼ke <olaf@tinkerforge.com>
#
# Redistribution and use in source and binary forms of this file,
# with or without modification, are permitted. See the Creative
# Commons Zero (CC0 1.0) License for more details.

import struct
import socket
import sys
import time
import os
import math
import hmac
import hashlib
import errno
import threading

try:
    import queue # Python 3
except ImportError:
    import Queue as queue # Python 2

def get_uid_from_data(data):
    return struct.unpack('<I', data[0:4])[0]

def get_length_from_data(data):
    return struct.unpack('<B', data[4:5])[0]

def get_function_id_from_data(data):
    return struct.unpack('<B', data[5:6])[0]

def get_sequence_number_from_data(data):
    return (struct.unpack('<B', data[6:7])[0] >> 4) & 0x0F

def get_error_code_from_data(data):
    return (struct.unpack('<B', data[7:8])[0] >> 6) & 0x03

BASE58 = '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'

def base58encode(value):
    encoded = ''

    while value >= 58:
        div, mod = divmod(value, 58)
        encoded = BASE58[mod] + encoded
        value = div

    return BASE58[value] + encoded

def base58decode(encoded):
    value = 0
    column_multiplier = 1

    for c in encoded[::-1]:
        try:
            column = BASE58.index(c)
        except ValueError:
            raise Error(Error.INVALID_UID, 'UID "{0}" contains invalid character'.format(encoded), suppress_context=True)

        value += column * column_multiplier
        column_multiplier *= 58

    return value

def uid64_to_uid32(uid64):
    value1 = uid64 & 0xFFFFFFFF
    value2 = (uid64 >> 32) & 0xFFFFFFFF

    uid32  = (value1 & 0x00000FFF)
    uid32 |= (value1 & 0x0F000000) >> 12
    uid32 |= (value2 & 0x0000003F) << 16
    uid32 |= (value2 & 0x000F0000) << 6
    uid32 |= (value2 & 0x3F000000) << 2

    return uid32

def create_chunk_data(data, chunk_offset, chunk_length, chunk_padding):
    chunk_data = data[chunk_offset:chunk_offset + chunk_length]

    if len(chunk_data) < chunk_length:
        chunk_data += [chunk_padding] * (chunk_length - len(chunk_data))

    return chunk_data

if sys.hexversion < 0x03000000:
    def create_char(value): # return str with len() == 1 and ord() <= 255
        if isinstance(value, str) and len(value) == 1: # Python2 str satisfies ord() <= 255 by default
            return value
        elif isinstance(value, unicode) and len(value) == 1:
            code_point = ord(value)

            if code_point <= 255:
                return chr(code_point)
            else:
                raise ValueError('Invalid char value: ' + repr(value))
        elif isinstance(value, bytearray) and len(value) == 1: # Python2 bytearray satisfies item <= 255 by default
            return chr(value[0])
        elif isinstance(value, int) and value >= 0 and value <= 255:
            return chr(value)
        else:
            raise ValueError('Invalid char value: ' + repr(value))
else:
    def create_char(value): # return str with len() == 1 and ord() <= 255
        if isinstance(value, str) and len(value) == 1 and ord(value) <= 255:
            return value
        elif isinstance(value, (bytes, bytearray)) and len(value) == 1: # Python3 bytes/bytearray satisfies item <= 255 by default
            return chr(value[0])
        elif isinstance(value, int) and value >= 0 and value <= 255:
            return chr(value)
        else:
            raise ValueError('Invalid char value: ' + repr(value))

if sys.hexversion < 0x03000000:
    def create_char_list(value, expected_type='char list'): # return list of str with len() == 1 and ord() <= 255 for all items
        if isinstance(value, list):
            return map(create_char, value)
        elif isinstance(value, str): # Python2 str satisfies ord() <= 255 by default
            return list(value)
        elif isinstance(value, unicode):
            chars = []

            for char in value:
                code_point = ord(char)

                if code_point <= 255:
                    chars.append(chr(code_point))
                else:
                    raise ValueError('Invalid {0} value: {1}'.format(expected_type, repr(value)))

            return chars
        elif isinstance(value, bytearray): # Python2 bytearray satisfies item <= 255 by default
            return map(chr, value)
        else:
            raise ValueError('Invalid {0} value: {1}'.format(expected_type, repr(value)))
else:
    def create_char_list(value, expected_type='char list'): # return list of str with len() == 1 and ord() <= 255 for all items
        if isinstance(value, list):
            return list(map(create_char, value))
        elif isinstance(value, str):
            chars = list(value)

            for char in chars:
                if ord(char) > 255:
                    raise ValueError('Invalid {0} value: {1}'.format(expected_type, repr(value)))

            return chars
        elif isinstance(value, (bytes, bytearray)): # Python3 bytes/bytearray satisfies item <= 255 by default
            return list(map(chr, value))
        else:
            raise ValueError('Invalid {0} value: {1}'.format(expected_type, repr(value)))

if sys.hexversion < 0x03000000:
    def create_string(value): # return str with ord() <= 255 for all chars
        if isinstance(value, str): # Python2 str satisfies ord() <= 255 by default
            return value
        elif isinstance(value, unicode):
            chars = []

            for char in value:
                code_point = ord(char)

                if code_point <= 255:
                    chars.append(chr(code_point))
                else:
                    raise ValueError('Invalid string value: {1}'.format(repr(value)))

            return ''.join(chars)
        elif isinstance(value, bytearray): # Python2 bytearray satisfies item <= 255 by default
            chars = []

            for byte in value:
                chars.append(chr(byte))

            return ''.join(chars)
        else:
            return ''.join(create_char_list(value, expected_type='string'))
else:
    def create_string(value): # return str with ord() <= 255 for all chars
        if isinstance(value, str):
            for char in value:
                if ord(char) > 255:
                    raise ValueError('Invalid string value: {1}'.format(repr(value)))

            return value
        elif isinstance(value, (bytes, bytearray)): # Python3 bytes/bytearray satisfies item <= 255 by default
            chars = []

            for byte in value:
                chars.append(chr(byte))

            return ''.join(chars)
        else:
            return ''.join(create_char_list(value, expected_type='string'))

def pack_payload(data, form):
    if sys.hexversion < 0x03000000:
        packed = ''
    else:
        packed = b''

    for f, d in zip(form.split(' '), data):
        if '!' in f:
            if len(f) > 1:
                if int(f.replace('!', '')) != len(d):
                    raise ValueError('Incorrect bool list length')

                p = [0] * int(math.ceil(len(d) / 8.0))

                for i, b in enumerate(d):
                    if b:
                        p[i // 8] |= 1 << (i % 8)

                packed += struct.pack('<{0}B'.format(len(p)), *p)
            else:
                packed += struct.pack('<?', d)
        elif 'c' in f:
            if sys.hexversion < 0x03000000:
                if len(f) > 1:
                    packed += struct.pack('<' + f, *d)
                else:
                    packed += struct.pack('<' + f, d)
            else:
                if len(f) > 1:
                    packed += struct.pack('<' + f, *list(map(lambda char: bytes([ord(char)]), d)))
                else:
                    packed += struct.pack('<' + f, bytes([ord(d)]))
        elif 's' in f:
            if sys.hexversion < 0x03000000:
                packed += struct.pack('<' + f, d)
            else:
                packed += struct.pack('<' + f, bytes(map(ord, d)))
        elif len(f) > 1:
            packed += struct.pack('<' + f, *d)
        else:
            packed += struct.pack('<' + f, d)

    return packed

def unpack_payload(data, form):
    ret = []

    for f in form.split(' '):
        o = f

        if '!' in f:
            if len(f) > 1:
                f = '{0}B'.format(int(math.ceil(int(f.replace('!', '')) / 8.0)))
            else:
                f = 'B'

        f = '<' + f
        length = struct.calcsize(f)
        x = struct.unpack(f, data[:length])

        if '!' in o:
            y = []

            if len(o) > 1:
                for i in range(int(o.replace('!', ''))):
                    y.append(x[i // 8] & (1 << (i % 8)) != 0)
            else:
                y.append(x[0] != 0)

            x = tuple(y)

        if 'c' in f:
            if sys.hexversion < 0x03000000:
                if len(x) > 1:
                    ret.append(x)
                else:
                    ret.append(x[0])
            else:
                if len(x) > 1:
                    ret.append(tuple(map(lambda item: chr(ord(item)), x)))
                else:
                    ret.append(chr(ord(x[0])))
        elif 's' in f:
            if sys.hexversion < 0x03000000:
                s = x[0]
            else:
                s = ''.join(map(chr, x[0]))

            i = s.find('\x00')

            if i >= 0:
                s = s[:i]

            ret.append(s)
        elif len(x) > 1:
            ret.append(x)
        else:
            ret.append(x[0])

        data = data[length:]

    if len(ret) == 1:
        return ret[0]
    else:
        return ret

class Error(Exception):
    TIMEOUT = -1
    NOT_ADDED = -6 # obsolete since v2.0
    ALREADY_CONNECTED = -7
    NOT_CONNECTED = -8
    INVALID_PARAMETER = -9
    NOT_SUPPORTED = -10
    UNKNOWN_ERROR_CODE = -11
    STREAM_OUT_OF_SYNC = -12
    INVALID_UID = -13

    def __init__(self, value, description, suppress_context=False):
        Exception.__init__(self, '{0} ({1})'.format(description, value))

        self.value = value
        self.description = description

        if sys.hexversion >= 0x03000000 and suppress_context:
            # this is a Python 2 syntax compatible form of the "raise ... from None"
            # syntax in Python 3. especially the timeout error shows in Python 3
            # the queue.Empty exception as its context. this is confusing and doesn't
            # help much. the "raise ... from None" syntax in Python 3 stops the
            # default traceback printer from outputting the context of the exception
            # while keeping the queue.Empty exception in the __context__ field for
            # debugging purposes.
            self.__cause__ = None
            self.__suppress_context__ = True

class Device(object):
    RESPONSE_EXPECTED_INVALID_FUNCTION_ID = 0
    RESPONSE_EXPECTED_ALWAYS_TRUE = 1 # getter
    RESPONSE_EXPECTED_TRUE = 2 # setter
    RESPONSE_EXPECTED_FALSE = 3 # setter, default

    def __init__(self, uid, ipcon):
        """
        Creates the device object with the unique device ID *uid* and adds
        it to the IPConnection *ipcon*.
        """

        uid_ = base58decode(uid)

        if uid_ > (1 << 64) - 1:
            raise Error(Error.INVALID_UID, 'UID "{0}" is too big'.format(uid))

        if uid_ > (1 << 32) - 1:
            uid_ = uid64_to_uid32(uid_)

        if uid_ == 0:
            raise Error(Error.INVALID_UID, 'UID "{0}" is empty or maps to zero'.format(uid))

        self.uid = uid_
        self.ipcon = ipcon
        self.api_version = (0, 0, 0)
        self.registered_callbacks = {}
        self.callback_formats = {}
        self.high_level_callbacks = {}
        self.expected_response_function_id = None # protected by request_lock
        self.expected_response_sequence_number = None # protected by request_lock
        self.response_queue = queue.Queue()
        self.request_lock = threading.Lock()
        self.stream_lock = threading.Lock()

        self.response_expected = [Device.RESPONSE_EXPECTED_INVALID_FUNCTION_ID] * 256
        self.response_expected[IPConnection.FUNCTION_ADC_CALIBRATE] = Device.RESPONSE_EXPECTED_ALWAYS_TRUE
        self.response_expected[IPConnection.FUNCTION_GET_ADC_CALIBRATION] = Device.RESPONSE_EXPECTED_ALWAYS_TRUE
        self.response_expected[IPConnection.FUNCTION_READ_BRICKLET_UID] = Device.RESPONSE_EXPECTED_ALWAYS_TRUE
        self.response_expected[IPConnection.FUNCTION_WRITE_BRICKLET_UID] = Device.RESPONSE_EXPECTED_ALWAYS_TRUE
        self.response_expected[IPConnection.FUNCTION_READ_BRICKLET_PLUGIN] = Device.RESPONSE_EXPECTED_ALWAYS_TRUE
        self.response_expected[IPConnection.FUNCTION_WRITE_BRICKLET_PLUGIN] = Device.RESPONSE_EXPECTED_ALWAYS_TRUE

        ipcon.devices[self.uid] = self # FIXME: maybe use a weakref here

    def get_api_version(self):
        """
        Returns the API version (major, minor, revision) of the bindings for
        this device.
        """

        return self.api_version

    def get_response_expected(self, function_id):
        """
        Returns the response expected flag for the function specified by the
        *function_id* parameter. It is *true* if the function is expected to
        send a response, *false* otherwise.

        For getter functions this is enabled by default and cannot be disabled,
        because those functions will always send a response. For callback
        configuration functions it is enabled by default too, but can be
        disabled via the set_response_expected function. For setter functions
        it is disabled by default and can be enabled.

        Enabling the response expected flag for a setter function allows to
        detect timeouts and other error conditions calls of this setter as
        well. The device will then send a response for this purpose. If this
        flag is disabled for a setter function then no response is send and
        errors are silently ignored, because they cannot be detected.
        """

        if function_id < 0 or function_id >= len(self.response_expected):
            raise ValueError('Function ID {0} out of range'.format(function_id))

        flag = self.response_expected[function_id]

        if flag == Device.RESPONSE_EXPECTED_INVALID_FUNCTION_ID:
            raise ValueError('Invalid function ID {0}'.format(function_id))

        return flag in [Device.RESPONSE_EXPECTED_ALWAYS_TRUE, Device.RESPONSE_EXPECTED_TRUE]

    def set_response_expected(self, function_id, response_expected):
        """
        Changes the response expected flag of the function specified by the
        *function_id* parameter. This flag can only be changed for setter
        (default value: *false*) and callback configuration functions
        (default value: *true*). For getter functions it is always enabled.

        Enabling the response expected flag for a setter function allows to
        detect timeouts and other error conditions calls of this setter as
        well. The device will then send a response for this purpose. If this
        flag is disabled for a setter function then no response is send and
        errors are silently ignored, because they cannot be detected.
        """

        if function_id < 0 or function_id >= len(self.response_expected):
            raise ValueError('Function ID {0} out of range'.format(function_id))

        flag = self.response_expected[function_id]

        if flag == Device.RESPONSE_EXPECTED_INVALID_FUNCTION_ID:
            raise ValueError('Invalid function ID {0}'.format(function_id))

        if flag == Device.RESPONSE_EXPECTED_ALWAYS_TRUE:
            raise ValueError('Response Expected flag cannot be changed for function ID {0}'.format(function_id))

        if bool(response_expected):
            self.response_expected[function_id] = Device.RESPONSE_EXPECTED_TRUE
        else:
            self.response_expected[function_id] = Device.RESPONSE_EXPECTED_FALSE

    def set_response_expected_all(self, response_expected):
        """
        Changes the response expected flag for all setter and callback
        configuration functions of this device at once.
        """

        if bool(response_expected):
            flag = Device.RESPONSE_EXPECTED_TRUE
        else:
            flag = Device.RESPONSE_EXPECTED_FALSE

        for i in range(len(self.response_expected)):
            if self.response_expected[i] in [Device.RESPONSE_EXPECTED_TRUE, Device.RESPONSE_EXPECTED_FALSE]:
                self.response_expected[i] = flag

class BrickDaemon(Device):
    FUNCTION_GET_AUTHENTICATION_NONCE = 1
    FUNCTION_AUTHENTICATE = 2

    def __init__(self, uid, ipcon):
        Device.__init__(self, uid, ipcon)

        self.api_version = (2, 0, 0)

        self.response_expected[BrickDaemon.FUNCTION_GET_AUTHENTICATION_NONCE] = BrickDaemon.RESPONSE_EXPECTED_ALWAYS_TRUE
        self.response_expected[BrickDaemon.FUNCTION_AUTHENTICATE] = BrickDaemon.RESPONSE_EXPECTED_TRUE

    def get_authentication_nonce(self):
        return self.ipcon.send_request(self, BrickDaemon.FUNCTION_GET_AUTHENTICATION_NONCE, (), '', '4B')

    def authenticate(self, client_nonce, digest):
        self.ipcon.send_request(self, BrickDaemon.FUNCTION_AUTHENTICATE, (client_nonce, digest), '4B 20B', '')

class IPConnection(object):
    FUNCTION_ENUMERATE = 254
    FUNCTION_ADC_CALIBRATE = 251
    FUNCTION_GET_ADC_CALIBRATION = 250
    FUNCTION_READ_BRICKLET_UID = 249
    FUNCTION_WRITE_BRICKLET_UID = 248
    FUNCTION_READ_BRICKLET_PLUGIN = 247
    FUNCTION_WRITE_BRICKLET_PLUGIN = 246
    FUNCTION_DISCONNECT_PROBE = 128

    CALLBACK_ENUMERATE = 253
    CALLBACK_CONNECTED = 0
    CALLBACK_DISCONNECTED = 1

    BROADCAST_UID = 0

    PLUGIN_CHUNK_SIZE = 32

    # enumeration_type parameter to the enumerate callback
    ENUMERATION_TYPE_AVAILABLE = 0
    ENUMERATION_TYPE_CONNECTED = 1
    ENUMERATION_TYPE_DISCONNECTED = 2

    # connect_reason parameter to the connected callback
    CONNECT_REASON_REQUEST = 0
    CONNECT_REASON_AUTO_RECONNECT = 1

    # disconnect_reason parameter to the disconnected callback
    DISCONNECT_REASON_REQUEST = 0
    DISCONNECT_REASON_ERROR = 1
    DISCONNECT_REASON_SHUTDOWN = 2

    # returned by get_connection_state
    CONNECTION_STATE_DISCONNECTED = 0
    CONNECTION_STATE_CONNECTED = 1
    CONNECTION_STATE_PENDING = 2 # auto-reconnect in process

    QUEUE_EXIT = 0
    QUEUE_META = 1
    QUEUE_PACKET = 2

    DISCONNECT_PROBE_INTERVAL = 5

    class CallbackContext(object):
        def __init__(self):
            self.queue = None
            self.thread = None
            self.packet_dispatch_allowed = False
            self.lock = None

    def __init__(self):
        """
        Creates an IP Connection object that can be used to enumerate the available
        devices. It is also required for the constructor of Bricks and Bricklets.
        """

        self.host = None
        self.port = None
        self.timeout = 2.5
        self.auto_reconnect = True
        self.auto_reconnect_allowed = False
        self.auto_reconnect_pending = False
        self.sequence_number_lock = threading.Lock()
        self.next_sequence_number = 0 # protected by sequence_number_lock
        self.authentication_lock = threading.Lock() # protects authentication handshake
        self.next_authentication_nonce = 0 # protected by authentication_lock
        self.devices = {}
        self.registered_callbacks = {}
        self.socket = None # protected by socket_lock
        self.socket_id = 0 # protected by socket_lock
        self.socket_lock = threading.Lock()
        self.socket_send_lock = threading.Lock()
        self.receive_flag = False
        self.receive_thread = None
        self.callback = None
        self.disconnect_probe_flag = False
        self.disconnect_probe_queue = None
        self.disconnect_probe_thread = None
        self.waiter = threading.Semaphore()
        self.brickd = BrickDaemon('2', self)
        self.retry_first_connection = False
        self.reconnect_sleep_time = 0.1

    def enable_retry_first_connection(self, log_fn):
        """
        Used for MQTT bindings. This will enable reconnect attempts even if there was no successful connection yet.

        log_fn will be called with an exception to signal, that the first connection attempt was unsuccessful and will be retried.
        """
        self.auto_reconnect_allowed = True
        self.retry_first_connection = True
        self.log_fn = log_fn
        self.reconnect_sleep_time = 5

    def connect(self, host, port):
        """
        Creates a TCP/IP connection to the given *host* and *port*. The host
        and port can point to a Brick Daemon or to a WIFI/Ethernet Extension.

        Devices can only be controlled when the connection was established
        successfully.

        Blocks until the connection is established and throws an exception if
        there is no Brick Daemon or WIFI/Ethernet Extension listening at the
        given host and port.
        """

        with self.socket_lock:
            if self.socket is not None:
                raise Error(Error.ALREADY_CONNECTED,
                            'Already connected to {0}:{1}'.format(self.host, self.port))

            self.host = host
            self.port = port

            self.connect_unlocked(False)

    def disconnect(self):
        """
        Disconnects the TCP/IP connection from the Brick Daemon or the
        WIFI/Ethernet Extension.
        """

        with self.socket_lock:
            self.auto_reconnect_allowed = False

            if self.auto_reconnect_pending:
                # abort potentially pending auto reconnect
                self.auto_reconnect_pending = False
            else:
                if self.socket is None:
                    raise Error(Error.NOT_CONNECTED, 'Not connected')

                self.disconnect_unlocked()

            # end callback thread
            callback = self.callback
            self.callback = None

        # do this outside of socket_lock to allow calling (dis-)connect from
        # the callbacks while blocking on the join call here
        callback.queue.put((IPConnection.QUEUE_META,
                            (IPConnection.CALLBACK_DISCONNECTED,
                             IPConnection.DISCONNECT_REASON_REQUEST, None)))
        callback.queue.put((IPConnection.QUEUE_EXIT, None))

        if threading.current_thread() is not callback.thread:
            callback.thread.join()

    def authenticate(self, secret):
        """
        Performs an authentication handshake with the connected Brick Daemon or
        WIFI/Ethernet Extension. If the handshake succeeds the connection switches
        from non-authenticated to authenticated state and communication can
        continue as normal. If the handshake fails then the connection gets closed.
        Authentication can fail if the wrong secret was used or if authentication
        is not enabled at all on the Brick Daemon or the WIFI/Ethernet Extension.

        For more information about authentication see
        https://www.tinkerforge.com/en/doc/Tutorials/Tutorial_Authentication/Tutorial.html
        """

        secret_bytes = secret.encode('ascii')

        with self.authentication_lock:
            if self.next_authentication_nonce == 0:
                try:
                    self.next_authentication_nonce = struct.unpack('<I', os.urandom(4))[0]
                except NotImplementedError:
                    subseconds, seconds = math.modf(time.time())
                    seconds = int(seconds)
                    subseconds = int(subseconds * 1000000)
                    self.next_authentication_nonce = ((seconds << 26 | seconds >> 6) & 0xFFFFFFFF) + subseconds + os.getpid()

            server_nonce = self.brickd.get_authentication_nonce()
            client_nonce = struct.unpack('<4B', struct.pack('<I', self.next_authentication_nonce))
            self.next_authentication_nonce = (self.next_authentication_nonce + 1) % (1 << 32)

            h = hmac.new(secret_bytes, digestmod=hashlib.sha1)

            h.update(struct.pack('<4B', *server_nonce))
            h.update(struct.pack('<4B', *client_nonce))

            digest = struct.unpack('<20B', h.digest())
            h = None

            self.brickd.authenticate(client_nonce, digest)

    def get_connection_state(self):
        """
        Can return the following states:

        - CONNECTION_STATE_DISCONNECTED: No connection is established.
        - CONNECTION_STATE_CONNECTED: A connection to the Brick Daemon or
          the WIFI/Ethernet Extension is established.
        - CONNECTION_STATE_PENDING: IP Connection is currently trying to
          connect.
        """

        if self.socket is not None:
            return IPConnection.CONNECTION_STATE_CONNECTED
        elif self.auto_reconnect_pending:
            return IPConnection.CONNECTION_STATE_PENDING
        else:
            return IPConnection.CONNECTION_STATE_DISCONNECTED

    def set_auto_reconnect(self, auto_reconnect):
        """
        Enables or disables auto-reconnect. If auto-reconnect is enabled,
        the IP Connection will try to reconnect to the previously given
        host and port, if the connection is lost.

        Default value is *True*.
        """

        self.auto_reconnect = bool(auto_reconnect)

        if not self.auto_reconnect:
            # abort potentially pending auto reconnect
            self.auto_reconnect_allowed = False

    def get_auto_reconnect(self):
        """
        Returns *true* if auto-reconnect is enabled, *false* otherwise.
        """

        return self.auto_reconnect

    def set_timeout(self, timeout):
        """
        Sets the timeout in seconds for getters and for setters for which the
        response expected flag is activated.

        Default timeout is 2.5.
        """

        timeout = float(timeout)

        if timeout < 0:
            raise ValueError('Timeout cannot be negative')

        self.timeout = timeout

    def get_timeout(self):
        """
        Returns the timeout as set by set_timeout.
        """

        return self.timeout

    def enumerate(self):
        """
        Broadcasts an enumerate request. All devices will respond with an
        enumerate callback.
        """

        request, _, _ = self.create_packet_header(None, 8, IPConnection.FUNCTION_ENUMERATE)

        self.send(request)

    def wait(self):
        """
        Stops the current thread until unwait is called.

        This is useful if you rely solely on callbacks for events, if you want
        to wait for a specific callback or if the IP Connection was created in
        a thread.

        Wait and unwait act in the same way as "acquire" and "release" of a
        semaphore.
        """
        self.waiter.acquire()

    def unwait(self):
        """
        Unwaits the thread previously stopped by wait.

        Wait and unwait act in the same way as "acquire" and "release" of
        a semaphore.
        """
        self.waiter.release()

    def register_callback(self, callback_id, function):
        """
        Registers the given *function* with the given *callback_id*.
        """
        if function is None:
            self.registered_callbacks.pop(callback_id, None)
        else:
            self.registered_callbacks[callback_id] = function

    def connect_unlocked(self, is_auto_reconnect):
        # NOTE: assumes that socket is None and socket_lock is locked

        # create callback thread and queue
        if self.callback is None:
            try:
                self.callback = IPConnection.CallbackContext()
                self.callback.queue = queue.Queue()
                self.callback.packet_dispatch_allowed = False
                self.callback.lock = threading.Lock()
                self.callback.thread = threading.Thread(name='Callback-Processor',
                                                        target=self.callback_loop,
                                                        args=(self.callback,))
                self.callback.thread.daemon = True
                self.callback.thread.start()
            except:
                self.callback = None
                raise

        # create and connect socket
        try:
            tmp = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            tmp.settimeout(5)
            tmp.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
            tmp.connect((self.host, self.port))

            if sys.platform == 'win32':
                # for some unknown reason the socket recv() call does not
                # immediate return on Windows if the socket gets shut down on
                # disconnect. the socket recv() call will still block for
                # several seconds before it returns. this in turn blocks the
                # disconnect. to workaround this use a 100ms timeout for
                # blocking socket operations.
                tmp.settimeout(0.1)
            else:
                tmp.settimeout(None)
        except Exception as e:
            def cleanup1():
                # end callback thread
                if not is_auto_reconnect:
                    self.callback.queue.put((IPConnection.QUEUE_EXIT, None))

                    if threading.current_thread() is not self.callback.thread:
                        self.callback.thread.join()

                    self.callback = None

            if not self.retry_first_connection:
                cleanup1()
            else:
                if not is_auto_reconnect and self.log_fn is not None:
                    self.log_fn(e)
                self.callback.queue.put((IPConnection.QUEUE_META,
                                    (IPConnection.CALLBACK_DISCONNECTED,
                                    IPConnection.DISCONNECT_REASON_ERROR, self.socket_id)))
            raise

        if self.retry_first_connection:
            self.reconnect_sleep_time = 0.1

        self.socket = tmp
        self.socket_id += 1

        # create disconnect probe thread
        try:
            self.disconnect_probe_flag = True
            self.disconnect_probe_queue = queue.Queue()
            self.disconnect_probe_thread = threading.Thread(name='Disconnect-Prober',
                                                            target=self.disconnect_probe_loop,
                                                            args=(self.disconnect_probe_queue,))
            self.disconnect_probe_thread.daemon = True
            self.disconnect_probe_thread.start()
        except:
            def cleanup2():
                self.disconnect_probe_thread = None

                # close socket
                self.socket.close()
                self.socket = None

                # end callback thread
                if not is_auto_reconnect:
                    self.callback.queue.put((IPConnection.QUEUE_EXIT, None))

                    if threading.current_thread() is not self.callback.thread:
                        self.callback.thread.join()

                    self.callback = None

            cleanup2()
            raise

        # create receive thread
        self.callback.packet_dispatch_allowed = True

        try:
            self.receive_flag = True
            self.receive_thread = threading.Thread(name='Brickd-Receiver',
                                                   target=self.receive_loop,
                                                   args=(self.socket_id,))
            self.receive_thread.daemon = True
            self.receive_thread.start()
        except:
            def cleanup3():
                self.receive_thread = None

                # close socket
                self.disconnect_unlocked()

                # end callback thread
                if not is_auto_reconnect:
                    self.callback.queue.put((IPConnection.QUEUE_EXIT, None))

                    if threading.current_thread() is not self.callback.thread:
                        self.callback.thread.join()

                    self.callback = None

            cleanup3()
            raise

        if not self.retry_first_connection:
            self.auto_reconnect_allowed = False
        self.auto_reconnect_pending = False

        if is_auto_reconnect:
            connect_reason = IPConnection.CONNECT_REASON_AUTO_RECONNECT
        else:
            connect_reason = IPConnection.CONNECT_REASON_REQUEST

        self.callback.queue.put((IPConnection.QUEUE_META,
                                 (IPConnection.CALLBACK_CONNECTED,
                                  connect_reason, None)))

    def disconnect_unlocked(self):
        # NOTE: assumes that socket is not None and socket_lock is locked

        # end disconnect probe thread
        self.disconnect_probe_queue.put(True)
        self.disconnect_probe_thread.join() # FIXME: use a timeout?
        self.disconnect_probe_thread = None

        # stop dispatching packet callbacks before ending the receive
        # thread to avoid timeout exceptions due to callback functions
        # trying to call getters
        if threading.current_thread() is not self.callback.thread:
            # FIXME: cannot hold callback lock here because this can
            #        deadlock due to an ordering problem with the socket lock
            #with self.callback.lock:
            if True:
                self.callback.packet_dispatch_allowed = False
        else:
            self.callback.packet_dispatch_allowed = False

        # end receive thread
        self.receive_flag = False

        try:
            self.socket.shutdown(socket.SHUT_RDWR)
        except socket.error:
            pass

        if self.receive_thread is not None:
            self.receive_thread.join() # FIXME: use a timeout?
            self.receive_thread = None

        # close socket
        self.socket.close()
        self.socket = None

    def receive_loop(self, socket_id):
        if sys.hexversion < 0x03000000:
            pending_data = ''
        else:
            pending_data = bytes()

        while self.receive_flag:
            try:
                data = self.socket.recv(8192)
            except socket.timeout:
                continue
            except socket.error:
                if self.receive_flag:
                    e = sys.exc_info()[1]
                    if e.errno == errno.EINTR:
                        continue

                    self.handle_disconnect_by_peer(IPConnection.DISCONNECT_REASON_ERROR, socket_id, False)
                break

            if len(data) == 0:
                if self.receive_flag:
                    self.handle_disconnect_by_peer(IPConnection.DISCONNECT_REASON_SHUTDOWN, socket_id, False)
                break

            pending_data += data

            while self.receive_flag:
                if len(pending_data) < 8:
                    # Wait for complete header
                    break

                length = get_length_from_data(pending_data)

                if len(pending_data) < length:
                    # Wait for complete packet
                    break

                packet = pending_data[0:length]
                pending_data = pending_data[length:]

                self.handle_response(packet)

    def dispatch_meta(self, function_id, parameter, socket_id):
        if function_id == IPConnection.CALLBACK_CONNECTED:
            if IPConnection.CALLBACK_CONNECTED in self.registered_callbacks:
                self.registered_callbacks[IPConnection.CALLBACK_CONNECTED](parameter)
        elif function_id == IPConnection.CALLBACK_DISCONNECTED:
            if parameter != IPConnection.DISCONNECT_REASON_REQUEST:
                # need to do this here, the receive_loop is not allowed to
                # hold the socket_lock because this could cause a deadlock
                # with a concurrent call to the (dis-)connect function
                with self.socket_lock:
                    # don't close the socket if it got disconnected or
                    # reconnected in the meantime
                    if self.socket is not None and self.socket_id == socket_id:
                        # end disconnect probe thread
                        self.disconnect_probe_queue.put(True)
                        self.disconnect_probe_thread.join() # FIXME: use a timeout?
                        self.disconnect_probe_thread = None

                        # close socket
                        self.socket.close()
                        self.socket = None

            # FIXME: wait a moment here, otherwise the next connect
            # attempt will succeed, even if there is no open server
            # socket. the first receive will then fail directly
            time.sleep(0.1)

            if IPConnection.CALLBACK_DISCONNECTED in self.registered_callbacks:
                self.registered_callbacks[IPConnection.CALLBACK_DISCONNECTED](parameter)

            if parameter != IPConnection.DISCONNECT_REASON_REQUEST and \
               self.auto_reconnect and self.auto_reconnect_allowed:
                self.auto_reconnect_pending = True
                retry = True

                # block here until reconnect. this is okay, there is no
                # callback to deliver when there is no connection
                while retry:
                    retry = False

                    with self.socket_lock:
                        if self.auto_reconnect_allowed and self.socket is None:
                            try:
                                self.connect_unlocked(True)
                            except:
                                retry = True
                        else:
                            self.auto_reconnect_pending = False

                    if retry:
                        time.sleep(self.reconnect_sleep_time)

    def dispatch_packet(self, packet):
        uid = get_uid_from_data(packet)
        length = get_length_from_data(packet)
        function_id = get_function_id_from_data(packet)
        payload = packet[8:]

        if function_id == IPConnection.CALLBACK_ENUMERATE and \
           IPConnection.CALLBACK_ENUMERATE in self.registered_callbacks:
            uid, connected_uid, position, hardware_version, \
                firmware_version, device_identifier, enumeration_type = \
                unpack_payload(payload, '8s 8s c 3B 3B H B')

            cb = self.registered_callbacks[IPConnection.CALLBACK_ENUMERATE]
            cb(uid, connected_uid, position, hardware_version,
               firmware_version, device_identifier, enumeration_type)
            return

        if uid not in self.devices:
            return

        device = self.devices[uid]

        if -function_id in device.high_level_callbacks:
            hlcb = device.high_level_callbacks[-function_id] # [roles, options, data]
            form = device.callback_formats[function_id] # FIXME: currently assuming that form is longer than 1
            llvalues = unpack_payload(payload, form)
            has_data = False
            data = None

            if hlcb[1]['fixed_length'] != None:
                length = hlcb[1]['fixed_length']
            else:
                length = llvalues[hlcb[0].index('stream_length')]

            if not hlcb[1]['single_chunk']:
                chunk_offset = llvalues[hlcb[0].index('stream_chunk_offset')]
            else:
                chunk_offset = 0

            chunk_data = llvalues[hlcb[0].index('stream_chunk_data')]

            if hlcb[2] == None: # no stream in-progress
                if chunk_offset == 0: # stream starts
                    hlcb[2] = chunk_data

                    if len(hlcb[2]) >= length: # stream complete
                        has_data = True
                        data = hlcb[2][:length]
                        hlcb[2] = None
                else: # ignore tail of current stream, wait for next stream start
                    pass
            else: # stream in-progress
                if chunk_offset != len(hlcb[2]): # stream out-of-sync
                    has_data = True
                    data = None
                    hlcb[2] = None
                else: # stream in-sync
                    hlcb[2] += chunk_data

                    if len(hlcb[2]) >= length: # stream complete
                        has_data = True
                        data = hlcb[2][:length]
                        hlcb[2] = None

            if has_data and -function_id in device.registered_callbacks:
                result = []

                for role, llvalue in zip(hlcb[0], llvalues):
                    if role == 'stream_chunk_data':
                        result.append(data)
                    elif role == None:
                        result.append(llvalue)

                device.registered_callbacks[-function_id](*tuple(result))

        if function_id in device.registered_callbacks:
            cb = device.registered_callbacks[function_id]
            form = device.callback_formats[function_id]

            if len(form) == 0:
                cb()
            elif len(form.split(' ')) == 1:
                cb(unpack_payload(payload, form))
            else:
                cb(*unpack_payload(payload, form))

    def callback_loop(self, callback):
        while True:
            kind, data = callback.queue.get()

            # FIXME: cannot hold callback lock here because this can
            #        deadlock due to an ordering problem with the socket lock
            #with callback.lock:
            if True:
                if kind == IPConnection.QUEUE_EXIT:
                    break
                elif kind == IPConnection.QUEUE_META:
                    self.dispatch_meta(*data)
                elif kind == IPConnection.QUEUE_PACKET:
                    # don't dispatch callbacks when the receive thread isn't running
                    if callback.packet_dispatch_allowed:
                        self.dispatch_packet(data)

    # NOTE: the disconnect probe thread is not allowed to hold the socket_lock at any
    #       time because it is created and joined while the socket_lock is locked
    def disconnect_probe_loop(self, disconnect_probe_queue):
        request, _, _ = self.create_packet_header(None, 8, IPConnection.FUNCTION_DISCONNECT_PROBE)

        while True:
            try:
                disconnect_probe_queue.get(True, IPConnection.DISCONNECT_PROBE_INTERVAL)
                break
            except queue.Empty:
                pass

            if self.disconnect_probe_flag:
                try:
                    with self.socket_send_lock:
                        while True:
                            try:
                                self.socket.send(request)
                                break
                            except socket.timeout:
                                continue
                except socket.error:
                    self.handle_disconnect_by_peer(IPConnection.DISCONNECT_REASON_ERROR,
                                                   self.socket_id, False)
                    break
            else:
                self.disconnect_probe_flag = True

    def send(self, packet):
        with self.socket_lock:
            if self.socket is None:
                raise Error(Error.NOT_CONNECTED, 'Not connected')

            try:
                with self.socket_send_lock:
                    while True:
                        try:
                            self.socket.send(packet)
                            break
                        except socket.timeout:
                            continue
            except socket.error:
                self.handle_disconnect_by_peer(IPConnection.DISCONNECT_REASON_ERROR, None, True)
                raise Error(Error.NOT_CONNECTED, 'Not connected', suppress_context=True)

            self.disconnect_probe_flag = False

    def send_request(self, device, function_id, data, form, form_ret):
        patched_from = []

        for f in form.split(' '):
            if '!' in f:
                if len(f) > 1:
                    patched_from.append('{0}B'.format(int(math.ceil(int(f.replace('!', '')) / 8.0))))
                else:
                    patched_from.append('?')
            else:
                patched_from.append(f)

        patched_from = '<' + ' '.join(patched_from)
        length = 8 + struct.calcsize(patched_from)
        request, response_expected, sequence_number = \
            self.create_packet_header(device, length, function_id)

        request += pack_payload(data, form)

        if response_expected:
            with device.request_lock:
                device.expected_response_function_id = function_id
                device.expected_response_sequence_number = sequence_number

                try:
                    self.send(request)

                    while True:
                        response = device.response_queue.get(True, self.timeout)

                        if function_id == get_function_id_from_data(response) and \
                           sequence_number == get_sequence_number_from_data(response):
                            # ignore old responses that arrived after the timeout expired, but before setting
                            # expected_response_function_id and expected_response_sequence_number back to None
                            break
                except queue.Empty:
                    msg = 'Did not receive response for function {0} in time'.format(function_id)
                    raise Error(Error.TIMEOUT, msg, suppress_context=True)
                finally:
                    device.expected_response_function_id = None
                    device.expected_response_sequence_number = None

            error_code = get_error_code_from_data(response)

            if error_code == 0:
                # no error
                pass
            elif error_code == 1:
                msg = 'Got invalid parameter for function {0}'.format(function_id)
                raise Error(Error.INVALID_PARAMETER, msg)
            elif error_code == 2:
                msg = 'Function {0} is not supported'.format(function_id)
                raise Error(Error.NOT_SUPPORTED, msg)
            else:
                msg = 'Function {0} returned an unknown error'.format(function_id)
                raise Error(Error.UNKNOWN_ERROR_CODE, msg)

            if len(form_ret) > 0:
                return unpack_payload(response[8:], form_ret)
        else:
            self.send(request)

    def get_next_sequence_number(self):
        with self.sequence_number_lock:
            sequence_number = self.next_sequence_number + 1
            self.next_sequence_number = sequence_number % 15
            return sequence_number

    def handle_response(self, packet):
        self.disconnect_probe_flag = False

        function_id = get_function_id_from_data(packet)
        sequence_number = get_sequence_number_from_data(packet)

        if sequence_number == 0 and function_id == IPConnection.CALLBACK_ENUMERATE:
            if IPConnection.CALLBACK_ENUMERATE in self.registered_callbacks:
                self.callback.queue.put((IPConnection.QUEUE_PACKET, packet))
            return

        uid = get_uid_from_data(packet)

        if not uid in self.devices:
            # Response from an unknown device, ignoring it
            return

        device = self.devices[uid]

        if sequence_number == 0:
            if function_id in device.registered_callbacks or \
               -function_id in device.high_level_callbacks:
                self.callback.queue.put((IPConnection.QUEUE_PACKET, packet))
            return

        if device.expected_response_function_id == function_id and \
           device.expected_response_sequence_number == sequence_number:
            device.response_queue.put(packet)
            return

        # Response seems to be OK, but can't be handled

    def handle_disconnect_by_peer(self, disconnect_reason, socket_id, disconnect_immediately):
        # NOTE: assumes that socket_lock is locked if disconnect_immediately is true

        self.auto_reconnect_allowed = True

        if disconnect_immediately:
            self.disconnect_unlocked()

        self.callback.queue.put((IPConnection.QUEUE_META,
                                 (IPConnection.CALLBACK_DISCONNECTED,
                                  disconnect_reason, socket_id)))

    def create_packet_header(self, device, length, function_id):
        uid = IPConnection.BROADCAST_UID
        sequence_number = self.get_next_sequence_number()
        r_bit = 0

        if device is not None:
            uid = device.uid

            if device.get_response_expected(function_id):
                r_bit = 1

        sequence_number_and_options = (sequence_number << 4) | (r_bit << 3)

        return (struct.pack('<IBBBB', uid, length, function_id,
                            sequence_number_and_options, 0),
                bool(r_bit),
                sequence_number)

    def write_bricklet_plugin(self, device, port, position, plugin_chunk):
        self.send_request(device,
                          IPConnection.FUNCTION_WRITE_BRICKLET_PLUGIN,
                          (port, position, plugin_chunk),
                          'c B 32B',
                          '')

    def read_bricklet_plugin(self, device, port, position):
        return self.send_request(device,
                                 IPConnection.FUNCTION_READ_BRICKLET_PLUGIN,
                                 (port, position),
                                 'c B',
                                 '32B')

    def get_adc_calibration(self, device):
        return self.send_request(device,
                                 IPConnection.FUNCTION_GET_ADC_CALIBRATION,
                                 (),
                                 '',
                                 'h h')

    def adc_calibrate(self, device, port):
        self.send_request(device,
                          IPConnection.FUNCTION_ADC_CALIBRATE,
                          (port,),
                          'c',
                          '')

    def write_bricklet_uid(self, device, port, uid):
        uid_int = base58decode(uid)

        self.send_request(device,
                          IPConnection.FUNCTION_WRITE_BRICKLET_UID,
                          (port, uid_int),
                          'c I',
                          '')

    def read_bricklet_uid(self, device, port):
        uid_int = self.send_request(device,
                                    IPConnection.FUNCTION_READ_BRICKLET_UID,
                                    (port,),
                                    'c',
                                    'I')

        return base58encode(uid_int)




class AccelerometerBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 2; re[3] = 1; re[4] = 2; re[5] = 1; re[6] = 2; re[7] = 1; re[8] = 1; re[9] = 3; re[10] = 1; re[11] = 3; re[12] = 3; re[13] = 1; re[255] = 1
		cf = self.callback_formats
		cf[14] = 'h h h'; cf[15] = 'h h h'


def call_accelerometer_bricklet(ctx, argv):
	prog_prefix = 'call accelerometer-bricklet <uid>'

	def get_acceleration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-acceleration')

		args = parser.parse_args(argv)

		device_call(ctx, AccelerometerBricklet, 1, (), '', 'h h h', args.execute, False, ['x', 'y', 'z'], [None, None, None])

	def set_acceleration_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-acceleration-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, AccelerometerBricklet, 2, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_acceleration_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-acceleration-callback-period')

		args = parser.parse_args(argv)

		device_call(ctx, AccelerometerBricklet, 3, (), '', 'I', args.execute, False, ['period'], [None])

	def set_acceleration_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-acceleration-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min_x', type=convert_int, help='int', metavar='<min-x>')
		parser.add_argument('max_x', type=convert_int, help='int', metavar='<max-x>')
		parser.add_argument('min_y', type=convert_int, help='int', metavar='<min-y>')
		parser.add_argument('max_y', type=convert_int, help='int', metavar='<max-y>')
		parser.add_argument('min_z', type=convert_int, help='int', metavar='<min-z>')
		parser.add_argument('max_z', type=convert_int, help='int', metavar='<max-z>')

		args = parser.parse_args(argv)

		device_call(ctx, AccelerometerBricklet, 4, (args.option, args.min_x, args.max_x, args.min_y, args.max_y, args.min_z, args.max_z), 'c h h h h h h', '', None, args.expect_response, [], [])

	def get_acceleration_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-acceleration-callback-threshold')

		args = parser.parse_args(argv)

		device_call(ctx, AccelerometerBricklet, 5, (), '', 'c h h h h h h', args.execute, False, ['option', 'min-x', 'max-x', 'min-y', 'max-y', 'min-z', 'max-z'], [{'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None, None, None, None, None])

	def set_debounce_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-debounce-period')

		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_call(ctx, AccelerometerBricklet, 6, (args.debounce,), 'I', '', None, args.expect_response, [], [])

	def get_debounce_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-debounce-period')

		args = parser.parse_args(argv)

		device_call(ctx, AccelerometerBricklet, 7, (), '', 'I', args.execute, False, ['debounce'], [None])

	def get_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, AccelerometerBricklet, 8, (), '', 'h', args.execute, False, ['temperature'], [None])

	def set_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-configuration')

		parser.add_argument('data_rate', type=create_symbol_converter(ctx, convert_int, {'data-rate-6hz': 2, 'data-rate-50hz': 5, 'data-rate-400hz': 7, 'data-rate-800hz': 8, 'data-rate-off': 0, 'data-rate-100hz': 6, 'data-rate-1600hz': 9, 'data-rate-3hz': 1, 'data-rate-12hz': 3, 'data-rate-25hz': 4}), help='int (data-rate-off: 0, data-rate-3hz: 1, data-rate-6hz: 2, data-rate-12hz: 3, data-rate-25hz: 4, data-rate-50hz: 5, data-rate-100hz: 6, data-rate-400hz: 7, data-rate-800hz: 8, data-rate-1600hz: 9)', metavar='<data-rate>')
		parser.add_argument('full_scale', type=create_symbol_converter(ctx, convert_int, {'full-scale-4g': 1, 'full-scale-6g': 2, 'full-scale-8g': 3, 'full-scale-16g': 4, 'full-scale-2g': 0}), help='int (full-scale-2g: 0, full-scale-4g: 1, full-scale-6g: 2, full-scale-8g: 3, full-scale-16g: 4)', metavar='<full-scale>')
		parser.add_argument('filter_bandwidth', type=create_symbol_converter(ctx, convert_int, {'filter-bandwidth-800hz': 0, 'filter-bandwidth-200hz': 2, 'filter-bandwidth-400hz': 1, 'filter-bandwidth-50hz': 3}), help='int (filter-bandwidth-800hz: 0, filter-bandwidth-400hz: 1, filter-bandwidth-200hz: 2, filter-bandwidth-50hz: 3)', metavar='<filter-bandwidth>')

		args = parser.parse_args(argv)

		device_call(ctx, AccelerometerBricklet, 9, (args.data_rate, args.full_scale, args.filter_bandwidth), 'B B B', '', None, args.expect_response, [], [])

	def get_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, AccelerometerBricklet, 10, (), '', 'B B B', args.execute, False, ['data-rate', 'full-scale', 'filter-bandwidth'], [{0: 'data-rate-off', 1: 'data-rate-3hz', 2: 'data-rate-6hz', 3: 'data-rate-12hz', 4: 'data-rate-25hz', 5: 'data-rate-50hz', 6: 'data-rate-100hz', 7: 'data-rate-400hz', 8: 'data-rate-800hz', 9: 'data-rate-1600hz'}, {0: 'full-scale-2g', 1: 'full-scale-4g', 2: 'full-scale-6g', 3: 'full-scale-8g', 4: 'full-scale-16g'}, {0: 'filter-bandwidth-800hz', 1: 'filter-bandwidth-400hz', 2: 'filter-bandwidth-200hz', 3: 'filter-bandwidth-50hz'}])

	def led_on(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' led-on')

		args = parser.parse_args(argv)

		device_call(ctx, AccelerometerBricklet, 11, (), '', '', None, args.expect_response, [], [])

	def led_off(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' led-off')

		args = parser.parse_args(argv)

		device_call(ctx, AccelerometerBricklet, 12, (), '', '', None, args.expect_response, [], [])

	def is_led_on(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' is-led-on')

		args = parser.parse_args(argv)

		device_call(ctx, AccelerometerBricklet, 13, (), '', '!', args.execute, False, ['on'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, AccelerometerBricklet, argv)

	functions = {
	'get-acceleration': get_acceleration,
	'set-acceleration-callback-period': set_acceleration_callback_period,
	'get-acceleration-callback-period': get_acceleration_callback_period,
	'set-acceleration-callback-threshold': set_acceleration_callback_threshold,
	'get-acceleration-callback-threshold': get_acceleration_callback_threshold,
	'set-debounce-period': set_debounce_period,
	'get-debounce-period': get_debounce_period,
	'get-temperature': get_temperature,
	'set-configuration': set_configuration,
	'get-configuration': get_configuration,
	'led-on': led_on,
	'led-off': led_off,
	'is-led-on': is_led_on,
	'get-identity': get_identity
	}

	call_generic(ctx, 'accelerometer-bricklet', functions, argv)

def dispatch_accelerometer_bricklet(ctx, argv):
	prog_prefix = 'dispatch accelerometer-bricklet <uid>'

	def acceleration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' acceleration')

		args = parser.parse_args(argv)

		device_dispatch(ctx, AccelerometerBricklet, 14, args.execute, ['x', 'y', 'z'], [None, None, None])

	def acceleration_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' acceleration-reached')

		args = parser.parse_args(argv)

		device_dispatch(ctx, AccelerometerBricklet, 15, args.execute, ['x', 'y', 'z'], [None, None, None])

	callbacks = {
	'acceleration': acceleration,
	'acceleration-reached': acceleration_reached
	}

	dispatch_generic(ctx, 'accelerometer-bricklet', callbacks, argv)

class AccelerometerV2Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 3; re[3] = 1; re[4] = 2; re[5] = 1; re[6] = 3; re[7] = 1; re[9] = 3; re[10] = 1; re[13] = 3; re[14] = 1; re[234] = 1; re[235] = 1; re[236] = 1; re[237] = 3; re[238] = 1; re[239] = 3; re[240] = 1; re[242] = 1; re[243] = 3; re[248] = 3; re[249] = 1; re[255] = 1
		cf = self.callback_formats
		cf[8] = 'i i i'; cf[11] = '30h'; cf[12] = '60b'


def call_accelerometer_v2_bricklet(ctx, argv):
	prog_prefix = 'call accelerometer-v2-bricklet <uid>'

	def get_acceleration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-acceleration')

		args = parser.parse_args(argv)

		device_call(ctx, AccelerometerV2Bricklet, 1, (), '', 'i i i', args.execute, False, ['x', 'y', 'z'], [None, None, None])

	def set_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-configuration')

		parser.add_argument('data_rate', type=create_symbol_converter(ctx, convert_int, {'data-rate-3-125hz': 2, 'data-rate-50hz': 6, 'data-rate-3200hz': 12, 'data-rate-400hz': 9, 'data-rate-0-781hz': 0, 'data-rate-200hz': 8, 'data-rate-800hz': 10, 'data-rate-12800hz': 14, 'data-rate-100hz': 7, 'data-rate-6-2512hz': 3, 'data-rate-25600hz': 15, 'data-rate-1-563hz': 1, 'data-rate-1600hz': 11, 'data-rate-6400hz': 13, 'data-rate-12-5hz': 4, 'data-rate-25hz': 5}), help='int (data-rate-0-781hz: 0, data-rate-1-563hz: 1, data-rate-3-125hz: 2, data-rate-6-2512hz: 3, data-rate-12-5hz: 4, data-rate-25hz: 5, data-rate-50hz: 6, data-rate-100hz: 7, data-rate-200hz: 8, data-rate-400hz: 9, data-rate-800hz: 10, data-rate-1600hz: 11, data-rate-3200hz: 12, data-rate-6400hz: 13, data-rate-12800hz: 14, data-rate-25600hz: 15)', metavar='<data-rate>')
		parser.add_argument('full_scale', type=create_symbol_converter(ctx, convert_int, {'full-scale-4g': 1, 'full-scale-8g': 2, 'full-scale-2g': 0}), help='int (full-scale-2g: 0, full-scale-4g: 1, full-scale-8g: 2)', metavar='<full-scale>')

		args = parser.parse_args(argv)

		device_call(ctx, AccelerometerV2Bricklet, 2, (args.data_rate, args.full_scale), 'B B', '', None, args.expect_response, [], [])

	def get_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, AccelerometerV2Bricklet, 3, (), '', 'B B', args.execute, False, ['data-rate', 'full-scale'], [{0: 'data-rate-0-781hz', 1: 'data-rate-1-563hz', 2: 'data-rate-3-125hz', 3: 'data-rate-6-2512hz', 4: 'data-rate-12-5hz', 5: 'data-rate-25hz', 6: 'data-rate-50hz', 7: 'data-rate-100hz', 8: 'data-rate-200hz', 9: 'data-rate-400hz', 10: 'data-rate-800hz', 11: 'data-rate-1600hz', 12: 'data-rate-3200hz', 13: 'data-rate-6400hz', 14: 'data-rate-12800hz', 15: 'data-rate-25600hz'}, {0: 'full-scale-2g', 1: 'full-scale-4g', 2: 'full-scale-8g'}])

	def set_acceleration_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-acceleration-callback-configuration')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')

		args = parser.parse_args(argv)

		device_call(ctx, AccelerometerV2Bricklet, 4, (args.period, args.value_has_to_change), 'I !', '', None, args.expect_response, [], [])

	def get_acceleration_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-acceleration-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, AccelerometerV2Bricklet, 5, (), '', 'I !', args.execute, False, ['period', 'value-has-to-change'], [None, None])

	def set_info_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-info-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'info-led-config-off': 0, 'info-led-config-on': 1, 'info-led-config-show-heartbeat': 2}), help='int (info-led-config-off: 0, info-led-config-on: 1, info-led-config-show-heartbeat: 2)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, AccelerometerV2Bricklet, 6, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_info_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-info-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, AccelerometerV2Bricklet, 7, (), '', 'B', args.execute, False, ['config'], [{0: 'info-led-config-off', 1: 'info-led-config-on', 2: 'info-led-config-show-heartbeat'}])

	def set_continuous_acceleration_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-continuous-acceleration-configuration')

		parser.add_argument('enable_x', type=convert_bool, help='bool', metavar='<enable-x>')
		parser.add_argument('enable_y', type=convert_bool, help='bool', metavar='<enable-y>')
		parser.add_argument('enable_z', type=convert_bool, help='bool', metavar='<enable-z>')
		parser.add_argument('resolution', type=create_symbol_converter(ctx, convert_int, {'resolution-8bit': 0, 'resolution-16bit': 1}), help='int (resolution-8bit: 0, resolution-16bit: 1)', metavar='<resolution>')

		args = parser.parse_args(argv)

		device_call(ctx, AccelerometerV2Bricklet, 9, (args.enable_x, args.enable_y, args.enable_z, args.resolution), '! ! ! B', '', None, args.expect_response, [], [])

	def get_continuous_acceleration_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-continuous-acceleration-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, AccelerometerV2Bricklet, 10, (), '', '! ! ! B', args.execute, False, ['enable-x', 'enable-y', 'enable-z', 'resolution'], [None, None, None, {0: 'resolution-8bit', 1: 'resolution-16bit'}])

	def set_filter_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-filter-configuration')

		parser.add_argument('iir_bypass', type=create_symbol_converter(ctx, convert_int, {'iir-bypass-bypassed': 1, 'iir-bypass-applied': 0}), help='int (iir-bypass-applied: 0, iir-bypass-bypassed: 1)', metavar='<iir-bypass>')
		parser.add_argument('low_pass_filter', type=create_symbol_converter(ctx, convert_int, {'low-pass-filter-ninth': 0, 'low-pass-filter-half': 1}), help='int (low-pass-filter-ninth: 0, low-pass-filter-half: 1)', metavar='<low-pass-filter>')

		args = parser.parse_args(argv)

		device_call(ctx, AccelerometerV2Bricklet, 13, (args.iir_bypass, args.low_pass_filter), 'B B', '', None, args.expect_response, [], [])

	def get_filter_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-filter-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, AccelerometerV2Bricklet, 14, (), '', 'B B', args.execute, False, ['iir-bypass', 'low-pass-filter'], [{0: 'iir-bypass-applied', 1: 'iir-bypass-bypassed'}, {0: 'low-pass-filter-ninth', 1: 'low-pass-filter-half'}])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, AccelerometerV2Bricklet, 234, (), '', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def set_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-bootloader-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'bootloader-mode-firmware-wait-for-reboot': 3, 'bootloader-mode-firmware': 1, 'bootloader-mode-firmware-wait-for-erase-and-reboot': 4, 'bootloader-mode-bootloader-wait-for-reboot': 2, 'bootloader-mode-bootloader': 0}), help='int (bootloader-mode-bootloader: 0, bootloader-mode-firmware: 1, bootloader-mode-bootloader-wait-for-reboot: 2, bootloader-mode-firmware-wait-for-reboot: 3, bootloader-mode-firmware-wait-for-erase-and-reboot: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, AccelerometerV2Bricklet, 235, (args.mode,), 'B', 'B', args.execute, False, ['status'], [{0: 'bootloader-status-ok', 1: 'bootloader-status-invalid-mode', 2: 'bootloader-status-no-change', 3: 'bootloader-status-entry-function-not-present', 4: 'bootloader-status-device-identifier-incorrect', 5: 'bootloader-status-crc-mismatch'}])

	def get_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-bootloader-mode')

		args = parser.parse_args(argv)

		device_call(ctx, AccelerometerV2Bricklet, 236, (), '', 'B', args.execute, False, ['mode'], [{0: 'bootloader-mode-bootloader', 1: 'bootloader-mode-firmware', 2: 'bootloader-mode-bootloader-wait-for-reboot', 3: 'bootloader-mode-firmware-wait-for-reboot', 4: 'bootloader-mode-firmware-wait-for-erase-and-reboot'}])

	def set_write_firmware_pointer(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-write-firmware-pointer')

		parser.add_argument('pointer', type=convert_int, help='int', metavar='<pointer>')

		args = parser.parse_args(argv)

		device_call(ctx, AccelerometerV2Bricklet, 237, (args.pointer,), 'I', '', None, args.expect_response, [], [])

	def write_firmware(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-firmware')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, AccelerometerV2Bricklet, 238, (args.data,), '64B', 'B', args.execute, False, ['status'], [None])

	def set_status_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'status-led-config-on': 1, 'status-led-config-show-heartbeat': 2, 'status-led-config-off': 0, 'status-led-config-show-status': 3}), help='int (status-led-config-off: 0, status-led-config-on: 1, status-led-config-show-heartbeat: 2, status-led-config-show-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, AccelerometerV2Bricklet, 239, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_status_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, AccelerometerV2Bricklet, 240, (), '', 'B', args.execute, False, ['config'], [{0: 'status-led-config-off', 1: 'status-led-config-on', 2: 'status-led-config-show-heartbeat', 3: 'status-led-config-show-status'}])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, AccelerometerV2Bricklet, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, AccelerometerV2Bricklet, 243, (), '', '', None, args.expect_response, [], [])

	def write_uid(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-uid')

		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')

		args = parser.parse_args(argv)

		device_call(ctx, AccelerometerV2Bricklet, 248, (args.uid,), 'I', '', None, args.expect_response, [], [])

	def read_uid(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-uid')

		args = parser.parse_args(argv)

		device_call(ctx, AccelerometerV2Bricklet, 249, (), '', 'I', args.execute, False, ['uid'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, AccelerometerV2Bricklet, argv)

	functions = {
	'get-acceleration': get_acceleration,
	'set-configuration': set_configuration,
	'get-configuration': get_configuration,
	'set-acceleration-callback-configuration': set_acceleration_callback_configuration,
	'get-acceleration-callback-configuration': get_acceleration_callback_configuration,
	'set-info-led-config': set_info_led_config,
	'get-info-led-config': get_info_led_config,
	'set-continuous-acceleration-configuration': set_continuous_acceleration_configuration,
	'get-continuous-acceleration-configuration': get_continuous_acceleration_configuration,
	'set-filter-configuration': set_filter_configuration,
	'get-filter-configuration': get_filter_configuration,
	'get-spitfp-error-count': get_spitfp_error_count,
	'set-bootloader-mode': set_bootloader_mode,
	'get-bootloader-mode': get_bootloader_mode,
	'set-write-firmware-pointer': set_write_firmware_pointer,
	'write-firmware': write_firmware,
	'set-status-led-config': set_status_led_config,
	'get-status-led-config': get_status_led_config,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'write-uid': write_uid,
	'read-uid': read_uid,
	'get-identity': get_identity
	}

	call_generic(ctx, 'accelerometer-v2-bricklet', functions, argv)

def dispatch_accelerometer_v2_bricklet(ctx, argv):
	prog_prefix = 'dispatch accelerometer-v2-bricklet <uid>'

	def acceleration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' acceleration')

		args = parser.parse_args(argv)

		device_dispatch(ctx, AccelerometerV2Bricklet, 8, args.execute, ['x', 'y', 'z'], [None, None, None])

	def continuous_acceleration_16_bit(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' continuous-acceleration-16-bit')

		args = parser.parse_args(argv)

		device_dispatch(ctx, AccelerometerV2Bricklet, 11, args.execute, ['acceleration'], [None])

	def continuous_acceleration_8_bit(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' continuous-acceleration-8-bit')

		args = parser.parse_args(argv)

		device_dispatch(ctx, AccelerometerV2Bricklet, 12, args.execute, ['acceleration'], [None])

	callbacks = {
	'acceleration': acceleration,
	'continuous-acceleration-16-bit': continuous_acceleration_16_bit,
	'continuous-acceleration-8-bit': continuous_acceleration_8_bit
	}

	dispatch_generic(ctx, 'accelerometer-v2-bricklet', callbacks, argv)

class AirQualityBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 3; re[3] = 1; re[4] = 2; re[5] = 1; re[7] = 1; re[8] = 2; re[9] = 1; re[11] = 1; re[12] = 2; re[13] = 1; re[15] = 1; re[16] = 2; re[17] = 1; re[19] = 1; re[20] = 2; re[21] = 1; re[23] = 3; re[24] = 3; re[25] = 1; re[234] = 1; re[235] = 1; re[236] = 1; re[237] = 3; re[238] = 1; re[239] = 3; re[240] = 1; re[242] = 1; re[243] = 3; re[248] = 3; re[249] = 1; re[255] = 1
		cf = self.callback_formats
		cf[6] = 'i B i i i'; cf[10] = 'i B'; cf[14] = 'i'; cf[18] = 'i'; cf[22] = 'i'


def call_air_quality_bricklet(ctx, argv):
	prog_prefix = 'call air-quality-bricklet <uid>'

	def get_all_values(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-all-values')

		args = parser.parse_args(argv)

		device_call(ctx, AirQualityBricklet, 1, (), '', 'i B i i i', args.execute, False, ['iaq-index', 'iaq-index-accuracy', 'temperature', 'humidity', 'air-pressure'], [None, {0: 'accuracy-unreliable', 1: 'accuracy-low', 2: 'accuracy-medium', 3: 'accuracy-high'}, None, None, None])

	def set_temperature_offset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-temperature-offset')

		parser.add_argument('offset', type=convert_int, help='int', metavar='<offset>')

		args = parser.parse_args(argv)

		device_call(ctx, AirQualityBricklet, 2, (args.offset,), 'i', '', None, args.expect_response, [], [])

	def get_temperature_offset(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-temperature-offset')

		args = parser.parse_args(argv)

		device_call(ctx, AirQualityBricklet, 3, (), '', 'i', args.execute, False, ['offset'], [None])

	def set_all_values_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-all-values-callback-configuration')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')

		args = parser.parse_args(argv)

		device_call(ctx, AirQualityBricklet, 4, (args.period, args.value_has_to_change), 'I !', '', None, args.expect_response, [], [])

	def get_all_values_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-all-values-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, AirQualityBricklet, 5, (), '', 'I !', args.execute, False, ['period', 'value-has-to-change'], [None, None])

	def get_iaq_index(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-iaq-index')

		args = parser.parse_args(argv)

		device_call(ctx, AirQualityBricklet, 7, (), '', 'i B', args.execute, False, ['iaq-index', 'iaq-index-accuracy'], [None, {0: 'accuracy-unreliable', 1: 'accuracy-low', 2: 'accuracy-medium', 3: 'accuracy-high'}])

	def set_iaq_index_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-iaq-index-callback-configuration')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')

		args = parser.parse_args(argv)

		device_call(ctx, AirQualityBricklet, 8, (args.period, args.value_has_to_change), 'I !', '', None, args.expect_response, [], [])

	def get_iaq_index_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-iaq-index-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, AirQualityBricklet, 9, (), '', 'I !', args.execute, False, ['period', 'value-has-to-change'], [None, None])

	def get_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, AirQualityBricklet, 11, (), '', 'i', args.execute, False, ['temperature'], [None])

	def set_temperature_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-temperature-callback-configuration')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')
		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, AirQualityBricklet, 12, (args.period, args.value_has_to_change, args.option, args.min, args.max), 'I ! c i i', '', None, args.expect_response, [], [])

	def get_temperature_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-temperature-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, AirQualityBricklet, 13, (), '', 'I ! c i i', args.execute, False, ['period', 'value-has-to-change', 'option', 'min', 'max'], [None, None, {'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def get_humidity(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-humidity')

		args = parser.parse_args(argv)

		device_call(ctx, AirQualityBricklet, 15, (), '', 'i', args.execute, False, ['humidity'], [None])

	def set_humidity_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-humidity-callback-configuration')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')
		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, AirQualityBricklet, 16, (args.period, args.value_has_to_change, args.option, args.min, args.max), 'I ! c i i', '', None, args.expect_response, [], [])

	def get_humidity_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-humidity-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, AirQualityBricklet, 17, (), '', 'I ! c i i', args.execute, False, ['period', 'value-has-to-change', 'option', 'min', 'max'], [None, None, {'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def get_air_pressure(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-air-pressure')

		args = parser.parse_args(argv)

		device_call(ctx, AirQualityBricklet, 19, (), '', 'i', args.execute, False, ['air-pressure'], [None])

	def set_air_pressure_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-air-pressure-callback-configuration')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')
		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, AirQualityBricklet, 20, (args.period, args.value_has_to_change, args.option, args.min, args.max), 'I ! c i i', '', None, args.expect_response, [], [])

	def get_air_pressure_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-air-pressure-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, AirQualityBricklet, 21, (), '', 'I ! c i i', args.execute, False, ['period', 'value-has-to-change', 'option', 'min', 'max'], [None, None, {'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def remove_calibration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' remove-calibration')

		args = parser.parse_args(argv)

		device_call(ctx, AirQualityBricklet, 23, (), '', '', None, args.expect_response, [], [])

	def set_background_calibration_duration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-background-calibration-duration')

		parser.add_argument('duration', type=create_symbol_converter(ctx, convert_int, {'duration-28-days': 1, 'duration-4-days': 0}), help='int (duration-4-days: 0, duration-28-days: 1)', metavar='<duration>')

		args = parser.parse_args(argv)

		device_call(ctx, AirQualityBricklet, 24, (args.duration,), 'B', '', None, args.expect_response, [], [])

	def get_background_calibration_duration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-background-calibration-duration')

		args = parser.parse_args(argv)

		device_call(ctx, AirQualityBricklet, 25, (), '', 'B', args.execute, False, ['duration'], [{0: 'duration-4-days', 1: 'duration-28-days'}])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, AirQualityBricklet, 234, (), '', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def set_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-bootloader-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'bootloader-mode-firmware-wait-for-reboot': 3, 'bootloader-mode-firmware': 1, 'bootloader-mode-firmware-wait-for-erase-and-reboot': 4, 'bootloader-mode-bootloader-wait-for-reboot': 2, 'bootloader-mode-bootloader': 0}), help='int (bootloader-mode-bootloader: 0, bootloader-mode-firmware: 1, bootloader-mode-bootloader-wait-for-reboot: 2, bootloader-mode-firmware-wait-for-reboot: 3, bootloader-mode-firmware-wait-for-erase-and-reboot: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, AirQualityBricklet, 235, (args.mode,), 'B', 'B', args.execute, False, ['status'], [{0: 'bootloader-status-ok', 1: 'bootloader-status-invalid-mode', 2: 'bootloader-status-no-change', 3: 'bootloader-status-entry-function-not-present', 4: 'bootloader-status-device-identifier-incorrect', 5: 'bootloader-status-crc-mismatch'}])

	def get_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-bootloader-mode')

		args = parser.parse_args(argv)

		device_call(ctx, AirQualityBricklet, 236, (), '', 'B', args.execute, False, ['mode'], [{0: 'bootloader-mode-bootloader', 1: 'bootloader-mode-firmware', 2: 'bootloader-mode-bootloader-wait-for-reboot', 3: 'bootloader-mode-firmware-wait-for-reboot', 4: 'bootloader-mode-firmware-wait-for-erase-and-reboot'}])

	def set_write_firmware_pointer(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-write-firmware-pointer')

		parser.add_argument('pointer', type=convert_int, help='int', metavar='<pointer>')

		args = parser.parse_args(argv)

		device_call(ctx, AirQualityBricklet, 237, (args.pointer,), 'I', '', None, args.expect_response, [], [])

	def write_firmware(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-firmware')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, AirQualityBricklet, 238, (args.data,), '64B', 'B', args.execute, False, ['status'], [None])

	def set_status_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'status-led-config-on': 1, 'status-led-config-show-heartbeat': 2, 'status-led-config-off': 0, 'status-led-config-show-status': 3}), help='int (status-led-config-off: 0, status-led-config-on: 1, status-led-config-show-heartbeat: 2, status-led-config-show-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, AirQualityBricklet, 239, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_status_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, AirQualityBricklet, 240, (), '', 'B', args.execute, False, ['config'], [{0: 'status-led-config-off', 1: 'status-led-config-on', 2: 'status-led-config-show-heartbeat', 3: 'status-led-config-show-status'}])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, AirQualityBricklet, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, AirQualityBricklet, 243, (), '', '', None, args.expect_response, [], [])

	def write_uid(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-uid')

		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')

		args = parser.parse_args(argv)

		device_call(ctx, AirQualityBricklet, 248, (args.uid,), 'I', '', None, args.expect_response, [], [])

	def read_uid(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-uid')

		args = parser.parse_args(argv)

		device_call(ctx, AirQualityBricklet, 249, (), '', 'I', args.execute, False, ['uid'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, AirQualityBricklet, argv)

	functions = {
	'get-all-values': get_all_values,
	'set-temperature-offset': set_temperature_offset,
	'get-temperature-offset': get_temperature_offset,
	'set-all-values-callback-configuration': set_all_values_callback_configuration,
	'get-all-values-callback-configuration': get_all_values_callback_configuration,
	'get-iaq-index': get_iaq_index,
	'set-iaq-index-callback-configuration': set_iaq_index_callback_configuration,
	'get-iaq-index-callback-configuration': get_iaq_index_callback_configuration,
	'get-temperature': get_temperature,
	'set-temperature-callback-configuration': set_temperature_callback_configuration,
	'get-temperature-callback-configuration': get_temperature_callback_configuration,
	'get-humidity': get_humidity,
	'set-humidity-callback-configuration': set_humidity_callback_configuration,
	'get-humidity-callback-configuration': get_humidity_callback_configuration,
	'get-air-pressure': get_air_pressure,
	'set-air-pressure-callback-configuration': set_air_pressure_callback_configuration,
	'get-air-pressure-callback-configuration': get_air_pressure_callback_configuration,
	'remove-calibration': remove_calibration,
	'set-background-calibration-duration': set_background_calibration_duration,
	'get-background-calibration-duration': get_background_calibration_duration,
	'get-spitfp-error-count': get_spitfp_error_count,
	'set-bootloader-mode': set_bootloader_mode,
	'get-bootloader-mode': get_bootloader_mode,
	'set-write-firmware-pointer': set_write_firmware_pointer,
	'write-firmware': write_firmware,
	'set-status-led-config': set_status_led_config,
	'get-status-led-config': get_status_led_config,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'write-uid': write_uid,
	'read-uid': read_uid,
	'get-identity': get_identity
	}

	call_generic(ctx, 'air-quality-bricklet', functions, argv)

def dispatch_air_quality_bricklet(ctx, argv):
	prog_prefix = 'dispatch air-quality-bricklet <uid>'

	def all_values(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' all-values')

		args = parser.parse_args(argv)

		device_dispatch(ctx, AirQualityBricklet, 6, args.execute, ['iaq-index', 'iaq-index-accuracy', 'temperature', 'humidity', 'air-pressure'], [None, {0: 'accuracy-unreliable', 1: 'accuracy-low', 2: 'accuracy-medium', 3: 'accuracy-high'}, None, None, None])

	def iaq_index(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' iaq-index')

		args = parser.parse_args(argv)

		device_dispatch(ctx, AirQualityBricklet, 10, args.execute, ['iaq-index', 'iaq-index-accuracy'], [None, {0: 'accuracy-unreliable', 1: 'accuracy-low', 2: 'accuracy-medium', 3: 'accuracy-high'}])

	def temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' temperature')

		args = parser.parse_args(argv)

		device_dispatch(ctx, AirQualityBricklet, 14, args.execute, ['temperature'], [None])

	def humidity(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' humidity')

		args = parser.parse_args(argv)

		device_dispatch(ctx, AirQualityBricklet, 18, args.execute, ['humidity'], [None])

	def air_pressure(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' air-pressure')

		args = parser.parse_args(argv)

		device_dispatch(ctx, AirQualityBricklet, 22, args.execute, ['air-pressure'], [None])

	callbacks = {
	'all-values': all_values,
	'iaq-index': iaq_index,
	'temperature': temperature,
	'humidity': humidity,
	'air-pressure': air_pressure
	}

	dispatch_generic(ctx, 'air-quality-bricklet', callbacks, argv)

class AmbientLightBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 1; re[3] = 2; re[4] = 1; re[5] = 2; re[6] = 1; re[7] = 2; re[8] = 1; re[9] = 2; re[10] = 1; re[11] = 2; re[12] = 1; re[255] = 1
		cf = self.callback_formats
		cf[13] = 'H'; cf[14] = 'H'; cf[15] = 'H'; cf[16] = 'H'


def call_ambient_light_bricklet(ctx, argv):
	prog_prefix = 'call ambient-light-bricklet <uid>'

	def get_illuminance(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-illuminance')

		args = parser.parse_args(argv)

		device_call(ctx, AmbientLightBricklet, 1, (), '', 'H', args.execute, False, ['illuminance'], [None])

	def get_analog_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-analog-value')

		args = parser.parse_args(argv)

		device_call(ctx, AmbientLightBricklet, 2, (), '', 'H', args.execute, False, ['value'], [None])

	def set_illuminance_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-illuminance-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, AmbientLightBricklet, 3, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_illuminance_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-illuminance-callback-period')

		args = parser.parse_args(argv)

		device_call(ctx, AmbientLightBricklet, 4, (), '', 'I', args.execute, False, ['period'], [None])

	def set_analog_value_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-analog-value-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, AmbientLightBricklet, 5, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_analog_value_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-analog-value-callback-period')

		args = parser.parse_args(argv)

		device_call(ctx, AmbientLightBricklet, 6, (), '', 'I', args.execute, False, ['period'], [None])

	def set_illuminance_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-illuminance-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, AmbientLightBricklet, 7, (args.option, args.min, args.max), 'c H H', '', None, args.expect_response, [], [])

	def get_illuminance_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-illuminance-callback-threshold')

		args = parser.parse_args(argv)

		device_call(ctx, AmbientLightBricklet, 8, (), '', 'c H H', args.execute, False, ['option', 'min', 'max'], [{'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def set_analog_value_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-analog-value-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, AmbientLightBricklet, 9, (args.option, args.min, args.max), 'c H H', '', None, args.expect_response, [], [])

	def get_analog_value_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-analog-value-callback-threshold')

		args = parser.parse_args(argv)

		device_call(ctx, AmbientLightBricklet, 10, (), '', 'c H H', args.execute, False, ['option', 'min', 'max'], [{'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def set_debounce_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-debounce-period')

		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_call(ctx, AmbientLightBricklet, 11, (args.debounce,), 'I', '', None, args.expect_response, [], [])

	def get_debounce_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-debounce-period')

		args = parser.parse_args(argv)

		device_call(ctx, AmbientLightBricklet, 12, (), '', 'I', args.execute, False, ['debounce'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, AmbientLightBricklet, argv)

	functions = {
	'get-illuminance': get_illuminance,
	'get-analog-value': get_analog_value,
	'set-illuminance-callback-period': set_illuminance_callback_period,
	'get-illuminance-callback-period': get_illuminance_callback_period,
	'set-analog-value-callback-period': set_analog_value_callback_period,
	'get-analog-value-callback-period': get_analog_value_callback_period,
	'set-illuminance-callback-threshold': set_illuminance_callback_threshold,
	'get-illuminance-callback-threshold': get_illuminance_callback_threshold,
	'set-analog-value-callback-threshold': set_analog_value_callback_threshold,
	'get-analog-value-callback-threshold': get_analog_value_callback_threshold,
	'set-debounce-period': set_debounce_period,
	'get-debounce-period': get_debounce_period,
	'get-identity': get_identity
	}

	call_generic(ctx, 'ambient-light-bricklet', functions, argv)

def dispatch_ambient_light_bricklet(ctx, argv):
	prog_prefix = 'dispatch ambient-light-bricklet <uid>'

	def illuminance(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' illuminance')

		args = parser.parse_args(argv)

		device_dispatch(ctx, AmbientLightBricklet, 13, args.execute, ['illuminance'], [None])

	def analog_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' analog-value')

		args = parser.parse_args(argv)

		device_dispatch(ctx, AmbientLightBricklet, 14, args.execute, ['value'], [None])

	def illuminance_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' illuminance-reached')

		args = parser.parse_args(argv)

		device_dispatch(ctx, AmbientLightBricklet, 15, args.execute, ['illuminance'], [None])

	def analog_value_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' analog-value-reached')

		args = parser.parse_args(argv)

		device_dispatch(ctx, AmbientLightBricklet, 16, args.execute, ['value'], [None])

	callbacks = {
	'illuminance': illuminance,
	'analog-value': analog_value,
	'illuminance-reached': illuminance_reached,
	'analog-value-reached': analog_value_reached
	}

	dispatch_generic(ctx, 'ambient-light-bricklet', callbacks, argv)

class AmbientLightV2Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 2; re[3] = 1; re[4] = 2; re[5] = 1; re[6] = 2; re[7] = 1; re[8] = 3; re[9] = 1; re[255] = 1
		cf = self.callback_formats
		cf[10] = 'I'; cf[11] = 'I'


def call_ambient_light_v2_bricklet(ctx, argv):
	prog_prefix = 'call ambient-light-v2-bricklet <uid>'

	def get_illuminance(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-illuminance')

		args = parser.parse_args(argv)

		device_call(ctx, AmbientLightV2Bricklet, 1, (), '', 'I', args.execute, False, ['illuminance'], [None])

	def set_illuminance_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-illuminance-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, AmbientLightV2Bricklet, 2, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_illuminance_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-illuminance-callback-period')

		args = parser.parse_args(argv)

		device_call(ctx, AmbientLightV2Bricklet, 3, (), '', 'I', args.execute, False, ['period'], [None])

	def set_illuminance_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-illuminance-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, AmbientLightV2Bricklet, 4, (args.option, args.min, args.max), 'c I I', '', None, args.expect_response, [], [])

	def get_illuminance_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-illuminance-callback-threshold')

		args = parser.parse_args(argv)

		device_call(ctx, AmbientLightV2Bricklet, 5, (), '', 'c I I', args.execute, False, ['option', 'min', 'max'], [{'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def set_debounce_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-debounce-period')

		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_call(ctx, AmbientLightV2Bricklet, 6, (args.debounce,), 'I', '', None, args.expect_response, [], [])

	def get_debounce_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-debounce-period')

		args = parser.parse_args(argv)

		device_call(ctx, AmbientLightV2Bricklet, 7, (), '', 'I', args.execute, False, ['debounce'], [None])

	def set_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-configuration')

		parser.add_argument('illuminance_range', type=create_symbol_converter(ctx, convert_int, {'illuminance-range-unlimited': 6, 'illuminance-range-8000lux': 3, 'illuminance-range-600lux': 5, 'illuminance-range-16000lux': 2, 'illuminance-range-32000lux': 1, 'illuminance-range-64000lux': 0, 'illuminance-range-1300lux': 4}), help='int (illuminance-range-unlimited: 6, illuminance-range-64000lux: 0, illuminance-range-32000lux: 1, illuminance-range-16000lux: 2, illuminance-range-8000lux: 3, illuminance-range-1300lux: 4, illuminance-range-600lux: 5)', metavar='<illuminance-range>')
		parser.add_argument('integration_time', type=create_symbol_converter(ctx, convert_int, {'integration-time-50ms': 0, 'integration-time-300ms': 5, 'integration-time-350ms': 6, 'integration-time-200ms': 3, 'integration-time-150ms': 2, 'integration-time-250ms': 4, 'integration-time-400ms': 7, 'integration-time-100ms': 1}), help='int (integration-time-50ms: 0, integration-time-100ms: 1, integration-time-150ms: 2, integration-time-200ms: 3, integration-time-250ms: 4, integration-time-300ms: 5, integration-time-350ms: 6, integration-time-400ms: 7)', metavar='<integration-time>')

		args = parser.parse_args(argv)

		device_call(ctx, AmbientLightV2Bricklet, 8, (args.illuminance_range, args.integration_time), 'B B', '', None, args.expect_response, [], [])

	def get_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, AmbientLightV2Bricklet, 9, (), '', 'B B', args.execute, False, ['illuminance-range', 'integration-time'], [{0: 'illuminance-range-64000lux', 1: 'illuminance-range-32000lux', 2: 'illuminance-range-16000lux', 3: 'illuminance-range-8000lux', 4: 'illuminance-range-1300lux', 5: 'illuminance-range-600lux', 6: 'illuminance-range-unlimited'}, {0: 'integration-time-50ms', 1: 'integration-time-100ms', 2: 'integration-time-150ms', 3: 'integration-time-200ms', 4: 'integration-time-250ms', 5: 'integration-time-300ms', 6: 'integration-time-350ms', 7: 'integration-time-400ms'}])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, AmbientLightV2Bricklet, argv)

	functions = {
	'get-illuminance': get_illuminance,
	'set-illuminance-callback-period': set_illuminance_callback_period,
	'get-illuminance-callback-period': get_illuminance_callback_period,
	'set-illuminance-callback-threshold': set_illuminance_callback_threshold,
	'get-illuminance-callback-threshold': get_illuminance_callback_threshold,
	'set-debounce-period': set_debounce_period,
	'get-debounce-period': get_debounce_period,
	'set-configuration': set_configuration,
	'get-configuration': get_configuration,
	'get-identity': get_identity
	}

	call_generic(ctx, 'ambient-light-v2-bricklet', functions, argv)

def dispatch_ambient_light_v2_bricklet(ctx, argv):
	prog_prefix = 'dispatch ambient-light-v2-bricklet <uid>'

	def illuminance(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' illuminance')

		args = parser.parse_args(argv)

		device_dispatch(ctx, AmbientLightV2Bricklet, 10, args.execute, ['illuminance'], [None])

	def illuminance_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' illuminance-reached')

		args = parser.parse_args(argv)

		device_dispatch(ctx, AmbientLightV2Bricklet, 11, args.execute, ['illuminance'], [None])

	callbacks = {
	'illuminance': illuminance,
	'illuminance-reached': illuminance_reached
	}

	dispatch_generic(ctx, 'ambient-light-v2-bricklet', callbacks, argv)

class AmbientLightV3Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 2; re[3] = 1; re[5] = 3; re[6] = 1; re[234] = 1; re[235] = 1; re[236] = 1; re[237] = 3; re[238] = 1; re[239] = 3; re[240] = 1; re[242] = 1; re[243] = 3; re[248] = 3; re[249] = 1; re[255] = 1
		cf = self.callback_formats
		cf[4] = 'I'


def call_ambient_light_v3_bricklet(ctx, argv):
	prog_prefix = 'call ambient-light-v3-bricklet <uid>'

	def get_illuminance(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-illuminance')

		args = parser.parse_args(argv)

		device_call(ctx, AmbientLightV3Bricklet, 1, (), '', 'I', args.execute, False, ['illuminance'], [None])

	def set_illuminance_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-illuminance-callback-configuration')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')
		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, AmbientLightV3Bricklet, 2, (args.period, args.value_has_to_change, args.option, args.min, args.max), 'I ! c I I', '', None, args.expect_response, [], [])

	def get_illuminance_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-illuminance-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, AmbientLightV3Bricklet, 3, (), '', 'I ! c I I', args.execute, False, ['period', 'value-has-to-change', 'option', 'min', 'max'], [None, None, {'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def set_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-configuration')

		parser.add_argument('illuminance_range', type=create_symbol_converter(ctx, convert_int, {'illuminance-range-unlimited': 6, 'illuminance-range-8000lux': 3, 'illuminance-range-600lux': 5, 'illuminance-range-16000lux': 2, 'illuminance-range-32000lux': 1, 'illuminance-range-64000lux': 0, 'illuminance-range-1300lux': 4}), help='int (illuminance-range-unlimited: 6, illuminance-range-64000lux: 0, illuminance-range-32000lux: 1, illuminance-range-16000lux: 2, illuminance-range-8000lux: 3, illuminance-range-1300lux: 4, illuminance-range-600lux: 5)', metavar='<illuminance-range>')
		parser.add_argument('integration_time', type=create_symbol_converter(ctx, convert_int, {'integration-time-50ms': 0, 'integration-time-300ms': 5, 'integration-time-350ms': 6, 'integration-time-200ms': 3, 'integration-time-150ms': 2, 'integration-time-250ms': 4, 'integration-time-400ms': 7, 'integration-time-100ms': 1}), help='int (integration-time-50ms: 0, integration-time-100ms: 1, integration-time-150ms: 2, integration-time-200ms: 3, integration-time-250ms: 4, integration-time-300ms: 5, integration-time-350ms: 6, integration-time-400ms: 7)', metavar='<integration-time>')

		args = parser.parse_args(argv)

		device_call(ctx, AmbientLightV3Bricklet, 5, (args.illuminance_range, args.integration_time), 'B B', '', None, args.expect_response, [], [])

	def get_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, AmbientLightV3Bricklet, 6, (), '', 'B B', args.execute, False, ['illuminance-range', 'integration-time'], [{0: 'illuminance-range-64000lux', 1: 'illuminance-range-32000lux', 2: 'illuminance-range-16000lux', 3: 'illuminance-range-8000lux', 4: 'illuminance-range-1300lux', 5: 'illuminance-range-600lux', 6: 'illuminance-range-unlimited'}, {0: 'integration-time-50ms', 1: 'integration-time-100ms', 2: 'integration-time-150ms', 3: 'integration-time-200ms', 4: 'integration-time-250ms', 5: 'integration-time-300ms', 6: 'integration-time-350ms', 7: 'integration-time-400ms'}])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, AmbientLightV3Bricklet, 234, (), '', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def set_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-bootloader-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'bootloader-mode-firmware-wait-for-reboot': 3, 'bootloader-mode-firmware': 1, 'bootloader-mode-firmware-wait-for-erase-and-reboot': 4, 'bootloader-mode-bootloader-wait-for-reboot': 2, 'bootloader-mode-bootloader': 0}), help='int (bootloader-mode-bootloader: 0, bootloader-mode-firmware: 1, bootloader-mode-bootloader-wait-for-reboot: 2, bootloader-mode-firmware-wait-for-reboot: 3, bootloader-mode-firmware-wait-for-erase-and-reboot: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, AmbientLightV3Bricklet, 235, (args.mode,), 'B', 'B', args.execute, False, ['status'], [{0: 'bootloader-status-ok', 1: 'bootloader-status-invalid-mode', 2: 'bootloader-status-no-change', 3: 'bootloader-status-entry-function-not-present', 4: 'bootloader-status-device-identifier-incorrect', 5: 'bootloader-status-crc-mismatch'}])

	def get_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-bootloader-mode')

		args = parser.parse_args(argv)

		device_call(ctx, AmbientLightV3Bricklet, 236, (), '', 'B', args.execute, False, ['mode'], [{0: 'bootloader-mode-bootloader', 1: 'bootloader-mode-firmware', 2: 'bootloader-mode-bootloader-wait-for-reboot', 3: 'bootloader-mode-firmware-wait-for-reboot', 4: 'bootloader-mode-firmware-wait-for-erase-and-reboot'}])

	def set_write_firmware_pointer(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-write-firmware-pointer')

		parser.add_argument('pointer', type=convert_int, help='int', metavar='<pointer>')

		args = parser.parse_args(argv)

		device_call(ctx, AmbientLightV3Bricklet, 237, (args.pointer,), 'I', '', None, args.expect_response, [], [])

	def write_firmware(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-firmware')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, AmbientLightV3Bricklet, 238, (args.data,), '64B', 'B', args.execute, False, ['status'], [None])

	def set_status_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'status-led-config-on': 1, 'status-led-config-show-heartbeat': 2, 'status-led-config-off': 0, 'status-led-config-show-status': 3}), help='int (status-led-config-off: 0, status-led-config-on: 1, status-led-config-show-heartbeat: 2, status-led-config-show-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, AmbientLightV3Bricklet, 239, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_status_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, AmbientLightV3Bricklet, 240, (), '', 'B', args.execute, False, ['config'], [{0: 'status-led-config-off', 1: 'status-led-config-on', 2: 'status-led-config-show-heartbeat', 3: 'status-led-config-show-status'}])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, AmbientLightV3Bricklet, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, AmbientLightV3Bricklet, 243, (), '', '', None, args.expect_response, [], [])

	def write_uid(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-uid')

		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')

		args = parser.parse_args(argv)

		device_call(ctx, AmbientLightV3Bricklet, 248, (args.uid,), 'I', '', None, args.expect_response, [], [])

	def read_uid(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-uid')

		args = parser.parse_args(argv)

		device_call(ctx, AmbientLightV3Bricklet, 249, (), '', 'I', args.execute, False, ['uid'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, AmbientLightV3Bricklet, argv)

	functions = {
	'get-illuminance': get_illuminance,
	'set-illuminance-callback-configuration': set_illuminance_callback_configuration,
	'get-illuminance-callback-configuration': get_illuminance_callback_configuration,
	'set-configuration': set_configuration,
	'get-configuration': get_configuration,
	'get-spitfp-error-count': get_spitfp_error_count,
	'set-bootloader-mode': set_bootloader_mode,
	'get-bootloader-mode': get_bootloader_mode,
	'set-write-firmware-pointer': set_write_firmware_pointer,
	'write-firmware': write_firmware,
	'set-status-led-config': set_status_led_config,
	'get-status-led-config': get_status_led_config,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'write-uid': write_uid,
	'read-uid': read_uid,
	'get-identity': get_identity
	}

	call_generic(ctx, 'ambient-light-v3-bricklet', functions, argv)

def dispatch_ambient_light_v3_bricklet(ctx, argv):
	prog_prefix = 'dispatch ambient-light-v3-bricklet <uid>'

	def illuminance(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' illuminance')

		args = parser.parse_args(argv)

		device_dispatch(ctx, AmbientLightV3Bricklet, 4, args.execute, ['illuminance'], [None])

	callbacks = {
	'illuminance': illuminance
	}

	dispatch_generic(ctx, 'ambient-light-v3-bricklet', callbacks, argv)

class AnalogInBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 1; re[3] = 2; re[4] = 1; re[5] = 2; re[6] = 1; re[7] = 2; re[8] = 1; re[9] = 2; re[10] = 1; re[11] = 2; re[12] = 1; re[17] = 3; re[18] = 1; re[19] = 3; re[20] = 1; re[255] = 1
		cf = self.callback_formats
		cf[13] = 'H'; cf[14] = 'H'; cf[15] = 'H'; cf[16] = 'H'


def call_analog_in_bricklet(ctx, argv):
	prog_prefix = 'call analog-in-bricklet <uid>'

	def get_voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-voltage')

		args = parser.parse_args(argv)

		device_call(ctx, AnalogInBricklet, 1, (), '', 'H', args.execute, False, ['voltage'], [None])

	def get_analog_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-analog-value')

		args = parser.parse_args(argv)

		device_call(ctx, AnalogInBricklet, 2, (), '', 'H', args.execute, False, ['value'], [None])

	def set_voltage_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-voltage-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, AnalogInBricklet, 3, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_voltage_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-voltage-callback-period')

		args = parser.parse_args(argv)

		device_call(ctx, AnalogInBricklet, 4, (), '', 'I', args.execute, False, ['period'], [None])

	def set_analog_value_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-analog-value-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, AnalogInBricklet, 5, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_analog_value_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-analog-value-callback-period')

		args = parser.parse_args(argv)

		device_call(ctx, AnalogInBricklet, 6, (), '', 'I', args.execute, False, ['period'], [None])

	def set_voltage_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-voltage-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, AnalogInBricklet, 7, (args.option, args.min, args.max), 'c H H', '', None, args.expect_response, [], [])

	def get_voltage_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-voltage-callback-threshold')

		args = parser.parse_args(argv)

		device_call(ctx, AnalogInBricklet, 8, (), '', 'c H H', args.execute, False, ['option', 'min', 'max'], [{'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def set_analog_value_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-analog-value-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, AnalogInBricklet, 9, (args.option, args.min, args.max), 'c H H', '', None, args.expect_response, [], [])

	def get_analog_value_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-analog-value-callback-threshold')

		args = parser.parse_args(argv)

		device_call(ctx, AnalogInBricklet, 10, (), '', 'c H H', args.execute, False, ['option', 'min', 'max'], [{'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def set_debounce_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-debounce-period')

		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_call(ctx, AnalogInBricklet, 11, (args.debounce,), 'I', '', None, args.expect_response, [], [])

	def get_debounce_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-debounce-period')

		args = parser.parse_args(argv)

		device_call(ctx, AnalogInBricklet, 12, (), '', 'I', args.execute, False, ['debounce'], [None])

	def set_range(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-range')

		parser.add_argument('range', type=create_symbol_converter(ctx, convert_int, {'range-up-to-36v': 3, 'range-up-to-6v': 1, 'range-automatic': 0, 'range-up-to-10v': 2, 'range-up-to-45v': 4, 'range-up-to-3v': 5}), help='int (range-automatic: 0, range-up-to-6v: 1, range-up-to-10v: 2, range-up-to-36v: 3, range-up-to-45v: 4, range-up-to-3v: 5)', metavar='<range>')

		args = parser.parse_args(argv)

		device_call(ctx, AnalogInBricklet, 17, (args.range,), 'B', '', None, args.expect_response, [], [])

	def get_range(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-range')

		args = parser.parse_args(argv)

		device_call(ctx, AnalogInBricklet, 18, (), '', 'B', args.execute, False, ['range'], [{0: 'range-automatic', 1: 'range-up-to-6v', 2: 'range-up-to-10v', 3: 'range-up-to-36v', 4: 'range-up-to-45v', 5: 'range-up-to-3v'}])

	def set_averaging(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-averaging')

		parser.add_argument('average', type=convert_int, help='int', metavar='<average>')

		args = parser.parse_args(argv)

		device_call(ctx, AnalogInBricklet, 19, (args.average,), 'B', '', None, args.expect_response, [], [])

	def get_averaging(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-averaging')

		args = parser.parse_args(argv)

		device_call(ctx, AnalogInBricklet, 20, (), '', 'B', args.execute, False, ['average'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, AnalogInBricklet, argv)

	functions = {
	'get-voltage': get_voltage,
	'get-analog-value': get_analog_value,
	'set-voltage-callback-period': set_voltage_callback_period,
	'get-voltage-callback-period': get_voltage_callback_period,
	'set-analog-value-callback-period': set_analog_value_callback_period,
	'get-analog-value-callback-period': get_analog_value_callback_period,
	'set-voltage-callback-threshold': set_voltage_callback_threshold,
	'get-voltage-callback-threshold': get_voltage_callback_threshold,
	'set-analog-value-callback-threshold': set_analog_value_callback_threshold,
	'get-analog-value-callback-threshold': get_analog_value_callback_threshold,
	'set-debounce-period': set_debounce_period,
	'get-debounce-period': get_debounce_period,
	'set-range': set_range,
	'get-range': get_range,
	'set-averaging': set_averaging,
	'get-averaging': get_averaging,
	'get-identity': get_identity
	}

	call_generic(ctx, 'analog-in-bricklet', functions, argv)

def dispatch_analog_in_bricklet(ctx, argv):
	prog_prefix = 'dispatch analog-in-bricklet <uid>'

	def voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' voltage')

		args = parser.parse_args(argv)

		device_dispatch(ctx, AnalogInBricklet, 13, args.execute, ['voltage'], [None])

	def analog_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' analog-value')

		args = parser.parse_args(argv)

		device_dispatch(ctx, AnalogInBricklet, 14, args.execute, ['value'], [None])

	def voltage_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' voltage-reached')

		args = parser.parse_args(argv)

		device_dispatch(ctx, AnalogInBricklet, 15, args.execute, ['voltage'], [None])

	def analog_value_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' analog-value-reached')

		args = parser.parse_args(argv)

		device_dispatch(ctx, AnalogInBricklet, 16, args.execute, ['value'], [None])

	callbacks = {
	'voltage': voltage,
	'analog-value': analog_value,
	'voltage-reached': voltage_reached,
	'analog-value-reached': analog_value_reached
	}

	dispatch_generic(ctx, 'analog-in-bricklet', callbacks, argv)

class AnalogInV2Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 1; re[3] = 2; re[4] = 1; re[5] = 2; re[6] = 1; re[7] = 2; re[8] = 1; re[9] = 2; re[10] = 1; re[11] = 2; re[12] = 1; re[13] = 3; re[14] = 1; re[255] = 1
		cf = self.callback_formats
		cf[15] = 'H'; cf[16] = 'H'; cf[17] = 'H'; cf[18] = 'H'


def call_analog_in_v2_bricklet(ctx, argv):
	prog_prefix = 'call analog-in-v2-bricklet <uid>'

	def get_voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-voltage')

		args = parser.parse_args(argv)

		device_call(ctx, AnalogInV2Bricklet, 1, (), '', 'H', args.execute, False, ['voltage'], [None])

	def get_analog_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-analog-value')

		args = parser.parse_args(argv)

		device_call(ctx, AnalogInV2Bricklet, 2, (), '', 'H', args.execute, False, ['value'], [None])

	def set_voltage_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-voltage-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, AnalogInV2Bricklet, 3, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_voltage_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-voltage-callback-period')

		args = parser.parse_args(argv)

		device_call(ctx, AnalogInV2Bricklet, 4, (), '', 'I', args.execute, False, ['period'], [None])

	def set_analog_value_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-analog-value-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, AnalogInV2Bricklet, 5, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_analog_value_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-analog-value-callback-period')

		args = parser.parse_args(argv)

		device_call(ctx, AnalogInV2Bricklet, 6, (), '', 'I', args.execute, False, ['period'], [None])

	def set_voltage_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-voltage-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, AnalogInV2Bricklet, 7, (args.option, args.min, args.max), 'c H H', '', None, args.expect_response, [], [])

	def get_voltage_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-voltage-callback-threshold')

		args = parser.parse_args(argv)

		device_call(ctx, AnalogInV2Bricklet, 8, (), '', 'c H H', args.execute, False, ['option', 'min', 'max'], [{'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def set_analog_value_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-analog-value-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, AnalogInV2Bricklet, 9, (args.option, args.min, args.max), 'c H H', '', None, args.expect_response, [], [])

	def get_analog_value_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-analog-value-callback-threshold')

		args = parser.parse_args(argv)

		device_call(ctx, AnalogInV2Bricklet, 10, (), '', 'c H H', args.execute, False, ['option', 'min', 'max'], [{'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def set_debounce_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-debounce-period')

		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_call(ctx, AnalogInV2Bricklet, 11, (args.debounce,), 'I', '', None, args.expect_response, [], [])

	def get_debounce_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-debounce-period')

		args = parser.parse_args(argv)

		device_call(ctx, AnalogInV2Bricklet, 12, (), '', 'I', args.execute, False, ['debounce'], [None])

	def set_moving_average(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-moving-average')

		parser.add_argument('average', type=convert_int, help='int', metavar='<average>')

		args = parser.parse_args(argv)

		device_call(ctx, AnalogInV2Bricklet, 13, (args.average,), 'B', '', None, args.expect_response, [], [])

	def get_moving_average(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-moving-average')

		args = parser.parse_args(argv)

		device_call(ctx, AnalogInV2Bricklet, 14, (), '', 'B', args.execute, False, ['average'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, AnalogInV2Bricklet, argv)

	functions = {
	'get-voltage': get_voltage,
	'get-analog-value': get_analog_value,
	'set-voltage-callback-period': set_voltage_callback_period,
	'get-voltage-callback-period': get_voltage_callback_period,
	'set-analog-value-callback-period': set_analog_value_callback_period,
	'get-analog-value-callback-period': get_analog_value_callback_period,
	'set-voltage-callback-threshold': set_voltage_callback_threshold,
	'get-voltage-callback-threshold': get_voltage_callback_threshold,
	'set-analog-value-callback-threshold': set_analog_value_callback_threshold,
	'get-analog-value-callback-threshold': get_analog_value_callback_threshold,
	'set-debounce-period': set_debounce_period,
	'get-debounce-period': get_debounce_period,
	'set-moving-average': set_moving_average,
	'get-moving-average': get_moving_average,
	'get-identity': get_identity
	}

	call_generic(ctx, 'analog-in-v2-bricklet', functions, argv)

def dispatch_analog_in_v2_bricklet(ctx, argv):
	prog_prefix = 'dispatch analog-in-v2-bricklet <uid>'

	def voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' voltage')

		args = parser.parse_args(argv)

		device_dispatch(ctx, AnalogInV2Bricklet, 15, args.execute, ['voltage'], [None])

	def analog_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' analog-value')

		args = parser.parse_args(argv)

		device_dispatch(ctx, AnalogInV2Bricklet, 16, args.execute, ['value'], [None])

	def voltage_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' voltage-reached')

		args = parser.parse_args(argv)

		device_dispatch(ctx, AnalogInV2Bricklet, 17, args.execute, ['voltage'], [None])

	def analog_value_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' analog-value-reached')

		args = parser.parse_args(argv)

		device_dispatch(ctx, AnalogInV2Bricklet, 18, args.execute, ['value'], [None])

	callbacks = {
	'voltage': voltage,
	'analog-value': analog_value,
	'voltage-reached': voltage_reached,
	'analog-value-reached': analog_value_reached
	}

	dispatch_generic(ctx, 'analog-in-v2-bricklet', callbacks, argv)

class AnalogInV3Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 2; re[3] = 1; re[5] = 3; re[6] = 1; re[7] = 3; re[8] = 1; re[234] = 1; re[235] = 1; re[236] = 1; re[237] = 3; re[238] = 1; re[239] = 3; re[240] = 1; re[242] = 1; re[243] = 3; re[248] = 3; re[249] = 1; re[255] = 1
		cf = self.callback_formats
		cf[4] = 'H'


def call_analog_in_v3_bricklet(ctx, argv):
	prog_prefix = 'call analog-in-v3-bricklet <uid>'

	def get_voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-voltage')

		args = parser.parse_args(argv)

		device_call(ctx, AnalogInV3Bricklet, 1, (), '', 'H', args.execute, False, ['voltage'], [None])

	def set_voltage_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-voltage-callback-configuration')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')
		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, AnalogInV3Bricklet, 2, (args.period, args.value_has_to_change, args.option, args.min, args.max), 'I ! c H H', '', None, args.expect_response, [], [])

	def get_voltage_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-voltage-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, AnalogInV3Bricklet, 3, (), '', 'I ! c H H', args.execute, False, ['period', 'value-has-to-change', 'option', 'min', 'max'], [None, None, {'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def set_oversampling(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-oversampling')

		parser.add_argument('oversampling', type=create_symbol_converter(ctx, convert_int, {'oversampling-2048': 6, 'oversampling-64': 1, 'oversampling-1024': 5, 'oversampling-16384': 9, 'oversampling-512': 4, 'oversampling-256': 3, 'oversampling-128': 2, 'oversampling-4096': 7, 'oversampling-32': 0, 'oversampling-8192': 8}), help='int (oversampling-32: 0, oversampling-64: 1, oversampling-128: 2, oversampling-256: 3, oversampling-512: 4, oversampling-1024: 5, oversampling-2048: 6, oversampling-4096: 7, oversampling-8192: 8, oversampling-16384: 9)', metavar='<oversampling>')

		args = parser.parse_args(argv)

		device_call(ctx, AnalogInV3Bricklet, 5, (args.oversampling,), 'B', '', None, args.expect_response, [], [])

	def get_oversampling(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-oversampling')

		args = parser.parse_args(argv)

		device_call(ctx, AnalogInV3Bricklet, 6, (), '', 'B', args.execute, False, ['oversampling'], [{0: 'oversampling-32', 1: 'oversampling-64', 2: 'oversampling-128', 3: 'oversampling-256', 4: 'oversampling-512', 5: 'oversampling-1024', 6: 'oversampling-2048', 7: 'oversampling-4096', 8: 'oversampling-8192', 9: 'oversampling-16384'}])

	def set_calibration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-calibration')

		parser.add_argument('offset', type=convert_int, help='int', metavar='<offset>')
		parser.add_argument('multiplier', type=convert_int, help='int', metavar='<multiplier>')
		parser.add_argument('divisor', type=convert_int, help='int', metavar='<divisor>')

		args = parser.parse_args(argv)

		device_call(ctx, AnalogInV3Bricklet, 7, (args.offset, args.multiplier, args.divisor), 'h H H', '', None, args.expect_response, [], [])

	def get_calibration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-calibration')

		args = parser.parse_args(argv)

		device_call(ctx, AnalogInV3Bricklet, 8, (), '', 'h H H', args.execute, False, ['offset', 'multiplier', 'divisor'], [None, None, None])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, AnalogInV3Bricklet, 234, (), '', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def set_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-bootloader-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'bootloader-mode-firmware-wait-for-reboot': 3, 'bootloader-mode-firmware': 1, 'bootloader-mode-firmware-wait-for-erase-and-reboot': 4, 'bootloader-mode-bootloader-wait-for-reboot': 2, 'bootloader-mode-bootloader': 0}), help='int (bootloader-mode-bootloader: 0, bootloader-mode-firmware: 1, bootloader-mode-bootloader-wait-for-reboot: 2, bootloader-mode-firmware-wait-for-reboot: 3, bootloader-mode-firmware-wait-for-erase-and-reboot: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, AnalogInV3Bricklet, 235, (args.mode,), 'B', 'B', args.execute, False, ['status'], [{0: 'bootloader-status-ok', 1: 'bootloader-status-invalid-mode', 2: 'bootloader-status-no-change', 3: 'bootloader-status-entry-function-not-present', 4: 'bootloader-status-device-identifier-incorrect', 5: 'bootloader-status-crc-mismatch'}])

	def get_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-bootloader-mode')

		args = parser.parse_args(argv)

		device_call(ctx, AnalogInV3Bricklet, 236, (), '', 'B', args.execute, False, ['mode'], [{0: 'bootloader-mode-bootloader', 1: 'bootloader-mode-firmware', 2: 'bootloader-mode-bootloader-wait-for-reboot', 3: 'bootloader-mode-firmware-wait-for-reboot', 4: 'bootloader-mode-firmware-wait-for-erase-and-reboot'}])

	def set_write_firmware_pointer(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-write-firmware-pointer')

		parser.add_argument('pointer', type=convert_int, help='int', metavar='<pointer>')

		args = parser.parse_args(argv)

		device_call(ctx, AnalogInV3Bricklet, 237, (args.pointer,), 'I', '', None, args.expect_response, [], [])

	def write_firmware(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-firmware')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, AnalogInV3Bricklet, 238, (args.data,), '64B', 'B', args.execute, False, ['status'], [None])

	def set_status_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'status-led-config-on': 1, 'status-led-config-show-heartbeat': 2, 'status-led-config-off': 0, 'status-led-config-show-status': 3}), help='int (status-led-config-off: 0, status-led-config-on: 1, status-led-config-show-heartbeat: 2, status-led-config-show-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, AnalogInV3Bricklet, 239, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_status_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, AnalogInV3Bricklet, 240, (), '', 'B', args.execute, False, ['config'], [{0: 'status-led-config-off', 1: 'status-led-config-on', 2: 'status-led-config-show-heartbeat', 3: 'status-led-config-show-status'}])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, AnalogInV3Bricklet, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, AnalogInV3Bricklet, 243, (), '', '', None, args.expect_response, [], [])

	def write_uid(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-uid')

		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')

		args = parser.parse_args(argv)

		device_call(ctx, AnalogInV3Bricklet, 248, (args.uid,), 'I', '', None, args.expect_response, [], [])

	def read_uid(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-uid')

		args = parser.parse_args(argv)

		device_call(ctx, AnalogInV3Bricklet, 249, (), '', 'I', args.execute, False, ['uid'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, AnalogInV3Bricklet, argv)

	functions = {
	'get-voltage': get_voltage,
	'set-voltage-callback-configuration': set_voltage_callback_configuration,
	'get-voltage-callback-configuration': get_voltage_callback_configuration,
	'set-oversampling': set_oversampling,
	'get-oversampling': get_oversampling,
	'set-calibration': set_calibration,
	'get-calibration': get_calibration,
	'get-spitfp-error-count': get_spitfp_error_count,
	'set-bootloader-mode': set_bootloader_mode,
	'get-bootloader-mode': get_bootloader_mode,
	'set-write-firmware-pointer': set_write_firmware_pointer,
	'write-firmware': write_firmware,
	'set-status-led-config': set_status_led_config,
	'get-status-led-config': get_status_led_config,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'write-uid': write_uid,
	'read-uid': read_uid,
	'get-identity': get_identity
	}

	call_generic(ctx, 'analog-in-v3-bricklet', functions, argv)

def dispatch_analog_in_v3_bricklet(ctx, argv):
	prog_prefix = 'dispatch analog-in-v3-bricklet <uid>'

	def voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' voltage')

		args = parser.parse_args(argv)

		device_dispatch(ctx, AnalogInV3Bricklet, 4, args.execute, ['voltage'], [None])

	callbacks = {
	'voltage': voltage
	}

	dispatch_generic(ctx, 'analog-in-v3-bricklet', callbacks, argv)

class AnalogOutBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 3; re[2] = 1; re[3] = 3; re[4] = 1; re[255] = 1



def call_analog_out_bricklet(ctx, argv):
	prog_prefix = 'call analog-out-bricklet <uid>'

	def set_voltage(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-voltage')

		parser.add_argument('voltage', type=convert_int, help='int', metavar='<voltage>')

		args = parser.parse_args(argv)

		device_call(ctx, AnalogOutBricklet, 1, (args.voltage,), 'H', '', None, args.expect_response, [], [])

	def get_voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-voltage')

		args = parser.parse_args(argv)

		device_call(ctx, AnalogOutBricklet, 2, (), '', 'H', args.execute, False, ['voltage'], [None])

	def set_mode(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'mode-1k-to-ground': 1, 'mode-analog-value': 0, 'mode-100k-to-ground': 2, 'mode-500k-to-ground': 3}), help='int (mode-analog-value: 0, mode-1k-to-ground: 1, mode-100k-to-ground: 2, mode-500k-to-ground: 3)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, AnalogOutBricklet, 3, (args.mode,), 'B', '', None, args.expect_response, [], [])

	def get_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-mode')

		args = parser.parse_args(argv)

		device_call(ctx, AnalogOutBricklet, 4, (), '', 'B', args.execute, False, ['mode'], [{0: 'mode-analog-value', 1: 'mode-1k-to-ground', 2: 'mode-100k-to-ground', 3: 'mode-500k-to-ground'}])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, AnalogOutBricklet, argv)

	functions = {
	'set-voltage': set_voltage,
	'get-voltage': get_voltage,
	'set-mode': set_mode,
	'get-mode': get_mode,
	'get-identity': get_identity
	}

	call_generic(ctx, 'analog-out-bricklet', functions, argv)

def dispatch_analog_out_bricklet(ctx, argv):
	prog_prefix = 'dispatch analog-out-bricklet <uid>'


	callbacks = {

	}

	dispatch_generic(ctx, 'analog-out-bricklet', callbacks, argv)

class AnalogOutV2Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 3; re[2] = 1; re[3] = 1; re[255] = 1



def call_analog_out_v2_bricklet(ctx, argv):
	prog_prefix = 'call analog-out-v2-bricklet <uid>'

	def set_output_voltage(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-output-voltage')

		parser.add_argument('voltage', type=convert_int, help='int', metavar='<voltage>')

		args = parser.parse_args(argv)

		device_call(ctx, AnalogOutV2Bricklet, 1, (args.voltage,), 'H', '', None, args.expect_response, [], [])

	def get_output_voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-output-voltage')

		args = parser.parse_args(argv)

		device_call(ctx, AnalogOutV2Bricklet, 2, (), '', 'H', args.execute, False, ['voltage'], [None])

	def get_input_voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-input-voltage')

		args = parser.parse_args(argv)

		device_call(ctx, AnalogOutV2Bricklet, 3, (), '', 'H', args.execute, False, ['voltage'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, AnalogOutV2Bricklet, argv)

	functions = {
	'set-output-voltage': set_output_voltage,
	'get-output-voltage': get_output_voltage,
	'get-input-voltage': get_input_voltage,
	'get-identity': get_identity
	}

	call_generic(ctx, 'analog-out-v2-bricklet', functions, argv)

def dispatch_analog_out_v2_bricklet(ctx, argv):
	prog_prefix = 'dispatch analog-out-v2-bricklet <uid>'


	callbacks = {

	}

	dispatch_generic(ctx, 'analog-out-v2-bricklet', callbacks, argv)

class AnalogOutV3Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 3; re[2] = 1; re[3] = 1; re[234] = 1; re[235] = 1; re[236] = 1; re[237] = 3; re[238] = 1; re[239] = 3; re[240] = 1; re[242] = 1; re[243] = 3; re[248] = 3; re[249] = 1; re[255] = 1



def call_analog_out_v3_bricklet(ctx, argv):
	prog_prefix = 'call analog-out-v3-bricklet <uid>'

	def set_output_voltage(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-output-voltage')

		parser.add_argument('voltage', type=convert_int, help='int', metavar='<voltage>')

		args = parser.parse_args(argv)

		device_call(ctx, AnalogOutV3Bricklet, 1, (args.voltage,), 'H', '', None, args.expect_response, [], [])

	def get_output_voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-output-voltage')

		args = parser.parse_args(argv)

		device_call(ctx, AnalogOutV3Bricklet, 2, (), '', 'H', args.execute, False, ['voltage'], [None])

	def get_input_voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-input-voltage')

		args = parser.parse_args(argv)

		device_call(ctx, AnalogOutV3Bricklet, 3, (), '', 'H', args.execute, False, ['voltage'], [None])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, AnalogOutV3Bricklet, 234, (), '', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def set_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-bootloader-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'bootloader-mode-firmware-wait-for-reboot': 3, 'bootloader-mode-firmware': 1, 'bootloader-mode-firmware-wait-for-erase-and-reboot': 4, 'bootloader-mode-bootloader-wait-for-reboot': 2, 'bootloader-mode-bootloader': 0}), help='int (bootloader-mode-bootloader: 0, bootloader-mode-firmware: 1, bootloader-mode-bootloader-wait-for-reboot: 2, bootloader-mode-firmware-wait-for-reboot: 3, bootloader-mode-firmware-wait-for-erase-and-reboot: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, AnalogOutV3Bricklet, 235, (args.mode,), 'B', 'B', args.execute, False, ['status'], [{0: 'bootloader-status-ok', 1: 'bootloader-status-invalid-mode', 2: 'bootloader-status-no-change', 3: 'bootloader-status-entry-function-not-present', 4: 'bootloader-status-device-identifier-incorrect', 5: 'bootloader-status-crc-mismatch'}])

	def get_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-bootloader-mode')

		args = parser.parse_args(argv)

		device_call(ctx, AnalogOutV3Bricklet, 236, (), '', 'B', args.execute, False, ['mode'], [{0: 'bootloader-mode-bootloader', 1: 'bootloader-mode-firmware', 2: 'bootloader-mode-bootloader-wait-for-reboot', 3: 'bootloader-mode-firmware-wait-for-reboot', 4: 'bootloader-mode-firmware-wait-for-erase-and-reboot'}])

	def set_write_firmware_pointer(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-write-firmware-pointer')

		parser.add_argument('pointer', type=convert_int, help='int', metavar='<pointer>')

		args = parser.parse_args(argv)

		device_call(ctx, AnalogOutV3Bricklet, 237, (args.pointer,), 'I', '', None, args.expect_response, [], [])

	def write_firmware(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-firmware')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, AnalogOutV3Bricklet, 238, (args.data,), '64B', 'B', args.execute, False, ['status'], [None])

	def set_status_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'status-led-config-on': 1, 'status-led-config-show-heartbeat': 2, 'status-led-config-off': 0, 'status-led-config-show-status': 3}), help='int (status-led-config-off: 0, status-led-config-on: 1, status-led-config-show-heartbeat: 2, status-led-config-show-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, AnalogOutV3Bricklet, 239, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_status_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, AnalogOutV3Bricklet, 240, (), '', 'B', args.execute, False, ['config'], [{0: 'status-led-config-off', 1: 'status-led-config-on', 2: 'status-led-config-show-heartbeat', 3: 'status-led-config-show-status'}])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, AnalogOutV3Bricklet, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, AnalogOutV3Bricklet, 243, (), '', '', None, args.expect_response, [], [])

	def write_uid(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-uid')

		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')

		args = parser.parse_args(argv)

		device_call(ctx, AnalogOutV3Bricklet, 248, (args.uid,), 'I', '', None, args.expect_response, [], [])

	def read_uid(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-uid')

		args = parser.parse_args(argv)

		device_call(ctx, AnalogOutV3Bricklet, 249, (), '', 'I', args.execute, False, ['uid'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, AnalogOutV3Bricklet, argv)

	functions = {
	'set-output-voltage': set_output_voltage,
	'get-output-voltage': get_output_voltage,
	'get-input-voltage': get_input_voltage,
	'get-spitfp-error-count': get_spitfp_error_count,
	'set-bootloader-mode': set_bootloader_mode,
	'get-bootloader-mode': get_bootloader_mode,
	'set-write-firmware-pointer': set_write_firmware_pointer,
	'write-firmware': write_firmware,
	'set-status-led-config': set_status_led_config,
	'get-status-led-config': get_status_led_config,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'write-uid': write_uid,
	'read-uid': read_uid,
	'get-identity': get_identity
	}

	call_generic(ctx, 'analog-out-v3-bricklet', functions, argv)

def dispatch_analog_out_v3_bricklet(ctx, argv):
	prog_prefix = 'dispatch analog-out-v3-bricklet <uid>'


	callbacks = {

	}

	dispatch_generic(ctx, 'analog-out-v3-bricklet', callbacks, argv)

class BarometerBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 1; re[3] = 2; re[4] = 1; re[5] = 2; re[6] = 1; re[7] = 2; re[8] = 1; re[9] = 2; re[10] = 1; re[11] = 2; re[12] = 1; re[13] = 3; re[14] = 1; re[19] = 1; re[20] = 3; re[21] = 1; re[255] = 1
		cf = self.callback_formats
		cf[15] = 'i'; cf[16] = 'i'; cf[17] = 'i'; cf[18] = 'i'


def call_barometer_bricklet(ctx, argv):
	prog_prefix = 'call barometer-bricklet <uid>'

	def get_air_pressure(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-air-pressure')

		args = parser.parse_args(argv)

		device_call(ctx, BarometerBricklet, 1, (), '', 'i', args.execute, False, ['air-pressure'], [None])

	def get_altitude(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-altitude')

		args = parser.parse_args(argv)

		device_call(ctx, BarometerBricklet, 2, (), '', 'i', args.execute, False, ['altitude'], [None])

	def set_air_pressure_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-air-pressure-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, BarometerBricklet, 3, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_air_pressure_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-air-pressure-callback-period')

		args = parser.parse_args(argv)

		device_call(ctx, BarometerBricklet, 4, (), '', 'I', args.execute, False, ['period'], [None])

	def set_altitude_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-altitude-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, BarometerBricklet, 5, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_altitude_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-altitude-callback-period')

		args = parser.parse_args(argv)

		device_call(ctx, BarometerBricklet, 6, (), '', 'I', args.execute, False, ['period'], [None])

	def set_air_pressure_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-air-pressure-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, BarometerBricklet, 7, (args.option, args.min, args.max), 'c i i', '', None, args.expect_response, [], [])

	def get_air_pressure_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-air-pressure-callback-threshold')

		args = parser.parse_args(argv)

		device_call(ctx, BarometerBricklet, 8, (), '', 'c i i', args.execute, False, ['option', 'min', 'max'], [{'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def set_altitude_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-altitude-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, BarometerBricklet, 9, (args.option, args.min, args.max), 'c i i', '', None, args.expect_response, [], [])

	def get_altitude_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-altitude-callback-threshold')

		args = parser.parse_args(argv)

		device_call(ctx, BarometerBricklet, 10, (), '', 'c i i', args.execute, False, ['option', 'min', 'max'], [{'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def set_debounce_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-debounce-period')

		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_call(ctx, BarometerBricklet, 11, (args.debounce,), 'I', '', None, args.expect_response, [], [])

	def get_debounce_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-debounce-period')

		args = parser.parse_args(argv)

		device_call(ctx, BarometerBricklet, 12, (), '', 'I', args.execute, False, ['debounce'], [None])

	def set_reference_air_pressure(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-reference-air-pressure')

		parser.add_argument('air_pressure', type=convert_int, help='int', metavar='<air-pressure>')

		args = parser.parse_args(argv)

		device_call(ctx, BarometerBricklet, 13, (args.air_pressure,), 'i', '', None, args.expect_response, [], [])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, BarometerBricklet, 14, (), '', 'h', args.execute, False, ['temperature'], [None])

	def get_reference_air_pressure(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-reference-air-pressure')

		args = parser.parse_args(argv)

		device_call(ctx, BarometerBricklet, 19, (), '', 'i', args.execute, False, ['air-pressure'], [None])

	def set_averaging(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-averaging')

		parser.add_argument('moving_average_pressure', type=convert_int, help='int', metavar='<moving-average-pressure>')
		parser.add_argument('average_pressure', type=convert_int, help='int', metavar='<average-pressure>')
		parser.add_argument('average_temperature', type=convert_int, help='int', metavar='<average-temperature>')

		args = parser.parse_args(argv)

		device_call(ctx, BarometerBricklet, 20, (args.moving_average_pressure, args.average_pressure, args.average_temperature), 'B B B', '', None, args.expect_response, [], [])

	def get_averaging(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-averaging')

		args = parser.parse_args(argv)

		device_call(ctx, BarometerBricklet, 21, (), '', 'B B B', args.execute, False, ['moving-average-pressure', 'average-pressure', 'average-temperature'], [None, None, None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, BarometerBricklet, argv)

	functions = {
	'get-air-pressure': get_air_pressure,
	'get-altitude': get_altitude,
	'set-air-pressure-callback-period': set_air_pressure_callback_period,
	'get-air-pressure-callback-period': get_air_pressure_callback_period,
	'set-altitude-callback-period': set_altitude_callback_period,
	'get-altitude-callback-period': get_altitude_callback_period,
	'set-air-pressure-callback-threshold': set_air_pressure_callback_threshold,
	'get-air-pressure-callback-threshold': get_air_pressure_callback_threshold,
	'set-altitude-callback-threshold': set_altitude_callback_threshold,
	'get-altitude-callback-threshold': get_altitude_callback_threshold,
	'set-debounce-period': set_debounce_period,
	'get-debounce-period': get_debounce_period,
	'set-reference-air-pressure': set_reference_air_pressure,
	'get-chip-temperature': get_chip_temperature,
	'get-reference-air-pressure': get_reference_air_pressure,
	'set-averaging': set_averaging,
	'get-averaging': get_averaging,
	'get-identity': get_identity
	}

	call_generic(ctx, 'barometer-bricklet', functions, argv)

def dispatch_barometer_bricklet(ctx, argv):
	prog_prefix = 'dispatch barometer-bricklet <uid>'

	def air_pressure(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' air-pressure')

		args = parser.parse_args(argv)

		device_dispatch(ctx, BarometerBricklet, 15, args.execute, ['air-pressure'], [None])

	def altitude(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' altitude')

		args = parser.parse_args(argv)

		device_dispatch(ctx, BarometerBricklet, 16, args.execute, ['altitude'], [None])

	def air_pressure_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' air-pressure-reached')

		args = parser.parse_args(argv)

		device_dispatch(ctx, BarometerBricklet, 17, args.execute, ['air-pressure'], [None])

	def altitude_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' altitude-reached')

		args = parser.parse_args(argv)

		device_dispatch(ctx, BarometerBricklet, 18, args.execute, ['altitude'], [None])

	callbacks = {
	'air-pressure': air_pressure,
	'altitude': altitude,
	'air-pressure-reached': air_pressure_reached,
	'altitude-reached': altitude_reached
	}

	dispatch_generic(ctx, 'barometer-bricklet', callbacks, argv)

class BarometerV2Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 2; re[3] = 1; re[5] = 1; re[6] = 2; re[7] = 1; re[9] = 1; re[10] = 2; re[11] = 1; re[13] = 3; re[14] = 1; re[15] = 3; re[16] = 1; re[17] = 3; re[18] = 1; re[19] = 3; re[20] = 1; re[234] = 1; re[235] = 1; re[236] = 1; re[237] = 3; re[238] = 1; re[239] = 3; re[240] = 1; re[242] = 1; re[243] = 3; re[248] = 3; re[249] = 1; re[255] = 1
		cf = self.callback_formats
		cf[4] = 'i'; cf[8] = 'i'; cf[12] = 'i'


def call_barometer_v2_bricklet(ctx, argv):
	prog_prefix = 'call barometer-v2-bricklet <uid>'

	def get_air_pressure(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-air-pressure')

		args = parser.parse_args(argv)

		device_call(ctx, BarometerV2Bricklet, 1, (), '', 'i', args.execute, False, ['air-pressure'], [None])

	def set_air_pressure_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-air-pressure-callback-configuration')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')
		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, BarometerV2Bricklet, 2, (args.period, args.value_has_to_change, args.option, args.min, args.max), 'I ! c i i', '', None, args.expect_response, [], [])

	def get_air_pressure_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-air-pressure-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, BarometerV2Bricklet, 3, (), '', 'I ! c i i', args.execute, False, ['period', 'value-has-to-change', 'option', 'min', 'max'], [None, None, {'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def get_altitude(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-altitude')

		args = parser.parse_args(argv)

		device_call(ctx, BarometerV2Bricklet, 5, (), '', 'i', args.execute, False, ['altitude'], [None])

	def set_altitude_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-altitude-callback-configuration')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')
		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, BarometerV2Bricklet, 6, (args.period, args.value_has_to_change, args.option, args.min, args.max), 'I ! c i i', '', None, args.expect_response, [], [])

	def get_altitude_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-altitude-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, BarometerV2Bricklet, 7, (), '', 'I ! c i i', args.execute, False, ['period', 'value-has-to-change', 'option', 'min', 'max'], [None, None, {'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def get_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, BarometerV2Bricklet, 9, (), '', 'i', args.execute, False, ['temperature'], [None])

	def set_temperature_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-temperature-callback-configuration')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')
		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, BarometerV2Bricklet, 10, (args.period, args.value_has_to_change, args.option, args.min, args.max), 'I ! c i i', '', None, args.expect_response, [], [])

	def get_temperature_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-temperature-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, BarometerV2Bricklet, 11, (), '', 'I ! c i i', args.execute, False, ['period', 'value-has-to-change', 'option', 'min', 'max'], [None, None, {'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def set_moving_average_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-moving-average-configuration')

		parser.add_argument('moving_average_length_air_pressure', type=convert_int, help='int', metavar='<moving-average-length-air-pressure>')
		parser.add_argument('moving_average_length_temperature', type=convert_int, help='int', metavar='<moving-average-length-temperature>')

		args = parser.parse_args(argv)

		device_call(ctx, BarometerV2Bricklet, 13, (args.moving_average_length_air_pressure, args.moving_average_length_temperature), 'H H', '', None, args.expect_response, [], [])

	def get_moving_average_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-moving-average-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, BarometerV2Bricklet, 14, (), '', 'H H', args.execute, False, ['moving-average-length-air-pressure', 'moving-average-length-temperature'], [None, None])

	def set_reference_air_pressure(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-reference-air-pressure')

		parser.add_argument('air_pressure', type=convert_int, help='int', metavar='<air-pressure>')

		args = parser.parse_args(argv)

		device_call(ctx, BarometerV2Bricklet, 15, (args.air_pressure,), 'i', '', None, args.expect_response, [], [])

	def get_reference_air_pressure(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-reference-air-pressure')

		args = parser.parse_args(argv)

		device_call(ctx, BarometerV2Bricklet, 16, (), '', 'i', args.execute, False, ['air-pressure'], [None])

	def set_calibration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-calibration')

		parser.add_argument('measured_air_pressure', type=convert_int, help='int', metavar='<measured-air-pressure>')
		parser.add_argument('actual_air_pressure', type=convert_int, help='int', metavar='<actual-air-pressure>')

		args = parser.parse_args(argv)

		device_call(ctx, BarometerV2Bricklet, 17, (args.measured_air_pressure, args.actual_air_pressure), 'i i', '', None, args.expect_response, [], [])

	def get_calibration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-calibration')

		args = parser.parse_args(argv)

		device_call(ctx, BarometerV2Bricklet, 18, (), '', 'i i', args.execute, False, ['measured-air-pressure', 'actual-air-pressure'], [None, None])

	def set_sensor_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-sensor-configuration')

		parser.add_argument('data_rate', type=create_symbol_converter(ctx, convert_int, {'data-rate-50hz': 4, 'data-rate-75hz': 5, 'data-rate-off': 0, 'data-rate-10hz': 2, 'data-rate-1hz': 1, 'data-rate-25hz': 3}), help='int (data-rate-off: 0, data-rate-1hz: 1, data-rate-10hz: 2, data-rate-25hz: 3, data-rate-50hz: 4, data-rate-75hz: 5)', metavar='<data-rate>')
		parser.add_argument('air_pressure_low_pass_filter', type=create_symbol_converter(ctx, convert_int, {'low-pass-filter-off': 0, 'low-pass-filter-1-20th': 2, 'low-pass-filter-1-9th': 1}), help='int (low-pass-filter-off: 0, low-pass-filter-1-9th: 1, low-pass-filter-1-20th: 2)', metavar='<air-pressure-low-pass-filter>')

		args = parser.parse_args(argv)

		device_call(ctx, BarometerV2Bricklet, 19, (args.data_rate, args.air_pressure_low_pass_filter), 'B B', '', None, args.expect_response, [], [])

	def get_sensor_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-sensor-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, BarometerV2Bricklet, 20, (), '', 'B B', args.execute, False, ['data-rate', 'air-pressure-low-pass-filter'], [{0: 'data-rate-off', 1: 'data-rate-1hz', 2: 'data-rate-10hz', 3: 'data-rate-25hz', 4: 'data-rate-50hz', 5: 'data-rate-75hz'}, {0: 'low-pass-filter-off', 1: 'low-pass-filter-1-9th', 2: 'low-pass-filter-1-20th'}])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, BarometerV2Bricklet, 234, (), '', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def set_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-bootloader-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'bootloader-mode-firmware-wait-for-reboot': 3, 'bootloader-mode-firmware': 1, 'bootloader-mode-firmware-wait-for-erase-and-reboot': 4, 'bootloader-mode-bootloader-wait-for-reboot': 2, 'bootloader-mode-bootloader': 0}), help='int (bootloader-mode-bootloader: 0, bootloader-mode-firmware: 1, bootloader-mode-bootloader-wait-for-reboot: 2, bootloader-mode-firmware-wait-for-reboot: 3, bootloader-mode-firmware-wait-for-erase-and-reboot: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, BarometerV2Bricklet, 235, (args.mode,), 'B', 'B', args.execute, False, ['status'], [{0: 'bootloader-status-ok', 1: 'bootloader-status-invalid-mode', 2: 'bootloader-status-no-change', 3: 'bootloader-status-entry-function-not-present', 4: 'bootloader-status-device-identifier-incorrect', 5: 'bootloader-status-crc-mismatch'}])

	def get_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-bootloader-mode')

		args = parser.parse_args(argv)

		device_call(ctx, BarometerV2Bricklet, 236, (), '', 'B', args.execute, False, ['mode'], [{0: 'bootloader-mode-bootloader', 1: 'bootloader-mode-firmware', 2: 'bootloader-mode-bootloader-wait-for-reboot', 3: 'bootloader-mode-firmware-wait-for-reboot', 4: 'bootloader-mode-firmware-wait-for-erase-and-reboot'}])

	def set_write_firmware_pointer(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-write-firmware-pointer')

		parser.add_argument('pointer', type=convert_int, help='int', metavar='<pointer>')

		args = parser.parse_args(argv)

		device_call(ctx, BarometerV2Bricklet, 237, (args.pointer,), 'I', '', None, args.expect_response, [], [])

	def write_firmware(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-firmware')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, BarometerV2Bricklet, 238, (args.data,), '64B', 'B', args.execute, False, ['status'], [None])

	def set_status_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'status-led-config-on': 1, 'status-led-config-show-heartbeat': 2, 'status-led-config-off': 0, 'status-led-config-show-status': 3}), help='int (status-led-config-off: 0, status-led-config-on: 1, status-led-config-show-heartbeat: 2, status-led-config-show-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, BarometerV2Bricklet, 239, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_status_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, BarometerV2Bricklet, 240, (), '', 'B', args.execute, False, ['config'], [{0: 'status-led-config-off', 1: 'status-led-config-on', 2: 'status-led-config-show-heartbeat', 3: 'status-led-config-show-status'}])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, BarometerV2Bricklet, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, BarometerV2Bricklet, 243, (), '', '', None, args.expect_response, [], [])

	def write_uid(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-uid')

		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')

		args = parser.parse_args(argv)

		device_call(ctx, BarometerV2Bricklet, 248, (args.uid,), 'I', '', None, args.expect_response, [], [])

	def read_uid(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-uid')

		args = parser.parse_args(argv)

		device_call(ctx, BarometerV2Bricklet, 249, (), '', 'I', args.execute, False, ['uid'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, BarometerV2Bricklet, argv)

	functions = {
	'get-air-pressure': get_air_pressure,
	'set-air-pressure-callback-configuration': set_air_pressure_callback_configuration,
	'get-air-pressure-callback-configuration': get_air_pressure_callback_configuration,
	'get-altitude': get_altitude,
	'set-altitude-callback-configuration': set_altitude_callback_configuration,
	'get-altitude-callback-configuration': get_altitude_callback_configuration,
	'get-temperature': get_temperature,
	'set-temperature-callback-configuration': set_temperature_callback_configuration,
	'get-temperature-callback-configuration': get_temperature_callback_configuration,
	'set-moving-average-configuration': set_moving_average_configuration,
	'get-moving-average-configuration': get_moving_average_configuration,
	'set-reference-air-pressure': set_reference_air_pressure,
	'get-reference-air-pressure': get_reference_air_pressure,
	'set-calibration': set_calibration,
	'get-calibration': get_calibration,
	'set-sensor-configuration': set_sensor_configuration,
	'get-sensor-configuration': get_sensor_configuration,
	'get-spitfp-error-count': get_spitfp_error_count,
	'set-bootloader-mode': set_bootloader_mode,
	'get-bootloader-mode': get_bootloader_mode,
	'set-write-firmware-pointer': set_write_firmware_pointer,
	'write-firmware': write_firmware,
	'set-status-led-config': set_status_led_config,
	'get-status-led-config': get_status_led_config,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'write-uid': write_uid,
	'read-uid': read_uid,
	'get-identity': get_identity
	}

	call_generic(ctx, 'barometer-v2-bricklet', functions, argv)

def dispatch_barometer_v2_bricklet(ctx, argv):
	prog_prefix = 'dispatch barometer-v2-bricklet <uid>'

	def air_pressure(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' air-pressure')

		args = parser.parse_args(argv)

		device_dispatch(ctx, BarometerV2Bricklet, 4, args.execute, ['air-pressure'], [None])

	def altitude(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' altitude')

		args = parser.parse_args(argv)

		device_dispatch(ctx, BarometerV2Bricklet, 8, args.execute, ['altitude'], [None])

	def temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' temperature')

		args = parser.parse_args(argv)

		device_dispatch(ctx, BarometerV2Bricklet, 12, args.execute, ['temperature'], [None])

	callbacks = {
	'air-pressure': air_pressure,
	'altitude': altitude,
	'temperature': temperature
	}

	dispatch_generic(ctx, 'barometer-v2-bricklet', callbacks, argv)

class CANBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 1; re[3] = 2; re[4] = 2; re[5] = 1; re[6] = 3; re[7] = 1; re[8] = 3; re[9] = 1; re[10] = 1; re[255] = 1
		cf = self.callback_formats
		cf[11] = 'B I 8B B'


def call_can_bricklet(ctx, argv):
	prog_prefix = 'call can-bricklet <uid>'

	def write_frame(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-frame')

		parser.add_argument('frame_type', type=create_symbol_converter(ctx, convert_int, {'frame-type-extended-remote': 3, 'frame-type-standard-data': 0, 'frame-type-extended-data': 2, 'frame-type-standard-remote': 1}), help='int (frame-type-standard-data: 0, frame-type-standard-remote: 1, frame-type-extended-data: 2, frame-type-extended-remote: 3)', metavar='<frame-type>')
		parser.add_argument('identifier', type=convert_int, help='int', metavar='<identifier>')
		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 8), help=get_array_type_name(ctx, 'int', 8), metavar='<data>')
		parser.add_argument('length', type=convert_int, help='int', metavar='<length>')

		args = parser.parse_args(argv)

		device_call(ctx, CANBricklet, 1, (args.frame_type, args.identifier, args.data, args.length), 'B I 8B B', '!', args.execute, False, ['success'], [None])

	def read_frame(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-frame')

		args = parser.parse_args(argv)

		device_call(ctx, CANBricklet, 2, (), '', '! B I 8B B', args.execute, False, ['success', 'frame-type', 'identifier', 'data', 'length'], [None, {0: 'frame-type-standard-data', 1: 'frame-type-standard-remote', 2: 'frame-type-extended-data', 3: 'frame-type-extended-remote'}, None, None, None])

	def enable_frame_read_callback(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' enable-frame-read-callback')

		args = parser.parse_args(argv)

		device_call(ctx, CANBricklet, 3, (), '', '', None, args.expect_response, [], [])

	def disable_frame_read_callback(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' disable-frame-read-callback')

		args = parser.parse_args(argv)

		device_call(ctx, CANBricklet, 4, (), '', '', None, args.expect_response, [], [])

	def is_frame_read_callback_enabled(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' is-frame-read-callback-enabled')

		args = parser.parse_args(argv)

		device_call(ctx, CANBricklet, 5, (), '', '!', args.execute, False, ['enabled'], [None])

	def set_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-configuration')

		parser.add_argument('baud_rate', type=create_symbol_converter(ctx, convert_int, {'baud-rate-125kbps': 3, 'baud-rate-10kbps': 0, 'baud-rate-800kbps': 6, 'baud-rate-1000kbps': 7, 'baud-rate-250kbps': 4, 'baud-rate-20kbps': 1, 'baud-rate-500kbps': 5, 'baud-rate-50kbps': 2}), help='int (baud-rate-10kbps: 0, baud-rate-20kbps: 1, baud-rate-50kbps: 2, baud-rate-125kbps: 3, baud-rate-250kbps: 4, baud-rate-500kbps: 5, baud-rate-800kbps: 6, baud-rate-1000kbps: 7)', metavar='<baud-rate>')
		parser.add_argument('transceiver_mode', type=create_symbol_converter(ctx, convert_int, {'transceiver-mode-read-only': 2, 'transceiver-mode-loopback': 1, 'transceiver-mode-normal': 0}), help='int (transceiver-mode-normal: 0, transceiver-mode-loopback: 1, transceiver-mode-read-only: 2)', metavar='<transceiver-mode>')
		parser.add_argument('write_timeout', type=convert_int, help='int', metavar='<write-timeout>')

		args = parser.parse_args(argv)

		device_call(ctx, CANBricklet, 6, (args.baud_rate, args.transceiver_mode, args.write_timeout), 'B B i', '', None, args.expect_response, [], [])

	def get_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, CANBricklet, 7, (), '', 'B B i', args.execute, False, ['baud-rate', 'transceiver-mode', 'write-timeout'], [{0: 'baud-rate-10kbps', 1: 'baud-rate-20kbps', 2: 'baud-rate-50kbps', 3: 'baud-rate-125kbps', 4: 'baud-rate-250kbps', 5: 'baud-rate-500kbps', 6: 'baud-rate-800kbps', 7: 'baud-rate-1000kbps'}, {0: 'transceiver-mode-normal', 1: 'transceiver-mode-loopback', 2: 'transceiver-mode-read-only'}, None])

	def set_read_filter(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-read-filter')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'filter-mode-match-extended': 4, 'filter-mode-accept-all': 1, 'filter-mode-disabled': 0, 'filter-mode-match-standard-and-data': 3, 'filter-mode-match-standard': 2}), help='int (filter-mode-disabled: 0, filter-mode-accept-all: 1, filter-mode-match-standard: 2, filter-mode-match-standard-and-data: 3, filter-mode-match-extended: 4)', metavar='<mode>')
		parser.add_argument('mask', type=convert_int, help='int', metavar='<mask>')
		parser.add_argument('filter1', type=convert_int, help='int', metavar='<filter1>')
		parser.add_argument('filter2', type=convert_int, help='int', metavar='<filter2>')

		args = parser.parse_args(argv)

		device_call(ctx, CANBricklet, 8, (args.mode, args.mask, args.filter1, args.filter2), 'B I I I', '', None, args.expect_response, [], [])

	def get_read_filter(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-read-filter')

		args = parser.parse_args(argv)

		device_call(ctx, CANBricklet, 9, (), '', 'B I I I', args.execute, False, ['mode', 'mask', 'filter1', 'filter2'], [{0: 'filter-mode-disabled', 1: 'filter-mode-accept-all', 2: 'filter-mode-match-standard', 3: 'filter-mode-match-standard-and-data', 4: 'filter-mode-match-extended'}, None, None, None])

	def get_error_log(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-error-log')

		args = parser.parse_args(argv)

		device_call(ctx, CANBricklet, 10, (), '', 'B B ! I I I', args.execute, False, ['write-error-level', 'read-error-level', 'transceiver-disabled', 'write-timeout-count', 'read-register-overflow-count', 'read-buffer-overflow-count'], [None, None, None, None, None, None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, CANBricklet, argv)

	functions = {
	'write-frame': write_frame,
	'read-frame': read_frame,
	'enable-frame-read-callback': enable_frame_read_callback,
	'disable-frame-read-callback': disable_frame_read_callback,
	'is-frame-read-callback-enabled': is_frame_read_callback_enabled,
	'set-configuration': set_configuration,
	'get-configuration': get_configuration,
	'set-read-filter': set_read_filter,
	'get-read-filter': get_read_filter,
	'get-error-log': get_error_log,
	'get-identity': get_identity
	}

	call_generic(ctx, 'can-bricklet', functions, argv)

def dispatch_can_bricklet(ctx, argv):
	prog_prefix = 'dispatch can-bricklet <uid>'

	def frame_read(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' frame-read')

		args = parser.parse_args(argv)

		device_dispatch(ctx, CANBricklet, 11, args.execute, ['frame-type', 'identifier', 'data', 'length'], [{0: 'frame-type-standard-data', 1: 'frame-type-standard-remote', 2: 'frame-type-extended-data', 3: 'frame-type-extended-remote'}, None, None, None])

	callbacks = {
	'frame-read': frame_read
	}

	dispatch_generic(ctx, 'can-bricklet', callbacks, argv)

class CANV2Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 1; re[3] = 2; re[4] = 1; re[5] = 3; re[6] = 1; re[7] = 2; re[8] = 1; re[9] = 3; re[10] = 1; re[11] = 1; re[12] = 3; re[13] = 1; re[14] = 3; re[15] = 1; re[234] = 1; re[235] = 1; re[236] = 1; re[237] = 3; re[238] = 1; re[239] = 3; re[240] = 1; re[242] = 1; re[243] = 3; re[248] = 3; re[249] = 1; re[255] = 1
		cf = self.callback_formats
		cf[16] = 'B I B 15B'
		hlc = self.high_level_callbacks
		hlc[-16] = [(None, None, 'stream_length', 'stream_chunk_data'), {'fixed_length': None, 'single_chunk': True}, None]

def call_can_v2_bricklet(ctx, argv):
	prog_prefix = 'call can-v2-bricklet <uid>'

	def write_frame_low_level(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-frame-low-level')

		parser.add_argument('frame_type', type=create_symbol_converter(ctx, convert_int, {'frame-type-extended-remote': 3, 'frame-type-standard-data': 0, 'frame-type-extended-data': 2, 'frame-type-standard-remote': 1}), help='int (frame-type-standard-data: 0, frame-type-standard-remote: 1, frame-type-extended-data: 2, frame-type-extended-remote: 3)', metavar='<frame-type>')
		parser.add_argument('identifier', type=convert_int, help='int', metavar='<identifier>')
		parser.add_argument('data_length', type=convert_int, help='int', metavar='<data-length>')
		parser.add_argument('data_data', type=create_array_converter(ctx, convert_int, '0', 15), help=get_array_type_name(ctx, 'int', 15), metavar='<data-data>')

		args = parser.parse_args(argv)

		device_call(ctx, CANV2Bricklet, 1, (args.frame_type, args.identifier, args.data_length, args.data_data), 'B I B 15B', '!', args.execute, False, ['success'], [None])

	def write_frame(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-frame')

		parser.add_argument('frame_type', type=create_symbol_converter(ctx, convert_int, {'frame-type-extended-remote': 3, 'frame-type-standard-data': 0, 'frame-type-extended-data': 2, 'frame-type-standard-remote': 1}), help='int (frame-type-standard-data: 0, frame-type-standard-remote: 1, frame-type-extended-data: 2, frame-type-extended-remote: 3)', metavar='<frame-type>')
		parser.add_argument('identifier', type=convert_int, help='int', metavar='<identifier>')
		parser.add_argument('data', type=create_array_converter(ctx, convert_int, None, -15), help=get_array_type_name(ctx, 'int', -15), metavar='<data>')

		args = parser.parse_args(argv)

		device_stream_call(ctx, CANV2Bricklet, 1, 'in', (args.frame_type, args.identifier, args.data), (None, None, 'stream_data'), (None,), (None, None, 'stream_length', 'stream_chunk_data'), (None,), 'B I B 15B', '!', args.execute, False, ['success'], [None], '0', 15, None, False, False, None)

	def read_frame_low_level(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-frame-low-level')

		args = parser.parse_args(argv)

		device_call(ctx, CANV2Bricklet, 2, (), '', '! B I B 15B', args.execute, False, ['success', 'frame-type', 'identifier', 'data-length', 'data-data'], [None, {0: 'frame-type-standard-data', 1: 'frame-type-standard-remote', 2: 'frame-type-extended-data', 3: 'frame-type-extended-remote'}, None, None, None])

	def read_frame(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-frame')

		args = parser.parse_args(argv)

		device_stream_call(ctx, CANV2Bricklet, 2, 'out', (), (), (None, None, None, 'stream_data'), (), (None, None, None, 'stream_length', 'stream_chunk_data'), '', '! B I B 15B', args.execute, False, ['success', 'frame-type', 'identifier', 'data'], [None, {0: 'frame-type-standard-data', 1: 'frame-type-standard-remote', 2: 'frame-type-extended-data', 3: 'frame-type-extended-remote'}, None, None], None, 15, None, False, True, None)

	def set_frame_read_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-frame-read-callback-configuration')

		parser.add_argument('enabled', type=convert_bool, help='bool', metavar='<enabled>')

		args = parser.parse_args(argv)

		device_call(ctx, CANV2Bricklet, 3, (args.enabled,), '!', '', None, args.expect_response, [], [])

	def get_frame_read_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-frame-read-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, CANV2Bricklet, 4, (), '', '!', args.execute, False, ['enabled'], [None])

	def set_transceiver_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-transceiver-configuration')

		parser.add_argument('baud_rate', type=convert_int, help='int', metavar='<baud-rate>')
		parser.add_argument('sample_point', type=convert_int, help='int', metavar='<sample-point>')
		parser.add_argument('transceiver_mode', type=create_symbol_converter(ctx, convert_int, {'transceiver-mode-read-only': 2, 'transceiver-mode-loopback': 1, 'transceiver-mode-normal': 0}), help='int (transceiver-mode-normal: 0, transceiver-mode-loopback: 1, transceiver-mode-read-only: 2)', metavar='<transceiver-mode>')

		args = parser.parse_args(argv)

		device_call(ctx, CANV2Bricklet, 5, (args.baud_rate, args.sample_point, args.transceiver_mode), 'I H B', '', None, args.expect_response, [], [])

	def get_transceiver_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-transceiver-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, CANV2Bricklet, 6, (), '', 'I H B', args.execute, False, ['baud-rate', 'sample-point', 'transceiver-mode'], [None, None, {0: 'transceiver-mode-normal', 1: 'transceiver-mode-loopback', 2: 'transceiver-mode-read-only'}])

	def set_queue_configuration_low_level(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-queue-configuration-low-level')

		parser.add_argument('write_buffer_size', type=convert_int, help='int', metavar='<write-buffer-size>')
		parser.add_argument('write_buffer_timeout', type=convert_int, help='int', metavar='<write-buffer-timeout>')
		parser.add_argument('write_backlog_size', type=convert_int, help='int', metavar='<write-backlog-size>')
		parser.add_argument('read_buffer_sizes_length', type=convert_int, help='int', metavar='<read-buffer-sizes-length>')
		parser.add_argument('read_buffer_sizes_data', type=create_array_converter(ctx, convert_int, '0', 32), help=get_array_type_name(ctx, 'int', 32), metavar='<read-buffer-sizes-data>')
		parser.add_argument('read_backlog_size', type=convert_int, help='int', metavar='<read-backlog-size>')

		args = parser.parse_args(argv)

		device_call(ctx, CANV2Bricklet, 7, (args.write_buffer_size, args.write_buffer_timeout, args.write_backlog_size, args.read_buffer_sizes_length, args.read_buffer_sizes_data, args.read_backlog_size), 'B i H B 32b H', '', None, args.expect_response, [], [])

	def set_queue_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-queue-configuration')

		parser.add_argument('write_buffer_size', type=convert_int, help='int', metavar='<write-buffer-size>')
		parser.add_argument('write_buffer_timeout', type=convert_int, help='int', metavar='<write-buffer-timeout>')
		parser.add_argument('write_backlog_size', type=convert_int, help='int', metavar='<write-backlog-size>')
		parser.add_argument('read_buffer_sizes', type=create_array_converter(ctx, convert_int, None, -32), help=get_array_type_name(ctx, 'int', -32), metavar='<read-buffer-sizes>')
		parser.add_argument('read_backlog_size', type=convert_int, help='int', metavar='<read-backlog-size>')

		args = parser.parse_args(argv)

		device_stream_call(ctx, CANV2Bricklet, 7, 'in', (args.write_buffer_size, args.write_buffer_timeout, args.write_backlog_size, args.read_buffer_sizes, args.read_backlog_size), (None, None, None, 'stream_data', None), (), (None, None, None, 'stream_length', 'stream_chunk_data', None), (), 'B i H B 32b H', '', None, args.expect_response, [], [], '0', 32, None, False, False, None)

	def get_queue_configuration_low_level(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-queue-configuration-low-level')

		args = parser.parse_args(argv)

		device_call(ctx, CANV2Bricklet, 8, (), '', 'B i H B 32b H', args.execute, False, ['write-buffer-size', 'write-buffer-timeout', 'write-backlog-size', 'read-buffer-sizes-length', 'read-buffer-sizes-data', 'read-backlog-size'], [None, None, None, None, None, None])

	def get_queue_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-queue-configuration')

		args = parser.parse_args(argv)

		device_stream_call(ctx, CANV2Bricklet, 8, 'out', (), (), (None, None, None, 'stream_data', None), (), (None, None, None, 'stream_length', 'stream_chunk_data', None), '', 'B i H B 32b H', args.execute, False, ['write-buffer-size', 'write-buffer-timeout', 'write-backlog-size', 'read-buffer-sizes', 'read-backlog-size'], [None, None, None, None, None], None, 32, None, False, True, None)

	def set_read_filter_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-read-filter-configuration')

		parser.add_argument('buffer_index', type=convert_int, help='int', metavar='<buffer-index>')
		parser.add_argument('filter_mode', type=create_symbol_converter(ctx, convert_int, {'filter-mode-match-standard-only': 1, 'filter-mode-match-extended-only': 2, 'filter-mode-accept-all': 0, 'filter-mode-match-standard-and-extended': 3}), help='int (filter-mode-accept-all: 0, filter-mode-match-standard-only: 1, filter-mode-match-extended-only: 2, filter-mode-match-standard-and-extended: 3)', metavar='<filter-mode>')
		parser.add_argument('filter_mask', type=convert_int, help='int', metavar='<filter-mask>')
		parser.add_argument('filter_identifier', type=convert_int, help='int', metavar='<filter-identifier>')

		args = parser.parse_args(argv)

		device_call(ctx, CANV2Bricklet, 9, (args.buffer_index, args.filter_mode, args.filter_mask, args.filter_identifier), 'B B I I', '', None, args.expect_response, [], [])

	def get_read_filter_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-read-filter-configuration')

		parser.add_argument('buffer_index', type=convert_int, help='int', metavar='<buffer-index>')

		args = parser.parse_args(argv)

		device_call(ctx, CANV2Bricklet, 10, (args.buffer_index,), 'B', 'B I I', args.execute, False, ['filter-mode', 'filter-mask', 'filter-identifier'], [{0: 'filter-mode-accept-all', 1: 'filter-mode-match-standard-only', 2: 'filter-mode-match-extended-only', 3: 'filter-mode-match-standard-and-extended'}, None, None])

	def get_error_log_low_level(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-error-log-low-level')

		args = parser.parse_args(argv)

		device_call(ctx, CANV2Bricklet, 11, (), '', 'B B B I I I I I I I I B 32! I', args.execute, False, ['transceiver-state', 'transceiver-write-error-level', 'transceiver-read-error-level', 'transceiver-stuffing-error-count', 'transceiver-format-error-count', 'transceiver-ack-error-count', 'transceiver-bit1-error-count', 'transceiver-bit0-error-count', 'transceiver-crc-error-count', 'write-buffer-timeout-error-count', 'read-buffer-overflow-error-count', 'read-buffer-overflow-error-occurred-length', 'read-buffer-overflow-error-occurred-data', 'read-backlog-overflow-error-count'], [{0: 'transceiver-state-active', 1: 'transceiver-state-passive', 2: 'transceiver-state-disabled'}, None, None, None, None, None, None, None, None, None, None, None, None, None])

	def get_error_log(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-error-log')

		args = parser.parse_args(argv)

		device_stream_call(ctx, CANV2Bricklet, 11, 'out', (), (), (None, None, None, None, None, None, None, None, None, None, None, 'stream_data', None), (), (None, None, None, None, None, None, None, None, None, None, None, 'stream_length', 'stream_chunk_data', None), '', 'B B B I I I I I I I I B 32! I', args.execute, False, ['transceiver-state', 'transceiver-write-error-level', 'transceiver-read-error-level', 'transceiver-stuffing-error-count', 'transceiver-format-error-count', 'transceiver-ack-error-count', 'transceiver-bit1-error-count', 'transceiver-bit0-error-count', 'transceiver-crc-error-count', 'write-buffer-timeout-error-count', 'read-buffer-overflow-error-count', 'read-buffer-overflow-error-occurred', 'read-backlog-overflow-error-count'], [{0: 'transceiver-state-active', 1: 'transceiver-state-passive', 2: 'transceiver-state-disabled'}, None, None, None, None, None, None, None, None, None, None, None, None], None, 32, None, False, True, None)

	def set_communication_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-communication-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'communication-led-config-show-communication': 3, 'communication-led-config-show-heartbeat': 2, 'communication-led-config-on': 1, 'communication-led-config-off': 0}), help='int (communication-led-config-off: 0, communication-led-config-on: 1, communication-led-config-show-heartbeat: 2, communication-led-config-show-communication: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, CANV2Bricklet, 12, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_communication_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-communication-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, CANV2Bricklet, 13, (), '', 'B', args.execute, False, ['config'], [{0: 'communication-led-config-off', 1: 'communication-led-config-on', 2: 'communication-led-config-show-heartbeat', 3: 'communication-led-config-show-communication'}])

	def set_error_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-error-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'error-led-config-off': 0, 'error-led-config-on': 1, 'error-led-config-show-transceiver-state': 3, 'error-led-config-show-error': 4, 'error-led-config-show-heartbeat': 2}), help='int (error-led-config-off: 0, error-led-config-on: 1, error-led-config-show-heartbeat: 2, error-led-config-show-transceiver-state: 3, error-led-config-show-error: 4)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, CANV2Bricklet, 14, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_error_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-error-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, CANV2Bricklet, 15, (), '', 'B', args.execute, False, ['config'], [{0: 'error-led-config-off', 1: 'error-led-config-on', 2: 'error-led-config-show-heartbeat', 3: 'error-led-config-show-transceiver-state', 4: 'error-led-config-show-error'}])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, CANV2Bricklet, 234, (), '', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def set_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-bootloader-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'bootloader-mode-firmware-wait-for-reboot': 3, 'bootloader-mode-firmware': 1, 'bootloader-mode-firmware-wait-for-erase-and-reboot': 4, 'bootloader-mode-bootloader-wait-for-reboot': 2, 'bootloader-mode-bootloader': 0}), help='int (bootloader-mode-bootloader: 0, bootloader-mode-firmware: 1, bootloader-mode-bootloader-wait-for-reboot: 2, bootloader-mode-firmware-wait-for-reboot: 3, bootloader-mode-firmware-wait-for-erase-and-reboot: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, CANV2Bricklet, 235, (args.mode,), 'B', 'B', args.execute, False, ['status'], [{0: 'bootloader-status-ok', 1: 'bootloader-status-invalid-mode', 2: 'bootloader-status-no-change', 3: 'bootloader-status-entry-function-not-present', 4: 'bootloader-status-device-identifier-incorrect', 5: 'bootloader-status-crc-mismatch'}])

	def get_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-bootloader-mode')

		args = parser.parse_args(argv)

		device_call(ctx, CANV2Bricklet, 236, (), '', 'B', args.execute, False, ['mode'], [{0: 'bootloader-mode-bootloader', 1: 'bootloader-mode-firmware', 2: 'bootloader-mode-bootloader-wait-for-reboot', 3: 'bootloader-mode-firmware-wait-for-reboot', 4: 'bootloader-mode-firmware-wait-for-erase-and-reboot'}])

	def set_write_firmware_pointer(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-write-firmware-pointer')

		parser.add_argument('pointer', type=convert_int, help='int', metavar='<pointer>')

		args = parser.parse_args(argv)

		device_call(ctx, CANV2Bricklet, 237, (args.pointer,), 'I', '', None, args.expect_response, [], [])

	def write_firmware(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-firmware')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, CANV2Bricklet, 238, (args.data,), '64B', 'B', args.execute, False, ['status'], [None])

	def set_status_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'status-led-config-on': 1, 'status-led-config-show-heartbeat': 2, 'status-led-config-off': 0, 'status-led-config-show-status': 3}), help='int (status-led-config-off: 0, status-led-config-on: 1, status-led-config-show-heartbeat: 2, status-led-config-show-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, CANV2Bricklet, 239, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_status_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, CANV2Bricklet, 240, (), '', 'B', args.execute, False, ['config'], [{0: 'status-led-config-off', 1: 'status-led-config-on', 2: 'status-led-config-show-heartbeat', 3: 'status-led-config-show-status'}])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, CANV2Bricklet, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, CANV2Bricklet, 243, (), '', '', None, args.expect_response, [], [])

	def write_uid(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-uid')

		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')

		args = parser.parse_args(argv)

		device_call(ctx, CANV2Bricklet, 248, (args.uid,), 'I', '', None, args.expect_response, [], [])

	def read_uid(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-uid')

		args = parser.parse_args(argv)

		device_call(ctx, CANV2Bricklet, 249, (), '', 'I', args.execute, False, ['uid'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, CANV2Bricklet, argv)

	functions = {
	'write-frame-low-level': write_frame_low_level,
	'write-frame': write_frame,
	'read-frame-low-level': read_frame_low_level,
	'read-frame': read_frame,
	'set-frame-read-callback-configuration': set_frame_read_callback_configuration,
	'get-frame-read-callback-configuration': get_frame_read_callback_configuration,
	'set-transceiver-configuration': set_transceiver_configuration,
	'get-transceiver-configuration': get_transceiver_configuration,
	'set-queue-configuration-low-level': set_queue_configuration_low_level,
	'set-queue-configuration': set_queue_configuration,
	'get-queue-configuration-low-level': get_queue_configuration_low_level,
	'get-queue-configuration': get_queue_configuration,
	'set-read-filter-configuration': set_read_filter_configuration,
	'get-read-filter-configuration': get_read_filter_configuration,
	'get-error-log-low-level': get_error_log_low_level,
	'get-error-log': get_error_log,
	'set-communication-led-config': set_communication_led_config,
	'get-communication-led-config': get_communication_led_config,
	'set-error-led-config': set_error_led_config,
	'get-error-led-config': get_error_led_config,
	'get-spitfp-error-count': get_spitfp_error_count,
	'set-bootloader-mode': set_bootloader_mode,
	'get-bootloader-mode': get_bootloader_mode,
	'set-write-firmware-pointer': set_write_firmware_pointer,
	'write-firmware': write_firmware,
	'set-status-led-config': set_status_led_config,
	'get-status-led-config': get_status_led_config,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'write-uid': write_uid,
	'read-uid': read_uid,
	'get-identity': get_identity
	}

	call_generic(ctx, 'can-v2-bricklet', functions, argv)

def dispatch_can_v2_bricklet(ctx, argv):
	prog_prefix = 'dispatch can-v2-bricklet <uid>'

	def frame_read_low_level(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' frame-read-low-level')

		args = parser.parse_args(argv)

		device_dispatch(ctx, CANV2Bricklet, 16, args.execute, ['frame-type', 'identifier', 'data-length', 'data-data'], [{0: 'frame-type-standard-data', 1: 'frame-type-standard-remote', 2: 'frame-type-extended-data', 3: 'frame-type-extended-remote'}, None, None, None])

	def frame_read(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' frame-read')

		args = parser.parse_args(argv)

		device_dispatch(ctx, CANV2Bricklet, -16, args.execute, ['frame-type', 'identifier', 'data'], [{0: 'frame-type-standard-data', 1: 'frame-type-standard-remote', 2: 'frame-type-extended-data', 3: 'frame-type-extended-remote'}, None, None])

	callbacks = {
	'frame-read-low-level': frame_read_low_level,
	'frame-read': frame_read
	}

	dispatch_generic(ctx, 'can-v2-bricklet', callbacks, argv)

class CO2Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 2; re[3] = 1; re[4] = 2; re[5] = 1; re[6] = 2; re[7] = 1; re[255] = 1
		cf = self.callback_formats
		cf[8] = 'H'; cf[9] = 'H'


def call_co2_bricklet(ctx, argv):
	prog_prefix = 'call co2-bricklet <uid>'

	def get_co2_concentration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-co2-concentration')

		args = parser.parse_args(argv)

		device_call(ctx, CO2Bricklet, 1, (), '', 'H', args.execute, False, ['co2-concentration'], [None])

	def set_co2_concentration_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-co2-concentration-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, CO2Bricklet, 2, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_co2_concentration_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-co2-concentration-callback-period')

		args = parser.parse_args(argv)

		device_call(ctx, CO2Bricklet, 3, (), '', 'I', args.execute, False, ['period'], [None])

	def set_co2_concentration_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-co2-concentration-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, CO2Bricklet, 4, (args.option, args.min, args.max), 'c H H', '', None, args.expect_response, [], [])

	def get_co2_concentration_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-co2-concentration-callback-threshold')

		args = parser.parse_args(argv)

		device_call(ctx, CO2Bricklet, 5, (), '', 'c H H', args.execute, False, ['option', 'min', 'max'], [{'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def set_debounce_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-debounce-period')

		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_call(ctx, CO2Bricklet, 6, (args.debounce,), 'I', '', None, args.expect_response, [], [])

	def get_debounce_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-debounce-period')

		args = parser.parse_args(argv)

		device_call(ctx, CO2Bricklet, 7, (), '', 'I', args.execute, False, ['debounce'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, CO2Bricklet, argv)

	functions = {
	'get-co2-concentration': get_co2_concentration,
	'set-co2-concentration-callback-period': set_co2_concentration_callback_period,
	'get-co2-concentration-callback-period': get_co2_concentration_callback_period,
	'set-co2-concentration-callback-threshold': set_co2_concentration_callback_threshold,
	'get-co2-concentration-callback-threshold': get_co2_concentration_callback_threshold,
	'set-debounce-period': set_debounce_period,
	'get-debounce-period': get_debounce_period,
	'get-identity': get_identity
	}

	call_generic(ctx, 'co2-bricklet', functions, argv)

def dispatch_co2_bricklet(ctx, argv):
	prog_prefix = 'dispatch co2-bricklet <uid>'

	def co2_concentration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' co2-concentration')

		args = parser.parse_args(argv)

		device_dispatch(ctx, CO2Bricklet, 8, args.execute, ['co2-concentration'], [None])

	def co2_concentration_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' co2-concentration-reached')

		args = parser.parse_args(argv)

		device_dispatch(ctx, CO2Bricklet, 9, args.execute, ['co2-concentration'], [None])

	callbacks = {
	'co2-concentration': co2_concentration,
	'co2-concentration-reached': co2_concentration_reached
	}

	dispatch_generic(ctx, 'co2-bricklet', callbacks, argv)

class CO2V2Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 3; re[3] = 1; re[4] = 3; re[5] = 1; re[6] = 2; re[7] = 1; re[9] = 1; re[10] = 2; re[11] = 1; re[13] = 1; re[14] = 2; re[15] = 1; re[17] = 1; re[18] = 2; re[19] = 1; re[234] = 1; re[235] = 1; re[236] = 1; re[237] = 3; re[238] = 1; re[239] = 3; re[240] = 1; re[242] = 1; re[243] = 3; re[248] = 3; re[249] = 1; re[255] = 1
		cf = self.callback_formats
		cf[8] = 'H h H'; cf[12] = 'H'; cf[16] = 'h'; cf[20] = 'H'


def call_co2_v2_bricklet(ctx, argv):
	prog_prefix = 'call co2-v2-bricklet <uid>'

	def get_all_values(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-all-values')

		args = parser.parse_args(argv)

		device_call(ctx, CO2V2Bricklet, 1, (), '', 'H h H', args.execute, False, ['co2-concentration', 'temperature', 'humidity'], [None, None, None])

	def set_air_pressure(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-air-pressure')

		parser.add_argument('air_pressure', type=convert_int, help='int', metavar='<air-pressure>')

		args = parser.parse_args(argv)

		device_call(ctx, CO2V2Bricklet, 2, (args.air_pressure,), 'H', '', None, args.expect_response, [], [])

	def get_air_pressure(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-air-pressure')

		args = parser.parse_args(argv)

		device_call(ctx, CO2V2Bricklet, 3, (), '', 'H', args.execute, False, ['air-pressure'], [None])

	def set_temperature_offset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-temperature-offset')

		parser.add_argument('offset', type=convert_int, help='int', metavar='<offset>')

		args = parser.parse_args(argv)

		device_call(ctx, CO2V2Bricklet, 4, (args.offset,), 'H', '', None, args.expect_response, [], [])

	def get_temperature_offset(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-temperature-offset')

		args = parser.parse_args(argv)

		device_call(ctx, CO2V2Bricklet, 5, (), '', 'H', args.execute, False, ['offset'], [None])

	def set_all_values_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-all-values-callback-configuration')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')

		args = parser.parse_args(argv)

		device_call(ctx, CO2V2Bricklet, 6, (args.period, args.value_has_to_change), 'I !', '', None, args.expect_response, [], [])

	def get_all_values_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-all-values-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, CO2V2Bricklet, 7, (), '', 'I !', args.execute, False, ['period', 'value-has-to-change'], [None, None])

	def get_co2_concentration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-co2-concentration')

		args = parser.parse_args(argv)

		device_call(ctx, CO2V2Bricklet, 9, (), '', 'H', args.execute, False, ['co2-concentration'], [None])

	def set_co2_concentration_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-co2-concentration-callback-configuration')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')
		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, CO2V2Bricklet, 10, (args.period, args.value_has_to_change, args.option, args.min, args.max), 'I ! c H H', '', None, args.expect_response, [], [])

	def get_co2_concentration_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-co2-concentration-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, CO2V2Bricklet, 11, (), '', 'I ! c H H', args.execute, False, ['period', 'value-has-to-change', 'option', 'min', 'max'], [None, None, {'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def get_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, CO2V2Bricklet, 13, (), '', 'h', args.execute, False, ['temperature'], [None])

	def set_temperature_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-temperature-callback-configuration')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')
		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, CO2V2Bricklet, 14, (args.period, args.value_has_to_change, args.option, args.min, args.max), 'I ! c h h', '', None, args.expect_response, [], [])

	def get_temperature_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-temperature-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, CO2V2Bricklet, 15, (), '', 'I ! c h h', args.execute, False, ['period', 'value-has-to-change', 'option', 'min', 'max'], [None, None, {'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def get_humidity(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-humidity')

		args = parser.parse_args(argv)

		device_call(ctx, CO2V2Bricklet, 17, (), '', 'H', args.execute, False, ['humidity'], [None])

	def set_humidity_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-humidity-callback-configuration')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')
		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, CO2V2Bricklet, 18, (args.period, args.value_has_to_change, args.option, args.min, args.max), 'I ! c H H', '', None, args.expect_response, [], [])

	def get_humidity_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-humidity-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, CO2V2Bricklet, 19, (), '', 'I ! c H H', args.execute, False, ['period', 'value-has-to-change', 'option', 'min', 'max'], [None, None, {'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, CO2V2Bricklet, 234, (), '', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def set_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-bootloader-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'bootloader-mode-firmware-wait-for-reboot': 3, 'bootloader-mode-firmware': 1, 'bootloader-mode-firmware-wait-for-erase-and-reboot': 4, 'bootloader-mode-bootloader-wait-for-reboot': 2, 'bootloader-mode-bootloader': 0}), help='int (bootloader-mode-bootloader: 0, bootloader-mode-firmware: 1, bootloader-mode-bootloader-wait-for-reboot: 2, bootloader-mode-firmware-wait-for-reboot: 3, bootloader-mode-firmware-wait-for-erase-and-reboot: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, CO2V2Bricklet, 235, (args.mode,), 'B', 'B', args.execute, False, ['status'], [{0: 'bootloader-status-ok', 1: 'bootloader-status-invalid-mode', 2: 'bootloader-status-no-change', 3: 'bootloader-status-entry-function-not-present', 4: 'bootloader-status-device-identifier-incorrect', 5: 'bootloader-status-crc-mismatch'}])

	def get_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-bootloader-mode')

		args = parser.parse_args(argv)

		device_call(ctx, CO2V2Bricklet, 236, (), '', 'B', args.execute, False, ['mode'], [{0: 'bootloader-mode-bootloader', 1: 'bootloader-mode-firmware', 2: 'bootloader-mode-bootloader-wait-for-reboot', 3: 'bootloader-mode-firmware-wait-for-reboot', 4: 'bootloader-mode-firmware-wait-for-erase-and-reboot'}])

	def set_write_firmware_pointer(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-write-firmware-pointer')

		parser.add_argument('pointer', type=convert_int, help='int', metavar='<pointer>')

		args = parser.parse_args(argv)

		device_call(ctx, CO2V2Bricklet, 237, (args.pointer,), 'I', '', None, args.expect_response, [], [])

	def write_firmware(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-firmware')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, CO2V2Bricklet, 238, (args.data,), '64B', 'B', args.execute, False, ['status'], [None])

	def set_status_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'status-led-config-on': 1, 'status-led-config-show-heartbeat': 2, 'status-led-config-off': 0, 'status-led-config-show-status': 3}), help='int (status-led-config-off: 0, status-led-config-on: 1, status-led-config-show-heartbeat: 2, status-led-config-show-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, CO2V2Bricklet, 239, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_status_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, CO2V2Bricklet, 240, (), '', 'B', args.execute, False, ['config'], [{0: 'status-led-config-off', 1: 'status-led-config-on', 2: 'status-led-config-show-heartbeat', 3: 'status-led-config-show-status'}])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, CO2V2Bricklet, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, CO2V2Bricklet, 243, (), '', '', None, args.expect_response, [], [])

	def write_uid(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-uid')

		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')

		args = parser.parse_args(argv)

		device_call(ctx, CO2V2Bricklet, 248, (args.uid,), 'I', '', None, args.expect_response, [], [])

	def read_uid(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-uid')

		args = parser.parse_args(argv)

		device_call(ctx, CO2V2Bricklet, 249, (), '', 'I', args.execute, False, ['uid'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, CO2V2Bricklet, argv)

	functions = {
	'get-all-values': get_all_values,
	'set-air-pressure': set_air_pressure,
	'get-air-pressure': get_air_pressure,
	'set-temperature-offset': set_temperature_offset,
	'get-temperature-offset': get_temperature_offset,
	'set-all-values-callback-configuration': set_all_values_callback_configuration,
	'get-all-values-callback-configuration': get_all_values_callback_configuration,
	'get-co2-concentration': get_co2_concentration,
	'set-co2-concentration-callback-configuration': set_co2_concentration_callback_configuration,
	'get-co2-concentration-callback-configuration': get_co2_concentration_callback_configuration,
	'get-temperature': get_temperature,
	'set-temperature-callback-configuration': set_temperature_callback_configuration,
	'get-temperature-callback-configuration': get_temperature_callback_configuration,
	'get-humidity': get_humidity,
	'set-humidity-callback-configuration': set_humidity_callback_configuration,
	'get-humidity-callback-configuration': get_humidity_callback_configuration,
	'get-spitfp-error-count': get_spitfp_error_count,
	'set-bootloader-mode': set_bootloader_mode,
	'get-bootloader-mode': get_bootloader_mode,
	'set-write-firmware-pointer': set_write_firmware_pointer,
	'write-firmware': write_firmware,
	'set-status-led-config': set_status_led_config,
	'get-status-led-config': get_status_led_config,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'write-uid': write_uid,
	'read-uid': read_uid,
	'get-identity': get_identity
	}

	call_generic(ctx, 'co2-v2-bricklet', functions, argv)

def dispatch_co2_v2_bricklet(ctx, argv):
	prog_prefix = 'dispatch co2-v2-bricklet <uid>'

	def all_values(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' all-values')

		args = parser.parse_args(argv)

		device_dispatch(ctx, CO2V2Bricklet, 8, args.execute, ['co2-concentration', 'temperature', 'humidity'], [None, None, None])

	def co2_concentration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' co2-concentration')

		args = parser.parse_args(argv)

		device_dispatch(ctx, CO2V2Bricklet, 12, args.execute, ['co2-concentration'], [None])

	def temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' temperature')

		args = parser.parse_args(argv)

		device_dispatch(ctx, CO2V2Bricklet, 16, args.execute, ['temperature'], [None])

	def humidity(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' humidity')

		args = parser.parse_args(argv)

		device_dispatch(ctx, CO2V2Bricklet, 20, args.execute, ['humidity'], [None])

	callbacks = {
	'all-values': all_values,
	'co2-concentration': co2_concentration,
	'temperature': temperature,
	'humidity': humidity
	}

	dispatch_generic(ctx, 'co2-v2-bricklet', callbacks, argv)

class ColorBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 2; re[3] = 1; re[4] = 2; re[5] = 1; re[6] = 2; re[7] = 1; re[10] = 3; re[11] = 3; re[12] = 1; re[13] = 3; re[14] = 1; re[15] = 1; re[16] = 1; re[17] = 2; re[18] = 1; re[19] = 2; re[20] = 1; re[255] = 1
		cf = self.callback_formats
		cf[8] = 'H H H H'; cf[9] = 'H H H H'; cf[21] = 'I'; cf[22] = 'H'


def call_color_bricklet(ctx, argv):
	prog_prefix = 'call color-bricklet <uid>'

	def get_color(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-color')

		args = parser.parse_args(argv)

		device_call(ctx, ColorBricklet, 1, (), '', 'H H H H', args.execute, False, ['r', 'g', 'b', 'c'], [None, None, None, None])

	def set_color_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-color-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, ColorBricklet, 2, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_color_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-color-callback-period')

		args = parser.parse_args(argv)

		device_call(ctx, ColorBricklet, 3, (), '', 'I', args.execute, False, ['period'], [None])

	def set_color_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-color-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min_r', type=convert_int, help='int', metavar='<min-r>')
		parser.add_argument('max_r', type=convert_int, help='int', metavar='<max-r>')
		parser.add_argument('min_g', type=convert_int, help='int', metavar='<min-g>')
		parser.add_argument('max_g', type=convert_int, help='int', metavar='<max-g>')
		parser.add_argument('min_b', type=convert_int, help='int', metavar='<min-b>')
		parser.add_argument('max_b', type=convert_int, help='int', metavar='<max-b>')
		parser.add_argument('min_c', type=convert_int, help='int', metavar='<min-c>')
		parser.add_argument('max_c', type=convert_int, help='int', metavar='<max-c>')

		args = parser.parse_args(argv)

		device_call(ctx, ColorBricklet, 4, (args.option, args.min_r, args.max_r, args.min_g, args.max_g, args.min_b, args.max_b, args.min_c, args.max_c), 'c H H H H H H H H', '', None, args.expect_response, [], [])

	def get_color_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-color-callback-threshold')

		args = parser.parse_args(argv)

		device_call(ctx, ColorBricklet, 5, (), '', 'c H H H H H H H H', args.execute, False, ['option', 'min-r', 'max-r', 'min-g', 'max-g', 'min-b', 'max-b', 'min-c', 'max-c'], [{'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None, None, None, None, None, None, None])

	def set_debounce_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-debounce-period')

		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_call(ctx, ColorBricklet, 6, (args.debounce,), 'I', '', None, args.expect_response, [], [])

	def get_debounce_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-debounce-period')

		args = parser.parse_args(argv)

		device_call(ctx, ColorBricklet, 7, (), '', 'I', args.execute, False, ['debounce'], [None])

	def light_on(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' light-on')

		args = parser.parse_args(argv)

		device_call(ctx, ColorBricklet, 10, (), '', '', None, args.expect_response, [], [])

	def light_off(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' light-off')

		args = parser.parse_args(argv)

		device_call(ctx, ColorBricklet, 11, (), '', '', None, args.expect_response, [], [])

	def is_light_on(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' is-light-on')

		args = parser.parse_args(argv)

		device_call(ctx, ColorBricklet, 12, (), '', 'B', args.execute, False, ['light'], [{0: 'light-on', 1: 'light-off'}])

	def set_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-config')

		parser.add_argument('gain', type=create_symbol_converter(ctx, convert_int, {'gain-60x': 3, 'gain-4x': 1, 'gain-1x': 0, 'gain-16x': 2}), help='int (gain-1x: 0, gain-4x: 1, gain-16x: 2, gain-60x: 3)', metavar='<gain>')
		parser.add_argument('integration_time', type=create_symbol_converter(ctx, convert_int, {'integration-time-101ms': 2, 'integration-time-154ms': 3, 'integration-time-2ms': 0, 'integration-time-24ms': 1, 'integration-time-700ms': 4}), help='int (integration-time-2ms: 0, integration-time-24ms: 1, integration-time-101ms: 2, integration-time-154ms: 3, integration-time-700ms: 4)', metavar='<integration-time>')

		args = parser.parse_args(argv)

		device_call(ctx, ColorBricklet, 13, (args.gain, args.integration_time), 'B B', '', None, args.expect_response, [], [])

	def get_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-config')

		args = parser.parse_args(argv)

		device_call(ctx, ColorBricklet, 14, (), '', 'B B', args.execute, False, ['gain', 'integration-time'], [{0: 'gain-1x', 1: 'gain-4x', 2: 'gain-16x', 3: 'gain-60x'}, {0: 'integration-time-2ms', 1: 'integration-time-24ms', 2: 'integration-time-101ms', 3: 'integration-time-154ms', 4: 'integration-time-700ms'}])

	def get_illuminance(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-illuminance')

		args = parser.parse_args(argv)

		device_call(ctx, ColorBricklet, 15, (), '', 'I', args.execute, False, ['illuminance'], [None])

	def get_color_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-color-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, ColorBricklet, 16, (), '', 'H', args.execute, False, ['color-temperature'], [None])

	def set_illuminance_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-illuminance-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, ColorBricklet, 17, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_illuminance_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-illuminance-callback-period')

		args = parser.parse_args(argv)

		device_call(ctx, ColorBricklet, 18, (), '', 'I', args.execute, False, ['period'], [None])

	def set_color_temperature_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-color-temperature-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, ColorBricklet, 19, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_color_temperature_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-color-temperature-callback-period')

		args = parser.parse_args(argv)

		device_call(ctx, ColorBricklet, 20, (), '', 'I', args.execute, False, ['period'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, ColorBricklet, argv)

	functions = {
	'get-color': get_color,
	'set-color-callback-period': set_color_callback_period,
	'get-color-callback-period': get_color_callback_period,
	'set-color-callback-threshold': set_color_callback_threshold,
	'get-color-callback-threshold': get_color_callback_threshold,
	'set-debounce-period': set_debounce_period,
	'get-debounce-period': get_debounce_period,
	'light-on': light_on,
	'light-off': light_off,
	'is-light-on': is_light_on,
	'set-config': set_config,
	'get-config': get_config,
	'get-illuminance': get_illuminance,
	'get-color-temperature': get_color_temperature,
	'set-illuminance-callback-period': set_illuminance_callback_period,
	'get-illuminance-callback-period': get_illuminance_callback_period,
	'set-color-temperature-callback-period': set_color_temperature_callback_period,
	'get-color-temperature-callback-period': get_color_temperature_callback_period,
	'get-identity': get_identity
	}

	call_generic(ctx, 'color-bricklet', functions, argv)

def dispatch_color_bricklet(ctx, argv):
	prog_prefix = 'dispatch color-bricklet <uid>'

	def color(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' color')

		args = parser.parse_args(argv)

		device_dispatch(ctx, ColorBricklet, 8, args.execute, ['r', 'g', 'b', 'c'], [None, None, None, None])

	def color_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' color-reached')

		args = parser.parse_args(argv)

		device_dispatch(ctx, ColorBricklet, 9, args.execute, ['r', 'g', 'b', 'c'], [None, None, None, None])

	def illuminance(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' illuminance')

		args = parser.parse_args(argv)

		device_dispatch(ctx, ColorBricklet, 21, args.execute, ['illuminance'], [None])

	def color_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' color-temperature')

		args = parser.parse_args(argv)

		device_dispatch(ctx, ColorBricklet, 22, args.execute, ['color-temperature'], [None])

	callbacks = {
	'color': color,
	'color-reached': color_reached,
	'illuminance': illuminance,
	'color-temperature': color_temperature
	}

	dispatch_generic(ctx, 'color-bricklet', callbacks, argv)

class ColorV2Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 2; re[3] = 1; re[5] = 1; re[6] = 2; re[7] = 1; re[9] = 1; re[10] = 2; re[11] = 1; re[13] = 3; re[14] = 1; re[15] = 3; re[16] = 1; re[234] = 1; re[235] = 1; re[236] = 1; re[237] = 3; re[238] = 1; re[239] = 3; re[240] = 1; re[242] = 1; re[243] = 3; re[248] = 3; re[249] = 1; re[255] = 1
		cf = self.callback_formats
		cf[4] = 'H H H H'; cf[8] = 'I'; cf[12] = 'H'


def call_color_v2_bricklet(ctx, argv):
	prog_prefix = 'call color-v2-bricklet <uid>'

	def get_color(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-color')

		args = parser.parse_args(argv)

		device_call(ctx, ColorV2Bricklet, 1, (), '', 'H H H H', args.execute, False, ['r', 'g', 'b', 'c'], [None, None, None, None])

	def set_color_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-color-callback-configuration')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')

		args = parser.parse_args(argv)

		device_call(ctx, ColorV2Bricklet, 2, (args.period, args.value_has_to_change), 'I !', '', None, args.expect_response, [], [])

	def get_color_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-color-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, ColorV2Bricklet, 3, (), '', 'I !', args.execute, False, ['period', 'value-has-to-change'], [None, None])

	def get_illuminance(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-illuminance')

		args = parser.parse_args(argv)

		device_call(ctx, ColorV2Bricklet, 5, (), '', 'I', args.execute, False, ['illuminance'], [None])

	def set_illuminance_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-illuminance-callback-configuration')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')
		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, ColorV2Bricklet, 6, (args.period, args.value_has_to_change, args.option, args.min, args.max), 'I ! c I I', '', None, args.expect_response, [], [])

	def get_illuminance_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-illuminance-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, ColorV2Bricklet, 7, (), '', 'I ! c I I', args.execute, False, ['period', 'value-has-to-change', 'option', 'min', 'max'], [None, None, {'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def get_color_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-color-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, ColorV2Bricklet, 9, (), '', 'H', args.execute, False, ['color-temperature'], [None])

	def set_color_temperature_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-color-temperature-callback-configuration')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')
		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, ColorV2Bricklet, 10, (args.period, args.value_has_to_change, args.option, args.min, args.max), 'I ! c H H', '', None, args.expect_response, [], [])

	def get_color_temperature_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-color-temperature-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, ColorV2Bricklet, 11, (), '', 'I ! c H H', args.execute, False, ['period', 'value-has-to-change', 'option', 'min', 'max'], [None, None, {'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def set_light(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-light')

		parser.add_argument('enable', type=convert_bool, help='bool', metavar='<enable>')

		args = parser.parse_args(argv)

		device_call(ctx, ColorV2Bricklet, 13, (args.enable,), '!', '', None, args.expect_response, [], [])

	def get_light(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-light')

		args = parser.parse_args(argv)

		device_call(ctx, ColorV2Bricklet, 14, (), '', '!', args.execute, False, ['enable'], [None])

	def set_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-configuration')

		parser.add_argument('gain', type=create_symbol_converter(ctx, convert_int, {'gain-60x': 3, 'gain-4x': 1, 'gain-1x': 0, 'gain-16x': 2}), help='int (gain-1x: 0, gain-4x: 1, gain-16x: 2, gain-60x: 3)', metavar='<gain>')
		parser.add_argument('integration_time', type=create_symbol_converter(ctx, convert_int, {'integration-time-101ms': 2, 'integration-time-154ms': 3, 'integration-time-2ms': 0, 'integration-time-24ms': 1, 'integration-time-700ms': 4}), help='int (integration-time-2ms: 0, integration-time-24ms: 1, integration-time-101ms: 2, integration-time-154ms: 3, integration-time-700ms: 4)', metavar='<integration-time>')

		args = parser.parse_args(argv)

		device_call(ctx, ColorV2Bricklet, 15, (args.gain, args.integration_time), 'B B', '', None, args.expect_response, [], [])

	def get_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, ColorV2Bricklet, 16, (), '', 'B B', args.execute, False, ['gain', 'integration-time'], [{0: 'gain-1x', 1: 'gain-4x', 2: 'gain-16x', 3: 'gain-60x'}, {0: 'integration-time-2ms', 1: 'integration-time-24ms', 2: 'integration-time-101ms', 3: 'integration-time-154ms', 4: 'integration-time-700ms'}])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, ColorV2Bricklet, 234, (), '', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def set_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-bootloader-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'bootloader-mode-firmware-wait-for-reboot': 3, 'bootloader-mode-firmware': 1, 'bootloader-mode-firmware-wait-for-erase-and-reboot': 4, 'bootloader-mode-bootloader-wait-for-reboot': 2, 'bootloader-mode-bootloader': 0}), help='int (bootloader-mode-bootloader: 0, bootloader-mode-firmware: 1, bootloader-mode-bootloader-wait-for-reboot: 2, bootloader-mode-firmware-wait-for-reboot: 3, bootloader-mode-firmware-wait-for-erase-and-reboot: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, ColorV2Bricklet, 235, (args.mode,), 'B', 'B', args.execute, False, ['status'], [{0: 'bootloader-status-ok', 1: 'bootloader-status-invalid-mode', 2: 'bootloader-status-no-change', 3: 'bootloader-status-entry-function-not-present', 4: 'bootloader-status-device-identifier-incorrect', 5: 'bootloader-status-crc-mismatch'}])

	def get_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-bootloader-mode')

		args = parser.parse_args(argv)

		device_call(ctx, ColorV2Bricklet, 236, (), '', 'B', args.execute, False, ['mode'], [{0: 'bootloader-mode-bootloader', 1: 'bootloader-mode-firmware', 2: 'bootloader-mode-bootloader-wait-for-reboot', 3: 'bootloader-mode-firmware-wait-for-reboot', 4: 'bootloader-mode-firmware-wait-for-erase-and-reboot'}])

	def set_write_firmware_pointer(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-write-firmware-pointer')

		parser.add_argument('pointer', type=convert_int, help='int', metavar='<pointer>')

		args = parser.parse_args(argv)

		device_call(ctx, ColorV2Bricklet, 237, (args.pointer,), 'I', '', None, args.expect_response, [], [])

	def write_firmware(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-firmware')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, ColorV2Bricklet, 238, (args.data,), '64B', 'B', args.execute, False, ['status'], [None])

	def set_status_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'status-led-config-on': 1, 'status-led-config-show-heartbeat': 2, 'status-led-config-off': 0, 'status-led-config-show-status': 3}), help='int (status-led-config-off: 0, status-led-config-on: 1, status-led-config-show-heartbeat: 2, status-led-config-show-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, ColorV2Bricklet, 239, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_status_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, ColorV2Bricklet, 240, (), '', 'B', args.execute, False, ['config'], [{0: 'status-led-config-off', 1: 'status-led-config-on', 2: 'status-led-config-show-heartbeat', 3: 'status-led-config-show-status'}])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, ColorV2Bricklet, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, ColorV2Bricklet, 243, (), '', '', None, args.expect_response, [], [])

	def write_uid(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-uid')

		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')

		args = parser.parse_args(argv)

		device_call(ctx, ColorV2Bricklet, 248, (args.uid,), 'I', '', None, args.expect_response, [], [])

	def read_uid(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-uid')

		args = parser.parse_args(argv)

		device_call(ctx, ColorV2Bricklet, 249, (), '', 'I', args.execute, False, ['uid'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, ColorV2Bricklet, argv)

	functions = {
	'get-color': get_color,
	'set-color-callback-configuration': set_color_callback_configuration,
	'get-color-callback-configuration': get_color_callback_configuration,
	'get-illuminance': get_illuminance,
	'set-illuminance-callback-configuration': set_illuminance_callback_configuration,
	'get-illuminance-callback-configuration': get_illuminance_callback_configuration,
	'get-color-temperature': get_color_temperature,
	'set-color-temperature-callback-configuration': set_color_temperature_callback_configuration,
	'get-color-temperature-callback-configuration': get_color_temperature_callback_configuration,
	'set-light': set_light,
	'get-light': get_light,
	'set-configuration': set_configuration,
	'get-configuration': get_configuration,
	'get-spitfp-error-count': get_spitfp_error_count,
	'set-bootloader-mode': set_bootloader_mode,
	'get-bootloader-mode': get_bootloader_mode,
	'set-write-firmware-pointer': set_write_firmware_pointer,
	'write-firmware': write_firmware,
	'set-status-led-config': set_status_led_config,
	'get-status-led-config': get_status_led_config,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'write-uid': write_uid,
	'read-uid': read_uid,
	'get-identity': get_identity
	}

	call_generic(ctx, 'color-v2-bricklet', functions, argv)

def dispatch_color_v2_bricklet(ctx, argv):
	prog_prefix = 'dispatch color-v2-bricklet <uid>'

	def color(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' color')

		args = parser.parse_args(argv)

		device_dispatch(ctx, ColorV2Bricklet, 4, args.execute, ['r', 'g', 'b', 'c'], [None, None, None, None])

	def illuminance(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' illuminance')

		args = parser.parse_args(argv)

		device_dispatch(ctx, ColorV2Bricklet, 8, args.execute, ['illuminance'], [None])

	def color_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' color-temperature')

		args = parser.parse_args(argv)

		device_dispatch(ctx, ColorV2Bricklet, 12, args.execute, ['color-temperature'], [None])

	callbacks = {
	'color': color,
	'illuminance': illuminance,
	'color-temperature': color_temperature
	}

	dispatch_generic(ctx, 'color-v2-bricklet', callbacks, argv)

class CompassBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 2; re[3] = 1; re[5] = 1; re[6] = 2; re[7] = 1; re[9] = 3; re[10] = 1; re[11] = 3; re[12] = 1; re[234] = 1; re[235] = 1; re[236] = 1; re[237] = 3; re[238] = 1; re[239] = 3; re[240] = 1; re[242] = 1; re[243] = 3; re[248] = 3; re[249] = 1; re[255] = 1
		cf = self.callback_formats
		cf[4] = 'h'; cf[8] = 'i i i'


def call_compass_bricklet(ctx, argv):
	prog_prefix = 'call compass-bricklet <uid>'

	def get_heading(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-heading')

		args = parser.parse_args(argv)

		device_call(ctx, CompassBricklet, 1, (), '', 'h', args.execute, False, ['heading'], [None])

	def set_heading_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-heading-callback-configuration')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')
		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, CompassBricklet, 2, (args.period, args.value_has_to_change, args.option, args.min, args.max), 'I ! c h h', '', None, args.expect_response, [], [])

	def get_heading_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-heading-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, CompassBricklet, 3, (), '', 'I ! c h h', args.execute, False, ['period', 'value-has-to-change', 'option', 'min', 'max'], [None, None, {'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def get_magnetic_flux_density(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-magnetic-flux-density')

		args = parser.parse_args(argv)

		device_call(ctx, CompassBricklet, 5, (), '', 'i i i', args.execute, False, ['x', 'y', 'z'], [None, None, None])

	def set_magnetic_flux_density_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-magnetic-flux-density-callback-configuration')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')

		args = parser.parse_args(argv)

		device_call(ctx, CompassBricklet, 6, (args.period, args.value_has_to_change), 'I !', '', None, args.expect_response, [], [])

	def get_magnetic_flux_density_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-magnetic-flux-density-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, CompassBricklet, 7, (), '', 'I !', args.execute, False, ['period', 'value-has-to-change'], [None, None])

	def set_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-configuration')

		parser.add_argument('data_rate', type=create_symbol_converter(ctx, convert_int, {'data-rate-400hz': 2, 'data-rate-600hz': 3, 'data-rate-100hz': 0, 'data-rate-200hz': 1}), help='int (data-rate-100hz: 0, data-rate-200hz: 1, data-rate-400hz: 2, data-rate-600hz: 3)', metavar='<data-rate>')
		parser.add_argument('background_calibration', type=convert_bool, help='bool', metavar='<background-calibration>')

		args = parser.parse_args(argv)

		device_call(ctx, CompassBricklet, 9, (args.data_rate, args.background_calibration), 'B !', '', None, args.expect_response, [], [])

	def get_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, CompassBricklet, 10, (), '', 'B !', args.execute, False, ['data-rate', 'background-calibration'], [{0: 'data-rate-100hz', 1: 'data-rate-200hz', 2: 'data-rate-400hz', 3: 'data-rate-600hz'}, None])

	def set_calibration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-calibration')

		parser.add_argument('offset', type=create_array_converter(ctx, convert_int, '0', 3), help=get_array_type_name(ctx, 'int', 3), metavar='<offset>')
		parser.add_argument('gain', type=create_array_converter(ctx, convert_int, '0', 3), help=get_array_type_name(ctx, 'int', 3), metavar='<gain>')

		args = parser.parse_args(argv)

		device_call(ctx, CompassBricklet, 11, (args.offset, args.gain), '3h 3h', '', None, args.expect_response, [], [])

	def get_calibration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-calibration')

		args = parser.parse_args(argv)

		device_call(ctx, CompassBricklet, 12, (), '', '3h 3h', args.execute, False, ['offset', 'gain'], [None, None])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, CompassBricklet, 234, (), '', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def set_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-bootloader-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'bootloader-mode-firmware-wait-for-reboot': 3, 'bootloader-mode-firmware': 1, 'bootloader-mode-firmware-wait-for-erase-and-reboot': 4, 'bootloader-mode-bootloader-wait-for-reboot': 2, 'bootloader-mode-bootloader': 0}), help='int (bootloader-mode-bootloader: 0, bootloader-mode-firmware: 1, bootloader-mode-bootloader-wait-for-reboot: 2, bootloader-mode-firmware-wait-for-reboot: 3, bootloader-mode-firmware-wait-for-erase-and-reboot: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, CompassBricklet, 235, (args.mode,), 'B', 'B', args.execute, False, ['status'], [{0: 'bootloader-status-ok', 1: 'bootloader-status-invalid-mode', 2: 'bootloader-status-no-change', 3: 'bootloader-status-entry-function-not-present', 4: 'bootloader-status-device-identifier-incorrect', 5: 'bootloader-status-crc-mismatch'}])

	def get_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-bootloader-mode')

		args = parser.parse_args(argv)

		device_call(ctx, CompassBricklet, 236, (), '', 'B', args.execute, False, ['mode'], [{0: 'bootloader-mode-bootloader', 1: 'bootloader-mode-firmware', 2: 'bootloader-mode-bootloader-wait-for-reboot', 3: 'bootloader-mode-firmware-wait-for-reboot', 4: 'bootloader-mode-firmware-wait-for-erase-and-reboot'}])

	def set_write_firmware_pointer(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-write-firmware-pointer')

		parser.add_argument('pointer', type=convert_int, help='int', metavar='<pointer>')

		args = parser.parse_args(argv)

		device_call(ctx, CompassBricklet, 237, (args.pointer,), 'I', '', None, args.expect_response, [], [])

	def write_firmware(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-firmware')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, CompassBricklet, 238, (args.data,), '64B', 'B', args.execute, False, ['status'], [None])

	def set_status_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'status-led-config-on': 1, 'status-led-config-show-heartbeat': 2, 'status-led-config-off': 0, 'status-led-config-show-status': 3}), help='int (status-led-config-off: 0, status-led-config-on: 1, status-led-config-show-heartbeat: 2, status-led-config-show-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, CompassBricklet, 239, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_status_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, CompassBricklet, 240, (), '', 'B', args.execute, False, ['config'], [{0: 'status-led-config-off', 1: 'status-led-config-on', 2: 'status-led-config-show-heartbeat', 3: 'status-led-config-show-status'}])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, CompassBricklet, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, CompassBricklet, 243, (), '', '', None, args.expect_response, [], [])

	def write_uid(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-uid')

		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')

		args = parser.parse_args(argv)

		device_call(ctx, CompassBricklet, 248, (args.uid,), 'I', '', None, args.expect_response, [], [])

	def read_uid(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-uid')

		args = parser.parse_args(argv)

		device_call(ctx, CompassBricklet, 249, (), '', 'I', args.execute, False, ['uid'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, CompassBricklet, argv)

	functions = {
	'get-heading': get_heading,
	'set-heading-callback-configuration': set_heading_callback_configuration,
	'get-heading-callback-configuration': get_heading_callback_configuration,
	'get-magnetic-flux-density': get_magnetic_flux_density,
	'set-magnetic-flux-density-callback-configuration': set_magnetic_flux_density_callback_configuration,
	'get-magnetic-flux-density-callback-configuration': get_magnetic_flux_density_callback_configuration,
	'set-configuration': set_configuration,
	'get-configuration': get_configuration,
	'set-calibration': set_calibration,
	'get-calibration': get_calibration,
	'get-spitfp-error-count': get_spitfp_error_count,
	'set-bootloader-mode': set_bootloader_mode,
	'get-bootloader-mode': get_bootloader_mode,
	'set-write-firmware-pointer': set_write_firmware_pointer,
	'write-firmware': write_firmware,
	'set-status-led-config': set_status_led_config,
	'get-status-led-config': get_status_led_config,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'write-uid': write_uid,
	'read-uid': read_uid,
	'get-identity': get_identity
	}

	call_generic(ctx, 'compass-bricklet', functions, argv)

def dispatch_compass_bricklet(ctx, argv):
	prog_prefix = 'dispatch compass-bricklet <uid>'

	def heading(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' heading')

		args = parser.parse_args(argv)

		device_dispatch(ctx, CompassBricklet, 4, args.execute, ['heading'], [None])

	def magnetic_flux_density(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' magnetic-flux-density')

		args = parser.parse_args(argv)

		device_dispatch(ctx, CompassBricklet, 8, args.execute, ['x', 'y', 'z'], [None, None, None])

	callbacks = {
	'heading': heading,
	'magnetic-flux-density': magnetic_flux_density
	}

	dispatch_generic(ctx, 'compass-bricklet', callbacks, argv)

class Current12Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 3; re[3] = 1; re[4] = 1; re[5] = 2; re[6] = 1; re[7] = 2; re[8] = 1; re[9] = 2; re[10] = 1; re[11] = 2; re[12] = 1; re[13] = 2; re[14] = 1; re[255] = 1
		cf = self.callback_formats
		cf[15] = 'h'; cf[16] = 'H'; cf[17] = 'h'; cf[18] = 'H'; cf[19] = ''


def call_current12_bricklet(ctx, argv):
	prog_prefix = 'call current12-bricklet <uid>'

	def get_current(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-current')

		args = parser.parse_args(argv)

		device_call(ctx, Current12Bricklet, 1, (), '', 'h', args.execute, False, ['current'], [None])

	def calibrate(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' calibrate')

		args = parser.parse_args(argv)

		device_call(ctx, Current12Bricklet, 2, (), '', '', None, args.expect_response, [], [])

	def is_over_current(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' is-over-current')

		args = parser.parse_args(argv)

		device_call(ctx, Current12Bricklet, 3, (), '', '!', args.execute, False, ['over'], [None])

	def get_analog_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-analog-value')

		args = parser.parse_args(argv)

		device_call(ctx, Current12Bricklet, 4, (), '', 'H', args.execute, False, ['value'], [None])

	def set_current_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-current-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, Current12Bricklet, 5, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_current_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-current-callback-period')

		args = parser.parse_args(argv)

		device_call(ctx, Current12Bricklet, 6, (), '', 'I', args.execute, False, ['period'], [None])

	def set_analog_value_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-analog-value-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, Current12Bricklet, 7, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_analog_value_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-analog-value-callback-period')

		args = parser.parse_args(argv)

		device_call(ctx, Current12Bricklet, 8, (), '', 'I', args.execute, False, ['period'], [None])

	def set_current_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-current-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, Current12Bricklet, 9, (args.option, args.min, args.max), 'c h h', '', None, args.expect_response, [], [])

	def get_current_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-current-callback-threshold')

		args = parser.parse_args(argv)

		device_call(ctx, Current12Bricklet, 10, (), '', 'c h h', args.execute, False, ['option', 'min', 'max'], [{'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def set_analog_value_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-analog-value-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, Current12Bricklet, 11, (args.option, args.min, args.max), 'c H H', '', None, args.expect_response, [], [])

	def get_analog_value_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-analog-value-callback-threshold')

		args = parser.parse_args(argv)

		device_call(ctx, Current12Bricklet, 12, (), '', 'c H H', args.execute, False, ['option', 'min', 'max'], [{'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def set_debounce_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-debounce-period')

		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_call(ctx, Current12Bricklet, 13, (args.debounce,), 'I', '', None, args.expect_response, [], [])

	def get_debounce_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-debounce-period')

		args = parser.parse_args(argv)

		device_call(ctx, Current12Bricklet, 14, (), '', 'I', args.execute, False, ['debounce'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, Current12Bricklet, argv)

	functions = {
	'get-current': get_current,
	'calibrate': calibrate,
	'is-over-current': is_over_current,
	'get-analog-value': get_analog_value,
	'set-current-callback-period': set_current_callback_period,
	'get-current-callback-period': get_current_callback_period,
	'set-analog-value-callback-period': set_analog_value_callback_period,
	'get-analog-value-callback-period': get_analog_value_callback_period,
	'set-current-callback-threshold': set_current_callback_threshold,
	'get-current-callback-threshold': get_current_callback_threshold,
	'set-analog-value-callback-threshold': set_analog_value_callback_threshold,
	'get-analog-value-callback-threshold': get_analog_value_callback_threshold,
	'set-debounce-period': set_debounce_period,
	'get-debounce-period': get_debounce_period,
	'get-identity': get_identity
	}

	call_generic(ctx, 'current12-bricklet', functions, argv)

def dispatch_current12_bricklet(ctx, argv):
	prog_prefix = 'dispatch current12-bricklet <uid>'

	def current(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' current')

		args = parser.parse_args(argv)

		device_dispatch(ctx, Current12Bricklet, 15, args.execute, ['current'], [None])

	def analog_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' analog-value')

		args = parser.parse_args(argv)

		device_dispatch(ctx, Current12Bricklet, 16, args.execute, ['value'], [None])

	def current_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' current-reached')

		args = parser.parse_args(argv)

		device_dispatch(ctx, Current12Bricklet, 17, args.execute, ['current'], [None])

	def analog_value_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' analog-value-reached')

		args = parser.parse_args(argv)

		device_dispatch(ctx, Current12Bricklet, 18, args.execute, ['value'], [None])

	def over_current(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' over-current')

		args = parser.parse_args(argv)

		device_dispatch(ctx, Current12Bricklet, 19, args.execute, [], [])

	callbacks = {
	'current': current,
	'analog-value': analog_value,
	'current-reached': current_reached,
	'analog-value-reached': analog_value_reached,
	'over-current': over_current
	}

	dispatch_generic(ctx, 'current12-bricklet', callbacks, argv)

class Current25Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 3; re[3] = 1; re[4] = 1; re[5] = 2; re[6] = 1; re[7] = 2; re[8] = 1; re[9] = 2; re[10] = 1; re[11] = 2; re[12] = 1; re[13] = 2; re[14] = 1; re[255] = 1
		cf = self.callback_formats
		cf[15] = 'h'; cf[16] = 'H'; cf[17] = 'h'; cf[18] = 'H'; cf[19] = ''


def call_current25_bricklet(ctx, argv):
	prog_prefix = 'call current25-bricklet <uid>'

	def get_current(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-current')

		args = parser.parse_args(argv)

		device_call(ctx, Current25Bricklet, 1, (), '', 'h', args.execute, False, ['current'], [None])

	def calibrate(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' calibrate')

		args = parser.parse_args(argv)

		device_call(ctx, Current25Bricklet, 2, (), '', '', None, args.expect_response, [], [])

	def is_over_current(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' is-over-current')

		args = parser.parse_args(argv)

		device_call(ctx, Current25Bricklet, 3, (), '', '!', args.execute, False, ['over'], [None])

	def get_analog_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-analog-value')

		args = parser.parse_args(argv)

		device_call(ctx, Current25Bricklet, 4, (), '', 'H', args.execute, False, ['value'], [None])

	def set_current_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-current-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, Current25Bricklet, 5, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_current_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-current-callback-period')

		args = parser.parse_args(argv)

		device_call(ctx, Current25Bricklet, 6, (), '', 'I', args.execute, False, ['period'], [None])

	def set_analog_value_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-analog-value-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, Current25Bricklet, 7, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_analog_value_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-analog-value-callback-period')

		args = parser.parse_args(argv)

		device_call(ctx, Current25Bricklet, 8, (), '', 'I', args.execute, False, ['period'], [None])

	def set_current_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-current-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, Current25Bricklet, 9, (args.option, args.min, args.max), 'c h h', '', None, args.expect_response, [], [])

	def get_current_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-current-callback-threshold')

		args = parser.parse_args(argv)

		device_call(ctx, Current25Bricklet, 10, (), '', 'c h h', args.execute, False, ['option', 'min', 'max'], [{'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def set_analog_value_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-analog-value-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, Current25Bricklet, 11, (args.option, args.min, args.max), 'c H H', '', None, args.expect_response, [], [])

	def get_analog_value_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-analog-value-callback-threshold')

		args = parser.parse_args(argv)

		device_call(ctx, Current25Bricklet, 12, (), '', 'c H H', args.execute, False, ['option', 'min', 'max'], [{'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def set_debounce_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-debounce-period')

		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_call(ctx, Current25Bricklet, 13, (args.debounce,), 'I', '', None, args.expect_response, [], [])

	def get_debounce_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-debounce-period')

		args = parser.parse_args(argv)

		device_call(ctx, Current25Bricklet, 14, (), '', 'I', args.execute, False, ['debounce'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, Current25Bricklet, argv)

	functions = {
	'get-current': get_current,
	'calibrate': calibrate,
	'is-over-current': is_over_current,
	'get-analog-value': get_analog_value,
	'set-current-callback-period': set_current_callback_period,
	'get-current-callback-period': get_current_callback_period,
	'set-analog-value-callback-period': set_analog_value_callback_period,
	'get-analog-value-callback-period': get_analog_value_callback_period,
	'set-current-callback-threshold': set_current_callback_threshold,
	'get-current-callback-threshold': get_current_callback_threshold,
	'set-analog-value-callback-threshold': set_analog_value_callback_threshold,
	'get-analog-value-callback-threshold': get_analog_value_callback_threshold,
	'set-debounce-period': set_debounce_period,
	'get-debounce-period': get_debounce_period,
	'get-identity': get_identity
	}

	call_generic(ctx, 'current25-bricklet', functions, argv)

def dispatch_current25_bricklet(ctx, argv):
	prog_prefix = 'dispatch current25-bricklet <uid>'

	def current(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' current')

		args = parser.parse_args(argv)

		device_dispatch(ctx, Current25Bricklet, 15, args.execute, ['current'], [None])

	def analog_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' analog-value')

		args = parser.parse_args(argv)

		device_dispatch(ctx, Current25Bricklet, 16, args.execute, ['value'], [None])

	def current_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' current-reached')

		args = parser.parse_args(argv)

		device_dispatch(ctx, Current25Bricklet, 17, args.execute, ['current'], [None])

	def analog_value_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' analog-value-reached')

		args = parser.parse_args(argv)

		device_dispatch(ctx, Current25Bricklet, 18, args.execute, ['value'], [None])

	def over_current(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' over-current')

		args = parser.parse_args(argv)

		device_dispatch(ctx, Current25Bricklet, 19, args.execute, [], [])

	callbacks = {
	'current': current,
	'analog-value': analog_value,
	'current-reached': current_reached,
	'analog-value-reached': analog_value_reached,
	'over-current': over_current
	}

	dispatch_generic(ctx, 'current25-bricklet', callbacks, argv)

class DCBrick(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 3; re[2] = 1; re[3] = 1; re[4] = 3; re[5] = 1; re[6] = 3; re[7] = 1; re[8] = 3; re[9] = 1; re[10] = 1; re[11] = 1; re[12] = 3; re[13] = 3; re[14] = 1; re[15] = 2; re[16] = 1; re[17] = 3; re[18] = 1; re[19] = 2; re[20] = 1; re[231] = 3; re[232] = 1; re[233] = 1; re[234] = 3; re[235] = 1; re[237] = 1; re[238] = 3; re[239] = 3; re[240] = 1; re[241] = 1; re[242] = 1; re[243] = 3; re[255] = 1
		cf = self.callback_formats
		cf[21] = 'H'; cf[22] = ''; cf[23] = 'h'; cf[24] = 'h'


def call_dc_brick(ctx, argv):
	prog_prefix = 'call dc-brick <uid>'

	def set_velocity(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-velocity')

		parser.add_argument('velocity', type=convert_int, help='int', metavar='<velocity>')

		args = parser.parse_args(argv)

		device_call(ctx, DCBrick, 1, (args.velocity,), 'h', '', None, args.expect_response, [], [])

	def get_velocity(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-velocity')

		args = parser.parse_args(argv)

		device_call(ctx, DCBrick, 2, (), '', 'h', args.execute, False, ['velocity'], [None])

	def get_current_velocity(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-current-velocity')

		args = parser.parse_args(argv)

		device_call(ctx, DCBrick, 3, (), '', 'h', args.execute, False, ['velocity'], [None])

	def set_acceleration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-acceleration')

		parser.add_argument('acceleration', type=convert_int, help='int', metavar='<acceleration>')

		args = parser.parse_args(argv)

		device_call(ctx, DCBrick, 4, (args.acceleration,), 'H', '', None, args.expect_response, [], [])

	def get_acceleration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-acceleration')

		args = parser.parse_args(argv)

		device_call(ctx, DCBrick, 5, (), '', 'H', args.execute, False, ['acceleration'], [None])

	def set_pwm_frequency(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-pwm-frequency')

		parser.add_argument('frequency', type=convert_int, help='int', metavar='<frequency>')

		args = parser.parse_args(argv)

		device_call(ctx, DCBrick, 6, (args.frequency,), 'H', '', None, args.expect_response, [], [])

	def get_pwm_frequency(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-pwm-frequency')

		args = parser.parse_args(argv)

		device_call(ctx, DCBrick, 7, (), '', 'H', args.execute, False, ['frequency'], [None])

	def full_brake(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' full-brake')

		args = parser.parse_args(argv)

		device_call(ctx, DCBrick, 8, (), '', '', None, args.expect_response, [], [])

	def get_stack_input_voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-stack-input-voltage')

		args = parser.parse_args(argv)

		device_call(ctx, DCBrick, 9, (), '', 'H', args.execute, False, ['voltage'], [None])

	def get_external_input_voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-external-input-voltage')

		args = parser.parse_args(argv)

		device_call(ctx, DCBrick, 10, (), '', 'H', args.execute, False, ['voltage'], [None])

	def get_current_consumption(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-current-consumption')

		args = parser.parse_args(argv)

		device_call(ctx, DCBrick, 11, (), '', 'H', args.execute, False, ['voltage'], [None])

	def enable(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' enable')

		args = parser.parse_args(argv)

		device_call(ctx, DCBrick, 12, (), '', '', None, args.expect_response, [], [])

	def disable(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' disable')

		args = parser.parse_args(argv)

		device_call(ctx, DCBrick, 13, (), '', '', None, args.expect_response, [], [])

	def is_enabled(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' is-enabled')

		args = parser.parse_args(argv)

		device_call(ctx, DCBrick, 14, (), '', '!', args.execute, False, ['enabled'], [None])

	def set_minimum_voltage(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-minimum-voltage')

		parser.add_argument('voltage', type=convert_int, help='int', metavar='<voltage>')

		args = parser.parse_args(argv)

		device_call(ctx, DCBrick, 15, (args.voltage,), 'H', '', None, args.expect_response, [], [])

	def get_minimum_voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-minimum-voltage')

		args = parser.parse_args(argv)

		device_call(ctx, DCBrick, 16, (), '', 'H', args.execute, False, ['voltage'], [None])

	def set_drive_mode(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-drive-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'drive-mode-drive-coast': 1, 'drive-mode-drive-brake': 0}), help='int (drive-mode-drive-brake: 0, drive-mode-drive-coast: 1)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, DCBrick, 17, (args.mode,), 'B', '', None, args.expect_response, [], [])

	def get_drive_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-drive-mode')

		args = parser.parse_args(argv)

		device_call(ctx, DCBrick, 18, (), '', 'B', args.execute, False, ['mode'], [{0: 'drive-mode-drive-brake', 1: 'drive-mode-drive-coast'}])

	def set_current_velocity_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-current-velocity-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, DCBrick, 19, (args.period,), 'H', '', None, args.expect_response, [], [])

	def get_current_velocity_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-current-velocity-period')

		args = parser.parse_args(argv)

		device_call(ctx, DCBrick, 20, (), '', 'H', args.execute, False, ['period'], [None])

	def set_spitfp_baudrate_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-spitfp-baudrate-config')

		parser.add_argument('enable_dynamic_baudrate', type=convert_bool, help='bool', metavar='<enable-dynamic-baudrate>')
		parser.add_argument('minimum_dynamic_baudrate', type=convert_int, help='int', metavar='<minimum-dynamic-baudrate>')

		args = parser.parse_args(argv)

		device_call(ctx, DCBrick, 231, (args.enable_dynamic_baudrate, args.minimum_dynamic_baudrate), '! I', '', None, args.expect_response, [], [])

	def get_spitfp_baudrate_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-baudrate-config')

		args = parser.parse_args(argv)

		device_call(ctx, DCBrick, 232, (), '', '! I', args.execute, False, ['enable-dynamic-baudrate', 'minimum-dynamic-baudrate'], [None, None])

	def get_send_timeout_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-send-timeout-count')

		parser.add_argument('communication_method', type=create_symbol_converter(ctx, convert_int, {'communication-method-none': 0, 'communication-method-rs485': 4, 'communication-method-usb': 1, 'communication-method-wifi-v2': 7, 'communication-method-spi-stack': 2, 'communication-method-wifi': 5, 'communication-method-chibi': 3, 'communication-method-ethernet': 6}), help='int (communication-method-none: 0, communication-method-usb: 1, communication-method-spi-stack: 2, communication-method-chibi: 3, communication-method-rs485: 4, communication-method-wifi: 5, communication-method-ethernet: 6, communication-method-wifi-v2: 7)', metavar='<communication-method>')

		args = parser.parse_args(argv)

		device_call(ctx, DCBrick, 233, (args.communication_method,), 'B', 'I', args.execute, False, ['timeout-count'], [None])

	def set_spitfp_baudrate(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-spitfp-baudrate')

		parser.add_argument('bricklet_port', type=create_char_converter(ctx), help='char', metavar='<bricklet-port>')
		parser.add_argument('baudrate', type=convert_int, help='int', metavar='<baudrate>')

		args = parser.parse_args(argv)

		device_call(ctx, DCBrick, 234, (args.bricklet_port, args.baudrate), 'c I', '', None, args.expect_response, [], [])

	def get_spitfp_baudrate(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-baudrate')

		parser.add_argument('bricklet_port', type=create_char_converter(ctx), help='char', metavar='<bricklet-port>')

		args = parser.parse_args(argv)

		device_call(ctx, DCBrick, 235, (args.bricklet_port,), 'c', 'I', args.execute, False, ['baudrate'], [None])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		parser.add_argument('bricklet_port', type=create_char_converter(ctx), help='char', metavar='<bricklet-port>')

		args = parser.parse_args(argv)

		device_call(ctx, DCBrick, 237, (args.bricklet_port,), 'c', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def enable_status_led(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' enable-status-led')

		args = parser.parse_args(argv)

		device_call(ctx, DCBrick, 238, (), '', '', None, args.expect_response, [], [])

	def disable_status_led(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' disable-status-led')

		args = parser.parse_args(argv)

		device_call(ctx, DCBrick, 239, (), '', '', None, args.expect_response, [], [])

	def is_status_led_enabled(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' is-status-led-enabled')

		args = parser.parse_args(argv)

		device_call(ctx, DCBrick, 240, (), '', '!', args.execute, False, ['enabled'], [None])

	def get_protocol1_bricklet_name(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-protocol1-bricklet-name')

		parser.add_argument('port', type=create_char_converter(ctx), help='char', metavar='<port>')

		args = parser.parse_args(argv)

		device_call(ctx, DCBrick, 241, (args.port,), 'c', 'B 3B 40s', args.execute, False, ['protocol-version', 'firmware-version', 'name'], [None, None, None])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, DCBrick, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, DCBrick, 243, (), '', '', None, args.expect_response, [], [])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, DCBrick, argv)

	functions = {
	'set-velocity': set_velocity,
	'get-velocity': get_velocity,
	'get-current-velocity': get_current_velocity,
	'set-acceleration': set_acceleration,
	'get-acceleration': get_acceleration,
	'set-pwm-frequency': set_pwm_frequency,
	'get-pwm-frequency': get_pwm_frequency,
	'full-brake': full_brake,
	'get-stack-input-voltage': get_stack_input_voltage,
	'get-external-input-voltage': get_external_input_voltage,
	'get-current-consumption': get_current_consumption,
	'enable': enable,
	'disable': disable,
	'is-enabled': is_enabled,
	'set-minimum-voltage': set_minimum_voltage,
	'get-minimum-voltage': get_minimum_voltage,
	'set-drive-mode': set_drive_mode,
	'get-drive-mode': get_drive_mode,
	'set-current-velocity-period': set_current_velocity_period,
	'get-current-velocity-period': get_current_velocity_period,
	'set-spitfp-baudrate-config': set_spitfp_baudrate_config,
	'get-spitfp-baudrate-config': get_spitfp_baudrate_config,
	'get-send-timeout-count': get_send_timeout_count,
	'set-spitfp-baudrate': set_spitfp_baudrate,
	'get-spitfp-baudrate': get_spitfp_baudrate,
	'get-spitfp-error-count': get_spitfp_error_count,
	'enable-status-led': enable_status_led,
	'disable-status-led': disable_status_led,
	'is-status-led-enabled': is_status_led_enabled,
	'get-protocol1-bricklet-name': get_protocol1_bricklet_name,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'get-identity': get_identity
	}

	call_generic(ctx, 'dc-brick', functions, argv)

def dispatch_dc_brick(ctx, argv):
	prog_prefix = 'dispatch dc-brick <uid>'

	def under_voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' under-voltage')

		args = parser.parse_args(argv)

		device_dispatch(ctx, DCBrick, 21, args.execute, ['voltage'], [None])

	def emergency_shutdown(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' emergency-shutdown')

		args = parser.parse_args(argv)

		device_dispatch(ctx, DCBrick, 22, args.execute, [], [])

	def velocity_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' velocity-reached')

		args = parser.parse_args(argv)

		device_dispatch(ctx, DCBrick, 23, args.execute, ['velocity'], [None])

	def current_velocity(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' current-velocity')

		args = parser.parse_args(argv)

		device_dispatch(ctx, DCBrick, 24, args.execute, ['velocity'], [None])

	callbacks = {
	'under-voltage': under_voltage,
	'emergency-shutdown': emergency_shutdown,
	'velocity-reached': velocity_reached,
	'current-velocity': current_velocity
	}

	dispatch_generic(ctx, 'dc-brick', callbacks, argv)

class DistanceIRBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 1; re[3] = 3; re[4] = 1; re[5] = 2; re[6] = 1; re[7] = 2; re[8] = 1; re[9] = 2; re[10] = 1; re[11] = 2; re[12] = 1; re[13] = 2; re[14] = 1; re[255] = 1
		cf = self.callback_formats
		cf[15] = 'H'; cf[16] = 'H'; cf[17] = 'H'; cf[18] = 'H'


def call_distance_ir_bricklet(ctx, argv):
	prog_prefix = 'call distance-ir-bricklet <uid>'

	def get_distance(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-distance')

		args = parser.parse_args(argv)

		device_call(ctx, DistanceIRBricklet, 1, (), '', 'H', args.execute, False, ['distance'], [None])

	def get_analog_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-analog-value')

		args = parser.parse_args(argv)

		device_call(ctx, DistanceIRBricklet, 2, (), '', 'H', args.execute, False, ['value'], [None])

	def set_sampling_point(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-sampling-point')

		parser.add_argument('position', type=convert_int, help='int', metavar='<position>')
		parser.add_argument('distance', type=convert_int, help='int', metavar='<distance>')

		args = parser.parse_args(argv)

		device_call(ctx, DistanceIRBricklet, 3, (args.position, args.distance), 'B H', '', None, args.expect_response, [], [])

	def get_sampling_point(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-sampling-point')

		parser.add_argument('position', type=convert_int, help='int', metavar='<position>')

		args = parser.parse_args(argv)

		device_call(ctx, DistanceIRBricklet, 4, (args.position,), 'B', 'H', args.execute, False, ['distance'], [None])

	def set_distance_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-distance-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, DistanceIRBricklet, 5, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_distance_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-distance-callback-period')

		args = parser.parse_args(argv)

		device_call(ctx, DistanceIRBricklet, 6, (), '', 'I', args.execute, False, ['period'], [None])

	def set_analog_value_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-analog-value-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, DistanceIRBricklet, 7, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_analog_value_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-analog-value-callback-period')

		args = parser.parse_args(argv)

		device_call(ctx, DistanceIRBricklet, 8, (), '', 'I', args.execute, False, ['period'], [None])

	def set_distance_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-distance-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, DistanceIRBricklet, 9, (args.option, args.min, args.max), 'c H H', '', None, args.expect_response, [], [])

	def get_distance_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-distance-callback-threshold')

		args = parser.parse_args(argv)

		device_call(ctx, DistanceIRBricklet, 10, (), '', 'c H H', args.execute, False, ['option', 'min', 'max'], [{'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def set_analog_value_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-analog-value-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, DistanceIRBricklet, 11, (args.option, args.min, args.max), 'c H H', '', None, args.expect_response, [], [])

	def get_analog_value_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-analog-value-callback-threshold')

		args = parser.parse_args(argv)

		device_call(ctx, DistanceIRBricklet, 12, (), '', 'c H H', args.execute, False, ['option', 'min', 'max'], [{'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def set_debounce_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-debounce-period')

		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_call(ctx, DistanceIRBricklet, 13, (args.debounce,), 'I', '', None, args.expect_response, [], [])

	def get_debounce_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-debounce-period')

		args = parser.parse_args(argv)

		device_call(ctx, DistanceIRBricklet, 14, (), '', 'I', args.execute, False, ['debounce'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, DistanceIRBricklet, argv)

	functions = {
	'get-distance': get_distance,
	'get-analog-value': get_analog_value,
	'set-sampling-point': set_sampling_point,
	'get-sampling-point': get_sampling_point,
	'set-distance-callback-period': set_distance_callback_period,
	'get-distance-callback-period': get_distance_callback_period,
	'set-analog-value-callback-period': set_analog_value_callback_period,
	'get-analog-value-callback-period': get_analog_value_callback_period,
	'set-distance-callback-threshold': set_distance_callback_threshold,
	'get-distance-callback-threshold': get_distance_callback_threshold,
	'set-analog-value-callback-threshold': set_analog_value_callback_threshold,
	'get-analog-value-callback-threshold': get_analog_value_callback_threshold,
	'set-debounce-period': set_debounce_period,
	'get-debounce-period': get_debounce_period,
	'get-identity': get_identity
	}

	call_generic(ctx, 'distance-ir-bricklet', functions, argv)

def dispatch_distance_ir_bricklet(ctx, argv):
	prog_prefix = 'dispatch distance-ir-bricklet <uid>'

	def distance(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' distance')

		args = parser.parse_args(argv)

		device_dispatch(ctx, DistanceIRBricklet, 15, args.execute, ['distance'], [None])

	def analog_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' analog-value')

		args = parser.parse_args(argv)

		device_dispatch(ctx, DistanceIRBricklet, 16, args.execute, ['value'], [None])

	def distance_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' distance-reached')

		args = parser.parse_args(argv)

		device_dispatch(ctx, DistanceIRBricklet, 17, args.execute, ['distance'], [None])

	def analog_value_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' analog-value-reached')

		args = parser.parse_args(argv)

		device_dispatch(ctx, DistanceIRBricklet, 18, args.execute, ['value'], [None])

	callbacks = {
	'distance': distance,
	'analog-value': analog_value,
	'distance-reached': distance_reached,
	'analog-value-reached': analog_value_reached
	}

	dispatch_generic(ctx, 'distance-ir-bricklet', callbacks, argv)

class DistanceIRV2Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 2; re[3] = 1; re[5] = 1; re[6] = 2; re[7] = 1; re[9] = 3; re[10] = 1; re[11] = 3; re[12] = 1; re[13] = 3; re[14] = 1; re[234] = 1; re[235] = 1; re[236] = 1; re[237] = 3; re[238] = 1; re[239] = 3; re[240] = 1; re[242] = 1; re[243] = 3; re[248] = 3; re[249] = 1; re[255] = 1
		cf = self.callback_formats
		cf[4] = 'H'; cf[8] = 'I'


def call_distance_ir_v2_bricklet(ctx, argv):
	prog_prefix = 'call distance-ir-v2-bricklet <uid>'

	def get_distance(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-distance')

		args = parser.parse_args(argv)

		device_call(ctx, DistanceIRV2Bricklet, 1, (), '', 'H', args.execute, False, ['distance'], [None])

	def set_distance_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-distance-callback-configuration')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')
		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, DistanceIRV2Bricklet, 2, (args.period, args.value_has_to_change, args.option, args.min, args.max), 'I ! c H H', '', None, args.expect_response, [], [])

	def get_distance_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-distance-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, DistanceIRV2Bricklet, 3, (), '', 'I ! c H H', args.execute, False, ['period', 'value-has-to-change', 'option', 'min', 'max'], [None, None, {'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def get_analog_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-analog-value')

		args = parser.parse_args(argv)

		device_call(ctx, DistanceIRV2Bricklet, 5, (), '', 'I', args.execute, False, ['analog-value'], [None])

	def set_analog_value_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-analog-value-callback-configuration')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')
		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, DistanceIRV2Bricklet, 6, (args.period, args.value_has_to_change, args.option, args.min, args.max), 'I ! c I I', '', None, args.expect_response, [], [])

	def get_analog_value_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-analog-value-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, DistanceIRV2Bricklet, 7, (), '', 'I ! c I I', args.execute, False, ['period', 'value-has-to-change', 'option', 'min', 'max'], [None, None, {'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def set_moving_average_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-moving-average-configuration')

		parser.add_argument('moving_average_length', type=convert_int, help='int', metavar='<moving-average-length>')

		args = parser.parse_args(argv)

		device_call(ctx, DistanceIRV2Bricklet, 9, (args.moving_average_length,), 'H', '', None, args.expect_response, [], [])

	def get_moving_average_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-moving-average-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, DistanceIRV2Bricklet, 10, (), '', 'H', args.execute, False, ['moving-average-length'], [None])

	def set_distance_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-distance-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'distance-led-config-show-heartbeat': 2, 'distance-led-config-on': 1, 'distance-led-config-show-distance': 3, 'distance-led-config-off': 0}), help='int (distance-led-config-off: 0, distance-led-config-on: 1, distance-led-config-show-heartbeat: 2, distance-led-config-show-distance: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, DistanceIRV2Bricklet, 11, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_distance_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-distance-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, DistanceIRV2Bricklet, 12, (), '', 'B', args.execute, False, ['config'], [{0: 'distance-led-config-off', 1: 'distance-led-config-on', 2: 'distance-led-config-show-heartbeat', 3: 'distance-led-config-show-distance'}])

	def set_sensor_type(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-sensor-type')

		parser.add_argument('sensor', type=create_symbol_converter(ctx, convert_int, {'sensor-type-2y0a02': 2, 'sensor-type-2y0a41': 0, 'sensor-type-2y0a21': 1}), help='int (sensor-type-2y0a41: 0, sensor-type-2y0a21: 1, sensor-type-2y0a02: 2)', metavar='<sensor>')

		args = parser.parse_args(argv)

		device_call(ctx, DistanceIRV2Bricklet, 13, (args.sensor,), 'B', '', None, args.expect_response, [], [])

	def get_sensor_type(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-sensor-type')

		args = parser.parse_args(argv)

		device_call(ctx, DistanceIRV2Bricklet, 14, (), '', 'B', args.execute, False, ['sensor'], [{0: 'sensor-type-2y0a41', 1: 'sensor-type-2y0a21', 2: 'sensor-type-2y0a02'}])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, DistanceIRV2Bricklet, 234, (), '', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def set_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-bootloader-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'bootloader-mode-firmware-wait-for-reboot': 3, 'bootloader-mode-firmware': 1, 'bootloader-mode-firmware-wait-for-erase-and-reboot': 4, 'bootloader-mode-bootloader-wait-for-reboot': 2, 'bootloader-mode-bootloader': 0}), help='int (bootloader-mode-bootloader: 0, bootloader-mode-firmware: 1, bootloader-mode-bootloader-wait-for-reboot: 2, bootloader-mode-firmware-wait-for-reboot: 3, bootloader-mode-firmware-wait-for-erase-and-reboot: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, DistanceIRV2Bricklet, 235, (args.mode,), 'B', 'B', args.execute, False, ['status'], [{0: 'bootloader-status-ok', 1: 'bootloader-status-invalid-mode', 2: 'bootloader-status-no-change', 3: 'bootloader-status-entry-function-not-present', 4: 'bootloader-status-device-identifier-incorrect', 5: 'bootloader-status-crc-mismatch'}])

	def get_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-bootloader-mode')

		args = parser.parse_args(argv)

		device_call(ctx, DistanceIRV2Bricklet, 236, (), '', 'B', args.execute, False, ['mode'], [{0: 'bootloader-mode-bootloader', 1: 'bootloader-mode-firmware', 2: 'bootloader-mode-bootloader-wait-for-reboot', 3: 'bootloader-mode-firmware-wait-for-reboot', 4: 'bootloader-mode-firmware-wait-for-erase-and-reboot'}])

	def set_write_firmware_pointer(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-write-firmware-pointer')

		parser.add_argument('pointer', type=convert_int, help='int', metavar='<pointer>')

		args = parser.parse_args(argv)

		device_call(ctx, DistanceIRV2Bricklet, 237, (args.pointer,), 'I', '', None, args.expect_response, [], [])

	def write_firmware(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-firmware')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, DistanceIRV2Bricklet, 238, (args.data,), '64B', 'B', args.execute, False, ['status'], [None])

	def set_status_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'status-led-config-on': 1, 'status-led-config-show-heartbeat': 2, 'status-led-config-off': 0, 'status-led-config-show-status': 3}), help='int (status-led-config-off: 0, status-led-config-on: 1, status-led-config-show-heartbeat: 2, status-led-config-show-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, DistanceIRV2Bricklet, 239, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_status_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, DistanceIRV2Bricklet, 240, (), '', 'B', args.execute, False, ['config'], [{0: 'status-led-config-off', 1: 'status-led-config-on', 2: 'status-led-config-show-heartbeat', 3: 'status-led-config-show-status'}])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, DistanceIRV2Bricklet, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, DistanceIRV2Bricklet, 243, (), '', '', None, args.expect_response, [], [])

	def write_uid(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-uid')

		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')

		args = parser.parse_args(argv)

		device_call(ctx, DistanceIRV2Bricklet, 248, (args.uid,), 'I', '', None, args.expect_response, [], [])

	def read_uid(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-uid')

		args = parser.parse_args(argv)

		device_call(ctx, DistanceIRV2Bricklet, 249, (), '', 'I', args.execute, False, ['uid'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, DistanceIRV2Bricklet, argv)

	functions = {
	'get-distance': get_distance,
	'set-distance-callback-configuration': set_distance_callback_configuration,
	'get-distance-callback-configuration': get_distance_callback_configuration,
	'get-analog-value': get_analog_value,
	'set-analog-value-callback-configuration': set_analog_value_callback_configuration,
	'get-analog-value-callback-configuration': get_analog_value_callback_configuration,
	'set-moving-average-configuration': set_moving_average_configuration,
	'get-moving-average-configuration': get_moving_average_configuration,
	'set-distance-led-config': set_distance_led_config,
	'get-distance-led-config': get_distance_led_config,
	'set-sensor-type': set_sensor_type,
	'get-sensor-type': get_sensor_type,
	'get-spitfp-error-count': get_spitfp_error_count,
	'set-bootloader-mode': set_bootloader_mode,
	'get-bootloader-mode': get_bootloader_mode,
	'set-write-firmware-pointer': set_write_firmware_pointer,
	'write-firmware': write_firmware,
	'set-status-led-config': set_status_led_config,
	'get-status-led-config': get_status_led_config,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'write-uid': write_uid,
	'read-uid': read_uid,
	'get-identity': get_identity
	}

	call_generic(ctx, 'distance-ir-v2-bricklet', functions, argv)

def dispatch_distance_ir_v2_bricklet(ctx, argv):
	prog_prefix = 'dispatch distance-ir-v2-bricklet <uid>'

	def distance(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' distance')

		args = parser.parse_args(argv)

		device_dispatch(ctx, DistanceIRV2Bricklet, 4, args.execute, ['distance'], [None])

	def analog_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' analog-value')

		args = parser.parse_args(argv)

		device_dispatch(ctx, DistanceIRV2Bricklet, 8, args.execute, ['analog-value'], [None])

	callbacks = {
	'distance': distance,
	'analog-value': analog_value
	}

	dispatch_generic(ctx, 'distance-ir-v2-bricklet', callbacks, argv)

class DistanceUSBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 2; re[3] = 1; re[4] = 2; re[5] = 1; re[6] = 2; re[7] = 1; re[10] = 3; re[11] = 1; re[255] = 1
		cf = self.callback_formats
		cf[8] = 'H'; cf[9] = 'H'


def call_distance_us_bricklet(ctx, argv):
	prog_prefix = 'call distance-us-bricklet <uid>'

	def get_distance_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-distance-value')

		args = parser.parse_args(argv)

		device_call(ctx, DistanceUSBricklet, 1, (), '', 'H', args.execute, False, ['distance'], [None])

	def set_distance_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-distance-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, DistanceUSBricklet, 2, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_distance_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-distance-callback-period')

		args = parser.parse_args(argv)

		device_call(ctx, DistanceUSBricklet, 3, (), '', 'I', args.execute, False, ['period'], [None])

	def set_distance_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-distance-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, DistanceUSBricklet, 4, (args.option, args.min, args.max), 'c H H', '', None, args.expect_response, [], [])

	def get_distance_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-distance-callback-threshold')

		args = parser.parse_args(argv)

		device_call(ctx, DistanceUSBricklet, 5, (), '', 'c H H', args.execute, False, ['option', 'min', 'max'], [{'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def set_debounce_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-debounce-period')

		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_call(ctx, DistanceUSBricklet, 6, (args.debounce,), 'I', '', None, args.expect_response, [], [])

	def get_debounce_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-debounce-period')

		args = parser.parse_args(argv)

		device_call(ctx, DistanceUSBricklet, 7, (), '', 'I', args.execute, False, ['debounce'], [None])

	def set_moving_average(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-moving-average')

		parser.add_argument('average', type=convert_int, help='int', metavar='<average>')

		args = parser.parse_args(argv)

		device_call(ctx, DistanceUSBricklet, 10, (args.average,), 'B', '', None, args.expect_response, [], [])

	def get_moving_average(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-moving-average')

		args = parser.parse_args(argv)

		device_call(ctx, DistanceUSBricklet, 11, (), '', 'B', args.execute, False, ['average'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, DistanceUSBricklet, argv)

	functions = {
	'get-distance-value': get_distance_value,
	'set-distance-callback-period': set_distance_callback_period,
	'get-distance-callback-period': get_distance_callback_period,
	'set-distance-callback-threshold': set_distance_callback_threshold,
	'get-distance-callback-threshold': get_distance_callback_threshold,
	'set-debounce-period': set_debounce_period,
	'get-debounce-period': get_debounce_period,
	'set-moving-average': set_moving_average,
	'get-moving-average': get_moving_average,
	'get-identity': get_identity
	}

	call_generic(ctx, 'distance-us-bricklet', functions, argv)

def dispatch_distance_us_bricklet(ctx, argv):
	prog_prefix = 'dispatch distance-us-bricklet <uid>'

	def distance(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' distance')

		args = parser.parse_args(argv)

		device_dispatch(ctx, DistanceUSBricklet, 8, args.execute, ['distance'], [None])

	def distance_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' distance-reached')

		args = parser.parse_args(argv)

		device_dispatch(ctx, DistanceUSBricklet, 9, args.execute, ['distance'], [None])

	callbacks = {
	'distance': distance,
	'distance-reached': distance_reached
	}

	dispatch_generic(ctx, 'distance-us-bricklet', callbacks, argv)

class DistanceUSV2Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 2; re[3] = 1; re[5] = 3; re[6] = 1; re[7] = 3; re[8] = 1; re[234] = 1; re[235] = 1; re[236] = 1; re[237] = 3; re[238] = 1; re[239] = 3; re[240] = 1; re[242] = 1; re[243] = 3; re[248] = 3; re[249] = 1; re[255] = 1
		cf = self.callback_formats
		cf[4] = 'H'


def call_distance_us_v2_bricklet(ctx, argv):
	prog_prefix = 'call distance-us-v2-bricklet <uid>'

	def get_distance(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-distance')

		args = parser.parse_args(argv)

		device_call(ctx, DistanceUSV2Bricklet, 1, (), '', 'H', args.execute, False, ['distance'], [None])

	def set_distance_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-distance-callback-configuration')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')
		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, DistanceUSV2Bricklet, 2, (args.period, args.value_has_to_change, args.option, args.min, args.max), 'I ! c H H', '', None, args.expect_response, [], [])

	def get_distance_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-distance-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, DistanceUSV2Bricklet, 3, (), '', 'I ! c H H', args.execute, False, ['period', 'value-has-to-change', 'option', 'min', 'max'], [None, None, {'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def set_update_rate(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-update-rate')

		parser.add_argument('update_rate', type=create_symbol_converter(ctx, convert_int, {'update-rate-10-hz': 1, 'update-rate-2-hz': 0}), help='int (update-rate-2-hz: 0, update-rate-10-hz: 1)', metavar='<update-rate>')

		args = parser.parse_args(argv)

		device_call(ctx, DistanceUSV2Bricklet, 5, (args.update_rate,), 'B', '', None, args.expect_response, [], [])

	def get_update_rate(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-update-rate')

		args = parser.parse_args(argv)

		device_call(ctx, DistanceUSV2Bricklet, 6, (), '', 'B', args.execute, False, ['update-rate'], [{0: 'update-rate-2-hz', 1: 'update-rate-10-hz'}])

	def set_distance_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-distance-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'distance-led-config-show-heartbeat': 2, 'distance-led-config-on': 1, 'distance-led-config-show-distance': 3, 'distance-led-config-off': 0}), help='int (distance-led-config-off: 0, distance-led-config-on: 1, distance-led-config-show-heartbeat: 2, distance-led-config-show-distance: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, DistanceUSV2Bricklet, 7, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_distance_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-distance-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, DistanceUSV2Bricklet, 8, (), '', 'B', args.execute, False, ['config'], [{0: 'distance-led-config-off', 1: 'distance-led-config-on', 2: 'distance-led-config-show-heartbeat', 3: 'distance-led-config-show-distance'}])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, DistanceUSV2Bricklet, 234, (), '', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def set_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-bootloader-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'bootloader-mode-firmware-wait-for-reboot': 3, 'bootloader-mode-firmware': 1, 'bootloader-mode-firmware-wait-for-erase-and-reboot': 4, 'bootloader-mode-bootloader-wait-for-reboot': 2, 'bootloader-mode-bootloader': 0}), help='int (bootloader-mode-bootloader: 0, bootloader-mode-firmware: 1, bootloader-mode-bootloader-wait-for-reboot: 2, bootloader-mode-firmware-wait-for-reboot: 3, bootloader-mode-firmware-wait-for-erase-and-reboot: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, DistanceUSV2Bricklet, 235, (args.mode,), 'B', 'B', args.execute, False, ['status'], [{0: 'bootloader-status-ok', 1: 'bootloader-status-invalid-mode', 2: 'bootloader-status-no-change', 3: 'bootloader-status-entry-function-not-present', 4: 'bootloader-status-device-identifier-incorrect', 5: 'bootloader-status-crc-mismatch'}])

	def get_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-bootloader-mode')

		args = parser.parse_args(argv)

		device_call(ctx, DistanceUSV2Bricklet, 236, (), '', 'B', args.execute, False, ['mode'], [{0: 'bootloader-mode-bootloader', 1: 'bootloader-mode-firmware', 2: 'bootloader-mode-bootloader-wait-for-reboot', 3: 'bootloader-mode-firmware-wait-for-reboot', 4: 'bootloader-mode-firmware-wait-for-erase-and-reboot'}])

	def set_write_firmware_pointer(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-write-firmware-pointer')

		parser.add_argument('pointer', type=convert_int, help='int', metavar='<pointer>')

		args = parser.parse_args(argv)

		device_call(ctx, DistanceUSV2Bricklet, 237, (args.pointer,), 'I', '', None, args.expect_response, [], [])

	def write_firmware(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-firmware')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, DistanceUSV2Bricklet, 238, (args.data,), '64B', 'B', args.execute, False, ['status'], [None])

	def set_status_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'status-led-config-on': 1, 'status-led-config-show-heartbeat': 2, 'status-led-config-off': 0, 'status-led-config-show-status': 3}), help='int (status-led-config-off: 0, status-led-config-on: 1, status-led-config-show-heartbeat: 2, status-led-config-show-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, DistanceUSV2Bricklet, 239, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_status_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, DistanceUSV2Bricklet, 240, (), '', 'B', args.execute, False, ['config'], [{0: 'status-led-config-off', 1: 'status-led-config-on', 2: 'status-led-config-show-heartbeat', 3: 'status-led-config-show-status'}])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, DistanceUSV2Bricklet, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, DistanceUSV2Bricklet, 243, (), '', '', None, args.expect_response, [], [])

	def write_uid(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-uid')

		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')

		args = parser.parse_args(argv)

		device_call(ctx, DistanceUSV2Bricklet, 248, (args.uid,), 'I', '', None, args.expect_response, [], [])

	def read_uid(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-uid')

		args = parser.parse_args(argv)

		device_call(ctx, DistanceUSV2Bricklet, 249, (), '', 'I', args.execute, False, ['uid'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, DistanceUSV2Bricklet, argv)

	functions = {
	'get-distance': get_distance,
	'set-distance-callback-configuration': set_distance_callback_configuration,
	'get-distance-callback-configuration': get_distance_callback_configuration,
	'set-update-rate': set_update_rate,
	'get-update-rate': get_update_rate,
	'set-distance-led-config': set_distance_led_config,
	'get-distance-led-config': get_distance_led_config,
	'get-spitfp-error-count': get_spitfp_error_count,
	'set-bootloader-mode': set_bootloader_mode,
	'get-bootloader-mode': get_bootloader_mode,
	'set-write-firmware-pointer': set_write_firmware_pointer,
	'write-firmware': write_firmware,
	'set-status-led-config': set_status_led_config,
	'get-status-led-config': get_status_led_config,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'write-uid': write_uid,
	'read-uid': read_uid,
	'get-identity': get_identity
	}

	call_generic(ctx, 'distance-us-v2-bricklet', functions, argv)

def dispatch_distance_us_v2_bricklet(ctx, argv):
	prog_prefix = 'dispatch distance-us-v2-bricklet <uid>'

	def distance(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' distance')

		args = parser.parse_args(argv)

		device_dispatch(ctx, DistanceUSV2Bricklet, 4, args.execute, ['distance'], [None])

	callbacks = {
	'distance': distance
	}

	dispatch_generic(ctx, 'distance-us-v2-bricklet', callbacks, argv)

class DMXBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 3; re[2] = 1; re[3] = 2; re[4] = 1; re[5] = 3; re[6] = 1; re[7] = 1; re[8] = 3; re[9] = 1; re[10] = 3; re[11] = 1; re[12] = 2; re[13] = 1; re[234] = 1; re[235] = 1; re[236] = 1; re[237] = 3; re[238] = 1; re[239] = 3; re[240] = 1; re[242] = 1; re[243] = 3; re[248] = 3; re[249] = 1; re[255] = 1
		cf = self.callback_formats
		cf[14] = ''; cf[15] = 'I'; cf[16] = 'H H 56B I'; cf[17] = 'I I'
		hlc = self.high_level_callbacks
		hlc[-16] = [('stream_length', 'stream_chunk_offset', 'stream_chunk_data', None), {'fixed_length': None, 'single_chunk': False}, None]

def call_dmx_bricklet(ctx, argv):
	prog_prefix = 'call dmx-bricklet <uid>'

	def set_dmx_mode(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-dmx-mode')

		parser.add_argument('dmx_mode', type=create_symbol_converter(ctx, convert_int, {'dmx-mode-slave': 1, 'dmx-mode-master': 0}), help='int (dmx-mode-master: 0, dmx-mode-slave: 1)', metavar='<dmx-mode>')

		args = parser.parse_args(argv)

		device_call(ctx, DMXBricklet, 1, (args.dmx_mode,), 'B', '', None, args.expect_response, [], [])

	def get_dmx_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-dmx-mode')

		args = parser.parse_args(argv)

		device_call(ctx, DMXBricklet, 2, (), '', 'B', args.execute, False, ['dmx-mode'], [{0: 'dmx-mode-master', 1: 'dmx-mode-slave'}])

	def write_frame_low_level(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-frame-low-level')

		parser.add_argument('frame_length', type=convert_int, help='int', metavar='<frame-length>')
		parser.add_argument('frame_chunk_offset', type=convert_int, help='int', metavar='<frame-chunk-offset>')
		parser.add_argument('frame_chunk_data', type=create_array_converter(ctx, convert_int, '0', 60), help=get_array_type_name(ctx, 'int', 60), metavar='<frame-chunk-data>')

		args = parser.parse_args(argv)

		device_call(ctx, DMXBricklet, 3, (args.frame_length, args.frame_chunk_offset, args.frame_chunk_data), 'H H 60B', '', None, args.expect_response, [], [])

	def write_frame(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-frame')

		parser.add_argument('frame', type=create_array_converter(ctx, convert_int, None, -65535), help=get_array_type_name(ctx, 'int', -65535), metavar='<frame>')

		args = parser.parse_args(argv)

		device_stream_call(ctx, DMXBricklet, 3, 'in', (args.frame,), ('stream_data',), (), ('stream_length', 'stream_chunk_offset', 'stream_chunk_data'), (), 'H H 60B', '', None, args.expect_response, [], [], '0', 60, None, False, False, None)

	def read_frame_low_level(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-frame-low-level')

		args = parser.parse_args(argv)

		device_call(ctx, DMXBricklet, 4, (), '', 'H H 56B I', args.execute, False, ['frame-length', 'frame-chunk-offset', 'frame-chunk-data', 'frame-number'], [None, None, None, None])

	def read_frame(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-frame')

		args = parser.parse_args(argv)

		device_stream_call(ctx, DMXBricklet, 4, 'out', (), (), ('stream_data', None), (), ('stream_length', 'stream_chunk_offset', 'stream_chunk_data', None), '', 'H H 56B I', args.execute, False, ['frame', 'frame-number'], [None, None], None, 56, None, False, False, None)

	def set_frame_duration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-frame-duration')

		parser.add_argument('frame_duration', type=convert_int, help='int', metavar='<frame-duration>')

		args = parser.parse_args(argv)

		device_call(ctx, DMXBricklet, 5, (args.frame_duration,), 'H', '', None, args.expect_response, [], [])

	def get_frame_duration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-frame-duration')

		args = parser.parse_args(argv)

		device_call(ctx, DMXBricklet, 6, (), '', 'H', args.execute, False, ['frame-duration'], [None])

	def get_frame_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-frame-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, DMXBricklet, 7, (), '', 'I I', args.execute, False, ['overrun-error-count', 'framing-error-count'], [None, None])

	def set_communication_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-communication-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'communication-led-config-show-communication': 3, 'communication-led-config-show-heartbeat': 2, 'communication-led-config-on': 1, 'communication-led-config-off': 0}), help='int (communication-led-config-off: 0, communication-led-config-on: 1, communication-led-config-show-heartbeat: 2, communication-led-config-show-communication: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, DMXBricklet, 8, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_communication_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-communication-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, DMXBricklet, 9, (), '', 'B', args.execute, False, ['config'], [{0: 'communication-led-config-off', 1: 'communication-led-config-on', 2: 'communication-led-config-show-heartbeat', 3: 'communication-led-config-show-communication'}])

	def set_error_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-error-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'error-led-config-off': 0, 'error-led-config-on': 1, 'error-led-config-show-error': 3, 'error-led-config-show-heartbeat': 2}), help='int (error-led-config-off: 0, error-led-config-on: 1, error-led-config-show-heartbeat: 2, error-led-config-show-error: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, DMXBricklet, 10, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_error_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-error-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, DMXBricklet, 11, (), '', 'B', args.execute, False, ['config'], [{0: 'error-led-config-off', 1: 'error-led-config-on', 2: 'error-led-config-show-heartbeat', 3: 'error-led-config-show-error'}])

	def set_frame_callback_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-frame-callback-config')

		parser.add_argument('frame_started_callback_enabled', type=convert_bool, help='bool', metavar='<frame-started-callback-enabled>')
		parser.add_argument('frame_available_callback_enabled', type=convert_bool, help='bool', metavar='<frame-available-callback-enabled>')
		parser.add_argument('frame_callback_enabled', type=convert_bool, help='bool', metavar='<frame-callback-enabled>')
		parser.add_argument('frame_error_count_callback_enabled', type=convert_bool, help='bool', metavar='<frame-error-count-callback-enabled>')

		args = parser.parse_args(argv)

		device_call(ctx, DMXBricklet, 12, (args.frame_started_callback_enabled, args.frame_available_callback_enabled, args.frame_callback_enabled, args.frame_error_count_callback_enabled), '! ! ! !', '', None, args.expect_response, [], [])

	def get_frame_callback_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-frame-callback-config')

		args = parser.parse_args(argv)

		device_call(ctx, DMXBricklet, 13, (), '', '! ! ! !', args.execute, False, ['frame-started-callback-enabled', 'frame-available-callback-enabled', 'frame-callback-enabled', 'frame-error-count-callback-enabled'], [None, None, None, None])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, DMXBricklet, 234, (), '', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def set_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-bootloader-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'bootloader-mode-firmware-wait-for-reboot': 3, 'bootloader-mode-firmware': 1, 'bootloader-mode-firmware-wait-for-erase-and-reboot': 4, 'bootloader-mode-bootloader-wait-for-reboot': 2, 'bootloader-mode-bootloader': 0}), help='int (bootloader-mode-bootloader: 0, bootloader-mode-firmware: 1, bootloader-mode-bootloader-wait-for-reboot: 2, bootloader-mode-firmware-wait-for-reboot: 3, bootloader-mode-firmware-wait-for-erase-and-reboot: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, DMXBricklet, 235, (args.mode,), 'B', 'B', args.execute, False, ['status'], [{0: 'bootloader-status-ok', 1: 'bootloader-status-invalid-mode', 2: 'bootloader-status-no-change', 3: 'bootloader-status-entry-function-not-present', 4: 'bootloader-status-device-identifier-incorrect', 5: 'bootloader-status-crc-mismatch'}])

	def get_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-bootloader-mode')

		args = parser.parse_args(argv)

		device_call(ctx, DMXBricklet, 236, (), '', 'B', args.execute, False, ['mode'], [{0: 'bootloader-mode-bootloader', 1: 'bootloader-mode-firmware', 2: 'bootloader-mode-bootloader-wait-for-reboot', 3: 'bootloader-mode-firmware-wait-for-reboot', 4: 'bootloader-mode-firmware-wait-for-erase-and-reboot'}])

	def set_write_firmware_pointer(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-write-firmware-pointer')

		parser.add_argument('pointer', type=convert_int, help='int', metavar='<pointer>')

		args = parser.parse_args(argv)

		device_call(ctx, DMXBricklet, 237, (args.pointer,), 'I', '', None, args.expect_response, [], [])

	def write_firmware(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-firmware')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, DMXBricklet, 238, (args.data,), '64B', 'B', args.execute, False, ['status'], [None])

	def set_status_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'status-led-config-on': 1, 'status-led-config-show-heartbeat': 2, 'status-led-config-off': 0, 'status-led-config-show-status': 3}), help='int (status-led-config-off: 0, status-led-config-on: 1, status-led-config-show-heartbeat: 2, status-led-config-show-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, DMXBricklet, 239, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_status_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, DMXBricklet, 240, (), '', 'B', args.execute, False, ['config'], [{0: 'status-led-config-off', 1: 'status-led-config-on', 2: 'status-led-config-show-heartbeat', 3: 'status-led-config-show-status'}])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, DMXBricklet, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, DMXBricklet, 243, (), '', '', None, args.expect_response, [], [])

	def write_uid(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-uid')

		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')

		args = parser.parse_args(argv)

		device_call(ctx, DMXBricklet, 248, (args.uid,), 'I', '', None, args.expect_response, [], [])

	def read_uid(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-uid')

		args = parser.parse_args(argv)

		device_call(ctx, DMXBricklet, 249, (), '', 'I', args.execute, False, ['uid'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, DMXBricklet, argv)

	functions = {
	'set-dmx-mode': set_dmx_mode,
	'get-dmx-mode': get_dmx_mode,
	'write-frame-low-level': write_frame_low_level,
	'write-frame': write_frame,
	'read-frame-low-level': read_frame_low_level,
	'read-frame': read_frame,
	'set-frame-duration': set_frame_duration,
	'get-frame-duration': get_frame_duration,
	'get-frame-error-count': get_frame_error_count,
	'set-communication-led-config': set_communication_led_config,
	'get-communication-led-config': get_communication_led_config,
	'set-error-led-config': set_error_led_config,
	'get-error-led-config': get_error_led_config,
	'set-frame-callback-config': set_frame_callback_config,
	'get-frame-callback-config': get_frame_callback_config,
	'get-spitfp-error-count': get_spitfp_error_count,
	'set-bootloader-mode': set_bootloader_mode,
	'get-bootloader-mode': get_bootloader_mode,
	'set-write-firmware-pointer': set_write_firmware_pointer,
	'write-firmware': write_firmware,
	'set-status-led-config': set_status_led_config,
	'get-status-led-config': get_status_led_config,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'write-uid': write_uid,
	'read-uid': read_uid,
	'get-identity': get_identity
	}

	call_generic(ctx, 'dmx-bricklet', functions, argv)

def dispatch_dmx_bricklet(ctx, argv):
	prog_prefix = 'dispatch dmx-bricklet <uid>'

	def frame_started(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' frame-started')

		args = parser.parse_args(argv)

		device_dispatch(ctx, DMXBricklet, 14, args.execute, [], [])

	def frame_available(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' frame-available')

		args = parser.parse_args(argv)

		device_dispatch(ctx, DMXBricklet, 15, args.execute, ['frame-number'], [None])

	def frame_low_level(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' frame-low-level')

		args = parser.parse_args(argv)

		device_dispatch(ctx, DMXBricklet, 16, args.execute, ['frame-length', 'frame-chunk-offset', 'frame-chunk-data', 'frame-number'], [None, None, None, None])

	def frame(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' frame')

		args = parser.parse_args(argv)

		device_dispatch(ctx, DMXBricklet, -16, args.execute, ['frame', 'frame-number'], [None, None])

	def frame_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' frame-error-count')

		args = parser.parse_args(argv)

		device_dispatch(ctx, DMXBricklet, 17, args.execute, ['overrun-error-count', 'framing-error-count'], [None, None])

	callbacks = {
	'frame-started': frame_started,
	'frame-available': frame_available,
	'frame-low-level': frame_low_level,
	'frame': frame,
	'frame-error-count': frame_error_count
	}

	dispatch_generic(ctx, 'dmx-bricklet', callbacks, argv)

class DualButtonBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 3; re[2] = 1; re[3] = 1; re[5] = 3; re[255] = 1
		cf = self.callback_formats
		cf[4] = 'B B B B'


def call_dual_button_bricklet(ctx, argv):
	prog_prefix = 'call dual-button-bricklet <uid>'

	def set_led_state(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-led-state')

		parser.add_argument('led_l', type=create_symbol_converter(ctx, convert_int, {'led-state-off': 3, 'led-state-auto-toggle-off': 1, 'led-state-auto-toggle-on': 0, 'led-state-on': 2}), help='int (led-state-auto-toggle-on: 0, led-state-auto-toggle-off: 1, led-state-on: 2, led-state-off: 3)', metavar='<led-l>')
		parser.add_argument('led_r', type=create_symbol_converter(ctx, convert_int, {'led-state-off': 3, 'led-state-auto-toggle-off': 1, 'led-state-auto-toggle-on': 0, 'led-state-on': 2}), help='int (led-state-auto-toggle-on: 0, led-state-auto-toggle-off: 1, led-state-on: 2, led-state-off: 3)', metavar='<led-r>')

		args = parser.parse_args(argv)

		device_call(ctx, DualButtonBricklet, 1, (args.led_l, args.led_r), 'B B', '', None, args.expect_response, [], [])

	def get_led_state(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-led-state')

		args = parser.parse_args(argv)

		device_call(ctx, DualButtonBricklet, 2, (), '', 'B B', args.execute, False, ['led-l', 'led-r'], [{0: 'led-state-auto-toggle-on', 1: 'led-state-auto-toggle-off', 2: 'led-state-on', 3: 'led-state-off'}, {0: 'led-state-auto-toggle-on', 1: 'led-state-auto-toggle-off', 2: 'led-state-on', 3: 'led-state-off'}])

	def get_button_state(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-button-state')

		args = parser.parse_args(argv)

		device_call(ctx, DualButtonBricklet, 3, (), '', 'B B', args.execute, False, ['button-l', 'button-r'], [{0: 'button-state-pressed', 1: 'button-state-released'}, {0: 'button-state-pressed', 1: 'button-state-released'}])

	def set_selected_led_state(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-selected-led-state')

		parser.add_argument('led', type=create_symbol_converter(ctx, convert_int, {'led-left': 0, 'led-right': 1}), help='int (led-left: 0, led-right: 1)', metavar='<led>')
		parser.add_argument('state', type=create_symbol_converter(ctx, convert_int, {'led-state-off': 3, 'led-state-auto-toggle-off': 1, 'led-state-auto-toggle-on': 0, 'led-state-on': 2}), help='int (led-state-auto-toggle-on: 0, led-state-auto-toggle-off: 1, led-state-on: 2, led-state-off: 3)', metavar='<state>')

		args = parser.parse_args(argv)

		device_call(ctx, DualButtonBricklet, 5, (args.led, args.state), 'B B', '', None, args.expect_response, [], [])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, DualButtonBricklet, argv)

	functions = {
	'set-led-state': set_led_state,
	'get-led-state': get_led_state,
	'get-button-state': get_button_state,
	'set-selected-led-state': set_selected_led_state,
	'get-identity': get_identity
	}

	call_generic(ctx, 'dual-button-bricklet', functions, argv)

def dispatch_dual_button_bricklet(ctx, argv):
	prog_prefix = 'dispatch dual-button-bricklet <uid>'

	def state_changed(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' state-changed')

		args = parser.parse_args(argv)

		device_dispatch(ctx, DualButtonBricklet, 4, args.execute, ['button-l', 'button-r', 'led-l', 'led-r'], [{0: 'button-state-pressed', 1: 'button-state-released'}, {0: 'button-state-pressed', 1: 'button-state-released'}, {0: 'led-state-auto-toggle-on', 1: 'led-state-auto-toggle-off', 2: 'led-state-on', 3: 'led-state-off'}, {0: 'led-state-auto-toggle-on', 1: 'led-state-auto-toggle-off', 2: 'led-state-on', 3: 'led-state-off'}])

	callbacks = {
	'state-changed': state_changed
	}

	dispatch_generic(ctx, 'dual-button-bricklet', callbacks, argv)

class DualButtonV2Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 3; re[2] = 1; re[3] = 1; re[5] = 3; re[6] = 2; re[7] = 1; re[234] = 1; re[235] = 1; re[236] = 1; re[237] = 3; re[238] = 1; re[239] = 3; re[240] = 1; re[242] = 1; re[243] = 3; re[248] = 3; re[249] = 1; re[255] = 1
		cf = self.callback_formats
		cf[4] = 'B B B B'


def call_dual_button_v2_bricklet(ctx, argv):
	prog_prefix = 'call dual-button-v2-bricklet <uid>'

	def set_led_state(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-led-state')

		parser.add_argument('led_l', type=create_symbol_converter(ctx, convert_int, {'led-state-off': 3, 'led-state-auto-toggle-off': 1, 'led-state-auto-toggle-on': 0, 'led-state-on': 2}), help='int (led-state-auto-toggle-on: 0, led-state-auto-toggle-off: 1, led-state-on: 2, led-state-off: 3)', metavar='<led-l>')
		parser.add_argument('led_r', type=create_symbol_converter(ctx, convert_int, {'led-state-off': 3, 'led-state-auto-toggle-off': 1, 'led-state-auto-toggle-on': 0, 'led-state-on': 2}), help='int (led-state-auto-toggle-on: 0, led-state-auto-toggle-off: 1, led-state-on: 2, led-state-off: 3)', metavar='<led-r>')

		args = parser.parse_args(argv)

		device_call(ctx, DualButtonV2Bricklet, 1, (args.led_l, args.led_r), 'B B', '', None, args.expect_response, [], [])

	def get_led_state(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-led-state')

		args = parser.parse_args(argv)

		device_call(ctx, DualButtonV2Bricklet, 2, (), '', 'B B', args.execute, False, ['led-l', 'led-r'], [{0: 'led-state-auto-toggle-on', 1: 'led-state-auto-toggle-off', 2: 'led-state-on', 3: 'led-state-off'}, {0: 'led-state-auto-toggle-on', 1: 'led-state-auto-toggle-off', 2: 'led-state-on', 3: 'led-state-off'}])

	def get_button_state(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-button-state')

		args = parser.parse_args(argv)

		device_call(ctx, DualButtonV2Bricklet, 3, (), '', 'B B', args.execute, False, ['button-l', 'button-r'], [{0: 'button-state-pressed', 1: 'button-state-released'}, {0: 'button-state-pressed', 1: 'button-state-released'}])

	def set_selected_led_state(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-selected-led-state')

		parser.add_argument('led', type=create_symbol_converter(ctx, convert_int, {'led-left': 0, 'led-right': 1}), help='int (led-left: 0, led-right: 1)', metavar='<led>')
		parser.add_argument('state', type=create_symbol_converter(ctx, convert_int, {'led-state-off': 3, 'led-state-auto-toggle-off': 1, 'led-state-auto-toggle-on': 0, 'led-state-on': 2}), help='int (led-state-auto-toggle-on: 0, led-state-auto-toggle-off: 1, led-state-on: 2, led-state-off: 3)', metavar='<state>')

		args = parser.parse_args(argv)

		device_call(ctx, DualButtonV2Bricklet, 5, (args.led, args.state), 'B B', '', None, args.expect_response, [], [])

	def set_state_changed_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-state-changed-callback-configuration')

		parser.add_argument('enabled', type=convert_bool, help='bool', metavar='<enabled>')

		args = parser.parse_args(argv)

		device_call(ctx, DualButtonV2Bricklet, 6, (args.enabled,), '!', '', None, args.expect_response, [], [])

	def get_state_changed_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-state-changed-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, DualButtonV2Bricklet, 7, (), '', '!', args.execute, False, ['enabled'], [None])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, DualButtonV2Bricklet, 234, (), '', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def set_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-bootloader-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'bootloader-mode-firmware-wait-for-reboot': 3, 'bootloader-mode-firmware': 1, 'bootloader-mode-firmware-wait-for-erase-and-reboot': 4, 'bootloader-mode-bootloader-wait-for-reboot': 2, 'bootloader-mode-bootloader': 0}), help='int (bootloader-mode-bootloader: 0, bootloader-mode-firmware: 1, bootloader-mode-bootloader-wait-for-reboot: 2, bootloader-mode-firmware-wait-for-reboot: 3, bootloader-mode-firmware-wait-for-erase-and-reboot: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, DualButtonV2Bricklet, 235, (args.mode,), 'B', 'B', args.execute, False, ['status'], [{0: 'bootloader-status-ok', 1: 'bootloader-status-invalid-mode', 2: 'bootloader-status-no-change', 3: 'bootloader-status-entry-function-not-present', 4: 'bootloader-status-device-identifier-incorrect', 5: 'bootloader-status-crc-mismatch'}])

	def get_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-bootloader-mode')

		args = parser.parse_args(argv)

		device_call(ctx, DualButtonV2Bricklet, 236, (), '', 'B', args.execute, False, ['mode'], [{0: 'bootloader-mode-bootloader', 1: 'bootloader-mode-firmware', 2: 'bootloader-mode-bootloader-wait-for-reboot', 3: 'bootloader-mode-firmware-wait-for-reboot', 4: 'bootloader-mode-firmware-wait-for-erase-and-reboot'}])

	def set_write_firmware_pointer(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-write-firmware-pointer')

		parser.add_argument('pointer', type=convert_int, help='int', metavar='<pointer>')

		args = parser.parse_args(argv)

		device_call(ctx, DualButtonV2Bricklet, 237, (args.pointer,), 'I', '', None, args.expect_response, [], [])

	def write_firmware(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-firmware')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, DualButtonV2Bricklet, 238, (args.data,), '64B', 'B', args.execute, False, ['status'], [None])

	def set_status_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'status-led-config-on': 1, 'status-led-config-show-heartbeat': 2, 'status-led-config-off': 0, 'status-led-config-show-status': 3}), help='int (status-led-config-off: 0, status-led-config-on: 1, status-led-config-show-heartbeat: 2, status-led-config-show-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, DualButtonV2Bricklet, 239, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_status_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, DualButtonV2Bricklet, 240, (), '', 'B', args.execute, False, ['config'], [{0: 'status-led-config-off', 1: 'status-led-config-on', 2: 'status-led-config-show-heartbeat', 3: 'status-led-config-show-status'}])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, DualButtonV2Bricklet, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, DualButtonV2Bricklet, 243, (), '', '', None, args.expect_response, [], [])

	def write_uid(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-uid')

		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')

		args = parser.parse_args(argv)

		device_call(ctx, DualButtonV2Bricklet, 248, (args.uid,), 'I', '', None, args.expect_response, [], [])

	def read_uid(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-uid')

		args = parser.parse_args(argv)

		device_call(ctx, DualButtonV2Bricklet, 249, (), '', 'I', args.execute, False, ['uid'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, DualButtonV2Bricklet, argv)

	functions = {
	'set-led-state': set_led_state,
	'get-led-state': get_led_state,
	'get-button-state': get_button_state,
	'set-selected-led-state': set_selected_led_state,
	'set-state-changed-callback-configuration': set_state_changed_callback_configuration,
	'get-state-changed-callback-configuration': get_state_changed_callback_configuration,
	'get-spitfp-error-count': get_spitfp_error_count,
	'set-bootloader-mode': set_bootloader_mode,
	'get-bootloader-mode': get_bootloader_mode,
	'set-write-firmware-pointer': set_write_firmware_pointer,
	'write-firmware': write_firmware,
	'set-status-led-config': set_status_led_config,
	'get-status-led-config': get_status_led_config,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'write-uid': write_uid,
	'read-uid': read_uid,
	'get-identity': get_identity
	}

	call_generic(ctx, 'dual-button-v2-bricklet', functions, argv)

def dispatch_dual_button_v2_bricklet(ctx, argv):
	prog_prefix = 'dispatch dual-button-v2-bricklet <uid>'

	def state_changed(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' state-changed')

		args = parser.parse_args(argv)

		device_dispatch(ctx, DualButtonV2Bricklet, 4, args.execute, ['button-l', 'button-r', 'led-l', 'led-r'], [{0: 'button-state-pressed', 1: 'button-state-released'}, {0: 'button-state-pressed', 1: 'button-state-released'}, {0: 'led-state-auto-toggle-on', 1: 'led-state-auto-toggle-off', 2: 'led-state-on', 3: 'led-state-off'}, {0: 'led-state-auto-toggle-on', 1: 'led-state-auto-toggle-off', 2: 'led-state-on', 3: 'led-state-off'}])

	callbacks = {
	'state-changed': state_changed
	}

	dispatch_generic(ctx, 'dual-button-v2-bricklet', callbacks, argv)

class DualRelayBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 3; re[2] = 1; re[3] = 3; re[4] = 1; re[6] = 3; re[255] = 1
		cf = self.callback_formats
		cf[5] = 'B !'


def call_dual_relay_bricklet(ctx, argv):
	prog_prefix = 'call dual-relay-bricklet <uid>'

	def set_state(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-state')

		parser.add_argument('relay1', type=convert_bool, help='bool', metavar='<relay1>')
		parser.add_argument('relay2', type=convert_bool, help='bool', metavar='<relay2>')

		args = parser.parse_args(argv)

		device_call(ctx, DualRelayBricklet, 1, (args.relay1, args.relay2), '! !', '', None, args.expect_response, [], [])

	def get_state(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-state')

		args = parser.parse_args(argv)

		device_call(ctx, DualRelayBricklet, 2, (), '', '! !', args.execute, False, ['relay1', 'relay2'], [None, None])

	def set_monoflop(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-monoflop')

		parser.add_argument('relay', type=convert_int, help='int', metavar='<relay>')
		parser.add_argument('state', type=convert_bool, help='bool', metavar='<state>')
		parser.add_argument('time', type=convert_int, help='int', metavar='<time>')

		args = parser.parse_args(argv)

		device_call(ctx, DualRelayBricklet, 3, (args.relay, args.state, args.time), 'B ! I', '', None, args.expect_response, [], [])

	def get_monoflop(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-monoflop')

		parser.add_argument('relay', type=convert_int, help='int', metavar='<relay>')

		args = parser.parse_args(argv)

		device_call(ctx, DualRelayBricklet, 4, (args.relay,), 'B', '! I I', args.execute, False, ['state', 'time', 'time-remaining'], [None, None, None])

	def set_selected_state(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-selected-state')

		parser.add_argument('relay', type=convert_int, help='int', metavar='<relay>')
		parser.add_argument('state', type=convert_bool, help='bool', metavar='<state>')

		args = parser.parse_args(argv)

		device_call(ctx, DualRelayBricklet, 6, (args.relay, args.state), 'B !', '', None, args.expect_response, [], [])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, DualRelayBricklet, argv)

	functions = {
	'set-state': set_state,
	'get-state': get_state,
	'set-monoflop': set_monoflop,
	'get-monoflop': get_monoflop,
	'set-selected-state': set_selected_state,
	'get-identity': get_identity
	}

	call_generic(ctx, 'dual-relay-bricklet', functions, argv)

def dispatch_dual_relay_bricklet(ctx, argv):
	prog_prefix = 'dispatch dual-relay-bricklet <uid>'

	def monoflop_done(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' monoflop-done')

		args = parser.parse_args(argv)

		device_dispatch(ctx, DualRelayBricklet, 5, args.execute, ['relay', 'state'], [None, None])

	callbacks = {
	'monoflop-done': monoflop_done
	}

	dispatch_generic(ctx, 'dual-relay-bricklet', callbacks, argv)

class DustDetectorBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 2; re[3] = 1; re[4] = 2; re[5] = 1; re[6] = 2; re[7] = 1; re[10] = 3; re[11] = 1; re[255] = 1
		cf = self.callback_formats
		cf[8] = 'H'; cf[9] = 'H'


def call_dust_detector_bricklet(ctx, argv):
	prog_prefix = 'call dust-detector-bricklet <uid>'

	def get_dust_density(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-dust-density')

		args = parser.parse_args(argv)

		device_call(ctx, DustDetectorBricklet, 1, (), '', 'H', args.execute, False, ['dust-density'], [None])

	def set_dust_density_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-dust-density-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, DustDetectorBricklet, 2, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_dust_density_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-dust-density-callback-period')

		args = parser.parse_args(argv)

		device_call(ctx, DustDetectorBricklet, 3, (), '', 'I', args.execute, False, ['period'], [None])

	def set_dust_density_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-dust-density-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, DustDetectorBricklet, 4, (args.option, args.min, args.max), 'c H H', '', None, args.expect_response, [], [])

	def get_dust_density_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-dust-density-callback-threshold')

		args = parser.parse_args(argv)

		device_call(ctx, DustDetectorBricklet, 5, (), '', 'c H H', args.execute, False, ['option', 'min', 'max'], [{'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def set_debounce_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-debounce-period')

		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_call(ctx, DustDetectorBricklet, 6, (args.debounce,), 'I', '', None, args.expect_response, [], [])

	def get_debounce_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-debounce-period')

		args = parser.parse_args(argv)

		device_call(ctx, DustDetectorBricklet, 7, (), '', 'I', args.execute, False, ['debounce'], [None])

	def set_moving_average(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-moving-average')

		parser.add_argument('average', type=convert_int, help='int', metavar='<average>')

		args = parser.parse_args(argv)

		device_call(ctx, DustDetectorBricklet, 10, (args.average,), 'B', '', None, args.expect_response, [], [])

	def get_moving_average(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-moving-average')

		args = parser.parse_args(argv)

		device_call(ctx, DustDetectorBricklet, 11, (), '', 'B', args.execute, False, ['average'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, DustDetectorBricklet, argv)

	functions = {
	'get-dust-density': get_dust_density,
	'set-dust-density-callback-period': set_dust_density_callback_period,
	'get-dust-density-callback-period': get_dust_density_callback_period,
	'set-dust-density-callback-threshold': set_dust_density_callback_threshold,
	'get-dust-density-callback-threshold': get_dust_density_callback_threshold,
	'set-debounce-period': set_debounce_period,
	'get-debounce-period': get_debounce_period,
	'set-moving-average': set_moving_average,
	'get-moving-average': get_moving_average,
	'get-identity': get_identity
	}

	call_generic(ctx, 'dust-detector-bricklet', functions, argv)

def dispatch_dust_detector_bricklet(ctx, argv):
	prog_prefix = 'dispatch dust-detector-bricklet <uid>'

	def dust_density(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' dust-density')

		args = parser.parse_args(argv)

		device_dispatch(ctx, DustDetectorBricklet, 8, args.execute, ['dust-density'], [None])

	def dust_density_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' dust-density-reached')

		args = parser.parse_args(argv)

		device_dispatch(ctx, DustDetectorBricklet, 9, args.execute, ['dust-density'], [None])

	callbacks = {
	'dust-density': dust_density,
	'dust-density-reached': dust_density_reached
	}

	dispatch_generic(ctx, 'dust-detector-bricklet', callbacks, argv)

class EPaper296x128Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 3; re[2] = 1; re[3] = 2; re[4] = 1; re[5] = 2; re[6] = 1; re[7] = 3; re[8] = 3; re[9] = 3; re[10] = 3; re[12] = 3; re[13] = 1; re[14] = 3; re[15] = 1; re[234] = 1; re[235] = 1; re[236] = 1; re[237] = 3; re[238] = 1; re[239] = 3; re[240] = 1; re[242] = 1; re[243] = 3; re[248] = 3; re[249] = 1; re[255] = 1
		cf = self.callback_formats
		cf[11] = 'B'


def call_e_paper_296x128_bricklet(ctx, argv):
	prog_prefix = 'call e-paper-296x128-bricklet <uid>'

	def draw(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' draw')

		args = parser.parse_args(argv)

		device_call(ctx, EPaper296x128Bricklet, 1, (), '', '', None, args.expect_response, [], [])

	def get_draw_status(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-draw-status')

		args = parser.parse_args(argv)

		device_call(ctx, EPaper296x128Bricklet, 2, (), '', 'B', args.execute, False, ['draw-status'], [{0: 'draw-status-idle', 1: 'draw-status-copying', 2: 'draw-status-drawing'}])

	def write_black_white_low_level(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-black-white-low-level')

		parser.add_argument('x_start', type=convert_int, help='int', metavar='<x-start>')
		parser.add_argument('y_start', type=convert_int, help='int', metavar='<y-start>')
		parser.add_argument('x_end', type=convert_int, help='int', metavar='<x-end>')
		parser.add_argument('y_end', type=convert_int, help='int', metavar='<y-end>')
		parser.add_argument('pixels_length', type=convert_int, help='int', metavar='<pixels-length>')
		parser.add_argument('pixels_chunk_offset', type=convert_int, help='int', metavar='<pixels-chunk-offset>')
		parser.add_argument('pixels_chunk_data', type=create_array_converter(ctx, convert_bool, 'false', 432), help=get_array_type_name(ctx, 'bool', 432), metavar='<pixels-chunk-data>')

		args = parser.parse_args(argv)

		device_call(ctx, EPaper296x128Bricklet, 3, (args.x_start, args.y_start, args.x_end, args.y_end, args.pixels_length, args.pixels_chunk_offset, args.pixels_chunk_data), 'H B H B H H 432!', '', None, args.expect_response, [], [])

	def write_black_white(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-black-white')

		parser.add_argument('x_start', type=convert_int, help='int', metavar='<x-start>')
		parser.add_argument('y_start', type=convert_int, help='int', metavar='<y-start>')
		parser.add_argument('x_end', type=convert_int, help='int', metavar='<x-end>')
		parser.add_argument('y_end', type=convert_int, help='int', metavar='<y-end>')
		parser.add_argument('pixels', type=create_array_converter(ctx, convert_bool, None, -65535), help=get_array_type_name(ctx, 'bool', -65535), metavar='<pixels>')

		args = parser.parse_args(argv)

		device_stream_call(ctx, EPaper296x128Bricklet, 3, 'in', (args.x_start, args.y_start, args.x_end, args.y_end, args.pixels), (None, None, None, None, 'stream_data'), (), (None, None, None, None, 'stream_length', 'stream_chunk_offset', 'stream_chunk_data'), (), 'H B H B H H 432!', '', None, args.expect_response, [], [], 'false', 432, None, False, False, None)

	def read_black_white_low_level(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-black-white-low-level')

		parser.add_argument('x_start', type=convert_int, help='int', metavar='<x-start>')
		parser.add_argument('y_start', type=convert_int, help='int', metavar='<y-start>')
		parser.add_argument('x_end', type=convert_int, help='int', metavar='<x-end>')
		parser.add_argument('y_end', type=convert_int, help='int', metavar='<y-end>')

		args = parser.parse_args(argv)

		device_call(ctx, EPaper296x128Bricklet, 4, (args.x_start, args.y_start, args.x_end, args.y_end), 'H B H B', 'H H 464!', args.execute, False, ['pixels-length', 'pixels-chunk-offset', 'pixels-chunk-data'], [None, None, None])

	def read_black_white(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-black-white')

		parser.add_argument('x_start', type=convert_int, help='int', metavar='<x-start>')
		parser.add_argument('y_start', type=convert_int, help='int', metavar='<y-start>')
		parser.add_argument('x_end', type=convert_int, help='int', metavar='<x-end>')
		parser.add_argument('y_end', type=convert_int, help='int', metavar='<y-end>')

		args = parser.parse_args(argv)

		device_stream_call(ctx, EPaper296x128Bricklet, 4, 'out', (args.x_start, args.y_start, args.x_end, args.y_end), (None, None, None, None), ('stream_data',), (None, None, None, None), ('stream_length', 'stream_chunk_offset', 'stream_chunk_data'), 'H B H B', 'H H 464!', args.execute, False, ['pixels'], [None], None, 464, None, False, False, None)

	def write_color_low_level(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-color-low-level')

		parser.add_argument('x_start', type=convert_int, help='int', metavar='<x-start>')
		parser.add_argument('y_start', type=convert_int, help='int', metavar='<y-start>')
		parser.add_argument('x_end', type=convert_int, help='int', metavar='<x-end>')
		parser.add_argument('y_end', type=convert_int, help='int', metavar='<y-end>')
		parser.add_argument('pixels_length', type=convert_int, help='int', metavar='<pixels-length>')
		parser.add_argument('pixels_chunk_offset', type=convert_int, help='int', metavar='<pixels-chunk-offset>')
		parser.add_argument('pixels_chunk_data', type=create_array_converter(ctx, convert_bool, 'false', 432), help=get_array_type_name(ctx, 'bool', 432), metavar='<pixels-chunk-data>')

		args = parser.parse_args(argv)

		device_call(ctx, EPaper296x128Bricklet, 5, (args.x_start, args.y_start, args.x_end, args.y_end, args.pixels_length, args.pixels_chunk_offset, args.pixels_chunk_data), 'H B H B H H 432!', '', None, args.expect_response, [], [])

	def write_color(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-color')

		parser.add_argument('x_start', type=convert_int, help='int', metavar='<x-start>')
		parser.add_argument('y_start', type=convert_int, help='int', metavar='<y-start>')
		parser.add_argument('x_end', type=convert_int, help='int', metavar='<x-end>')
		parser.add_argument('y_end', type=convert_int, help='int', metavar='<y-end>')
		parser.add_argument('pixels', type=create_array_converter(ctx, convert_bool, None, -65535), help=get_array_type_name(ctx, 'bool', -65535), metavar='<pixels>')

		args = parser.parse_args(argv)

		device_stream_call(ctx, EPaper296x128Bricklet, 5, 'in', (args.x_start, args.y_start, args.x_end, args.y_end, args.pixels), (None, None, None, None, 'stream_data'), (), (None, None, None, None, 'stream_length', 'stream_chunk_offset', 'stream_chunk_data'), (), 'H B H B H H 432!', '', None, args.expect_response, [], [], 'false', 432, None, False, False, None)

	def read_color_low_level(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-color-low-level')

		parser.add_argument('x_start', type=convert_int, help='int', metavar='<x-start>')
		parser.add_argument('y_start', type=convert_int, help='int', metavar='<y-start>')
		parser.add_argument('x_end', type=convert_int, help='int', metavar='<x-end>')
		parser.add_argument('y_end', type=convert_int, help='int', metavar='<y-end>')

		args = parser.parse_args(argv)

		device_call(ctx, EPaper296x128Bricklet, 6, (args.x_start, args.y_start, args.x_end, args.y_end), 'H B H B', 'H H 464!', args.execute, False, ['pixels-length', 'pixels-chunk-offset', 'pixels-chunk-data'], [None, None, None])

	def read_color(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-color')

		parser.add_argument('x_start', type=convert_int, help='int', metavar='<x-start>')
		parser.add_argument('y_start', type=convert_int, help='int', metavar='<y-start>')
		parser.add_argument('x_end', type=convert_int, help='int', metavar='<x-end>')
		parser.add_argument('y_end', type=convert_int, help='int', metavar='<y-end>')

		args = parser.parse_args(argv)

		device_stream_call(ctx, EPaper296x128Bricklet, 6, 'out', (args.x_start, args.y_start, args.x_end, args.y_end), (None, None, None, None), ('stream_data',), (None, None, None, None), ('stream_length', 'stream_chunk_offset', 'stream_chunk_data'), 'H B H B', 'H H 464!', args.execute, False, ['pixels'], [None], None, 464, None, False, False, None)

	def fill_display(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' fill-display')

		parser.add_argument('color', type=create_symbol_converter(ctx, convert_int, {'color-black': 0, 'color-white': 1, 'color-gray': 2, 'color-red': 2}), help='int (color-black: 0, color-white: 1, color-red: 2, color-gray: 2)', metavar='<color>')

		args = parser.parse_args(argv)

		device_call(ctx, EPaper296x128Bricklet, 7, (args.color,), 'B', '', None, args.expect_response, [], [])

	def draw_text(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' draw-text')

		parser.add_argument('position_x', type=convert_int, help='int', metavar='<position-x>')
		parser.add_argument('position_y', type=convert_int, help='int', metavar='<position-y>')
		parser.add_argument('font', type=create_symbol_converter(ctx, convert_int, {'font-18x32': 8, 'font-18x24': 7, 'font-12x24': 5, 'font-12x16': 4, 'font-6x8': 0, 'font-6x16': 1, 'font-24x32': 9, 'font-12x32': 6, 'font-6x24': 2, 'font-6x32': 3}), help='int (font-6x8: 0, font-6x16: 1, font-6x24: 2, font-6x32: 3, font-12x16: 4, font-12x24: 5, font-12x32: 6, font-18x24: 7, font-18x32: 8, font-24x32: 9)', metavar='<font>')
		parser.add_argument('color', type=create_symbol_converter(ctx, convert_int, {'color-black': 0, 'color-white': 1, 'color-gray': 2, 'color-red': 2}), help='int (color-black: 0, color-white: 1, color-red: 2, color-gray: 2)', metavar='<color>')
		parser.add_argument('orientation', type=create_symbol_converter(ctx, convert_int, {'orientation-horizontal': 0, 'orientation-vertical': 1}), help='int (orientation-horizontal: 0, orientation-vertical: 1)', metavar='<orientation>')
		parser.add_argument('text', type=create_string_converter(ctx, str, 50), help='string', metavar='<text>')

		args = parser.parse_args(argv)

		device_call(ctx, EPaper296x128Bricklet, 8, (args.position_x, args.position_y, args.font, args.color, args.orientation, args.text), 'H B B B B 50s', '', None, args.expect_response, [], [])

	def draw_line(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' draw-line')

		parser.add_argument('position_x_start', type=convert_int, help='int', metavar='<position-x-start>')
		parser.add_argument('position_y_start', type=convert_int, help='int', metavar='<position-y-start>')
		parser.add_argument('position_x_end', type=convert_int, help='int', metavar='<position-x-end>')
		parser.add_argument('position_y_end', type=convert_int, help='int', metavar='<position-y-end>')
		parser.add_argument('color', type=create_symbol_converter(ctx, convert_int, {'color-black': 0, 'color-white': 1, 'color-gray': 2, 'color-red': 2}), help='int (color-black: 0, color-white: 1, color-red: 2, color-gray: 2)', metavar='<color>')

		args = parser.parse_args(argv)

		device_call(ctx, EPaper296x128Bricklet, 9, (args.position_x_start, args.position_y_start, args.position_x_end, args.position_y_end, args.color), 'H B H B B', '', None, args.expect_response, [], [])

	def draw_box(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' draw-box')

		parser.add_argument('position_x_start', type=convert_int, help='int', metavar='<position-x-start>')
		parser.add_argument('position_y_start', type=convert_int, help='int', metavar='<position-y-start>')
		parser.add_argument('position_x_end', type=convert_int, help='int', metavar='<position-x-end>')
		parser.add_argument('position_y_end', type=convert_int, help='int', metavar='<position-y-end>')
		parser.add_argument('fill', type=convert_bool, help='bool', metavar='<fill>')
		parser.add_argument('color', type=create_symbol_converter(ctx, convert_int, {'color-black': 0, 'color-white': 1, 'color-gray': 2, 'color-red': 2}), help='int (color-black: 0, color-white: 1, color-red: 2, color-gray: 2)', metavar='<color>')

		args = parser.parse_args(argv)

		device_call(ctx, EPaper296x128Bricklet, 10, (args.position_x_start, args.position_y_start, args.position_x_end, args.position_y_end, args.fill, args.color), 'H B H B ! B', '', None, args.expect_response, [], [])

	def set_update_mode(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-update-mode')

		parser.add_argument('update_mode', type=create_symbol_converter(ctx, convert_int, {'update-mode-delta': 2, 'update-mode-default': 0, 'update-mode-black-white': 1}), help='int (update-mode-default: 0, update-mode-black-white: 1, update-mode-delta: 2)', metavar='<update-mode>')

		args = parser.parse_args(argv)

		device_call(ctx, EPaper296x128Bricklet, 12, (args.update_mode,), 'B', '', None, args.expect_response, [], [])

	def get_update_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-update-mode')

		args = parser.parse_args(argv)

		device_call(ctx, EPaper296x128Bricklet, 13, (), '', 'B', args.execute, False, ['update-mode'], [{0: 'update-mode-default', 1: 'update-mode-black-white', 2: 'update-mode-delta'}])

	def set_display_type(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-display-type')

		parser.add_argument('display_type', type=create_symbol_converter(ctx, convert_int, {'display-type-black-white-gray': 1, 'display-type-black-white-red': 0}), help='int (display-type-black-white-red: 0, display-type-black-white-gray: 1)', metavar='<display-type>')

		args = parser.parse_args(argv)

		device_call(ctx, EPaper296x128Bricklet, 14, (args.display_type,), 'B', '', None, args.expect_response, [], [])

	def get_display_type(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-display-type')

		args = parser.parse_args(argv)

		device_call(ctx, EPaper296x128Bricklet, 15, (), '', 'B', args.execute, False, ['display-type'], [{0: 'display-type-black-white-red', 1: 'display-type-black-white-gray'}])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, EPaper296x128Bricklet, 234, (), '', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def set_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-bootloader-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'bootloader-mode-firmware-wait-for-reboot': 3, 'bootloader-mode-firmware': 1, 'bootloader-mode-firmware-wait-for-erase-and-reboot': 4, 'bootloader-mode-bootloader-wait-for-reboot': 2, 'bootloader-mode-bootloader': 0}), help='int (bootloader-mode-bootloader: 0, bootloader-mode-firmware: 1, bootloader-mode-bootloader-wait-for-reboot: 2, bootloader-mode-firmware-wait-for-reboot: 3, bootloader-mode-firmware-wait-for-erase-and-reboot: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, EPaper296x128Bricklet, 235, (args.mode,), 'B', 'B', args.execute, False, ['status'], [{0: 'bootloader-status-ok', 1: 'bootloader-status-invalid-mode', 2: 'bootloader-status-no-change', 3: 'bootloader-status-entry-function-not-present', 4: 'bootloader-status-device-identifier-incorrect', 5: 'bootloader-status-crc-mismatch'}])

	def get_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-bootloader-mode')

		args = parser.parse_args(argv)

		device_call(ctx, EPaper296x128Bricklet, 236, (), '', 'B', args.execute, False, ['mode'], [{0: 'bootloader-mode-bootloader', 1: 'bootloader-mode-firmware', 2: 'bootloader-mode-bootloader-wait-for-reboot', 3: 'bootloader-mode-firmware-wait-for-reboot', 4: 'bootloader-mode-firmware-wait-for-erase-and-reboot'}])

	def set_write_firmware_pointer(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-write-firmware-pointer')

		parser.add_argument('pointer', type=convert_int, help='int', metavar='<pointer>')

		args = parser.parse_args(argv)

		device_call(ctx, EPaper296x128Bricklet, 237, (args.pointer,), 'I', '', None, args.expect_response, [], [])

	def write_firmware(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-firmware')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, EPaper296x128Bricklet, 238, (args.data,), '64B', 'B', args.execute, False, ['status'], [None])

	def set_status_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'status-led-config-on': 1, 'status-led-config-show-heartbeat': 2, 'status-led-config-off': 0, 'status-led-config-show-status': 3}), help='int (status-led-config-off: 0, status-led-config-on: 1, status-led-config-show-heartbeat: 2, status-led-config-show-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, EPaper296x128Bricklet, 239, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_status_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, EPaper296x128Bricklet, 240, (), '', 'B', args.execute, False, ['config'], [{0: 'status-led-config-off', 1: 'status-led-config-on', 2: 'status-led-config-show-heartbeat', 3: 'status-led-config-show-status'}])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, EPaper296x128Bricklet, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, EPaper296x128Bricklet, 243, (), '', '', None, args.expect_response, [], [])

	def write_uid(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-uid')

		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')

		args = parser.parse_args(argv)

		device_call(ctx, EPaper296x128Bricklet, 248, (args.uid,), 'I', '', None, args.expect_response, [], [])

	def read_uid(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-uid')

		args = parser.parse_args(argv)

		device_call(ctx, EPaper296x128Bricklet, 249, (), '', 'I', args.execute, False, ['uid'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, EPaper296x128Bricklet, argv)

	functions = {
	'draw': draw,
	'get-draw-status': get_draw_status,
	'write-black-white-low-level': write_black_white_low_level,
	'write-black-white': write_black_white,
	'read-black-white-low-level': read_black_white_low_level,
	'read-black-white': read_black_white,
	'write-color-low-level': write_color_low_level,
	'write-color': write_color,
	'read-color-low-level': read_color_low_level,
	'read-color': read_color,
	'fill-display': fill_display,
	'draw-text': draw_text,
	'draw-line': draw_line,
	'draw-box': draw_box,
	'set-update-mode': set_update_mode,
	'get-update-mode': get_update_mode,
	'set-display-type': set_display_type,
	'get-display-type': get_display_type,
	'get-spitfp-error-count': get_spitfp_error_count,
	'set-bootloader-mode': set_bootloader_mode,
	'get-bootloader-mode': get_bootloader_mode,
	'set-write-firmware-pointer': set_write_firmware_pointer,
	'write-firmware': write_firmware,
	'set-status-led-config': set_status_led_config,
	'get-status-led-config': get_status_led_config,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'write-uid': write_uid,
	'read-uid': read_uid,
	'get-identity': get_identity
	}

	call_generic(ctx, 'e-paper-296x128-bricklet', functions, argv)

def dispatch_e_paper_296x128_bricklet(ctx, argv):
	prog_prefix = 'dispatch e-paper-296x128-bricklet <uid>'

	def draw_status(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' draw-status')

		args = parser.parse_args(argv)

		device_dispatch(ctx, EPaper296x128Bricklet, 11, args.execute, ['draw-status'], [{0: 'draw-status-idle', 1: 'draw-status-copying', 2: 'draw-status-drawing'}])

	callbacks = {
	'draw-status': draw_status
	}

	dispatch_generic(ctx, 'e-paper-296x128-bricklet', callbacks, argv)

class EnergyMonitorBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 3; re[3] = 1; re[4] = 1; re[5] = 3; re[6] = 1; re[7] = 3; re[8] = 2; re[9] = 1; re[234] = 1; re[235] = 1; re[236] = 1; re[237] = 3; re[238] = 1; re[239] = 3; re[240] = 1; re[242] = 1; re[243] = 3; re[248] = 3; re[249] = 1; re[255] = 1
		cf = self.callback_formats
		cf[10] = 'i i i i i i H H'


def call_energy_monitor_bricklet(ctx, argv):
	prog_prefix = 'call energy-monitor-bricklet <uid>'

	def get_energy_data(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-energy-data')

		args = parser.parse_args(argv)

		device_call(ctx, EnergyMonitorBricklet, 1, (), '', 'i i i i i i H H', args.execute, False, ['voltage', 'current', 'energy', 'real-power', 'apparent-power', 'reactive-power', 'power-factor', 'frequency'], [None, None, None, None, None, None, None, None])

	def reset_energy(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset-energy')

		args = parser.parse_args(argv)

		device_call(ctx, EnergyMonitorBricklet, 2, (), '', '', None, args.expect_response, [], [])

	def get_waveform_low_level(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-waveform-low-level')

		args = parser.parse_args(argv)

		device_call(ctx, EnergyMonitorBricklet, 3, (), '', 'H 30h', args.execute, False, ['waveform-chunk-offset', 'waveform-chunk-data'], [None, None])

	def get_waveform(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-waveform')

		args = parser.parse_args(argv)

		device_stream_call(ctx, EnergyMonitorBricklet, 3, 'out', (), (), ('stream_data',), (), ('stream_chunk_offset', 'stream_chunk_data'), '', 'H 30h', args.execute, False, ['waveform'], [None], None, 30, 65535, False, False, 1536)

	def get_transformer_status(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-transformer-status')

		args = parser.parse_args(argv)

		device_call(ctx, EnergyMonitorBricklet, 4, (), '', '! !', args.execute, False, ['voltage-transformer-connected', 'current-transformer-connected'], [None, None])

	def set_transformer_calibration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-transformer-calibration')

		parser.add_argument('voltage_ratio', type=convert_int, help='int', metavar='<voltage-ratio>')
		parser.add_argument('current_ratio', type=convert_int, help='int', metavar='<current-ratio>')
		parser.add_argument('phase_shift', type=convert_int, help='int', metavar='<phase-shift>')

		args = parser.parse_args(argv)

		device_call(ctx, EnergyMonitorBricklet, 5, (args.voltage_ratio, args.current_ratio, args.phase_shift), 'H H h', '', None, args.expect_response, [], [])

	def get_transformer_calibration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-transformer-calibration')

		args = parser.parse_args(argv)

		device_call(ctx, EnergyMonitorBricklet, 6, (), '', 'H H h', args.execute, False, ['voltage-ratio', 'current-ratio', 'phase-shift'], [None, None, None])

	def calibrate_offset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' calibrate-offset')

		args = parser.parse_args(argv)

		device_call(ctx, EnergyMonitorBricklet, 7, (), '', '', None, args.expect_response, [], [])

	def set_energy_data_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-energy-data-callback-configuration')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')

		args = parser.parse_args(argv)

		device_call(ctx, EnergyMonitorBricklet, 8, (args.period, args.value_has_to_change), 'I !', '', None, args.expect_response, [], [])

	def get_energy_data_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-energy-data-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, EnergyMonitorBricklet, 9, (), '', 'I !', args.execute, False, ['period', 'value-has-to-change'], [None, None])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, EnergyMonitorBricklet, 234, (), '', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def set_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-bootloader-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'bootloader-mode-firmware-wait-for-reboot': 3, 'bootloader-mode-firmware': 1, 'bootloader-mode-firmware-wait-for-erase-and-reboot': 4, 'bootloader-mode-bootloader-wait-for-reboot': 2, 'bootloader-mode-bootloader': 0}), help='int (bootloader-mode-bootloader: 0, bootloader-mode-firmware: 1, bootloader-mode-bootloader-wait-for-reboot: 2, bootloader-mode-firmware-wait-for-reboot: 3, bootloader-mode-firmware-wait-for-erase-and-reboot: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, EnergyMonitorBricklet, 235, (args.mode,), 'B', 'B', args.execute, False, ['status'], [{0: 'bootloader-status-ok', 1: 'bootloader-status-invalid-mode', 2: 'bootloader-status-no-change', 3: 'bootloader-status-entry-function-not-present', 4: 'bootloader-status-device-identifier-incorrect', 5: 'bootloader-status-crc-mismatch'}])

	def get_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-bootloader-mode')

		args = parser.parse_args(argv)

		device_call(ctx, EnergyMonitorBricklet, 236, (), '', 'B', args.execute, False, ['mode'], [{0: 'bootloader-mode-bootloader', 1: 'bootloader-mode-firmware', 2: 'bootloader-mode-bootloader-wait-for-reboot', 3: 'bootloader-mode-firmware-wait-for-reboot', 4: 'bootloader-mode-firmware-wait-for-erase-and-reboot'}])

	def set_write_firmware_pointer(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-write-firmware-pointer')

		parser.add_argument('pointer', type=convert_int, help='int', metavar='<pointer>')

		args = parser.parse_args(argv)

		device_call(ctx, EnergyMonitorBricklet, 237, (args.pointer,), 'I', '', None, args.expect_response, [], [])

	def write_firmware(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-firmware')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, EnergyMonitorBricklet, 238, (args.data,), '64B', 'B', args.execute, False, ['status'], [None])

	def set_status_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'status-led-config-on': 1, 'status-led-config-show-heartbeat': 2, 'status-led-config-off': 0, 'status-led-config-show-status': 3}), help='int (status-led-config-off: 0, status-led-config-on: 1, status-led-config-show-heartbeat: 2, status-led-config-show-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, EnergyMonitorBricklet, 239, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_status_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, EnergyMonitorBricklet, 240, (), '', 'B', args.execute, False, ['config'], [{0: 'status-led-config-off', 1: 'status-led-config-on', 2: 'status-led-config-show-heartbeat', 3: 'status-led-config-show-status'}])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, EnergyMonitorBricklet, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, EnergyMonitorBricklet, 243, (), '', '', None, args.expect_response, [], [])

	def write_uid(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-uid')

		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')

		args = parser.parse_args(argv)

		device_call(ctx, EnergyMonitorBricklet, 248, (args.uid,), 'I', '', None, args.expect_response, [], [])

	def read_uid(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-uid')

		args = parser.parse_args(argv)

		device_call(ctx, EnergyMonitorBricklet, 249, (), '', 'I', args.execute, False, ['uid'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, EnergyMonitorBricklet, argv)

	functions = {
	'get-energy-data': get_energy_data,
	'reset-energy': reset_energy,
	'get-waveform-low-level': get_waveform_low_level,
	'get-waveform': get_waveform,
	'get-transformer-status': get_transformer_status,
	'set-transformer-calibration': set_transformer_calibration,
	'get-transformer-calibration': get_transformer_calibration,
	'calibrate-offset': calibrate_offset,
	'set-energy-data-callback-configuration': set_energy_data_callback_configuration,
	'get-energy-data-callback-configuration': get_energy_data_callback_configuration,
	'get-spitfp-error-count': get_spitfp_error_count,
	'set-bootloader-mode': set_bootloader_mode,
	'get-bootloader-mode': get_bootloader_mode,
	'set-write-firmware-pointer': set_write_firmware_pointer,
	'write-firmware': write_firmware,
	'set-status-led-config': set_status_led_config,
	'get-status-led-config': get_status_led_config,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'write-uid': write_uid,
	'read-uid': read_uid,
	'get-identity': get_identity
	}

	call_generic(ctx, 'energy-monitor-bricklet', functions, argv)

def dispatch_energy_monitor_bricklet(ctx, argv):
	prog_prefix = 'dispatch energy-monitor-bricklet <uid>'

	def energy_data(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' energy-data')

		args = parser.parse_args(argv)

		device_dispatch(ctx, EnergyMonitorBricklet, 10, args.execute, ['voltage', 'current', 'energy', 'real-power', 'apparent-power', 'reactive-power', 'power-factor', 'frequency'], [None, None, None, None, None, None, None, None])

	callbacks = {
	'energy-data': energy_data
	}

	dispatch_generic(ctx, 'energy-monitor-bricklet', callbacks, argv)

class GPSBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 1; re[3] = 1; re[4] = 1; re[5] = 1; re[6] = 3; re[7] = 2; re[8] = 1; re[9] = 2; re[10] = 1; re[11] = 2; re[12] = 1; re[13] = 2; re[14] = 1; re[15] = 2; re[16] = 1; re[255] = 1
		cf = self.callback_formats
		cf[17] = 'I c I c H H H H'; cf[18] = 'B B B'; cf[19] = 'i i'; cf[20] = 'I I'; cf[21] = 'I I'


def call_gps_bricklet(ctx, argv):
	prog_prefix = 'call gps-bricklet <uid>'

	def get_coordinates(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-coordinates')

		args = parser.parse_args(argv)

		device_call(ctx, GPSBricklet, 1, (), '', 'I c I c H H H H', args.execute, False, ['latitude', 'ns', 'longitude', 'ew', 'pdop', 'hdop', 'vdop', 'epe'], [None, None, None, None, None, None, None, None])

	def get_status(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status')

		args = parser.parse_args(argv)

		device_call(ctx, GPSBricklet, 2, (), '', 'B B B', args.execute, False, ['fix', 'satellites-view', 'satellites-used'], [{1: 'fix-no-fix', 2: 'fix-2d-fix', 3: 'fix-3d-fix'}, None, None])

	def get_altitude(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-altitude')

		args = parser.parse_args(argv)

		device_call(ctx, GPSBricklet, 3, (), '', 'i i', args.execute, False, ['altitude', 'geoidal-separation'], [None, None])

	def get_motion(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-motion')

		args = parser.parse_args(argv)

		device_call(ctx, GPSBricklet, 4, (), '', 'I I', args.execute, False, ['course', 'speed'], [None, None])

	def get_date_time(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-date-time')

		args = parser.parse_args(argv)

		device_call(ctx, GPSBricklet, 5, (), '', 'I I', args.execute, False, ['date', 'time'], [None, None])

	def restart(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' restart')

		parser.add_argument('restart_type', type=create_symbol_converter(ctx, convert_int, {'restart-type-warm-start': 1, 'restart-type-factory-reset': 3, 'restart-type-hot-start': 0, 'restart-type-cold-start': 2}), help='int (restart-type-hot-start: 0, restart-type-warm-start: 1, restart-type-cold-start: 2, restart-type-factory-reset: 3)', metavar='<restart-type>')

		args = parser.parse_args(argv)

		device_call(ctx, GPSBricklet, 6, (args.restart_type,), 'B', '', None, args.expect_response, [], [])

	def set_coordinates_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-coordinates-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, GPSBricklet, 7, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_coordinates_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-coordinates-callback-period')

		args = parser.parse_args(argv)

		device_call(ctx, GPSBricklet, 8, (), '', 'I', args.execute, False, ['period'], [None])

	def set_status_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, GPSBricklet, 9, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_status_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-callback-period')

		args = parser.parse_args(argv)

		device_call(ctx, GPSBricklet, 10, (), '', 'I', args.execute, False, ['period'], [None])

	def set_altitude_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-altitude-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, GPSBricklet, 11, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_altitude_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-altitude-callback-period')

		args = parser.parse_args(argv)

		device_call(ctx, GPSBricklet, 12, (), '', 'I', args.execute, False, ['period'], [None])

	def set_motion_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-motion-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, GPSBricklet, 13, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_motion_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-motion-callback-period')

		args = parser.parse_args(argv)

		device_call(ctx, GPSBricklet, 14, (), '', 'I', args.execute, False, ['period'], [None])

	def set_date_time_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-date-time-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, GPSBricklet, 15, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_date_time_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-date-time-callback-period')

		args = parser.parse_args(argv)

		device_call(ctx, GPSBricklet, 16, (), '', 'I', args.execute, False, ['period'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, GPSBricklet, argv)

	functions = {
	'get-coordinates': get_coordinates,
	'get-status': get_status,
	'get-altitude': get_altitude,
	'get-motion': get_motion,
	'get-date-time': get_date_time,
	'restart': restart,
	'set-coordinates-callback-period': set_coordinates_callback_period,
	'get-coordinates-callback-period': get_coordinates_callback_period,
	'set-status-callback-period': set_status_callback_period,
	'get-status-callback-period': get_status_callback_period,
	'set-altitude-callback-period': set_altitude_callback_period,
	'get-altitude-callback-period': get_altitude_callback_period,
	'set-motion-callback-period': set_motion_callback_period,
	'get-motion-callback-period': get_motion_callback_period,
	'set-date-time-callback-period': set_date_time_callback_period,
	'get-date-time-callback-period': get_date_time_callback_period,
	'get-identity': get_identity
	}

	call_generic(ctx, 'gps-bricklet', functions, argv)

def dispatch_gps_bricklet(ctx, argv):
	prog_prefix = 'dispatch gps-bricklet <uid>'

	def coordinates(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' coordinates')

		args = parser.parse_args(argv)

		device_dispatch(ctx, GPSBricklet, 17, args.execute, ['latitude', 'ns', 'longitude', 'ew', 'pdop', 'hdop', 'vdop', 'epe'], [None, None, None, None, None, None, None, None])

	def status(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' status')

		args = parser.parse_args(argv)

		device_dispatch(ctx, GPSBricklet, 18, args.execute, ['fix', 'satellites-view', 'satellites-used'], [{1: 'fix-no-fix', 2: 'fix-2d-fix', 3: 'fix-3d-fix'}, None, None])

	def altitude(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' altitude')

		args = parser.parse_args(argv)

		device_dispatch(ctx, GPSBricklet, 19, args.execute, ['altitude', 'geoidal-separation'], [None, None])

	def motion(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' motion')

		args = parser.parse_args(argv)

		device_dispatch(ctx, GPSBricklet, 20, args.execute, ['course', 'speed'], [None, None])

	def date_time(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' date-time')

		args = parser.parse_args(argv)

		device_dispatch(ctx, GPSBricklet, 21, args.execute, ['date', 'time'], [None, None])

	callbacks = {
	'coordinates': coordinates,
	'status': status,
	'altitude': altitude,
	'motion': motion,
	'date-time': date_time
	}

	dispatch_generic(ctx, 'gps-bricklet', callbacks, argv)

class GPSV2Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 1; re[3] = 1; re[4] = 1; re[5] = 1; re[6] = 3; re[7] = 1; re[8] = 1; re[9] = 3; re[10] = 1; re[11] = 2; re[12] = 1; re[13] = 2; re[14] = 1; re[15] = 2; re[16] = 1; re[17] = 2; re[18] = 1; re[19] = 2; re[20] = 1; re[27] = 3; re[28] = 1; re[234] = 1; re[235] = 1; re[236] = 1; re[237] = 3; re[238] = 1; re[239] = 3; re[240] = 1; re[242] = 1; re[243] = 3; re[248] = 3; re[249] = 1; re[255] = 1
		cf = self.callback_formats
		cf[21] = ''; cf[22] = 'I c I c'; cf[23] = '! B'; cf[24] = 'i i'; cf[25] = 'I I'; cf[26] = 'I I'


def call_gps_v2_bricklet(ctx, argv):
	prog_prefix = 'call gps-v2-bricklet <uid>'

	def get_coordinates(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-coordinates')

		args = parser.parse_args(argv)

		device_call(ctx, GPSV2Bricklet, 1, (), '', 'I c I c', args.execute, False, ['latitude', 'ns', 'longitude', 'ew'], [None, None, None, None])

	def get_status(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status')

		args = parser.parse_args(argv)

		device_call(ctx, GPSV2Bricklet, 2, (), '', '! B', args.execute, False, ['has-fix', 'satellites-view'], [None, None])

	def get_altitude(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-altitude')

		args = parser.parse_args(argv)

		device_call(ctx, GPSV2Bricklet, 3, (), '', 'i i', args.execute, False, ['altitude', 'geoidal-separation'], [None, None])

	def get_motion(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-motion')

		args = parser.parse_args(argv)

		device_call(ctx, GPSV2Bricklet, 4, (), '', 'I I', args.execute, False, ['course', 'speed'], [None, None])

	def get_date_time(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-date-time')

		args = parser.parse_args(argv)

		device_call(ctx, GPSV2Bricklet, 5, (), '', 'I I', args.execute, False, ['date', 'time'], [None, None])

	def restart(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' restart')

		parser.add_argument('restart_type', type=create_symbol_converter(ctx, convert_int, {'restart-type-warm-start': 1, 'restart-type-factory-reset': 3, 'restart-type-hot-start': 0, 'restart-type-cold-start': 2}), help='int (restart-type-hot-start: 0, restart-type-warm-start: 1, restart-type-cold-start: 2, restart-type-factory-reset: 3)', metavar='<restart-type>')

		args = parser.parse_args(argv)

		device_call(ctx, GPSV2Bricklet, 6, (args.restart_type,), 'B', '', None, args.expect_response, [], [])

	def get_satellite_system_status_low_level(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-satellite-system-status-low-level')

		parser.add_argument('satellite_system', type=create_symbol_converter(ctx, convert_int, {'satellite-system-gps': 0, 'satellite-system-glonass': 1, 'satellite-system-galileo': 2}), help='int (satellite-system-gps: 0, satellite-system-glonass: 1, satellite-system-galileo: 2)', metavar='<satellite-system>')

		args = parser.parse_args(argv)

		device_call(ctx, GPSV2Bricklet, 7, (args.satellite_system,), 'B', 'B 12B B H H H', args.execute, False, ['satellite-numbers-length', 'satellite-numbers-data', 'fix', 'pdop', 'hdop', 'vdop'], [None, None, {1: 'fix-no-fix', 2: 'fix-2d-fix', 3: 'fix-3d-fix'}, None, None, None])

	def get_satellite_system_status(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-satellite-system-status')

		parser.add_argument('satellite_system', type=create_symbol_converter(ctx, convert_int, {'satellite-system-gps': 0, 'satellite-system-glonass': 1, 'satellite-system-galileo': 2}), help='int (satellite-system-gps: 0, satellite-system-glonass: 1, satellite-system-galileo: 2)', metavar='<satellite-system>')

		args = parser.parse_args(argv)

		device_stream_call(ctx, GPSV2Bricklet, 7, 'out', (args.satellite_system,), (None,), ('stream_data', None, None, None, None), (None,), ('stream_length', 'stream_chunk_data', None, None, None, None), 'B', 'B 12B B H H H', args.execute, False, ['satellite-numbers', 'fix', 'pdop', 'hdop', 'vdop'], [None, {1: 'fix-no-fix', 2: 'fix-2d-fix', 3: 'fix-3d-fix'}, None, None, None], None, 12, None, False, True, None)

	def get_satellite_status(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-satellite-status')

		parser.add_argument('satellite_system', type=create_symbol_converter(ctx, convert_int, {'satellite-system-gps': 0, 'satellite-system-glonass': 1, 'satellite-system-galileo': 2}), help='int (satellite-system-gps: 0, satellite-system-glonass: 1, satellite-system-galileo: 2)', metavar='<satellite-system>')
		parser.add_argument('satellite_number', type=convert_int, help='int', metavar='<satellite-number>')

		args = parser.parse_args(argv)

		device_call(ctx, GPSV2Bricklet, 8, (args.satellite_system, args.satellite_number), 'B B', 'h h h', args.execute, False, ['elevation', 'azimuth', 'snr'], [None, None, None])

	def set_fix_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-fix-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'fix-led-config-off': 0, 'fix-led-config-on': 1, 'fix-led-config-show-heartbeat': 2, 'fix-led-config-show-pps': 4, 'fix-led-config-show-fix': 3}), help='int (fix-led-config-off: 0, fix-led-config-on: 1, fix-led-config-show-heartbeat: 2, fix-led-config-show-fix: 3, fix-led-config-show-pps: 4)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, GPSV2Bricklet, 9, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_fix_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-fix-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, GPSV2Bricklet, 10, (), '', 'B', args.execute, False, ['config'], [{0: 'fix-led-config-off', 1: 'fix-led-config-on', 2: 'fix-led-config-show-heartbeat', 3: 'fix-led-config-show-fix', 4: 'fix-led-config-show-pps'}])

	def set_coordinates_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-coordinates-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, GPSV2Bricklet, 11, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_coordinates_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-coordinates-callback-period')

		args = parser.parse_args(argv)

		device_call(ctx, GPSV2Bricklet, 12, (), '', 'I', args.execute, False, ['period'], [None])

	def set_status_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, GPSV2Bricklet, 13, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_status_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-callback-period')

		args = parser.parse_args(argv)

		device_call(ctx, GPSV2Bricklet, 14, (), '', 'I', args.execute, False, ['period'], [None])

	def set_altitude_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-altitude-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, GPSV2Bricklet, 15, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_altitude_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-altitude-callback-period')

		args = parser.parse_args(argv)

		device_call(ctx, GPSV2Bricklet, 16, (), '', 'I', args.execute, False, ['period'], [None])

	def set_motion_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-motion-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, GPSV2Bricklet, 17, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_motion_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-motion-callback-period')

		args = parser.parse_args(argv)

		device_call(ctx, GPSV2Bricklet, 18, (), '', 'I', args.execute, False, ['period'], [None])

	def set_date_time_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-date-time-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, GPSV2Bricklet, 19, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_date_time_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-date-time-callback-period')

		args = parser.parse_args(argv)

		device_call(ctx, GPSV2Bricklet, 20, (), '', 'I', args.execute, False, ['period'], [None])

	def set_sbas_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-sbas-config')

		parser.add_argument('sbas_config', type=create_symbol_converter(ctx, convert_int, {'sbas-disabled': 1, 'sbas-enabled': 0}), help='int (sbas-enabled: 0, sbas-disabled: 1)', metavar='<sbas-config>')

		args = parser.parse_args(argv)

		device_call(ctx, GPSV2Bricklet, 27, (args.sbas_config,), 'B', '', None, args.expect_response, [], [])

	def get_sbas_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-sbas-config')

		args = parser.parse_args(argv)

		device_call(ctx, GPSV2Bricklet, 28, (), '', 'B', args.execute, False, ['sbas-config'], [{0: 'sbas-enabled', 1: 'sbas-disabled'}])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, GPSV2Bricklet, 234, (), '', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def set_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-bootloader-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'bootloader-mode-firmware-wait-for-reboot': 3, 'bootloader-mode-firmware': 1, 'bootloader-mode-firmware-wait-for-erase-and-reboot': 4, 'bootloader-mode-bootloader-wait-for-reboot': 2, 'bootloader-mode-bootloader': 0}), help='int (bootloader-mode-bootloader: 0, bootloader-mode-firmware: 1, bootloader-mode-bootloader-wait-for-reboot: 2, bootloader-mode-firmware-wait-for-reboot: 3, bootloader-mode-firmware-wait-for-erase-and-reboot: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, GPSV2Bricklet, 235, (args.mode,), 'B', 'B', args.execute, False, ['status'], [{0: 'bootloader-status-ok', 1: 'bootloader-status-invalid-mode', 2: 'bootloader-status-no-change', 3: 'bootloader-status-entry-function-not-present', 4: 'bootloader-status-device-identifier-incorrect', 5: 'bootloader-status-crc-mismatch'}])

	def get_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-bootloader-mode')

		args = parser.parse_args(argv)

		device_call(ctx, GPSV2Bricklet, 236, (), '', 'B', args.execute, False, ['mode'], [{0: 'bootloader-mode-bootloader', 1: 'bootloader-mode-firmware', 2: 'bootloader-mode-bootloader-wait-for-reboot', 3: 'bootloader-mode-firmware-wait-for-reboot', 4: 'bootloader-mode-firmware-wait-for-erase-and-reboot'}])

	def set_write_firmware_pointer(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-write-firmware-pointer')

		parser.add_argument('pointer', type=convert_int, help='int', metavar='<pointer>')

		args = parser.parse_args(argv)

		device_call(ctx, GPSV2Bricklet, 237, (args.pointer,), 'I', '', None, args.expect_response, [], [])

	def write_firmware(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-firmware')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, GPSV2Bricklet, 238, (args.data,), '64B', 'B', args.execute, False, ['status'], [None])

	def set_status_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'status-led-config-on': 1, 'status-led-config-show-heartbeat': 2, 'status-led-config-off': 0, 'status-led-config-show-status': 3}), help='int (status-led-config-off: 0, status-led-config-on: 1, status-led-config-show-heartbeat: 2, status-led-config-show-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, GPSV2Bricklet, 239, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_status_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, GPSV2Bricklet, 240, (), '', 'B', args.execute, False, ['config'], [{0: 'status-led-config-off', 1: 'status-led-config-on', 2: 'status-led-config-show-heartbeat', 3: 'status-led-config-show-status'}])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, GPSV2Bricklet, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, GPSV2Bricklet, 243, (), '', '', None, args.expect_response, [], [])

	def write_uid(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-uid')

		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')

		args = parser.parse_args(argv)

		device_call(ctx, GPSV2Bricklet, 248, (args.uid,), 'I', '', None, args.expect_response, [], [])

	def read_uid(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-uid')

		args = parser.parse_args(argv)

		device_call(ctx, GPSV2Bricklet, 249, (), '', 'I', args.execute, False, ['uid'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, GPSV2Bricklet, argv)

	functions = {
	'get-coordinates': get_coordinates,
	'get-status': get_status,
	'get-altitude': get_altitude,
	'get-motion': get_motion,
	'get-date-time': get_date_time,
	'restart': restart,
	'get-satellite-system-status-low-level': get_satellite_system_status_low_level,
	'get-satellite-system-status': get_satellite_system_status,
	'get-satellite-status': get_satellite_status,
	'set-fix-led-config': set_fix_led_config,
	'get-fix-led-config': get_fix_led_config,
	'set-coordinates-callback-period': set_coordinates_callback_period,
	'get-coordinates-callback-period': get_coordinates_callback_period,
	'set-status-callback-period': set_status_callback_period,
	'get-status-callback-period': get_status_callback_period,
	'set-altitude-callback-period': set_altitude_callback_period,
	'get-altitude-callback-period': get_altitude_callback_period,
	'set-motion-callback-period': set_motion_callback_period,
	'get-motion-callback-period': get_motion_callback_period,
	'set-date-time-callback-period': set_date_time_callback_period,
	'get-date-time-callback-period': get_date_time_callback_period,
	'set-sbas-config': set_sbas_config,
	'get-sbas-config': get_sbas_config,
	'get-spitfp-error-count': get_spitfp_error_count,
	'set-bootloader-mode': set_bootloader_mode,
	'get-bootloader-mode': get_bootloader_mode,
	'set-write-firmware-pointer': set_write_firmware_pointer,
	'write-firmware': write_firmware,
	'set-status-led-config': set_status_led_config,
	'get-status-led-config': get_status_led_config,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'write-uid': write_uid,
	'read-uid': read_uid,
	'get-identity': get_identity
	}

	call_generic(ctx, 'gps-v2-bricklet', functions, argv)

def dispatch_gps_v2_bricklet(ctx, argv):
	prog_prefix = 'dispatch gps-v2-bricklet <uid>'

	def pulse_per_second(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' pulse-per-second')

		args = parser.parse_args(argv)

		device_dispatch(ctx, GPSV2Bricklet, 21, args.execute, [], [])

	def coordinates(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' coordinates')

		args = parser.parse_args(argv)

		device_dispatch(ctx, GPSV2Bricklet, 22, args.execute, ['latitude', 'ns', 'longitude', 'ew'], [None, None, None, None])

	def status(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' status')

		args = parser.parse_args(argv)

		device_dispatch(ctx, GPSV2Bricklet, 23, args.execute, ['has-fix', 'satellites-view'], [None, None])

	def altitude(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' altitude')

		args = parser.parse_args(argv)

		device_dispatch(ctx, GPSV2Bricklet, 24, args.execute, ['altitude', 'geoidal-separation'], [None, None])

	def motion(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' motion')

		args = parser.parse_args(argv)

		device_dispatch(ctx, GPSV2Bricklet, 25, args.execute, ['course', 'speed'], [None, None])

	def date_time(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' date-time')

		args = parser.parse_args(argv)

		device_dispatch(ctx, GPSV2Bricklet, 26, args.execute, ['date', 'time'], [None, None])

	callbacks = {
	'pulse-per-second': pulse_per_second,
	'coordinates': coordinates,
	'status': status,
	'altitude': altitude,
	'motion': motion,
	'date-time': date_time
	}

	dispatch_generic(ctx, 'gps-v2-bricklet', callbacks, argv)

class HallEffectBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 1; re[3] = 3; re[4] = 1; re[5] = 2; re[6] = 1; re[7] = 2; re[8] = 1; re[9] = 1; re[255] = 1
		cf = self.callback_formats
		cf[10] = 'I !'


def call_hall_effect_bricklet(ctx, argv):
	prog_prefix = 'call hall-effect-bricklet <uid>'

	def get_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-value')

		args = parser.parse_args(argv)

		device_call(ctx, HallEffectBricklet, 1, (), '', '!', args.execute, False, ['value'], [None])

	def get_edge_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-edge-count')

		parser.add_argument('reset_counter', type=convert_bool, help='bool', metavar='<reset-counter>')

		args = parser.parse_args(argv)

		device_call(ctx, HallEffectBricklet, 2, (args.reset_counter,), '!', 'I', args.execute, False, ['count'], [None])

	def set_edge_count_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-edge-count-config')

		parser.add_argument('edge_type', type=create_symbol_converter(ctx, convert_int, {'edge-type-both': 2, 'edge-type-falling': 1, 'edge-type-rising': 0}), help='int (edge-type-rising: 0, edge-type-falling: 1, edge-type-both: 2)', metavar='<edge-type>')
		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_call(ctx, HallEffectBricklet, 3, (args.edge_type, args.debounce), 'B B', '', None, args.expect_response, [], [])

	def get_edge_count_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-edge-count-config')

		args = parser.parse_args(argv)

		device_call(ctx, HallEffectBricklet, 4, (), '', 'B B', args.execute, False, ['edge-type', 'debounce'], [{0: 'edge-type-rising', 1: 'edge-type-falling', 2: 'edge-type-both'}, None])

	def set_edge_interrupt(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-edge-interrupt')

		parser.add_argument('edges', type=convert_int, help='int', metavar='<edges>')

		args = parser.parse_args(argv)

		device_call(ctx, HallEffectBricklet, 5, (args.edges,), 'I', '', None, args.expect_response, [], [])

	def get_edge_interrupt(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-edge-interrupt')

		args = parser.parse_args(argv)

		device_call(ctx, HallEffectBricklet, 6, (), '', 'I', args.execute, False, ['edges'], [None])

	def set_edge_count_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-edge-count-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, HallEffectBricklet, 7, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_edge_count_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-edge-count-callback-period')

		args = parser.parse_args(argv)

		device_call(ctx, HallEffectBricklet, 8, (), '', 'I', args.execute, False, ['period'], [None])

	def edge_interrupt(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' edge-interrupt')

		args = parser.parse_args(argv)

		device_call(ctx, HallEffectBricklet, 9, (), '', 'I !', args.execute, False, ['count', 'value'], [None, None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, HallEffectBricklet, argv)

	functions = {
	'get-value': get_value,
	'get-edge-count': get_edge_count,
	'set-edge-count-config': set_edge_count_config,
	'get-edge-count-config': get_edge_count_config,
	'set-edge-interrupt': set_edge_interrupt,
	'get-edge-interrupt': get_edge_interrupt,
	'set-edge-count-callback-period': set_edge_count_callback_period,
	'get-edge-count-callback-period': get_edge_count_callback_period,
	'edge-interrupt': edge_interrupt,
	'get-identity': get_identity
	}

	call_generic(ctx, 'hall-effect-bricklet', functions, argv)

def dispatch_hall_effect_bricklet(ctx, argv):
	prog_prefix = 'dispatch hall-effect-bricklet <uid>'

	def edge_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' edge-count')

		args = parser.parse_args(argv)

		device_dispatch(ctx, HallEffectBricklet, 10, args.execute, ['count', 'value'], [None, None])

	callbacks = {
	'edge-count': edge_count
	}

	dispatch_generic(ctx, 'hall-effect-bricklet', callbacks, argv)

class HallEffectV2Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 2; re[3] = 1; re[5] = 1; re[6] = 3; re[7] = 1; re[8] = 2; re[9] = 1; re[234] = 1; re[235] = 1; re[236] = 1; re[237] = 3; re[238] = 1; re[239] = 3; re[240] = 1; re[242] = 1; re[243] = 3; re[248] = 3; re[249] = 1; re[255] = 1
		cf = self.callback_formats
		cf[4] = 'h'; cf[10] = 'I'


def call_hall_effect_v2_bricklet(ctx, argv):
	prog_prefix = 'call hall-effect-v2-bricklet <uid>'

	def get_magnetic_flux_density(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-magnetic-flux-density')

		args = parser.parse_args(argv)

		device_call(ctx, HallEffectV2Bricklet, 1, (), '', 'h', args.execute, False, ['magnetic-flux-density'], [None])

	def set_magnetic_flux_density_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-magnetic-flux-density-callback-configuration')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')
		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, HallEffectV2Bricklet, 2, (args.period, args.value_has_to_change, args.option, args.min, args.max), 'I ! c h h', '', None, args.expect_response, [], [])

	def get_magnetic_flux_density_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-magnetic-flux-density-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, HallEffectV2Bricklet, 3, (), '', 'I ! c h h', args.execute, False, ['period', 'value-has-to-change', 'option', 'min', 'max'], [None, None, {'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def get_counter(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-counter')

		parser.add_argument('reset_counter', type=convert_bool, help='bool', metavar='<reset-counter>')

		args = parser.parse_args(argv)

		device_call(ctx, HallEffectV2Bricklet, 5, (args.reset_counter,), '!', 'I', args.execute, False, ['count'], [None])

	def set_counter_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-counter-config')

		parser.add_argument('high_threshold', type=convert_int, help='int', metavar='<high-threshold>')
		parser.add_argument('low_threshold', type=convert_int, help='int', metavar='<low-threshold>')
		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_call(ctx, HallEffectV2Bricklet, 6, (args.high_threshold, args.low_threshold, args.debounce), 'h h I', '', None, args.expect_response, [], [])

	def get_counter_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-counter-config')

		args = parser.parse_args(argv)

		device_call(ctx, HallEffectV2Bricklet, 7, (), '', 'h h I', args.execute, False, ['high-threshold', 'low-threshold', 'debounce'], [None, None, None])

	def set_counter_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-counter-callback-configuration')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')

		args = parser.parse_args(argv)

		device_call(ctx, HallEffectV2Bricklet, 8, (args.period, args.value_has_to_change), 'I !', '', None, args.expect_response, [], [])

	def get_counter_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-counter-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, HallEffectV2Bricklet, 9, (), '', 'I !', args.execute, False, ['period', 'value-has-to-change'], [None, None])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, HallEffectV2Bricklet, 234, (), '', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def set_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-bootloader-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'bootloader-mode-firmware-wait-for-reboot': 3, 'bootloader-mode-firmware': 1, 'bootloader-mode-firmware-wait-for-erase-and-reboot': 4, 'bootloader-mode-bootloader-wait-for-reboot': 2, 'bootloader-mode-bootloader': 0}), help='int (bootloader-mode-bootloader: 0, bootloader-mode-firmware: 1, bootloader-mode-bootloader-wait-for-reboot: 2, bootloader-mode-firmware-wait-for-reboot: 3, bootloader-mode-firmware-wait-for-erase-and-reboot: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, HallEffectV2Bricklet, 235, (args.mode,), 'B', 'B', args.execute, False, ['status'], [{0: 'bootloader-status-ok', 1: 'bootloader-status-invalid-mode', 2: 'bootloader-status-no-change', 3: 'bootloader-status-entry-function-not-present', 4: 'bootloader-status-device-identifier-incorrect', 5: 'bootloader-status-crc-mismatch'}])

	def get_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-bootloader-mode')

		args = parser.parse_args(argv)

		device_call(ctx, HallEffectV2Bricklet, 236, (), '', 'B', args.execute, False, ['mode'], [{0: 'bootloader-mode-bootloader', 1: 'bootloader-mode-firmware', 2: 'bootloader-mode-bootloader-wait-for-reboot', 3: 'bootloader-mode-firmware-wait-for-reboot', 4: 'bootloader-mode-firmware-wait-for-erase-and-reboot'}])

	def set_write_firmware_pointer(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-write-firmware-pointer')

		parser.add_argument('pointer', type=convert_int, help='int', metavar='<pointer>')

		args = parser.parse_args(argv)

		device_call(ctx, HallEffectV2Bricklet, 237, (args.pointer,), 'I', '', None, args.expect_response, [], [])

	def write_firmware(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-firmware')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, HallEffectV2Bricklet, 238, (args.data,), '64B', 'B', args.execute, False, ['status'], [None])

	def set_status_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'status-led-config-on': 1, 'status-led-config-show-heartbeat': 2, 'status-led-config-off': 0, 'status-led-config-show-status': 3}), help='int (status-led-config-off: 0, status-led-config-on: 1, status-led-config-show-heartbeat: 2, status-led-config-show-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, HallEffectV2Bricklet, 239, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_status_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, HallEffectV2Bricklet, 240, (), '', 'B', args.execute, False, ['config'], [{0: 'status-led-config-off', 1: 'status-led-config-on', 2: 'status-led-config-show-heartbeat', 3: 'status-led-config-show-status'}])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, HallEffectV2Bricklet, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, HallEffectV2Bricklet, 243, (), '', '', None, args.expect_response, [], [])

	def write_uid(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-uid')

		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')

		args = parser.parse_args(argv)

		device_call(ctx, HallEffectV2Bricklet, 248, (args.uid,), 'I', '', None, args.expect_response, [], [])

	def read_uid(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-uid')

		args = parser.parse_args(argv)

		device_call(ctx, HallEffectV2Bricklet, 249, (), '', 'I', args.execute, False, ['uid'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, HallEffectV2Bricklet, argv)

	functions = {
	'get-magnetic-flux-density': get_magnetic_flux_density,
	'set-magnetic-flux-density-callback-configuration': set_magnetic_flux_density_callback_configuration,
	'get-magnetic-flux-density-callback-configuration': get_magnetic_flux_density_callback_configuration,
	'get-counter': get_counter,
	'set-counter-config': set_counter_config,
	'get-counter-config': get_counter_config,
	'set-counter-callback-configuration': set_counter_callback_configuration,
	'get-counter-callback-configuration': get_counter_callback_configuration,
	'get-spitfp-error-count': get_spitfp_error_count,
	'set-bootloader-mode': set_bootloader_mode,
	'get-bootloader-mode': get_bootloader_mode,
	'set-write-firmware-pointer': set_write_firmware_pointer,
	'write-firmware': write_firmware,
	'set-status-led-config': set_status_led_config,
	'get-status-led-config': get_status_led_config,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'write-uid': write_uid,
	'read-uid': read_uid,
	'get-identity': get_identity
	}

	call_generic(ctx, 'hall-effect-v2-bricklet', functions, argv)

def dispatch_hall_effect_v2_bricklet(ctx, argv):
	prog_prefix = 'dispatch hall-effect-v2-bricklet <uid>'

	def magnetic_flux_density(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' magnetic-flux-density')

		args = parser.parse_args(argv)

		device_dispatch(ctx, HallEffectV2Bricklet, 4, args.execute, ['magnetic-flux-density'], [None])

	def counter(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' counter')

		args = parser.parse_args(argv)

		device_dispatch(ctx, HallEffectV2Bricklet, 10, args.execute, ['count'], [None])

	callbacks = {
	'magnetic-flux-density': magnetic_flux_density,
	'counter': counter
	}

	dispatch_generic(ctx, 'hall-effect-v2-bricklet', callbacks, argv)

class HATBrick(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 3; re[2] = 1; re[3] = 3; re[4] = 1; re[5] = 1; re[234] = 1; re[235] = 1; re[236] = 1; re[237] = 3; re[238] = 1; re[239] = 3; re[240] = 1; re[242] = 1; re[243] = 3; re[248] = 3; re[249] = 1; re[255] = 1



def call_hat_brick(ctx, argv):
	prog_prefix = 'call hat-brick <uid>'

	def set_sleep_mode(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-sleep-mode')

		parser.add_argument('power_off_delay', type=convert_int, help='int', metavar='<power-off-delay>')
		parser.add_argument('power_off_duration', type=convert_int, help='int', metavar='<power-off-duration>')
		parser.add_argument('raspberry_pi_off', type=convert_bool, help='bool', metavar='<raspberry-pi-off>')
		parser.add_argument('bricklets_off', type=convert_bool, help='bool', metavar='<bricklets-off>')
		parser.add_argument('enable_sleep_indicator', type=convert_bool, help='bool', metavar='<enable-sleep-indicator>')

		args = parser.parse_args(argv)

		device_call(ctx, HATBrick, 1, (args.power_off_delay, args.power_off_duration, args.raspberry_pi_off, args.bricklets_off, args.enable_sleep_indicator), 'I I ! ! !', '', None, args.expect_response, [], [])

	def get_sleep_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-sleep-mode')

		args = parser.parse_args(argv)

		device_call(ctx, HATBrick, 2, (), '', 'I I ! ! !', args.execute, False, ['power-off-delay', 'power-off-duration', 'raspberry-pi-off', 'bricklets-off', 'enable-sleep-indicator'], [None, None, None, None, None])

	def set_bricklet_power(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-bricklet-power')

		parser.add_argument('bricklet_power', type=convert_bool, help='bool', metavar='<bricklet-power>')

		args = parser.parse_args(argv)

		device_call(ctx, HATBrick, 3, (args.bricklet_power,), '!', '', None, args.expect_response, [], [])

	def get_bricklet_power(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-bricklet-power')

		args = parser.parse_args(argv)

		device_call(ctx, HATBrick, 4, (), '', '!', args.execute, False, ['bricklet-power'], [None])

	def get_voltages(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-voltages')

		args = parser.parse_args(argv)

		device_call(ctx, HATBrick, 5, (), '', 'H H', args.execute, False, ['voltage-usb', 'voltage-dc'], [None, None])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, HATBrick, 234, (), '', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def set_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-bootloader-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'bootloader-mode-firmware-wait-for-reboot': 3, 'bootloader-mode-firmware': 1, 'bootloader-mode-firmware-wait-for-erase-and-reboot': 4, 'bootloader-mode-bootloader-wait-for-reboot': 2, 'bootloader-mode-bootloader': 0}), help='int (bootloader-mode-bootloader: 0, bootloader-mode-firmware: 1, bootloader-mode-bootloader-wait-for-reboot: 2, bootloader-mode-firmware-wait-for-reboot: 3, bootloader-mode-firmware-wait-for-erase-and-reboot: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, HATBrick, 235, (args.mode,), 'B', 'B', args.execute, False, ['status'], [{0: 'bootloader-status-ok', 1: 'bootloader-status-invalid-mode', 2: 'bootloader-status-no-change', 3: 'bootloader-status-entry-function-not-present', 4: 'bootloader-status-device-identifier-incorrect', 5: 'bootloader-status-crc-mismatch'}])

	def get_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-bootloader-mode')

		args = parser.parse_args(argv)

		device_call(ctx, HATBrick, 236, (), '', 'B', args.execute, False, ['mode'], [{0: 'bootloader-mode-bootloader', 1: 'bootloader-mode-firmware', 2: 'bootloader-mode-bootloader-wait-for-reboot', 3: 'bootloader-mode-firmware-wait-for-reboot', 4: 'bootloader-mode-firmware-wait-for-erase-and-reboot'}])

	def set_write_firmware_pointer(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-write-firmware-pointer')

		parser.add_argument('pointer', type=convert_int, help='int', metavar='<pointer>')

		args = parser.parse_args(argv)

		device_call(ctx, HATBrick, 237, (args.pointer,), 'I', '', None, args.expect_response, [], [])

	def write_firmware(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-firmware')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, HATBrick, 238, (args.data,), '64B', 'B', args.execute, False, ['status'], [None])

	def set_status_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'status-led-config-on': 1, 'status-led-config-show-heartbeat': 2, 'status-led-config-off': 0, 'status-led-config-show-status': 3}), help='int (status-led-config-off: 0, status-led-config-on: 1, status-led-config-show-heartbeat: 2, status-led-config-show-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, HATBrick, 239, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_status_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, HATBrick, 240, (), '', 'B', args.execute, False, ['config'], [{0: 'status-led-config-off', 1: 'status-led-config-on', 2: 'status-led-config-show-heartbeat', 3: 'status-led-config-show-status'}])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, HATBrick, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, HATBrick, 243, (), '', '', None, args.expect_response, [], [])

	def write_uid(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-uid')

		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')

		args = parser.parse_args(argv)

		device_call(ctx, HATBrick, 248, (args.uid,), 'I', '', None, args.expect_response, [], [])

	def read_uid(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-uid')

		args = parser.parse_args(argv)

		device_call(ctx, HATBrick, 249, (), '', 'I', args.execute, False, ['uid'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, HATBrick, argv)

	functions = {
	'set-sleep-mode': set_sleep_mode,
	'get-sleep-mode': get_sleep_mode,
	'set-bricklet-power': set_bricklet_power,
	'get-bricklet-power': get_bricklet_power,
	'get-voltages': get_voltages,
	'get-spitfp-error-count': get_spitfp_error_count,
	'set-bootloader-mode': set_bootloader_mode,
	'get-bootloader-mode': get_bootloader_mode,
	'set-write-firmware-pointer': set_write_firmware_pointer,
	'write-firmware': write_firmware,
	'set-status-led-config': set_status_led_config,
	'get-status-led-config': get_status_led_config,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'write-uid': write_uid,
	'read-uid': read_uid,
	'get-identity': get_identity
	}

	call_generic(ctx, 'hat-brick', functions, argv)

def dispatch_hat_brick(ctx, argv):
	prog_prefix = 'dispatch hat-brick <uid>'


	callbacks = {

	}

	dispatch_generic(ctx, 'hat-brick', callbacks, argv)

class HATZeroBrick(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[234] = 1; re[235] = 1; re[236] = 1; re[237] = 3; re[238] = 1; re[239] = 3; re[240] = 1; re[242] = 1; re[243] = 3; re[248] = 3; re[249] = 1; re[255] = 1



def call_hat_zero_brick(ctx, argv):
	prog_prefix = 'call hat-zero-brick <uid>'

	def get_usb_voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-usb-voltage')

		args = parser.parse_args(argv)

		device_call(ctx, HATZeroBrick, 1, (), '', 'H', args.execute, False, ['voltage'], [None])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, HATZeroBrick, 234, (), '', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def set_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-bootloader-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'bootloader-mode-firmware-wait-for-reboot': 3, 'bootloader-mode-firmware': 1, 'bootloader-mode-firmware-wait-for-erase-and-reboot': 4, 'bootloader-mode-bootloader-wait-for-reboot': 2, 'bootloader-mode-bootloader': 0}), help='int (bootloader-mode-bootloader: 0, bootloader-mode-firmware: 1, bootloader-mode-bootloader-wait-for-reboot: 2, bootloader-mode-firmware-wait-for-reboot: 3, bootloader-mode-firmware-wait-for-erase-and-reboot: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, HATZeroBrick, 235, (args.mode,), 'B', 'B', args.execute, False, ['status'], [{0: 'bootloader-status-ok', 1: 'bootloader-status-invalid-mode', 2: 'bootloader-status-no-change', 3: 'bootloader-status-entry-function-not-present', 4: 'bootloader-status-device-identifier-incorrect', 5: 'bootloader-status-crc-mismatch'}])

	def get_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-bootloader-mode')

		args = parser.parse_args(argv)

		device_call(ctx, HATZeroBrick, 236, (), '', 'B', args.execute, False, ['mode'], [{0: 'bootloader-mode-bootloader', 1: 'bootloader-mode-firmware', 2: 'bootloader-mode-bootloader-wait-for-reboot', 3: 'bootloader-mode-firmware-wait-for-reboot', 4: 'bootloader-mode-firmware-wait-for-erase-and-reboot'}])

	def set_write_firmware_pointer(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-write-firmware-pointer')

		parser.add_argument('pointer', type=convert_int, help='int', metavar='<pointer>')

		args = parser.parse_args(argv)

		device_call(ctx, HATZeroBrick, 237, (args.pointer,), 'I', '', None, args.expect_response, [], [])

	def write_firmware(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-firmware')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, HATZeroBrick, 238, (args.data,), '64B', 'B', args.execute, False, ['status'], [None])

	def set_status_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'status-led-config-on': 1, 'status-led-config-show-heartbeat': 2, 'status-led-config-off': 0, 'status-led-config-show-status': 3}), help='int (status-led-config-off: 0, status-led-config-on: 1, status-led-config-show-heartbeat: 2, status-led-config-show-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, HATZeroBrick, 239, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_status_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, HATZeroBrick, 240, (), '', 'B', args.execute, False, ['config'], [{0: 'status-led-config-off', 1: 'status-led-config-on', 2: 'status-led-config-show-heartbeat', 3: 'status-led-config-show-status'}])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, HATZeroBrick, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, HATZeroBrick, 243, (), '', '', None, args.expect_response, [], [])

	def write_uid(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-uid')

		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')

		args = parser.parse_args(argv)

		device_call(ctx, HATZeroBrick, 248, (args.uid,), 'I', '', None, args.expect_response, [], [])

	def read_uid(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-uid')

		args = parser.parse_args(argv)

		device_call(ctx, HATZeroBrick, 249, (), '', 'I', args.execute, False, ['uid'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, HATZeroBrick, argv)

	functions = {
	'get-usb-voltage': get_usb_voltage,
	'get-spitfp-error-count': get_spitfp_error_count,
	'set-bootloader-mode': set_bootloader_mode,
	'get-bootloader-mode': get_bootloader_mode,
	'set-write-firmware-pointer': set_write_firmware_pointer,
	'write-firmware': write_firmware,
	'set-status-led-config': set_status_led_config,
	'get-status-led-config': get_status_led_config,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'write-uid': write_uid,
	'read-uid': read_uid,
	'get-identity': get_identity
	}

	call_generic(ctx, 'hat-zero-brick', functions, argv)

def dispatch_hat_zero_brick(ctx, argv):
	prog_prefix = 'dispatch hat-zero-brick <uid>'


	callbacks = {

	}

	dispatch_generic(ctx, 'hat-zero-brick', callbacks, argv)

class HumidityBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 1; re[3] = 2; re[4] = 1; re[5] = 2; re[6] = 1; re[7] = 2; re[8] = 1; re[9] = 2; re[10] = 1; re[11] = 2; re[12] = 1; re[255] = 1
		cf = self.callback_formats
		cf[13] = 'H'; cf[14] = 'H'; cf[15] = 'H'; cf[16] = 'H'


def call_humidity_bricklet(ctx, argv):
	prog_prefix = 'call humidity-bricklet <uid>'

	def get_humidity(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-humidity')

		args = parser.parse_args(argv)

		device_call(ctx, HumidityBricklet, 1, (), '', 'H', args.execute, False, ['humidity'], [None])

	def get_analog_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-analog-value')

		args = parser.parse_args(argv)

		device_call(ctx, HumidityBricklet, 2, (), '', 'H', args.execute, False, ['value'], [None])

	def set_humidity_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-humidity-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, HumidityBricklet, 3, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_humidity_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-humidity-callback-period')

		args = parser.parse_args(argv)

		device_call(ctx, HumidityBricklet, 4, (), '', 'I', args.execute, False, ['period'], [None])

	def set_analog_value_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-analog-value-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, HumidityBricklet, 5, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_analog_value_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-analog-value-callback-period')

		args = parser.parse_args(argv)

		device_call(ctx, HumidityBricklet, 6, (), '', 'I', args.execute, False, ['period'], [None])

	def set_humidity_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-humidity-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, HumidityBricklet, 7, (args.option, args.min, args.max), 'c H H', '', None, args.expect_response, [], [])

	def get_humidity_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-humidity-callback-threshold')

		args = parser.parse_args(argv)

		device_call(ctx, HumidityBricklet, 8, (), '', 'c H H', args.execute, False, ['option', 'min', 'max'], [{'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def set_analog_value_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-analog-value-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, HumidityBricklet, 9, (args.option, args.min, args.max), 'c H H', '', None, args.expect_response, [], [])

	def get_analog_value_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-analog-value-callback-threshold')

		args = parser.parse_args(argv)

		device_call(ctx, HumidityBricklet, 10, (), '', 'c H H', args.execute, False, ['option', 'min', 'max'], [{'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def set_debounce_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-debounce-period')

		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_call(ctx, HumidityBricklet, 11, (args.debounce,), 'I', '', None, args.expect_response, [], [])

	def get_debounce_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-debounce-period')

		args = parser.parse_args(argv)

		device_call(ctx, HumidityBricklet, 12, (), '', 'I', args.execute, False, ['debounce'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, HumidityBricklet, argv)

	functions = {
	'get-humidity': get_humidity,
	'get-analog-value': get_analog_value,
	'set-humidity-callback-period': set_humidity_callback_period,
	'get-humidity-callback-period': get_humidity_callback_period,
	'set-analog-value-callback-period': set_analog_value_callback_period,
	'get-analog-value-callback-period': get_analog_value_callback_period,
	'set-humidity-callback-threshold': set_humidity_callback_threshold,
	'get-humidity-callback-threshold': get_humidity_callback_threshold,
	'set-analog-value-callback-threshold': set_analog_value_callback_threshold,
	'get-analog-value-callback-threshold': get_analog_value_callback_threshold,
	'set-debounce-period': set_debounce_period,
	'get-debounce-period': get_debounce_period,
	'get-identity': get_identity
	}

	call_generic(ctx, 'humidity-bricklet', functions, argv)

def dispatch_humidity_bricklet(ctx, argv):
	prog_prefix = 'dispatch humidity-bricklet <uid>'

	def humidity(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' humidity')

		args = parser.parse_args(argv)

		device_dispatch(ctx, HumidityBricklet, 13, args.execute, ['humidity'], [None])

	def analog_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' analog-value')

		args = parser.parse_args(argv)

		device_dispatch(ctx, HumidityBricklet, 14, args.execute, ['value'], [None])

	def humidity_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' humidity-reached')

		args = parser.parse_args(argv)

		device_dispatch(ctx, HumidityBricklet, 15, args.execute, ['humidity'], [None])

	def analog_value_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' analog-value-reached')

		args = parser.parse_args(argv)

		device_dispatch(ctx, HumidityBricklet, 16, args.execute, ['value'], [None])

	callbacks = {
	'humidity': humidity,
	'analog-value': analog_value,
	'humidity-reached': humidity_reached,
	'analog-value-reached': analog_value_reached
	}

	dispatch_generic(ctx, 'humidity-bricklet', callbacks, argv)

class HumidityV2Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 2; re[3] = 1; re[5] = 1; re[6] = 2; re[7] = 1; re[9] = 3; re[10] = 1; re[11] = 3; re[12] = 1; re[13] = 3; re[14] = 1; re[234] = 1; re[235] = 1; re[236] = 1; re[237] = 3; re[238] = 1; re[239] = 3; re[240] = 1; re[242] = 1; re[243] = 3; re[248] = 3; re[249] = 1; re[255] = 1
		cf = self.callback_formats
		cf[4] = 'H'; cf[8] = 'h'


def call_humidity_v2_bricklet(ctx, argv):
	prog_prefix = 'call humidity-v2-bricklet <uid>'

	def get_humidity(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-humidity')

		args = parser.parse_args(argv)

		device_call(ctx, HumidityV2Bricklet, 1, (), '', 'H', args.execute, False, ['humidity'], [None])

	def set_humidity_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-humidity-callback-configuration')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')
		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, HumidityV2Bricklet, 2, (args.period, args.value_has_to_change, args.option, args.min, args.max), 'I ! c H H', '', None, args.expect_response, [], [])

	def get_humidity_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-humidity-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, HumidityV2Bricklet, 3, (), '', 'I ! c H H', args.execute, False, ['period', 'value-has-to-change', 'option', 'min', 'max'], [None, None, {'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def get_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, HumidityV2Bricklet, 5, (), '', 'h', args.execute, False, ['temperature'], [None])

	def set_temperature_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-temperature-callback-configuration')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')
		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, HumidityV2Bricklet, 6, (args.period, args.value_has_to_change, args.option, args.min, args.max), 'I ! c h h', '', None, args.expect_response, [], [])

	def get_temperature_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-temperature-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, HumidityV2Bricklet, 7, (), '', 'I ! c h h', args.execute, False, ['period', 'value-has-to-change', 'option', 'min', 'max'], [None, None, {'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def set_heater_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-heater-configuration')

		parser.add_argument('heater_config', type=create_symbol_converter(ctx, convert_int, {'heater-config-enabled': 1, 'heater-config-disabled': 0}), help='int (heater-config-disabled: 0, heater-config-enabled: 1)', metavar='<heater-config>')

		args = parser.parse_args(argv)

		device_call(ctx, HumidityV2Bricklet, 9, (args.heater_config,), 'B', '', None, args.expect_response, [], [])

	def get_heater_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-heater-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, HumidityV2Bricklet, 10, (), '', 'B', args.execute, False, ['heater-config'], [{0: 'heater-config-disabled', 1: 'heater-config-enabled'}])

	def set_moving_average_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-moving-average-configuration')

		parser.add_argument('moving_average_length_humidity', type=convert_int, help='int', metavar='<moving-average-length-humidity>')
		parser.add_argument('moving_average_length_temperature', type=convert_int, help='int', metavar='<moving-average-length-temperature>')

		args = parser.parse_args(argv)

		device_call(ctx, HumidityV2Bricklet, 11, (args.moving_average_length_humidity, args.moving_average_length_temperature), 'H H', '', None, args.expect_response, [], [])

	def get_moving_average_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-moving-average-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, HumidityV2Bricklet, 12, (), '', 'H H', args.execute, False, ['moving-average-length-humidity', 'moving-average-length-temperature'], [None, None])

	def set_samples_per_second(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-samples-per-second')

		parser.add_argument('sps', type=create_symbol_converter(ctx, convert_int, {'sps-1': 3, 'sps-5': 2, 'sps-20': 0, 'sps-02': 4, 'sps-01': 5, 'sps-10': 1}), help='int (sps-20: 0, sps-10: 1, sps-5: 2, sps-1: 3, sps-02: 4, sps-01: 5)', metavar='<sps>')

		args = parser.parse_args(argv)

		device_call(ctx, HumidityV2Bricklet, 13, (args.sps,), 'B', '', None, args.expect_response, [], [])

	def get_samples_per_second(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-samples-per-second')

		args = parser.parse_args(argv)

		device_call(ctx, HumidityV2Bricklet, 14, (), '', 'B', args.execute, False, ['sps'], [{0: 'sps-20', 1: 'sps-10', 2: 'sps-5', 3: 'sps-1', 4: 'sps-02', 5: 'sps-01'}])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, HumidityV2Bricklet, 234, (), '', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def set_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-bootloader-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'bootloader-mode-firmware-wait-for-reboot': 3, 'bootloader-mode-firmware': 1, 'bootloader-mode-firmware-wait-for-erase-and-reboot': 4, 'bootloader-mode-bootloader-wait-for-reboot': 2, 'bootloader-mode-bootloader': 0}), help='int (bootloader-mode-bootloader: 0, bootloader-mode-firmware: 1, bootloader-mode-bootloader-wait-for-reboot: 2, bootloader-mode-firmware-wait-for-reboot: 3, bootloader-mode-firmware-wait-for-erase-and-reboot: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, HumidityV2Bricklet, 235, (args.mode,), 'B', 'B', args.execute, False, ['status'], [{0: 'bootloader-status-ok', 1: 'bootloader-status-invalid-mode', 2: 'bootloader-status-no-change', 3: 'bootloader-status-entry-function-not-present', 4: 'bootloader-status-device-identifier-incorrect', 5: 'bootloader-status-crc-mismatch'}])

	def get_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-bootloader-mode')

		args = parser.parse_args(argv)

		device_call(ctx, HumidityV2Bricklet, 236, (), '', 'B', args.execute, False, ['mode'], [{0: 'bootloader-mode-bootloader', 1: 'bootloader-mode-firmware', 2: 'bootloader-mode-bootloader-wait-for-reboot', 3: 'bootloader-mode-firmware-wait-for-reboot', 4: 'bootloader-mode-firmware-wait-for-erase-and-reboot'}])

	def set_write_firmware_pointer(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-write-firmware-pointer')

		parser.add_argument('pointer', type=convert_int, help='int', metavar='<pointer>')

		args = parser.parse_args(argv)

		device_call(ctx, HumidityV2Bricklet, 237, (args.pointer,), 'I', '', None, args.expect_response, [], [])

	def write_firmware(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-firmware')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, HumidityV2Bricklet, 238, (args.data,), '64B', 'B', args.execute, False, ['status'], [None])

	def set_status_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'status-led-config-on': 1, 'status-led-config-show-heartbeat': 2, 'status-led-config-off': 0, 'status-led-config-show-status': 3}), help='int (status-led-config-off: 0, status-led-config-on: 1, status-led-config-show-heartbeat: 2, status-led-config-show-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, HumidityV2Bricklet, 239, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_status_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, HumidityV2Bricklet, 240, (), '', 'B', args.execute, False, ['config'], [{0: 'status-led-config-off', 1: 'status-led-config-on', 2: 'status-led-config-show-heartbeat', 3: 'status-led-config-show-status'}])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, HumidityV2Bricklet, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, HumidityV2Bricklet, 243, (), '', '', None, args.expect_response, [], [])

	def write_uid(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-uid')

		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')

		args = parser.parse_args(argv)

		device_call(ctx, HumidityV2Bricklet, 248, (args.uid,), 'I', '', None, args.expect_response, [], [])

	def read_uid(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-uid')

		args = parser.parse_args(argv)

		device_call(ctx, HumidityV2Bricklet, 249, (), '', 'I', args.execute, False, ['uid'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, HumidityV2Bricklet, argv)

	functions = {
	'get-humidity': get_humidity,
	'set-humidity-callback-configuration': set_humidity_callback_configuration,
	'get-humidity-callback-configuration': get_humidity_callback_configuration,
	'get-temperature': get_temperature,
	'set-temperature-callback-configuration': set_temperature_callback_configuration,
	'get-temperature-callback-configuration': get_temperature_callback_configuration,
	'set-heater-configuration': set_heater_configuration,
	'get-heater-configuration': get_heater_configuration,
	'set-moving-average-configuration': set_moving_average_configuration,
	'get-moving-average-configuration': get_moving_average_configuration,
	'set-samples-per-second': set_samples_per_second,
	'get-samples-per-second': get_samples_per_second,
	'get-spitfp-error-count': get_spitfp_error_count,
	'set-bootloader-mode': set_bootloader_mode,
	'get-bootloader-mode': get_bootloader_mode,
	'set-write-firmware-pointer': set_write_firmware_pointer,
	'write-firmware': write_firmware,
	'set-status-led-config': set_status_led_config,
	'get-status-led-config': get_status_led_config,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'write-uid': write_uid,
	'read-uid': read_uid,
	'get-identity': get_identity
	}

	call_generic(ctx, 'humidity-v2-bricklet', functions, argv)

def dispatch_humidity_v2_bricklet(ctx, argv):
	prog_prefix = 'dispatch humidity-v2-bricklet <uid>'

	def humidity(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' humidity')

		args = parser.parse_args(argv)

		device_dispatch(ctx, HumidityV2Bricklet, 4, args.execute, ['humidity'], [None])

	def temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' temperature')

		args = parser.parse_args(argv)

		device_dispatch(ctx, HumidityV2Bricklet, 8, args.execute, ['temperature'], [None])

	callbacks = {
	'humidity': humidity,
	'temperature': temperature
	}

	dispatch_generic(ctx, 'humidity-v2-bricklet', callbacks, argv)

class IMUBrick(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 1; re[3] = 1; re[4] = 1; re[5] = 1; re[6] = 1; re[7] = 1; re[8] = 3; re[9] = 3; re[10] = 1; re[11] = 3; re[12] = 1; re[13] = 3; re[14] = 1; re[15] = 3; re[16] = 1; re[17] = 3; re[18] = 1; re[19] = 2; re[20] = 1; re[21] = 2; re[22] = 1; re[23] = 2; re[24] = 1; re[25] = 2; re[26] = 1; re[27] = 2; re[28] = 1; re[29] = 2; re[30] = 1; re[37] = 3; re[38] = 3; re[39] = 1; re[231] = 3; re[232] = 1; re[233] = 1; re[234] = 3; re[235] = 1; re[237] = 1; re[238] = 3; re[239] = 3; re[240] = 1; re[241] = 1; re[242] = 1; re[243] = 3; re[255] = 1
		cf = self.callback_formats
		cf[31] = 'h h h'; cf[32] = 'h h h'; cf[33] = 'h h h'; cf[34] = 'h h h h h h h h h h'; cf[35] = 'h h h'; cf[36] = 'f f f f'


def call_imu_brick(ctx, argv):
	prog_prefix = 'call imu-brick <uid>'

	def get_acceleration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-acceleration')

		args = parser.parse_args(argv)

		device_call(ctx, IMUBrick, 1, (), '', 'h h h', args.execute, False, ['x', 'y', 'z'], [None, None, None])

	def get_magnetic_field(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-magnetic-field')

		args = parser.parse_args(argv)

		device_call(ctx, IMUBrick, 2, (), '', 'h h h', args.execute, False, ['x', 'y', 'z'], [None, None, None])

	def get_angular_velocity(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-angular-velocity')

		args = parser.parse_args(argv)

		device_call(ctx, IMUBrick, 3, (), '', 'h h h', args.execute, False, ['x', 'y', 'z'], [None, None, None])

	def get_all_data(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-all-data')

		args = parser.parse_args(argv)

		device_call(ctx, IMUBrick, 4, (), '', 'h h h h h h h h h h', args.execute, False, ['acc-x', 'acc-y', 'acc-z', 'mag-x', 'mag-y', 'mag-z', 'ang-x', 'ang-y', 'ang-z', 'temperature'], [None, None, None, None, None, None, None, None, None, None])

	def get_orientation(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-orientation')

		args = parser.parse_args(argv)

		device_call(ctx, IMUBrick, 5, (), '', 'h h h', args.execute, False, ['roll', 'pitch', 'yaw'], [None, None, None])

	def get_quaternion(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-quaternion')

		args = parser.parse_args(argv)

		device_call(ctx, IMUBrick, 6, (), '', 'f f f f', args.execute, False, ['x', 'y', 'z', 'w'], [None, None, None, None])

	def get_imu_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-imu-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, IMUBrick, 7, (), '', 'h', args.execute, False, ['temperature'], [None])

	def leds_on(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' leds-on')

		args = parser.parse_args(argv)

		device_call(ctx, IMUBrick, 8, (), '', '', None, args.expect_response, [], [])

	def leds_off(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' leds-off')

		args = parser.parse_args(argv)

		device_call(ctx, IMUBrick, 9, (), '', '', None, args.expect_response, [], [])

	def are_leds_on(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' are-leds-on')

		args = parser.parse_args(argv)

		device_call(ctx, IMUBrick, 10, (), '', '!', args.execute, False, ['leds'], [None])

	def set_acceleration_range(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-acceleration-range')

		parser.add_argument('range', type=convert_int, help='int', metavar='<range>')

		args = parser.parse_args(argv)

		device_call(ctx, IMUBrick, 11, (args.range,), 'B', '', None, args.expect_response, [], [])

	def get_acceleration_range(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-acceleration-range')

		args = parser.parse_args(argv)

		device_call(ctx, IMUBrick, 12, (), '', 'B', args.execute, False, ['range'], [None])

	def set_magnetometer_range(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-magnetometer-range')

		parser.add_argument('range', type=convert_int, help='int', metavar='<range>')

		args = parser.parse_args(argv)

		device_call(ctx, IMUBrick, 13, (args.range,), 'B', '', None, args.expect_response, [], [])

	def get_magnetometer_range(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-magnetometer-range')

		args = parser.parse_args(argv)

		device_call(ctx, IMUBrick, 14, (), '', 'B', args.execute, False, ['range'], [None])

	def set_convergence_speed(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-convergence-speed')

		parser.add_argument('speed', type=convert_int, help='int', metavar='<speed>')

		args = parser.parse_args(argv)

		device_call(ctx, IMUBrick, 15, (args.speed,), 'H', '', None, args.expect_response, [], [])

	def get_convergence_speed(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-convergence-speed')

		args = parser.parse_args(argv)

		device_call(ctx, IMUBrick, 16, (), '', 'H', args.execute, False, ['speed'], [None])

	def set_calibration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-calibration')

		parser.add_argument('typ', type=create_symbol_converter(ctx, convert_int, {'calibration-type-accelerometer-gain': 0, 'calibration-type-gyroscope-gain': 4, 'calibration-type-gyroscope-bias': 5, 'calibration-type-magnetometer-bias': 3, 'calibration-type-magnetometer-gain': 2, 'calibration-type-accelerometer-bias': 1}), help='int (calibration-type-accelerometer-gain: 0, calibration-type-accelerometer-bias: 1, calibration-type-magnetometer-gain: 2, calibration-type-magnetometer-bias: 3, calibration-type-gyroscope-gain: 4, calibration-type-gyroscope-bias: 5)', metavar='<typ>')
		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 10), help=get_array_type_name(ctx, 'int', 10), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, IMUBrick, 17, (args.typ, args.data), 'B 10h', '', None, args.expect_response, [], [])

	def get_calibration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-calibration')

		parser.add_argument('typ', type=create_symbol_converter(ctx, convert_int, {'calibration-type-accelerometer-gain': 0, 'calibration-type-gyroscope-gain': 4, 'calibration-type-gyroscope-bias': 5, 'calibration-type-magnetometer-bias': 3, 'calibration-type-magnetometer-gain': 2, 'calibration-type-accelerometer-bias': 1}), help='int (calibration-type-accelerometer-gain: 0, calibration-type-accelerometer-bias: 1, calibration-type-magnetometer-gain: 2, calibration-type-magnetometer-bias: 3, calibration-type-gyroscope-gain: 4, calibration-type-gyroscope-bias: 5)', metavar='<typ>')

		args = parser.parse_args(argv)

		device_call(ctx, IMUBrick, 18, (args.typ,), 'B', '10h', args.execute, False, ['data'], [None])

	def set_acceleration_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-acceleration-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, IMUBrick, 19, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_acceleration_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-acceleration-period')

		args = parser.parse_args(argv)

		device_call(ctx, IMUBrick, 20, (), '', 'I', args.execute, False, ['period'], [None])

	def set_magnetic_field_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-magnetic-field-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, IMUBrick, 21, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_magnetic_field_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-magnetic-field-period')

		args = parser.parse_args(argv)

		device_call(ctx, IMUBrick, 22, (), '', 'I', args.execute, False, ['period'], [None])

	def set_angular_velocity_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-angular-velocity-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, IMUBrick, 23, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_angular_velocity_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-angular-velocity-period')

		args = parser.parse_args(argv)

		device_call(ctx, IMUBrick, 24, (), '', 'I', args.execute, False, ['period'], [None])

	def set_all_data_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-all-data-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, IMUBrick, 25, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_all_data_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-all-data-period')

		args = parser.parse_args(argv)

		device_call(ctx, IMUBrick, 26, (), '', 'I', args.execute, False, ['period'], [None])

	def set_orientation_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-orientation-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, IMUBrick, 27, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_orientation_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-orientation-period')

		args = parser.parse_args(argv)

		device_call(ctx, IMUBrick, 28, (), '', 'I', args.execute, False, ['period'], [None])

	def set_quaternion_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-quaternion-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, IMUBrick, 29, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_quaternion_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-quaternion-period')

		args = parser.parse_args(argv)

		device_call(ctx, IMUBrick, 30, (), '', 'I', args.execute, False, ['period'], [None])

	def orientation_calculation_on(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' orientation-calculation-on')

		args = parser.parse_args(argv)

		device_call(ctx, IMUBrick, 37, (), '', '', None, args.expect_response, [], [])

	def orientation_calculation_off(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' orientation-calculation-off')

		args = parser.parse_args(argv)

		device_call(ctx, IMUBrick, 38, (), '', '', None, args.expect_response, [], [])

	def is_orientation_calculation_on(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' is-orientation-calculation-on')

		args = parser.parse_args(argv)

		device_call(ctx, IMUBrick, 39, (), '', '!', args.execute, False, ['orientation-calculation-on'], [None])

	def set_spitfp_baudrate_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-spitfp-baudrate-config')

		parser.add_argument('enable_dynamic_baudrate', type=convert_bool, help='bool', metavar='<enable-dynamic-baudrate>')
		parser.add_argument('minimum_dynamic_baudrate', type=convert_int, help='int', metavar='<minimum-dynamic-baudrate>')

		args = parser.parse_args(argv)

		device_call(ctx, IMUBrick, 231, (args.enable_dynamic_baudrate, args.minimum_dynamic_baudrate), '! I', '', None, args.expect_response, [], [])

	def get_spitfp_baudrate_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-baudrate-config')

		args = parser.parse_args(argv)

		device_call(ctx, IMUBrick, 232, (), '', '! I', args.execute, False, ['enable-dynamic-baudrate', 'minimum-dynamic-baudrate'], [None, None])

	def get_send_timeout_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-send-timeout-count')

		parser.add_argument('communication_method', type=create_symbol_converter(ctx, convert_int, {'communication-method-none': 0, 'communication-method-rs485': 4, 'communication-method-usb': 1, 'communication-method-wifi-v2': 7, 'communication-method-spi-stack': 2, 'communication-method-wifi': 5, 'communication-method-chibi': 3, 'communication-method-ethernet': 6}), help='int (communication-method-none: 0, communication-method-usb: 1, communication-method-spi-stack: 2, communication-method-chibi: 3, communication-method-rs485: 4, communication-method-wifi: 5, communication-method-ethernet: 6, communication-method-wifi-v2: 7)', metavar='<communication-method>')

		args = parser.parse_args(argv)

		device_call(ctx, IMUBrick, 233, (args.communication_method,), 'B', 'I', args.execute, False, ['timeout-count'], [None])

	def set_spitfp_baudrate(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-spitfp-baudrate')

		parser.add_argument('bricklet_port', type=create_char_converter(ctx), help='char', metavar='<bricklet-port>')
		parser.add_argument('baudrate', type=convert_int, help='int', metavar='<baudrate>')

		args = parser.parse_args(argv)

		device_call(ctx, IMUBrick, 234, (args.bricklet_port, args.baudrate), 'c I', '', None, args.expect_response, [], [])

	def get_spitfp_baudrate(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-baudrate')

		parser.add_argument('bricklet_port', type=create_char_converter(ctx), help='char', metavar='<bricklet-port>')

		args = parser.parse_args(argv)

		device_call(ctx, IMUBrick, 235, (args.bricklet_port,), 'c', 'I', args.execute, False, ['baudrate'], [None])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		parser.add_argument('bricklet_port', type=create_char_converter(ctx), help='char', metavar='<bricklet-port>')

		args = parser.parse_args(argv)

		device_call(ctx, IMUBrick, 237, (args.bricklet_port,), 'c', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def enable_status_led(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' enable-status-led')

		args = parser.parse_args(argv)

		device_call(ctx, IMUBrick, 238, (), '', '', None, args.expect_response, [], [])

	def disable_status_led(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' disable-status-led')

		args = parser.parse_args(argv)

		device_call(ctx, IMUBrick, 239, (), '', '', None, args.expect_response, [], [])

	def is_status_led_enabled(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' is-status-led-enabled')

		args = parser.parse_args(argv)

		device_call(ctx, IMUBrick, 240, (), '', '!', args.execute, False, ['enabled'], [None])

	def get_protocol1_bricklet_name(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-protocol1-bricklet-name')

		parser.add_argument('port', type=create_char_converter(ctx), help='char', metavar='<port>')

		args = parser.parse_args(argv)

		device_call(ctx, IMUBrick, 241, (args.port,), 'c', 'B 3B 40s', args.execute, False, ['protocol-version', 'firmware-version', 'name'], [None, None, None])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, IMUBrick, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, IMUBrick, 243, (), '', '', None, args.expect_response, [], [])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, IMUBrick, argv)

	functions = {
	'get-acceleration': get_acceleration,
	'get-magnetic-field': get_magnetic_field,
	'get-angular-velocity': get_angular_velocity,
	'get-all-data': get_all_data,
	'get-orientation': get_orientation,
	'get-quaternion': get_quaternion,
	'get-imu-temperature': get_imu_temperature,
	'leds-on': leds_on,
	'leds-off': leds_off,
	'are-leds-on': are_leds_on,
	'set-acceleration-range': set_acceleration_range,
	'get-acceleration-range': get_acceleration_range,
	'set-magnetometer-range': set_magnetometer_range,
	'get-magnetometer-range': get_magnetometer_range,
	'set-convergence-speed': set_convergence_speed,
	'get-convergence-speed': get_convergence_speed,
	'set-calibration': set_calibration,
	'get-calibration': get_calibration,
	'set-acceleration-period': set_acceleration_period,
	'get-acceleration-period': get_acceleration_period,
	'set-magnetic-field-period': set_magnetic_field_period,
	'get-magnetic-field-period': get_magnetic_field_period,
	'set-angular-velocity-period': set_angular_velocity_period,
	'get-angular-velocity-period': get_angular_velocity_period,
	'set-all-data-period': set_all_data_period,
	'get-all-data-period': get_all_data_period,
	'set-orientation-period': set_orientation_period,
	'get-orientation-period': get_orientation_period,
	'set-quaternion-period': set_quaternion_period,
	'get-quaternion-period': get_quaternion_period,
	'orientation-calculation-on': orientation_calculation_on,
	'orientation-calculation-off': orientation_calculation_off,
	'is-orientation-calculation-on': is_orientation_calculation_on,
	'set-spitfp-baudrate-config': set_spitfp_baudrate_config,
	'get-spitfp-baudrate-config': get_spitfp_baudrate_config,
	'get-send-timeout-count': get_send_timeout_count,
	'set-spitfp-baudrate': set_spitfp_baudrate,
	'get-spitfp-baudrate': get_spitfp_baudrate,
	'get-spitfp-error-count': get_spitfp_error_count,
	'enable-status-led': enable_status_led,
	'disable-status-led': disable_status_led,
	'is-status-led-enabled': is_status_led_enabled,
	'get-protocol1-bricklet-name': get_protocol1_bricklet_name,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'get-identity': get_identity
	}

	call_generic(ctx, 'imu-brick', functions, argv)

def dispatch_imu_brick(ctx, argv):
	prog_prefix = 'dispatch imu-brick <uid>'

	def acceleration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' acceleration')

		args = parser.parse_args(argv)

		device_dispatch(ctx, IMUBrick, 31, args.execute, ['x', 'y', 'z'], [None, None, None])

	def magnetic_field(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' magnetic-field')

		args = parser.parse_args(argv)

		device_dispatch(ctx, IMUBrick, 32, args.execute, ['x', 'y', 'z'], [None, None, None])

	def angular_velocity(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' angular-velocity')

		args = parser.parse_args(argv)

		device_dispatch(ctx, IMUBrick, 33, args.execute, ['x', 'y', 'z'], [None, None, None])

	def all_data(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' all-data')

		args = parser.parse_args(argv)

		device_dispatch(ctx, IMUBrick, 34, args.execute, ['acc-x', 'acc-y', 'acc-z', 'mag-x', 'mag-y', 'mag-z', 'ang-x', 'ang-y', 'ang-z', 'temperature'], [None, None, None, None, None, None, None, None, None, None])

	def orientation(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' orientation')

		args = parser.parse_args(argv)

		device_dispatch(ctx, IMUBrick, 35, args.execute, ['roll', 'pitch', 'yaw'], [None, None, None])

	def quaternion(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' quaternion')

		args = parser.parse_args(argv)

		device_dispatch(ctx, IMUBrick, 36, args.execute, ['x', 'y', 'z', 'w'], [None, None, None, None])

	callbacks = {
	'acceleration': acceleration,
	'magnetic-field': magnetic_field,
	'angular-velocity': angular_velocity,
	'all-data': all_data,
	'orientation': orientation,
	'quaternion': quaternion
	}

	dispatch_generic(ctx, 'imu-brick', callbacks, argv)

class IMUV2Brick(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 1; re[3] = 1; re[4] = 1; re[5] = 1; re[6] = 1; re[7] = 1; re[8] = 1; re[9] = 1; re[10] = 3; re[11] = 3; re[12] = 1; re[13] = 1; re[14] = 2; re[15] = 1; re[16] = 2; re[17] = 1; re[18] = 2; re[19] = 1; re[20] = 2; re[21] = 1; re[22] = 2; re[23] = 1; re[24] = 2; re[25] = 1; re[26] = 2; re[27] = 1; re[28] = 2; re[29] = 1; re[30] = 2; re[31] = 1; re[41] = 3; re[42] = 1; re[43] = 3; re[44] = 1; re[231] = 3; re[232] = 1; re[233] = 1; re[234] = 3; re[235] = 1; re[237] = 1; re[238] = 3; re[239] = 3; re[240] = 1; re[241] = 1; re[242] = 1; re[243] = 3; re[255] = 1
		cf = self.callback_formats
		cf[32] = 'h h h'; cf[33] = 'h h h'; cf[34] = 'h h h'; cf[35] = 'b'; cf[36] = 'h h h'; cf[37] = 'h h h'; cf[38] = 'h h h'; cf[39] = 'h h h h'; cf[40] = '3h 3h 3h 3h 4h 3h 3h b B'


def call_imu_v2_brick(ctx, argv):
	prog_prefix = 'call imu-v2-brick <uid>'

	def get_acceleration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-acceleration')

		args = parser.parse_args(argv)

		device_call(ctx, IMUV2Brick, 1, (), '', 'h h h', args.execute, False, ['x', 'y', 'z'], [None, None, None])

	def get_magnetic_field(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-magnetic-field')

		args = parser.parse_args(argv)

		device_call(ctx, IMUV2Brick, 2, (), '', 'h h h', args.execute, False, ['x', 'y', 'z'], [None, None, None])

	def get_angular_velocity(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-angular-velocity')

		args = parser.parse_args(argv)

		device_call(ctx, IMUV2Brick, 3, (), '', 'h h h', args.execute, False, ['x', 'y', 'z'], [None, None, None])

	def get_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, IMUV2Brick, 4, (), '', 'b', args.execute, False, ['temperature'], [None])

	def get_orientation(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-orientation')

		args = parser.parse_args(argv)

		device_call(ctx, IMUV2Brick, 5, (), '', 'h h h', args.execute, False, ['heading', 'roll', 'pitch'], [None, None, None])

	def get_linear_acceleration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-linear-acceleration')

		args = parser.parse_args(argv)

		device_call(ctx, IMUV2Brick, 6, (), '', 'h h h', args.execute, False, ['x', 'y', 'z'], [None, None, None])

	def get_gravity_vector(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-gravity-vector')

		args = parser.parse_args(argv)

		device_call(ctx, IMUV2Brick, 7, (), '', 'h h h', args.execute, False, ['x', 'y', 'z'], [None, None, None])

	def get_quaternion(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-quaternion')

		args = parser.parse_args(argv)

		device_call(ctx, IMUV2Brick, 8, (), '', 'h h h h', args.execute, False, ['w', 'x', 'y', 'z'], [None, None, None, None])

	def get_all_data(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-all-data')

		args = parser.parse_args(argv)

		device_call(ctx, IMUV2Brick, 9, (), '', '3h 3h 3h 3h 4h 3h 3h b B', args.execute, False, ['acceleration', 'magnetic-field', 'angular-velocity', 'euler-angle', 'quaternion', 'linear-acceleration', 'gravity-vector', 'temperature', 'calibration-status'], [None, None, None, None, None, None, None, None, None])

	def leds_on(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' leds-on')

		args = parser.parse_args(argv)

		device_call(ctx, IMUV2Brick, 10, (), '', '', None, args.expect_response, [], [])

	def leds_off(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' leds-off')

		args = parser.parse_args(argv)

		device_call(ctx, IMUV2Brick, 11, (), '', '', None, args.expect_response, [], [])

	def are_leds_on(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' are-leds-on')

		args = parser.parse_args(argv)

		device_call(ctx, IMUV2Brick, 12, (), '', '!', args.execute, False, ['leds'], [None])

	def save_calibration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' save-calibration')

		args = parser.parse_args(argv)

		device_call(ctx, IMUV2Brick, 13, (), '', '!', args.execute, False, ['calibration-done'], [None])

	def set_acceleration_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-acceleration-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, IMUV2Brick, 14, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_acceleration_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-acceleration-period')

		args = parser.parse_args(argv)

		device_call(ctx, IMUV2Brick, 15, (), '', 'I', args.execute, False, ['period'], [None])

	def set_magnetic_field_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-magnetic-field-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, IMUV2Brick, 16, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_magnetic_field_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-magnetic-field-period')

		args = parser.parse_args(argv)

		device_call(ctx, IMUV2Brick, 17, (), '', 'I', args.execute, False, ['period'], [None])

	def set_angular_velocity_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-angular-velocity-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, IMUV2Brick, 18, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_angular_velocity_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-angular-velocity-period')

		args = parser.parse_args(argv)

		device_call(ctx, IMUV2Brick, 19, (), '', 'I', args.execute, False, ['period'], [None])

	def set_temperature_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-temperature-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, IMUV2Brick, 20, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_temperature_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-temperature-period')

		args = parser.parse_args(argv)

		device_call(ctx, IMUV2Brick, 21, (), '', 'I', args.execute, False, ['period'], [None])

	def set_orientation_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-orientation-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, IMUV2Brick, 22, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_orientation_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-orientation-period')

		args = parser.parse_args(argv)

		device_call(ctx, IMUV2Brick, 23, (), '', 'I', args.execute, False, ['period'], [None])

	def set_linear_acceleration_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-linear-acceleration-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, IMUV2Brick, 24, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_linear_acceleration_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-linear-acceleration-period')

		args = parser.parse_args(argv)

		device_call(ctx, IMUV2Brick, 25, (), '', 'I', args.execute, False, ['period'], [None])

	def set_gravity_vector_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-gravity-vector-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, IMUV2Brick, 26, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_gravity_vector_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-gravity-vector-period')

		args = parser.parse_args(argv)

		device_call(ctx, IMUV2Brick, 27, (), '', 'I', args.execute, False, ['period'], [None])

	def set_quaternion_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-quaternion-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, IMUV2Brick, 28, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_quaternion_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-quaternion-period')

		args = parser.parse_args(argv)

		device_call(ctx, IMUV2Brick, 29, (), '', 'I', args.execute, False, ['period'], [None])

	def set_all_data_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-all-data-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, IMUV2Brick, 30, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_all_data_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-all-data-period')

		args = parser.parse_args(argv)

		device_call(ctx, IMUV2Brick, 31, (), '', 'I', args.execute, False, ['period'], [None])

	def set_sensor_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-sensor-configuration')

		parser.add_argument('magnetometer_rate', type=create_symbol_converter(ctx, convert_int, {'magnetometer-rate-10hz': 3, 'magnetometer-rate-30hz': 7, 'magnetometer-rate-25hz': 6, 'magnetometer-rate-15hz': 4, 'magnetometer-rate-2hz': 0, 'magnetometer-rate-6hz': 1, 'magnetometer-rate-20hz': 5, 'magnetometer-rate-8hz': 2}), help='int (magnetometer-rate-2hz: 0, magnetometer-rate-6hz: 1, magnetometer-rate-8hz: 2, magnetometer-rate-10hz: 3, magnetometer-rate-15hz: 4, magnetometer-rate-20hz: 5, magnetometer-rate-25hz: 6, magnetometer-rate-30hz: 7)', metavar='<magnetometer-rate>')
		parser.add_argument('gyroscope_range', type=create_symbol_converter(ctx, convert_int, {'gyroscope-range-1000dps': 1, 'gyroscope-range-2000dps': 0, 'gyroscope-range-125dps': 4, 'gyroscope-range-250dps': 3, 'gyroscope-range-500dps': 2}), help='int (gyroscope-range-2000dps: 0, gyroscope-range-1000dps: 1, gyroscope-range-500dps: 2, gyroscope-range-250dps: 3, gyroscope-range-125dps: 4)', metavar='<gyroscope-range>')
		parser.add_argument('gyroscope_bandwidth', type=create_symbol_converter(ctx, convert_int, {'gyroscope-bandwidth-523hz': 0, 'gyroscope-bandwidth-32hz': 7, 'gyroscope-bandwidth-116hz': 2, 'gyroscope-bandwidth-64hz': 6, 'gyroscope-bandwidth-12hz': 5, 'gyroscope-bandwidth-230hz': 1, 'gyroscope-bandwidth-23hz': 4, 'gyroscope-bandwidth-47hz': 3}), help='int (gyroscope-bandwidth-523hz: 0, gyroscope-bandwidth-230hz: 1, gyroscope-bandwidth-116hz: 2, gyroscope-bandwidth-47hz: 3, gyroscope-bandwidth-23hz: 4, gyroscope-bandwidth-12hz: 5, gyroscope-bandwidth-64hz: 6, gyroscope-bandwidth-32hz: 7)', metavar='<gyroscope-bandwidth>')
		parser.add_argument('accelerometer_range', type=create_symbol_converter(ctx, convert_int, {'accelerometer-range-4g': 1, 'accelerometer-range-16g': 3, 'accelerometer-range-2g': 0, 'accelerometer-range-8g': 2}), help='int (accelerometer-range-2g: 0, accelerometer-range-4g: 1, accelerometer-range-8g: 2, accelerometer-range-16g: 3)', metavar='<accelerometer-range>')
		parser.add_argument('accelerometer_bandwidth', type=create_symbol_converter(ctx, convert_int, {'accelerometer-bandwidth-62-5hz': 3, 'accelerometer-bandwidth-250hz': 5, 'accelerometer-bandwidth-31-25hz': 2, 'accelerometer-bandwidth-15-63hz': 1, 'accelerometer-bandwidth-125hz': 4, 'accelerometer-bandwidth-500hz': 6, 'accelerometer-bandwidth-1000hz': 7, 'accelerometer-bandwidth-7-81hz': 0}), help='int (accelerometer-bandwidth-7-81hz: 0, accelerometer-bandwidth-15-63hz: 1, accelerometer-bandwidth-31-25hz: 2, accelerometer-bandwidth-62-5hz: 3, accelerometer-bandwidth-125hz: 4, accelerometer-bandwidth-250hz: 5, accelerometer-bandwidth-500hz: 6, accelerometer-bandwidth-1000hz: 7)', metavar='<accelerometer-bandwidth>')

		args = parser.parse_args(argv)

		device_call(ctx, IMUV2Brick, 41, (args.magnetometer_rate, args.gyroscope_range, args.gyroscope_bandwidth, args.accelerometer_range, args.accelerometer_bandwidth), 'B B B B B', '', None, args.expect_response, [], [])

	def get_sensor_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-sensor-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, IMUV2Brick, 42, (), '', 'B B B B B', args.execute, False, ['magnetometer-rate', 'gyroscope-range', 'gyroscope-bandwidth', 'accelerometer-range', 'accelerometer-bandwidth'], [{0: 'magnetometer-rate-2hz', 1: 'magnetometer-rate-6hz', 2: 'magnetometer-rate-8hz', 3: 'magnetometer-rate-10hz', 4: 'magnetometer-rate-15hz', 5: 'magnetometer-rate-20hz', 6: 'magnetometer-rate-25hz', 7: 'magnetometer-rate-30hz'}, {0: 'gyroscope-range-2000dps', 1: 'gyroscope-range-1000dps', 2: 'gyroscope-range-500dps', 3: 'gyroscope-range-250dps', 4: 'gyroscope-range-125dps'}, {0: 'gyroscope-bandwidth-523hz', 1: 'gyroscope-bandwidth-230hz', 2: 'gyroscope-bandwidth-116hz', 3: 'gyroscope-bandwidth-47hz', 4: 'gyroscope-bandwidth-23hz', 5: 'gyroscope-bandwidth-12hz', 6: 'gyroscope-bandwidth-64hz', 7: 'gyroscope-bandwidth-32hz'}, {0: 'accelerometer-range-2g', 1: 'accelerometer-range-4g', 2: 'accelerometer-range-8g', 3: 'accelerometer-range-16g'}, {0: 'accelerometer-bandwidth-7-81hz', 1: 'accelerometer-bandwidth-15-63hz', 2: 'accelerometer-bandwidth-31-25hz', 3: 'accelerometer-bandwidth-62-5hz', 4: 'accelerometer-bandwidth-125hz', 5: 'accelerometer-bandwidth-250hz', 6: 'accelerometer-bandwidth-500hz', 7: 'accelerometer-bandwidth-1000hz'}])

	def set_sensor_fusion_mode(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-sensor-fusion-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'sensor-fusion-on-without-magnetometer': 2, 'sensor-fusion-on-without-fast-magnetometer-calibration': 3, 'sensor-fusion-off': 0, 'sensor-fusion-on': 1}), help='int (sensor-fusion-off: 0, sensor-fusion-on: 1, sensor-fusion-on-without-magnetometer: 2, sensor-fusion-on-without-fast-magnetometer-calibration: 3)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, IMUV2Brick, 43, (args.mode,), 'B', '', None, args.expect_response, [], [])

	def get_sensor_fusion_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-sensor-fusion-mode')

		args = parser.parse_args(argv)

		device_call(ctx, IMUV2Brick, 44, (), '', 'B', args.execute, False, ['mode'], [{0: 'sensor-fusion-off', 1: 'sensor-fusion-on', 2: 'sensor-fusion-on-without-magnetometer', 3: 'sensor-fusion-on-without-fast-magnetometer-calibration'}])

	def set_spitfp_baudrate_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-spitfp-baudrate-config')

		parser.add_argument('enable_dynamic_baudrate', type=convert_bool, help='bool', metavar='<enable-dynamic-baudrate>')
		parser.add_argument('minimum_dynamic_baudrate', type=convert_int, help='int', metavar='<minimum-dynamic-baudrate>')

		args = parser.parse_args(argv)

		device_call(ctx, IMUV2Brick, 231, (args.enable_dynamic_baudrate, args.minimum_dynamic_baudrate), '! I', '', None, args.expect_response, [], [])

	def get_spitfp_baudrate_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-baudrate-config')

		args = parser.parse_args(argv)

		device_call(ctx, IMUV2Brick, 232, (), '', '! I', args.execute, False, ['enable-dynamic-baudrate', 'minimum-dynamic-baudrate'], [None, None])

	def get_send_timeout_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-send-timeout-count')

		parser.add_argument('communication_method', type=create_symbol_converter(ctx, convert_int, {'communication-method-none': 0, 'communication-method-rs485': 4, 'communication-method-usb': 1, 'communication-method-wifi-v2': 7, 'communication-method-spi-stack': 2, 'communication-method-wifi': 5, 'communication-method-chibi': 3, 'communication-method-ethernet': 6}), help='int (communication-method-none: 0, communication-method-usb: 1, communication-method-spi-stack: 2, communication-method-chibi: 3, communication-method-rs485: 4, communication-method-wifi: 5, communication-method-ethernet: 6, communication-method-wifi-v2: 7)', metavar='<communication-method>')

		args = parser.parse_args(argv)

		device_call(ctx, IMUV2Brick, 233, (args.communication_method,), 'B', 'I', args.execute, False, ['timeout-count'], [None])

	def set_spitfp_baudrate(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-spitfp-baudrate')

		parser.add_argument('bricklet_port', type=create_char_converter(ctx), help='char', metavar='<bricklet-port>')
		parser.add_argument('baudrate', type=convert_int, help='int', metavar='<baudrate>')

		args = parser.parse_args(argv)

		device_call(ctx, IMUV2Brick, 234, (args.bricklet_port, args.baudrate), 'c I', '', None, args.expect_response, [], [])

	def get_spitfp_baudrate(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-baudrate')

		parser.add_argument('bricklet_port', type=create_char_converter(ctx), help='char', metavar='<bricklet-port>')

		args = parser.parse_args(argv)

		device_call(ctx, IMUV2Brick, 235, (args.bricklet_port,), 'c', 'I', args.execute, False, ['baudrate'], [None])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		parser.add_argument('bricklet_port', type=create_char_converter(ctx), help='char', metavar='<bricklet-port>')

		args = parser.parse_args(argv)

		device_call(ctx, IMUV2Brick, 237, (args.bricklet_port,), 'c', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def enable_status_led(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' enable-status-led')

		args = parser.parse_args(argv)

		device_call(ctx, IMUV2Brick, 238, (), '', '', None, args.expect_response, [], [])

	def disable_status_led(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' disable-status-led')

		args = parser.parse_args(argv)

		device_call(ctx, IMUV2Brick, 239, (), '', '', None, args.expect_response, [], [])

	def is_status_led_enabled(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' is-status-led-enabled')

		args = parser.parse_args(argv)

		device_call(ctx, IMUV2Brick, 240, (), '', '!', args.execute, False, ['enabled'], [None])

	def get_protocol1_bricklet_name(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-protocol1-bricklet-name')

		parser.add_argument('port', type=create_char_converter(ctx), help='char', metavar='<port>')

		args = parser.parse_args(argv)

		device_call(ctx, IMUV2Brick, 241, (args.port,), 'c', 'B 3B 40s', args.execute, False, ['protocol-version', 'firmware-version', 'name'], [None, None, None])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, IMUV2Brick, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, IMUV2Brick, 243, (), '', '', None, args.expect_response, [], [])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, IMUV2Brick, argv)

	functions = {
	'get-acceleration': get_acceleration,
	'get-magnetic-field': get_magnetic_field,
	'get-angular-velocity': get_angular_velocity,
	'get-temperature': get_temperature,
	'get-orientation': get_orientation,
	'get-linear-acceleration': get_linear_acceleration,
	'get-gravity-vector': get_gravity_vector,
	'get-quaternion': get_quaternion,
	'get-all-data': get_all_data,
	'leds-on': leds_on,
	'leds-off': leds_off,
	'are-leds-on': are_leds_on,
	'save-calibration': save_calibration,
	'set-acceleration-period': set_acceleration_period,
	'get-acceleration-period': get_acceleration_period,
	'set-magnetic-field-period': set_magnetic_field_period,
	'get-magnetic-field-period': get_magnetic_field_period,
	'set-angular-velocity-period': set_angular_velocity_period,
	'get-angular-velocity-period': get_angular_velocity_period,
	'set-temperature-period': set_temperature_period,
	'get-temperature-period': get_temperature_period,
	'set-orientation-period': set_orientation_period,
	'get-orientation-period': get_orientation_period,
	'set-linear-acceleration-period': set_linear_acceleration_period,
	'get-linear-acceleration-period': get_linear_acceleration_period,
	'set-gravity-vector-period': set_gravity_vector_period,
	'get-gravity-vector-period': get_gravity_vector_period,
	'set-quaternion-period': set_quaternion_period,
	'get-quaternion-period': get_quaternion_period,
	'set-all-data-period': set_all_data_period,
	'get-all-data-period': get_all_data_period,
	'set-sensor-configuration': set_sensor_configuration,
	'get-sensor-configuration': get_sensor_configuration,
	'set-sensor-fusion-mode': set_sensor_fusion_mode,
	'get-sensor-fusion-mode': get_sensor_fusion_mode,
	'set-spitfp-baudrate-config': set_spitfp_baudrate_config,
	'get-spitfp-baudrate-config': get_spitfp_baudrate_config,
	'get-send-timeout-count': get_send_timeout_count,
	'set-spitfp-baudrate': set_spitfp_baudrate,
	'get-spitfp-baudrate': get_spitfp_baudrate,
	'get-spitfp-error-count': get_spitfp_error_count,
	'enable-status-led': enable_status_led,
	'disable-status-led': disable_status_led,
	'is-status-led-enabled': is_status_led_enabled,
	'get-protocol1-bricklet-name': get_protocol1_bricklet_name,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'get-identity': get_identity
	}

	call_generic(ctx, 'imu-v2-brick', functions, argv)

def dispatch_imu_v2_brick(ctx, argv):
	prog_prefix = 'dispatch imu-v2-brick <uid>'

	def acceleration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' acceleration')

		args = parser.parse_args(argv)

		device_dispatch(ctx, IMUV2Brick, 32, args.execute, ['x', 'y', 'z'], [None, None, None])

	def magnetic_field(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' magnetic-field')

		args = parser.parse_args(argv)

		device_dispatch(ctx, IMUV2Brick, 33, args.execute, ['x', 'y', 'z'], [None, None, None])

	def angular_velocity(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' angular-velocity')

		args = parser.parse_args(argv)

		device_dispatch(ctx, IMUV2Brick, 34, args.execute, ['x', 'y', 'z'], [None, None, None])

	def temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' temperature')

		args = parser.parse_args(argv)

		device_dispatch(ctx, IMUV2Brick, 35, args.execute, ['temperature'], [None])

	def linear_acceleration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' linear-acceleration')

		args = parser.parse_args(argv)

		device_dispatch(ctx, IMUV2Brick, 36, args.execute, ['x', 'y', 'z'], [None, None, None])

	def gravity_vector(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' gravity-vector')

		args = parser.parse_args(argv)

		device_dispatch(ctx, IMUV2Brick, 37, args.execute, ['x', 'y', 'z'], [None, None, None])

	def orientation(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' orientation')

		args = parser.parse_args(argv)

		device_dispatch(ctx, IMUV2Brick, 38, args.execute, ['heading', 'roll', 'pitch'], [None, None, None])

	def quaternion(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' quaternion')

		args = parser.parse_args(argv)

		device_dispatch(ctx, IMUV2Brick, 39, args.execute, ['w', 'x', 'y', 'z'], [None, None, None, None])

	def all_data(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' all-data')

		args = parser.parse_args(argv)

		device_dispatch(ctx, IMUV2Brick, 40, args.execute, ['acceleration', 'magnetic-field', 'angular-velocity', 'euler-angle', 'quaternion', 'linear-acceleration', 'gravity-vector', 'temperature', 'calibration-status'], [None, None, None, None, None, None, None, None, None])

	callbacks = {
	'acceleration': acceleration,
	'magnetic-field': magnetic_field,
	'angular-velocity': angular_velocity,
	'temperature': temperature,
	'linear-acceleration': linear_acceleration,
	'gravity-vector': gravity_vector,
	'orientation': orientation,
	'quaternion': quaternion,
	'all-data': all_data
	}

	dispatch_generic(ctx, 'imu-v2-brick', callbacks, argv)

class IndustrialAnalogOutBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 3; re[2] = 3; re[3] = 1; re[4] = 3; re[5] = 1; re[6] = 3; re[7] = 1; re[8] = 3; re[9] = 1; re[255] = 1



def call_industrial_analog_out_bricklet(ctx, argv):
	prog_prefix = 'call industrial-analog-out-bricklet <uid>'

	def enable(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' enable')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialAnalogOutBricklet, 1, (), '', '', None, args.expect_response, [], [])

	def disable(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' disable')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialAnalogOutBricklet, 2, (), '', '', None, args.expect_response, [], [])

	def is_enabled(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' is-enabled')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialAnalogOutBricklet, 3, (), '', '!', args.execute, False, ['enabled'], [None])

	def set_voltage(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-voltage')

		parser.add_argument('voltage', type=convert_int, help='int', metavar='<voltage>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialAnalogOutBricklet, 4, (args.voltage,), 'H', '', None, args.expect_response, [], [])

	def get_voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-voltage')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialAnalogOutBricklet, 5, (), '', 'H', args.execute, False, ['voltage'], [None])

	def set_current(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-current')

		parser.add_argument('current', type=convert_int, help='int', metavar='<current>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialAnalogOutBricklet, 6, (args.current,), 'H', '', None, args.expect_response, [], [])

	def get_current(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-current')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialAnalogOutBricklet, 7, (), '', 'H', args.execute, False, ['current'], [None])

	def set_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-configuration')

		parser.add_argument('voltage_range', type=create_symbol_converter(ctx, convert_int, {'voltage-range-0-to-5v': 0, 'voltage-range-0-to-10v': 1}), help='int (voltage-range-0-to-5v: 0, voltage-range-0-to-10v: 1)', metavar='<voltage-range>')
		parser.add_argument('current_range', type=create_symbol_converter(ctx, convert_int, {'current-range-0-to-20ma': 1, 'current-range-0-to-24ma': 2, 'current-range-4-to-20ma': 0}), help='int (current-range-4-to-20ma: 0, current-range-0-to-20ma: 1, current-range-0-to-24ma: 2)', metavar='<current-range>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialAnalogOutBricklet, 8, (args.voltage_range, args.current_range), 'B B', '', None, args.expect_response, [], [])

	def get_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialAnalogOutBricklet, 9, (), '', 'B B', args.execute, False, ['voltage-range', 'current-range'], [{0: 'voltage-range-0-to-5v', 1: 'voltage-range-0-to-10v'}, {0: 'current-range-4-to-20ma', 1: 'current-range-0-to-20ma', 2: 'current-range-0-to-24ma'}])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, IndustrialAnalogOutBricklet, argv)

	functions = {
	'enable': enable,
	'disable': disable,
	'is-enabled': is_enabled,
	'set-voltage': set_voltage,
	'get-voltage': get_voltage,
	'set-current': set_current,
	'get-current': get_current,
	'set-configuration': set_configuration,
	'get-configuration': get_configuration,
	'get-identity': get_identity
	}

	call_generic(ctx, 'industrial-analog-out-bricklet', functions, argv)

def dispatch_industrial_analog_out_bricklet(ctx, argv):
	prog_prefix = 'dispatch industrial-analog-out-bricklet <uid>'


	callbacks = {

	}

	dispatch_generic(ctx, 'industrial-analog-out-bricklet', callbacks, argv)

class IndustrialAnalogOutV2Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 3; re[2] = 1; re[3] = 3; re[4] = 1; re[5] = 3; re[6] = 1; re[7] = 3; re[8] = 1; re[9] = 3; re[10] = 1; re[11] = 3; re[12] = 1; re[234] = 1; re[235] = 1; re[236] = 1; re[237] = 3; re[238] = 1; re[239] = 3; re[240] = 1; re[242] = 1; re[243] = 3; re[248] = 3; re[249] = 1; re[255] = 1



def call_industrial_analog_out_v2_bricklet(ctx, argv):
	prog_prefix = 'call industrial-analog-out-v2-bricklet <uid>'

	def set_enabled(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-enabled')

		parser.add_argument('enabled', type=convert_bool, help='bool', metavar='<enabled>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialAnalogOutV2Bricklet, 1, (args.enabled,), '!', '', None, args.expect_response, [], [])

	def get_enabled(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-enabled')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialAnalogOutV2Bricklet, 2, (), '', '!', args.execute, False, ['enabled'], [None])

	def set_voltage(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-voltage')

		parser.add_argument('voltage', type=convert_int, help='int', metavar='<voltage>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialAnalogOutV2Bricklet, 3, (args.voltage,), 'H', '', None, args.expect_response, [], [])

	def get_voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-voltage')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialAnalogOutV2Bricklet, 4, (), '', 'H', args.execute, False, ['voltage'], [None])

	def set_current(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-current')

		parser.add_argument('current', type=convert_int, help='int', metavar='<current>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialAnalogOutV2Bricklet, 5, (args.current,), 'H', '', None, args.expect_response, [], [])

	def get_current(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-current')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialAnalogOutV2Bricklet, 6, (), '', 'H', args.execute, False, ['current'], [None])

	def set_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-configuration')

		parser.add_argument('voltage_range', type=create_symbol_converter(ctx, convert_int, {'voltage-range-0-to-5v': 0, 'voltage-range-0-to-10v': 1}), help='int (voltage-range-0-to-5v: 0, voltage-range-0-to-10v: 1)', metavar='<voltage-range>')
		parser.add_argument('current_range', type=create_symbol_converter(ctx, convert_int, {'current-range-0-to-20ma': 1, 'current-range-0-to-24ma': 2, 'current-range-4-to-20ma': 0}), help='int (current-range-4-to-20ma: 0, current-range-0-to-20ma: 1, current-range-0-to-24ma: 2)', metavar='<current-range>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialAnalogOutV2Bricklet, 7, (args.voltage_range, args.current_range), 'B B', '', None, args.expect_response, [], [])

	def get_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialAnalogOutV2Bricklet, 8, (), '', 'B B', args.execute, False, ['voltage-range', 'current-range'], [{0: 'voltage-range-0-to-5v', 1: 'voltage-range-0-to-10v'}, {0: 'current-range-4-to-20ma', 1: 'current-range-0-to-20ma', 2: 'current-range-0-to-24ma'}])

	def set_out_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-out-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'out-led-config-off': 0, 'out-led-config-show-heartbeat': 2, 'out-led-config-on': 1, 'out-led-config-show-out-status': 3}), help='int (out-led-config-off: 0, out-led-config-on: 1, out-led-config-show-heartbeat: 2, out-led-config-show-out-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialAnalogOutV2Bricklet, 9, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_out_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-out-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialAnalogOutV2Bricklet, 10, (), '', 'B', args.execute, False, ['config'], [{0: 'out-led-config-off', 1: 'out-led-config-on', 2: 'out-led-config-show-heartbeat', 3: 'out-led-config-show-out-status'}])

	def set_out_led_status_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-out-led-status-config')

		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')
		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'out-led-status-config-threshold': 0, 'out-led-status-config-intensity': 1}), help='int (out-led-status-config-threshold: 0, out-led-status-config-intensity: 1)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialAnalogOutV2Bricklet, 11, (args.min, args.max, args.config), 'H H B', '', None, args.expect_response, [], [])

	def get_out_led_status_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-out-led-status-config')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialAnalogOutV2Bricklet, 12, (), '', 'H H B', args.execute, False, ['min', 'max', 'config'], [None, None, {0: 'out-led-status-config-threshold', 1: 'out-led-status-config-intensity'}])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialAnalogOutV2Bricklet, 234, (), '', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def set_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-bootloader-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'bootloader-mode-firmware-wait-for-reboot': 3, 'bootloader-mode-firmware': 1, 'bootloader-mode-firmware-wait-for-erase-and-reboot': 4, 'bootloader-mode-bootloader-wait-for-reboot': 2, 'bootloader-mode-bootloader': 0}), help='int (bootloader-mode-bootloader: 0, bootloader-mode-firmware: 1, bootloader-mode-bootloader-wait-for-reboot: 2, bootloader-mode-firmware-wait-for-reboot: 3, bootloader-mode-firmware-wait-for-erase-and-reboot: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialAnalogOutV2Bricklet, 235, (args.mode,), 'B', 'B', args.execute, False, ['status'], [{0: 'bootloader-status-ok', 1: 'bootloader-status-invalid-mode', 2: 'bootloader-status-no-change', 3: 'bootloader-status-entry-function-not-present', 4: 'bootloader-status-device-identifier-incorrect', 5: 'bootloader-status-crc-mismatch'}])

	def get_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-bootloader-mode')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialAnalogOutV2Bricklet, 236, (), '', 'B', args.execute, False, ['mode'], [{0: 'bootloader-mode-bootloader', 1: 'bootloader-mode-firmware', 2: 'bootloader-mode-bootloader-wait-for-reboot', 3: 'bootloader-mode-firmware-wait-for-reboot', 4: 'bootloader-mode-firmware-wait-for-erase-and-reboot'}])

	def set_write_firmware_pointer(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-write-firmware-pointer')

		parser.add_argument('pointer', type=convert_int, help='int', metavar='<pointer>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialAnalogOutV2Bricklet, 237, (args.pointer,), 'I', '', None, args.expect_response, [], [])

	def write_firmware(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-firmware')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialAnalogOutV2Bricklet, 238, (args.data,), '64B', 'B', args.execute, False, ['status'], [None])

	def set_status_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'status-led-config-on': 1, 'status-led-config-show-heartbeat': 2, 'status-led-config-off': 0, 'status-led-config-show-status': 3}), help='int (status-led-config-off: 0, status-led-config-on: 1, status-led-config-show-heartbeat: 2, status-led-config-show-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialAnalogOutV2Bricklet, 239, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_status_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialAnalogOutV2Bricklet, 240, (), '', 'B', args.execute, False, ['config'], [{0: 'status-led-config-off', 1: 'status-led-config-on', 2: 'status-led-config-show-heartbeat', 3: 'status-led-config-show-status'}])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialAnalogOutV2Bricklet, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialAnalogOutV2Bricklet, 243, (), '', '', None, args.expect_response, [], [])

	def write_uid(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-uid')

		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialAnalogOutV2Bricklet, 248, (args.uid,), 'I', '', None, args.expect_response, [], [])

	def read_uid(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-uid')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialAnalogOutV2Bricklet, 249, (), '', 'I', args.execute, False, ['uid'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, IndustrialAnalogOutV2Bricklet, argv)

	functions = {
	'set-enabled': set_enabled,
	'get-enabled': get_enabled,
	'set-voltage': set_voltage,
	'get-voltage': get_voltage,
	'set-current': set_current,
	'get-current': get_current,
	'set-configuration': set_configuration,
	'get-configuration': get_configuration,
	'set-out-led-config': set_out_led_config,
	'get-out-led-config': get_out_led_config,
	'set-out-led-status-config': set_out_led_status_config,
	'get-out-led-status-config': get_out_led_status_config,
	'get-spitfp-error-count': get_spitfp_error_count,
	'set-bootloader-mode': set_bootloader_mode,
	'get-bootloader-mode': get_bootloader_mode,
	'set-write-firmware-pointer': set_write_firmware_pointer,
	'write-firmware': write_firmware,
	'set-status-led-config': set_status_led_config,
	'get-status-led-config': get_status_led_config,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'write-uid': write_uid,
	'read-uid': read_uid,
	'get-identity': get_identity
	}

	call_generic(ctx, 'industrial-analog-out-v2-bricklet', functions, argv)

def dispatch_industrial_analog_out_v2_bricklet(ctx, argv):
	prog_prefix = 'dispatch industrial-analog-out-v2-bricklet <uid>'


	callbacks = {

	}

	dispatch_generic(ctx, 'industrial-analog-out-v2-bricklet', callbacks, argv)

class IndustrialCounterBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 1; re[3] = 3; re[4] = 3; re[5] = 1; re[6] = 1; re[7] = 3; re[8] = 3; re[9] = 1; re[10] = 1; re[11] = 3; re[12] = 1; re[13] = 2; re[14] = 1; re[15] = 2; re[16] = 1; re[17] = 3; re[18] = 1; re[234] = 1; re[235] = 1; re[236] = 1; re[237] = 3; re[238] = 1; re[239] = 3; re[240] = 1; re[242] = 1; re[243] = 3; re[248] = 3; re[249] = 1; re[255] = 1
		cf = self.callback_formats
		cf[19] = '4q'; cf[20] = '4H 4Q 4I 4!'


def call_industrial_counter_bricklet(ctx, argv):
	prog_prefix = 'call industrial-counter-bricklet <uid>'

	def get_counter(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-counter')

		parser.add_argument('channel', type=create_symbol_converter(ctx, convert_int, {'channel-3': 3, 'channel-2': 2, 'channel-1': 1, 'channel-0': 0}), help='int (channel-0: 0, channel-1: 1, channel-2: 2, channel-3: 3)', metavar='<channel>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialCounterBricklet, 1, (args.channel,), 'B', 'q', args.execute, False, ['counter'], [None])

	def get_all_counter(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-all-counter')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialCounterBricklet, 2, (), '', '4q', args.execute, False, ['counter'], [None])

	def set_counter(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-counter')

		parser.add_argument('channel', type=create_symbol_converter(ctx, convert_int, {'channel-3': 3, 'channel-2': 2, 'channel-1': 1, 'channel-0': 0}), help='int (channel-0: 0, channel-1: 1, channel-2: 2, channel-3: 3)', metavar='<channel>')
		parser.add_argument('counter', type=convert_int, help='int', metavar='<counter>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialCounterBricklet, 3, (args.channel, args.counter), 'B q', '', None, args.expect_response, [], [])

	def set_all_counter(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-all-counter')

		parser.add_argument('counter', type=create_array_converter(ctx, convert_int, '0', 4), help=get_array_type_name(ctx, 'int', 4), metavar='<counter>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialCounterBricklet, 4, (args.counter,), '4q', '', None, args.expect_response, [], [])

	def get_signal_data(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-signal-data')

		parser.add_argument('channel', type=create_symbol_converter(ctx, convert_int, {'channel-3': 3, 'channel-2': 2, 'channel-1': 1, 'channel-0': 0}), help='int (channel-0: 0, channel-1: 1, channel-2: 2, channel-3: 3)', metavar='<channel>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialCounterBricklet, 5, (args.channel,), 'B', 'H Q I !', args.execute, False, ['duty-cycle', 'period', 'frequency', 'value'], [None, None, None, None])

	def get_all_signal_data(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-all-signal-data')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialCounterBricklet, 6, (), '', '4H 4Q 4I 4!', args.execute, False, ['duty-cycle', 'period', 'frequency', 'value'], [None, None, None, None])

	def set_counter_active(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-counter-active')

		parser.add_argument('channel', type=create_symbol_converter(ctx, convert_int, {'channel-3': 3, 'channel-2': 2, 'channel-1': 1, 'channel-0': 0}), help='int (channel-0: 0, channel-1: 1, channel-2: 2, channel-3: 3)', metavar='<channel>')
		parser.add_argument('active', type=convert_bool, help='bool', metavar='<active>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialCounterBricklet, 7, (args.channel, args.active), 'B !', '', None, args.expect_response, [], [])

	def set_all_counter_active(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-all-counter-active')

		parser.add_argument('active', type=create_array_converter(ctx, convert_bool, 'false', 4), help=get_array_type_name(ctx, 'bool', 4), metavar='<active>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialCounterBricklet, 8, (args.active,), '4!', '', None, args.expect_response, [], [])

	def get_counter_active(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-counter-active')

		parser.add_argument('channel', type=create_symbol_converter(ctx, convert_int, {'channel-3': 3, 'channel-2': 2, 'channel-1': 1, 'channel-0': 0}), help='int (channel-0: 0, channel-1: 1, channel-2: 2, channel-3: 3)', metavar='<channel>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialCounterBricklet, 9, (args.channel,), 'B', '!', args.execute, False, ['active'], [None])

	def get_all_counter_active(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-all-counter-active')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialCounterBricklet, 10, (), '', '4!', args.execute, False, ['active'], [None])

	def set_counter_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-counter-configuration')

		parser.add_argument('channel', type=create_symbol_converter(ctx, convert_int, {'channel-3': 3, 'channel-2': 2, 'channel-1': 1, 'channel-0': 0}), help='int (channel-0: 0, channel-1: 1, channel-2: 2, channel-3: 3)', metavar='<channel>')
		parser.add_argument('count_edge', type=create_symbol_converter(ctx, convert_int, {'count-edge-both': 2, 'count-edge-rising': 0, 'count-edge-falling': 1}), help='int (count-edge-rising: 0, count-edge-falling: 1, count-edge-both: 2)', metavar='<count-edge>')
		parser.add_argument('count_direction', type=create_symbol_converter(ctx, convert_int, {'count-direction-external-up': 2, 'count-direction-down': 1, 'count-direction-external-down': 3, 'count-direction-up': 0}), help='int (count-direction-up: 0, count-direction-down: 1, count-direction-external-up: 2, count-direction-external-down: 3)', metavar='<count-direction>')
		parser.add_argument('duty_cycle_prescaler', type=create_symbol_converter(ctx, convert_int, {'duty-cycle-prescaler-16': 4, 'duty-cycle-prescaler-16384': 14, 'duty-cycle-prescaler-512': 9, 'duty-cycle-prescaler-2048': 11, 'duty-cycle-prescaler-64': 6, 'duty-cycle-prescaler-256': 8, 'duty-cycle-prescaler-4096': 12, 'duty-cycle-prescaler-1024': 10, 'duty-cycle-prescaler-8': 3, 'duty-cycle-prescaler-2': 1, 'duty-cycle-prescaler-4': 2, 'duty-cycle-prescaler-128': 7, 'duty-cycle-prescaler-32768': 15, 'duty-cycle-prescaler-1': 0, 'duty-cycle-prescaler-32': 5, 'duty-cycle-prescaler-8192': 13}), help='int (duty-cycle-prescaler-1: 0, duty-cycle-prescaler-2: 1, duty-cycle-prescaler-4: 2, duty-cycle-prescaler-8: 3, duty-cycle-prescaler-16: 4, duty-cycle-prescaler-32: 5, duty-cycle-prescaler-64: 6, duty-cycle-prescaler-128: 7, duty-cycle-prescaler-256: 8, duty-cycle-prescaler-512: 9, duty-cycle-prescaler-1024: 10, duty-cycle-prescaler-2048: 11, duty-cycle-prescaler-4096: 12, duty-cycle-prescaler-8192: 13, duty-cycle-prescaler-16384: 14, duty-cycle-prescaler-32768: 15)', metavar='<duty-cycle-prescaler>')
		parser.add_argument('frequency_integration_time', type=create_symbol_converter(ctx, convert_int, {'frequency-integration-time-1024-ms': 3, 'frequency-integration-time-4096-ms': 5, 'frequency-integration-time-256-ms': 1, 'frequency-integration-time-128-ms': 0, 'frequency-integration-time-32768-ms': 8, 'frequency-integration-time-8192-ms': 6, 'frequency-integration-time-2048-ms': 4, 'frequency-integration-time-16384-ms': 7, 'frequency-integration-time-512-ms': 2}), help='int (frequency-integration-time-128-ms: 0, frequency-integration-time-256-ms: 1, frequency-integration-time-512-ms: 2, frequency-integration-time-1024-ms: 3, frequency-integration-time-2048-ms: 4, frequency-integration-time-4096-ms: 5, frequency-integration-time-8192-ms: 6, frequency-integration-time-16384-ms: 7, frequency-integration-time-32768-ms: 8)', metavar='<frequency-integration-time>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialCounterBricklet, 11, (args.channel, args.count_edge, args.count_direction, args.duty_cycle_prescaler, args.frequency_integration_time), 'B B B B B', '', None, args.expect_response, [], [])

	def get_counter_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-counter-configuration')

		parser.add_argument('channel', type=create_symbol_converter(ctx, convert_int, {'channel-3': 3, 'channel-2': 2, 'channel-1': 1, 'channel-0': 0}), help='int (channel-0: 0, channel-1: 1, channel-2: 2, channel-3: 3)', metavar='<channel>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialCounterBricklet, 12, (args.channel,), 'B', 'B B B B', args.execute, False, ['count-edge', 'count-direction', 'duty-cycle-prescaler', 'frequency-integration-time'], [{0: 'count-edge-rising', 1: 'count-edge-falling', 2: 'count-edge-both'}, {0: 'count-direction-up', 1: 'count-direction-down', 2: 'count-direction-external-up', 3: 'count-direction-external-down'}, {0: 'duty-cycle-prescaler-1', 1: 'duty-cycle-prescaler-2', 2: 'duty-cycle-prescaler-4', 3: 'duty-cycle-prescaler-8', 4: 'duty-cycle-prescaler-16', 5: 'duty-cycle-prescaler-32', 6: 'duty-cycle-prescaler-64', 7: 'duty-cycle-prescaler-128', 8: 'duty-cycle-prescaler-256', 9: 'duty-cycle-prescaler-512', 10: 'duty-cycle-prescaler-1024', 11: 'duty-cycle-prescaler-2048', 12: 'duty-cycle-prescaler-4096', 13: 'duty-cycle-prescaler-8192', 14: 'duty-cycle-prescaler-16384', 15: 'duty-cycle-prescaler-32768'}, {0: 'frequency-integration-time-128-ms', 1: 'frequency-integration-time-256-ms', 2: 'frequency-integration-time-512-ms', 3: 'frequency-integration-time-1024-ms', 4: 'frequency-integration-time-2048-ms', 5: 'frequency-integration-time-4096-ms', 6: 'frequency-integration-time-8192-ms', 7: 'frequency-integration-time-16384-ms', 8: 'frequency-integration-time-32768-ms'}])

	def set_all_counter_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-all-counter-callback-configuration')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialCounterBricklet, 13, (args.period, args.value_has_to_change), 'I !', '', None, args.expect_response, [], [])

	def get_all_counter_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-all-counter-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialCounterBricklet, 14, (), '', 'I !', args.execute, False, ['period', 'value-has-to-change'], [None, None])

	def set_all_signal_data_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-all-signal-data-callback-configuration')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialCounterBricklet, 15, (args.period, args.value_has_to_change), 'I !', '', None, args.expect_response, [], [])

	def get_all_signal_data_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-all-signal-data-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialCounterBricklet, 16, (), '', 'I !', args.execute, False, ['period', 'value-has-to-change'], [None, None])

	def set_channel_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-channel-led-config')

		parser.add_argument('channel', type=create_symbol_converter(ctx, convert_int, {'channel-3': 3, 'channel-2': 2, 'channel-1': 1, 'channel-0': 0}), help='int (channel-0: 0, channel-1: 1, channel-2: 2, channel-3: 3)', metavar='<channel>')
		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'channel-led-config-show-heartbeat': 2, 'channel-led-config-show-channel-status': 3, 'channel-led-config-off': 0, 'channel-led-config-on': 1}), help='int (channel-led-config-off: 0, channel-led-config-on: 1, channel-led-config-show-heartbeat: 2, channel-led-config-show-channel-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialCounterBricklet, 17, (args.channel, args.config), 'B B', '', None, args.expect_response, [], [])

	def get_channel_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-channel-led-config')

		parser.add_argument('channel', type=create_symbol_converter(ctx, convert_int, {'channel-3': 3, 'channel-2': 2, 'channel-1': 1, 'channel-0': 0}), help='int (channel-0: 0, channel-1: 1, channel-2: 2, channel-3: 3)', metavar='<channel>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialCounterBricklet, 18, (args.channel,), 'B', 'B', args.execute, False, ['config'], [{0: 'channel-led-config-off', 1: 'channel-led-config-on', 2: 'channel-led-config-show-heartbeat', 3: 'channel-led-config-show-channel-status'}])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialCounterBricklet, 234, (), '', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def set_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-bootloader-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'bootloader-mode-firmware-wait-for-reboot': 3, 'bootloader-mode-firmware': 1, 'bootloader-mode-firmware-wait-for-erase-and-reboot': 4, 'bootloader-mode-bootloader-wait-for-reboot': 2, 'bootloader-mode-bootloader': 0}), help='int (bootloader-mode-bootloader: 0, bootloader-mode-firmware: 1, bootloader-mode-bootloader-wait-for-reboot: 2, bootloader-mode-firmware-wait-for-reboot: 3, bootloader-mode-firmware-wait-for-erase-and-reboot: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialCounterBricklet, 235, (args.mode,), 'B', 'B', args.execute, False, ['status'], [{0: 'bootloader-status-ok', 1: 'bootloader-status-invalid-mode', 2: 'bootloader-status-no-change', 3: 'bootloader-status-entry-function-not-present', 4: 'bootloader-status-device-identifier-incorrect', 5: 'bootloader-status-crc-mismatch'}])

	def get_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-bootloader-mode')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialCounterBricklet, 236, (), '', 'B', args.execute, False, ['mode'], [{0: 'bootloader-mode-bootloader', 1: 'bootloader-mode-firmware', 2: 'bootloader-mode-bootloader-wait-for-reboot', 3: 'bootloader-mode-firmware-wait-for-reboot', 4: 'bootloader-mode-firmware-wait-for-erase-and-reboot'}])

	def set_write_firmware_pointer(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-write-firmware-pointer')

		parser.add_argument('pointer', type=convert_int, help='int', metavar='<pointer>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialCounterBricklet, 237, (args.pointer,), 'I', '', None, args.expect_response, [], [])

	def write_firmware(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-firmware')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialCounterBricklet, 238, (args.data,), '64B', 'B', args.execute, False, ['status'], [None])

	def set_status_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'status-led-config-on': 1, 'status-led-config-show-heartbeat': 2, 'status-led-config-off': 0, 'status-led-config-show-status': 3}), help='int (status-led-config-off: 0, status-led-config-on: 1, status-led-config-show-heartbeat: 2, status-led-config-show-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialCounterBricklet, 239, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_status_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialCounterBricklet, 240, (), '', 'B', args.execute, False, ['config'], [{0: 'status-led-config-off', 1: 'status-led-config-on', 2: 'status-led-config-show-heartbeat', 3: 'status-led-config-show-status'}])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialCounterBricklet, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialCounterBricklet, 243, (), '', '', None, args.expect_response, [], [])

	def write_uid(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-uid')

		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialCounterBricklet, 248, (args.uid,), 'I', '', None, args.expect_response, [], [])

	def read_uid(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-uid')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialCounterBricklet, 249, (), '', 'I', args.execute, False, ['uid'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, IndustrialCounterBricklet, argv)

	functions = {
	'get-counter': get_counter,
	'get-all-counter': get_all_counter,
	'set-counter': set_counter,
	'set-all-counter': set_all_counter,
	'get-signal-data': get_signal_data,
	'get-all-signal-data': get_all_signal_data,
	'set-counter-active': set_counter_active,
	'set-all-counter-active': set_all_counter_active,
	'get-counter-active': get_counter_active,
	'get-all-counter-active': get_all_counter_active,
	'set-counter-configuration': set_counter_configuration,
	'get-counter-configuration': get_counter_configuration,
	'set-all-counter-callback-configuration': set_all_counter_callback_configuration,
	'get-all-counter-callback-configuration': get_all_counter_callback_configuration,
	'set-all-signal-data-callback-configuration': set_all_signal_data_callback_configuration,
	'get-all-signal-data-callback-configuration': get_all_signal_data_callback_configuration,
	'set-channel-led-config': set_channel_led_config,
	'get-channel-led-config': get_channel_led_config,
	'get-spitfp-error-count': get_spitfp_error_count,
	'set-bootloader-mode': set_bootloader_mode,
	'get-bootloader-mode': get_bootloader_mode,
	'set-write-firmware-pointer': set_write_firmware_pointer,
	'write-firmware': write_firmware,
	'set-status-led-config': set_status_led_config,
	'get-status-led-config': get_status_led_config,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'write-uid': write_uid,
	'read-uid': read_uid,
	'get-identity': get_identity
	}

	call_generic(ctx, 'industrial-counter-bricklet', functions, argv)

def dispatch_industrial_counter_bricklet(ctx, argv):
	prog_prefix = 'dispatch industrial-counter-bricklet <uid>'

	def all_counter(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' all-counter')

		args = parser.parse_args(argv)

		device_dispatch(ctx, IndustrialCounterBricklet, 19, args.execute, ['counter'], [None])

	def all_signal_data(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' all-signal-data')

		args = parser.parse_args(argv)

		device_dispatch(ctx, IndustrialCounterBricklet, 20, args.execute, ['duty-cycle', 'period', 'frequency', 'value'], [None, None, None, None])

	callbacks = {
	'all-counter': all_counter,
	'all-signal-data': all_signal_data
	}

	dispatch_generic(ctx, 'industrial-counter-bricklet', callbacks, argv)

class IndustrialDigitalIn4Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 3; re[3] = 1; re[4] = 1; re[5] = 2; re[6] = 1; re[7] = 2; re[8] = 1; re[10] = 1; re[11] = 3; re[12] = 1; re[255] = 1
		cf = self.callback_formats
		cf[9] = 'H H'


def call_industrial_digital_in_4_bricklet(ctx, argv):
	prog_prefix = 'call industrial-digital-in-4-bricklet <uid>'

	def get_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-value')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDigitalIn4Bricklet, 1, (), '', 'H', args.execute, False, ['value-mask'], [None])

	def set_group(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-group')

		parser.add_argument('group', type=create_array_converter(ctx, create_char_converter(ctx), '\0', 4), help=get_array_type_name(ctx, 'char', 4), metavar='<group>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDigitalIn4Bricklet, 2, (args.group,), '4c', '', None, args.expect_response, [], [])

	def get_group(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-group')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDigitalIn4Bricklet, 3, (), '', '4c', args.execute, False, ['group'], [None])

	def get_available_for_group(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-available-for-group')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDigitalIn4Bricklet, 4, (), '', 'B', args.execute, False, ['available'], [None])

	def set_debounce_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-debounce-period')

		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDigitalIn4Bricklet, 5, (args.debounce,), 'I', '', None, args.expect_response, [], [])

	def get_debounce_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-debounce-period')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDigitalIn4Bricklet, 6, (), '', 'I', args.execute, False, ['debounce'], [None])

	def set_interrupt(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-interrupt')

		parser.add_argument('interrupt_mask', type=convert_int, help='int', metavar='<interrupt-mask>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDigitalIn4Bricklet, 7, (args.interrupt_mask,), 'H', '', None, args.expect_response, [], [])

	def get_interrupt(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-interrupt')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDigitalIn4Bricklet, 8, (), '', 'H', args.execute, False, ['interrupt-mask'], [None])

	def get_edge_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-edge-count')

		parser.add_argument('pin', type=convert_int, help='int', metavar='<pin>')
		parser.add_argument('reset_counter', type=convert_bool, help='bool', metavar='<reset-counter>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDigitalIn4Bricklet, 10, (args.pin, args.reset_counter), 'B !', 'I', args.execute, False, ['count'], [None])

	def set_edge_count_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-edge-count-config')

		parser.add_argument('selection_mask', type=convert_int, help='int', metavar='<selection-mask>')
		parser.add_argument('edge_type', type=create_symbol_converter(ctx, convert_int, {'edge-type-both': 2, 'edge-type-falling': 1, 'edge-type-rising': 0}), help='int (edge-type-rising: 0, edge-type-falling: 1, edge-type-both: 2)', metavar='<edge-type>')
		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDigitalIn4Bricklet, 11, (args.selection_mask, args.edge_type, args.debounce), 'H B B', '', None, args.expect_response, [], [])

	def get_edge_count_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-edge-count-config')

		parser.add_argument('pin', type=convert_int, help='int', metavar='<pin>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDigitalIn4Bricklet, 12, (args.pin,), 'B', 'B B', args.execute, False, ['edge-type', 'debounce'], [{0: 'edge-type-rising', 1: 'edge-type-falling', 2: 'edge-type-both'}, None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, IndustrialDigitalIn4Bricklet, argv)

	functions = {
	'get-value': get_value,
	'set-group': set_group,
	'get-group': get_group,
	'get-available-for-group': get_available_for_group,
	'set-debounce-period': set_debounce_period,
	'get-debounce-period': get_debounce_period,
	'set-interrupt': set_interrupt,
	'get-interrupt': get_interrupt,
	'get-edge-count': get_edge_count,
	'set-edge-count-config': set_edge_count_config,
	'get-edge-count-config': get_edge_count_config,
	'get-identity': get_identity
	}

	call_generic(ctx, 'industrial-digital-in-4-bricklet', functions, argv)

def dispatch_industrial_digital_in_4_bricklet(ctx, argv):
	prog_prefix = 'dispatch industrial-digital-in-4-bricklet <uid>'

	def interrupt(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' interrupt')

		args = parser.parse_args(argv)

		device_dispatch(ctx, IndustrialDigitalIn4Bricklet, 9, args.execute, ['interrupt-mask', 'value-mask'], [None, None])

	callbacks = {
	'interrupt': interrupt
	}

	dispatch_generic(ctx, 'industrial-digital-in-4-bricklet', callbacks, argv)

class IndustrialDigitalIn4V2Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 2; re[3] = 1; re[4] = 2; re[5] = 1; re[6] = 1; re[7] = 3; re[8] = 1; re[9] = 3; re[10] = 1; re[234] = 1; re[235] = 1; re[236] = 1; re[237] = 3; re[238] = 1; re[239] = 3; re[240] = 1; re[242] = 1; re[243] = 3; re[248] = 3; re[249] = 1; re[255] = 1
		cf = self.callback_formats
		cf[11] = 'B ! !'; cf[12] = '4! 4!'


def call_industrial_digital_in_4_v2_bricklet(ctx, argv):
	prog_prefix = 'call industrial-digital-in-4-v2-bricklet <uid>'

	def get_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-value')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDigitalIn4V2Bricklet, 1, (), '', '4!', args.execute, False, ['value'], [None])

	def set_value_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-value-callback-configuration')

		parser.add_argument('channel', type=create_symbol_converter(ctx, convert_int, {'channel-3': 3, 'channel-2': 2, 'channel-1': 1, 'channel-0': 0}), help='int (channel-0: 0, channel-1: 1, channel-2: 2, channel-3: 3)', metavar='<channel>')
		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDigitalIn4V2Bricklet, 2, (args.channel, args.period, args.value_has_to_change), 'B I !', '', None, args.expect_response, [], [])

	def get_value_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-value-callback-configuration')

		parser.add_argument('channel', type=create_symbol_converter(ctx, convert_int, {'channel-3': 3, 'channel-2': 2, 'channel-1': 1, 'channel-0': 0}), help='int (channel-0: 0, channel-1: 1, channel-2: 2, channel-3: 3)', metavar='<channel>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDigitalIn4V2Bricklet, 3, (args.channel,), 'B', 'I !', args.execute, False, ['period', 'value-has-to-change'], [None, None])

	def set_all_value_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-all-value-callback-configuration')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDigitalIn4V2Bricklet, 4, (args.period, args.value_has_to_change), 'I !', '', None, args.expect_response, [], [])

	def get_all_value_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-all-value-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDigitalIn4V2Bricklet, 5, (), '', 'I !', args.execute, False, ['period', 'value-has-to-change'], [None, None])

	def get_edge_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-edge-count')

		parser.add_argument('channel', type=create_symbol_converter(ctx, convert_int, {'channel-3': 3, 'channel-2': 2, 'channel-1': 1, 'channel-0': 0}), help='int (channel-0: 0, channel-1: 1, channel-2: 2, channel-3: 3)', metavar='<channel>')
		parser.add_argument('reset_counter', type=convert_bool, help='bool', metavar='<reset-counter>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDigitalIn4V2Bricklet, 6, (args.channel, args.reset_counter), 'B !', 'I', args.execute, False, ['count'], [None])

	def set_edge_count_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-edge-count-configuration')

		parser.add_argument('channel', type=create_symbol_converter(ctx, convert_int, {'channel-3': 3, 'channel-2': 2, 'channel-1': 1, 'channel-0': 0}), help='int (channel-0: 0, channel-1: 1, channel-2: 2, channel-3: 3)', metavar='<channel>')
		parser.add_argument('edge_type', type=create_symbol_converter(ctx, convert_int, {'edge-type-both': 2, 'edge-type-falling': 1, 'edge-type-rising': 0}), help='int (edge-type-rising: 0, edge-type-falling: 1, edge-type-both: 2)', metavar='<edge-type>')
		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDigitalIn4V2Bricklet, 7, (args.channel, args.edge_type, args.debounce), 'B B B', '', None, args.expect_response, [], [])

	def get_edge_count_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-edge-count-configuration')

		parser.add_argument('channel', type=create_symbol_converter(ctx, convert_int, {'channel-3': 3, 'channel-2': 2, 'channel-1': 1, 'channel-0': 0}), help='int (channel-0: 0, channel-1: 1, channel-2: 2, channel-3: 3)', metavar='<channel>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDigitalIn4V2Bricklet, 8, (args.channel,), 'B', 'B B', args.execute, False, ['edge-type', 'debounce'], [{0: 'edge-type-rising', 1: 'edge-type-falling', 2: 'edge-type-both'}, None])

	def set_channel_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-channel-led-config')

		parser.add_argument('channel', type=create_symbol_converter(ctx, convert_int, {'channel-3': 3, 'channel-2': 2, 'channel-1': 1, 'channel-0': 0}), help='int (channel-0: 0, channel-1: 1, channel-2: 2, channel-3: 3)', metavar='<channel>')
		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'channel-led-config-show-heartbeat': 2, 'channel-led-config-show-channel-status': 3, 'channel-led-config-off': 0, 'channel-led-config-on': 1}), help='int (channel-led-config-off: 0, channel-led-config-on: 1, channel-led-config-show-heartbeat: 2, channel-led-config-show-channel-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDigitalIn4V2Bricklet, 9, (args.channel, args.config), 'B B', '', None, args.expect_response, [], [])

	def get_channel_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-channel-led-config')

		parser.add_argument('channel', type=create_symbol_converter(ctx, convert_int, {'channel-3': 3, 'channel-2': 2, 'channel-1': 1, 'channel-0': 0}), help='int (channel-0: 0, channel-1: 1, channel-2: 2, channel-3: 3)', metavar='<channel>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDigitalIn4V2Bricklet, 10, (args.channel,), 'B', 'B', args.execute, False, ['config'], [{0: 'channel-led-config-off', 1: 'channel-led-config-on', 2: 'channel-led-config-show-heartbeat', 3: 'channel-led-config-show-channel-status'}])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDigitalIn4V2Bricklet, 234, (), '', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def set_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-bootloader-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'bootloader-mode-firmware-wait-for-reboot': 3, 'bootloader-mode-firmware': 1, 'bootloader-mode-firmware-wait-for-erase-and-reboot': 4, 'bootloader-mode-bootloader-wait-for-reboot': 2, 'bootloader-mode-bootloader': 0}), help='int (bootloader-mode-bootloader: 0, bootloader-mode-firmware: 1, bootloader-mode-bootloader-wait-for-reboot: 2, bootloader-mode-firmware-wait-for-reboot: 3, bootloader-mode-firmware-wait-for-erase-and-reboot: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDigitalIn4V2Bricklet, 235, (args.mode,), 'B', 'B', args.execute, False, ['status'], [{0: 'bootloader-status-ok', 1: 'bootloader-status-invalid-mode', 2: 'bootloader-status-no-change', 3: 'bootloader-status-entry-function-not-present', 4: 'bootloader-status-device-identifier-incorrect', 5: 'bootloader-status-crc-mismatch'}])

	def get_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-bootloader-mode')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDigitalIn4V2Bricklet, 236, (), '', 'B', args.execute, False, ['mode'], [{0: 'bootloader-mode-bootloader', 1: 'bootloader-mode-firmware', 2: 'bootloader-mode-bootloader-wait-for-reboot', 3: 'bootloader-mode-firmware-wait-for-reboot', 4: 'bootloader-mode-firmware-wait-for-erase-and-reboot'}])

	def set_write_firmware_pointer(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-write-firmware-pointer')

		parser.add_argument('pointer', type=convert_int, help='int', metavar='<pointer>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDigitalIn4V2Bricklet, 237, (args.pointer,), 'I', '', None, args.expect_response, [], [])

	def write_firmware(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-firmware')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDigitalIn4V2Bricklet, 238, (args.data,), '64B', 'B', args.execute, False, ['status'], [None])

	def set_status_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'status-led-config-on': 1, 'status-led-config-show-heartbeat': 2, 'status-led-config-off': 0, 'status-led-config-show-status': 3}), help='int (status-led-config-off: 0, status-led-config-on: 1, status-led-config-show-heartbeat: 2, status-led-config-show-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDigitalIn4V2Bricklet, 239, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_status_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDigitalIn4V2Bricklet, 240, (), '', 'B', args.execute, False, ['config'], [{0: 'status-led-config-off', 1: 'status-led-config-on', 2: 'status-led-config-show-heartbeat', 3: 'status-led-config-show-status'}])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDigitalIn4V2Bricklet, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDigitalIn4V2Bricklet, 243, (), '', '', None, args.expect_response, [], [])

	def write_uid(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-uid')

		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDigitalIn4V2Bricklet, 248, (args.uid,), 'I', '', None, args.expect_response, [], [])

	def read_uid(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-uid')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDigitalIn4V2Bricklet, 249, (), '', 'I', args.execute, False, ['uid'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, IndustrialDigitalIn4V2Bricklet, argv)

	functions = {
	'get-value': get_value,
	'set-value-callback-configuration': set_value_callback_configuration,
	'get-value-callback-configuration': get_value_callback_configuration,
	'set-all-value-callback-configuration': set_all_value_callback_configuration,
	'get-all-value-callback-configuration': get_all_value_callback_configuration,
	'get-edge-count': get_edge_count,
	'set-edge-count-configuration': set_edge_count_configuration,
	'get-edge-count-configuration': get_edge_count_configuration,
	'set-channel-led-config': set_channel_led_config,
	'get-channel-led-config': get_channel_led_config,
	'get-spitfp-error-count': get_spitfp_error_count,
	'set-bootloader-mode': set_bootloader_mode,
	'get-bootloader-mode': get_bootloader_mode,
	'set-write-firmware-pointer': set_write_firmware_pointer,
	'write-firmware': write_firmware,
	'set-status-led-config': set_status_led_config,
	'get-status-led-config': get_status_led_config,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'write-uid': write_uid,
	'read-uid': read_uid,
	'get-identity': get_identity
	}

	call_generic(ctx, 'industrial-digital-in-4-v2-bricklet', functions, argv)

def dispatch_industrial_digital_in_4_v2_bricklet(ctx, argv):
	prog_prefix = 'dispatch industrial-digital-in-4-v2-bricklet <uid>'

	def value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' value')

		args = parser.parse_args(argv)

		device_dispatch(ctx, IndustrialDigitalIn4V2Bricklet, 11, args.execute, ['channel', 'changed', 'value'], [{0: 'channel-0', 1: 'channel-1', 2: 'channel-2', 3: 'channel-3'}, None, None])

	def all_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' all-value')

		args = parser.parse_args(argv)

		device_dispatch(ctx, IndustrialDigitalIn4V2Bricklet, 12, args.execute, ['changed', 'value'], [None, None])

	callbacks = {
	'value': value,
	'all-value': all_value
	}

	dispatch_generic(ctx, 'industrial-digital-in-4-v2-bricklet', callbacks, argv)

class IndustrialDigitalOut4Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 3; re[2] = 1; re[3] = 3; re[4] = 1; re[5] = 3; re[6] = 1; re[7] = 1; re[9] = 3; re[255] = 1
		cf = self.callback_formats
		cf[8] = 'H H'


def call_industrial_digital_out_4_bricklet(ctx, argv):
	prog_prefix = 'call industrial-digital-out-4-bricklet <uid>'

	def set_value(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-value')

		parser.add_argument('value_mask', type=convert_int, help='int', metavar='<value-mask>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDigitalOut4Bricklet, 1, (args.value_mask,), 'H', '', None, args.expect_response, [], [])

	def get_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-value')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDigitalOut4Bricklet, 2, (), '', 'H', args.execute, False, ['value-mask'], [None])

	def set_monoflop(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-monoflop')

		parser.add_argument('selection_mask', type=convert_int, help='int', metavar='<selection-mask>')
		parser.add_argument('value_mask', type=convert_int, help='int', metavar='<value-mask>')
		parser.add_argument('time', type=convert_int, help='int', metavar='<time>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDigitalOut4Bricklet, 3, (args.selection_mask, args.value_mask, args.time), 'H H I', '', None, args.expect_response, [], [])

	def get_monoflop(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-monoflop')

		parser.add_argument('pin', type=convert_int, help='int', metavar='<pin>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDigitalOut4Bricklet, 4, (args.pin,), 'B', 'H I I', args.execute, False, ['value', 'time', 'time-remaining'], [None, None, None])

	def set_group(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-group')

		parser.add_argument('group', type=create_array_converter(ctx, create_char_converter(ctx), '\0', 4), help=get_array_type_name(ctx, 'char', 4), metavar='<group>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDigitalOut4Bricklet, 5, (args.group,), '4c', '', None, args.expect_response, [], [])

	def get_group(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-group')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDigitalOut4Bricklet, 6, (), '', '4c', args.execute, False, ['group'], [None])

	def get_available_for_group(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-available-for-group')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDigitalOut4Bricklet, 7, (), '', 'B', args.execute, False, ['available'], [None])

	def set_selected_values(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-selected-values')

		parser.add_argument('selection_mask', type=convert_int, help='int', metavar='<selection-mask>')
		parser.add_argument('value_mask', type=convert_int, help='int', metavar='<value-mask>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDigitalOut4Bricklet, 9, (args.selection_mask, args.value_mask), 'H H', '', None, args.expect_response, [], [])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, IndustrialDigitalOut4Bricklet, argv)

	functions = {
	'set-value': set_value,
	'get-value': get_value,
	'set-monoflop': set_monoflop,
	'get-monoflop': get_monoflop,
	'set-group': set_group,
	'get-group': get_group,
	'get-available-for-group': get_available_for_group,
	'set-selected-values': set_selected_values,
	'get-identity': get_identity
	}

	call_generic(ctx, 'industrial-digital-out-4-bricklet', functions, argv)

def dispatch_industrial_digital_out_4_bricklet(ctx, argv):
	prog_prefix = 'dispatch industrial-digital-out-4-bricklet <uid>'

	def monoflop_done(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' monoflop-done')

		args = parser.parse_args(argv)

		device_dispatch(ctx, IndustrialDigitalOut4Bricklet, 8, args.execute, ['selection-mask', 'value-mask'], [None, None])

	callbacks = {
	'monoflop-done': monoflop_done
	}

	dispatch_generic(ctx, 'industrial-digital-out-4-bricklet', callbacks, argv)

class IndustrialDigitalOut4V2Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 3; re[2] = 1; re[3] = 3; re[4] = 3; re[5] = 1; re[7] = 3; re[8] = 1; re[9] = 3; re[10] = 1; re[234] = 1; re[235] = 1; re[236] = 1; re[237] = 3; re[238] = 1; re[239] = 3; re[240] = 1; re[242] = 1; re[243] = 3; re[248] = 3; re[249] = 1; re[255] = 1
		cf = self.callback_formats
		cf[6] = 'B !'


def call_industrial_digital_out_4_v2_bricklet(ctx, argv):
	prog_prefix = 'call industrial-digital-out-4-v2-bricklet <uid>'

	def set_value(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-value')

		parser.add_argument('value', type=create_array_converter(ctx, convert_bool, 'false', 4), help=get_array_type_name(ctx, 'bool', 4), metavar='<value>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDigitalOut4V2Bricklet, 1, (args.value,), '4!', '', None, args.expect_response, [], [])

	def get_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-value')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDigitalOut4V2Bricklet, 2, (), '', '4!', args.execute, False, ['value'], [None])

	def set_selected_value(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-selected-value')

		parser.add_argument('channel', type=convert_int, help='int', metavar='<channel>')
		parser.add_argument('value', type=convert_bool, help='bool', metavar='<value>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDigitalOut4V2Bricklet, 3, (args.channel, args.value), 'B !', '', None, args.expect_response, [], [])

	def set_monoflop(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-monoflop')

		parser.add_argument('channel', type=convert_int, help='int', metavar='<channel>')
		parser.add_argument('value', type=convert_bool, help='bool', metavar='<value>')
		parser.add_argument('time', type=convert_int, help='int', metavar='<time>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDigitalOut4V2Bricklet, 4, (args.channel, args.value, args.time), 'B ! I', '', None, args.expect_response, [], [])

	def get_monoflop(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-monoflop')

		parser.add_argument('channel', type=convert_int, help='int', metavar='<channel>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDigitalOut4V2Bricklet, 5, (args.channel,), 'B', '! I I', args.execute, False, ['value', 'time', 'time-remaining'], [None, None, None])

	def set_channel_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-channel-led-config')

		parser.add_argument('channel', type=convert_int, help='int', metavar='<channel>')
		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'channel-led-config-show-heartbeat': 2, 'channel-led-config-show-channel-status': 3, 'channel-led-config-off': 0, 'channel-led-config-on': 1}), help='int (channel-led-config-off: 0, channel-led-config-on: 1, channel-led-config-show-heartbeat: 2, channel-led-config-show-channel-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDigitalOut4V2Bricklet, 7, (args.channel, args.config), 'B B', '', None, args.expect_response, [], [])

	def get_channel_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-channel-led-config')

		parser.add_argument('channel', type=convert_int, help='int', metavar='<channel>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDigitalOut4V2Bricklet, 8, (args.channel,), 'B', 'B', args.execute, False, ['config'], [{0: 'channel-led-config-off', 1: 'channel-led-config-on', 2: 'channel-led-config-show-heartbeat', 3: 'channel-led-config-show-channel-status'}])

	def set_pwm_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-pwm-configuration')

		parser.add_argument('channel', type=convert_int, help='int', metavar='<channel>')
		parser.add_argument('frequency', type=convert_int, help='int', metavar='<frequency>')
		parser.add_argument('duty_cycle', type=convert_int, help='int', metavar='<duty-cycle>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDigitalOut4V2Bricklet, 9, (args.channel, args.frequency, args.duty_cycle), 'B I H', '', None, args.expect_response, [], [])

	def get_pwm_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-pwm-configuration')

		parser.add_argument('channel', type=convert_int, help='int', metavar='<channel>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDigitalOut4V2Bricklet, 10, (args.channel,), 'B', 'I H', args.execute, False, ['frequency', 'duty-cycle'], [None, None])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDigitalOut4V2Bricklet, 234, (), '', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def set_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-bootloader-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'bootloader-mode-firmware-wait-for-reboot': 3, 'bootloader-mode-firmware': 1, 'bootloader-mode-firmware-wait-for-erase-and-reboot': 4, 'bootloader-mode-bootloader-wait-for-reboot': 2, 'bootloader-mode-bootloader': 0}), help='int (bootloader-mode-bootloader: 0, bootloader-mode-firmware: 1, bootloader-mode-bootloader-wait-for-reboot: 2, bootloader-mode-firmware-wait-for-reboot: 3, bootloader-mode-firmware-wait-for-erase-and-reboot: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDigitalOut4V2Bricklet, 235, (args.mode,), 'B', 'B', args.execute, False, ['status'], [{0: 'bootloader-status-ok', 1: 'bootloader-status-invalid-mode', 2: 'bootloader-status-no-change', 3: 'bootloader-status-entry-function-not-present', 4: 'bootloader-status-device-identifier-incorrect', 5: 'bootloader-status-crc-mismatch'}])

	def get_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-bootloader-mode')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDigitalOut4V2Bricklet, 236, (), '', 'B', args.execute, False, ['mode'], [{0: 'bootloader-mode-bootloader', 1: 'bootloader-mode-firmware', 2: 'bootloader-mode-bootloader-wait-for-reboot', 3: 'bootloader-mode-firmware-wait-for-reboot', 4: 'bootloader-mode-firmware-wait-for-erase-and-reboot'}])

	def set_write_firmware_pointer(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-write-firmware-pointer')

		parser.add_argument('pointer', type=convert_int, help='int', metavar='<pointer>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDigitalOut4V2Bricklet, 237, (args.pointer,), 'I', '', None, args.expect_response, [], [])

	def write_firmware(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-firmware')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDigitalOut4V2Bricklet, 238, (args.data,), '64B', 'B', args.execute, False, ['status'], [None])

	def set_status_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'status-led-config-on': 1, 'status-led-config-show-heartbeat': 2, 'status-led-config-off': 0, 'status-led-config-show-status': 3}), help='int (status-led-config-off: 0, status-led-config-on: 1, status-led-config-show-heartbeat: 2, status-led-config-show-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDigitalOut4V2Bricklet, 239, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_status_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDigitalOut4V2Bricklet, 240, (), '', 'B', args.execute, False, ['config'], [{0: 'status-led-config-off', 1: 'status-led-config-on', 2: 'status-led-config-show-heartbeat', 3: 'status-led-config-show-status'}])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDigitalOut4V2Bricklet, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDigitalOut4V2Bricklet, 243, (), '', '', None, args.expect_response, [], [])

	def write_uid(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-uid')

		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDigitalOut4V2Bricklet, 248, (args.uid,), 'I', '', None, args.expect_response, [], [])

	def read_uid(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-uid')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDigitalOut4V2Bricklet, 249, (), '', 'I', args.execute, False, ['uid'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, IndustrialDigitalOut4V2Bricklet, argv)

	functions = {
	'set-value': set_value,
	'get-value': get_value,
	'set-selected-value': set_selected_value,
	'set-monoflop': set_monoflop,
	'get-monoflop': get_monoflop,
	'set-channel-led-config': set_channel_led_config,
	'get-channel-led-config': get_channel_led_config,
	'set-pwm-configuration': set_pwm_configuration,
	'get-pwm-configuration': get_pwm_configuration,
	'get-spitfp-error-count': get_spitfp_error_count,
	'set-bootloader-mode': set_bootloader_mode,
	'get-bootloader-mode': get_bootloader_mode,
	'set-write-firmware-pointer': set_write_firmware_pointer,
	'write-firmware': write_firmware,
	'set-status-led-config': set_status_led_config,
	'get-status-led-config': get_status_led_config,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'write-uid': write_uid,
	'read-uid': read_uid,
	'get-identity': get_identity
	}

	call_generic(ctx, 'industrial-digital-out-4-v2-bricklet', functions, argv)

def dispatch_industrial_digital_out_4_v2_bricklet(ctx, argv):
	prog_prefix = 'dispatch industrial-digital-out-4-v2-bricklet <uid>'

	def monoflop_done(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' monoflop-done')

		args = parser.parse_args(argv)

		device_dispatch(ctx, IndustrialDigitalOut4V2Bricklet, 6, args.execute, ['channel', 'value'], [None, None])

	callbacks = {
	'monoflop-done': monoflop_done
	}

	dispatch_generic(ctx, 'industrial-digital-out-4-v2-bricklet', callbacks, argv)

class IndustrialDual020mABricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 2; re[3] = 1; re[4] = 2; re[5] = 1; re[6] = 2; re[7] = 1; re[8] = 3; re[9] = 1; re[255] = 1
		cf = self.callback_formats
		cf[10] = 'B i'; cf[11] = 'B i'


def call_industrial_dual_0_20ma_bricklet(ctx, argv):
	prog_prefix = 'call industrial-dual-0-20ma-bricklet <uid>'

	def get_current(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-current')

		parser.add_argument('sensor', type=convert_int, help='int', metavar='<sensor>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDual020mABricklet, 1, (args.sensor,), 'B', 'i', args.execute, False, ['current'], [None])

	def set_current_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-current-callback-period')

		parser.add_argument('sensor', type=convert_int, help='int', metavar='<sensor>')
		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDual020mABricklet, 2, (args.sensor, args.period), 'B I', '', None, args.expect_response, [], [])

	def get_current_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-current-callback-period')

		parser.add_argument('sensor', type=convert_int, help='int', metavar='<sensor>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDual020mABricklet, 3, (args.sensor,), 'B', 'I', args.execute, False, ['period'], [None])

	def set_current_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-current-callback-threshold')

		parser.add_argument('sensor', type=convert_int, help='int', metavar='<sensor>')
		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDual020mABricklet, 4, (args.sensor, args.option, args.min, args.max), 'B c i i', '', None, args.expect_response, [], [])

	def get_current_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-current-callback-threshold')

		parser.add_argument('sensor', type=convert_int, help='int', metavar='<sensor>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDual020mABricklet, 5, (args.sensor,), 'B', 'c i i', args.execute, False, ['option', 'min', 'max'], [{'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def set_debounce_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-debounce-period')

		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDual020mABricklet, 6, (args.debounce,), 'I', '', None, args.expect_response, [], [])

	def get_debounce_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-debounce-period')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDual020mABricklet, 7, (), '', 'I', args.execute, False, ['debounce'], [None])

	def set_sample_rate(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-sample-rate')

		parser.add_argument('rate', type=create_symbol_converter(ctx, convert_int, {'sample-rate-4-sps': 3, 'sample-rate-240-sps': 0, 'sample-rate-60-sps': 1, 'sample-rate-15-sps': 2}), help='int (sample-rate-240-sps: 0, sample-rate-60-sps: 1, sample-rate-15-sps: 2, sample-rate-4-sps: 3)', metavar='<rate>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDual020mABricklet, 8, (args.rate,), 'B', '', None, args.expect_response, [], [])

	def get_sample_rate(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-sample-rate')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDual020mABricklet, 9, (), '', 'B', args.execute, False, ['rate'], [{0: 'sample-rate-240-sps', 1: 'sample-rate-60-sps', 2: 'sample-rate-15-sps', 3: 'sample-rate-4-sps'}])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, IndustrialDual020mABricklet, argv)

	functions = {
	'get-current': get_current,
	'set-current-callback-period': set_current_callback_period,
	'get-current-callback-period': get_current_callback_period,
	'set-current-callback-threshold': set_current_callback_threshold,
	'get-current-callback-threshold': get_current_callback_threshold,
	'set-debounce-period': set_debounce_period,
	'get-debounce-period': get_debounce_period,
	'set-sample-rate': set_sample_rate,
	'get-sample-rate': get_sample_rate,
	'get-identity': get_identity
	}

	call_generic(ctx, 'industrial-dual-0-20ma-bricklet', functions, argv)

def dispatch_industrial_dual_0_20ma_bricklet(ctx, argv):
	prog_prefix = 'dispatch industrial-dual-0-20ma-bricklet <uid>'

	def current(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' current')

		args = parser.parse_args(argv)

		device_dispatch(ctx, IndustrialDual020mABricklet, 10, args.execute, ['sensor', 'current'], [None, None])

	def current_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' current-reached')

		args = parser.parse_args(argv)

		device_dispatch(ctx, IndustrialDual020mABricklet, 11, args.execute, ['sensor', 'current'], [None, None])

	callbacks = {
	'current': current,
	'current-reached': current_reached
	}

	dispatch_generic(ctx, 'industrial-dual-0-20ma-bricklet', callbacks, argv)

class IndustrialDual020mAV2Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 2; re[3] = 1; re[5] = 3; re[6] = 1; re[7] = 3; re[8] = 1; re[9] = 3; re[10] = 1; re[11] = 3; re[12] = 1; re[234] = 1; re[235] = 1; re[236] = 1; re[237] = 3; re[238] = 1; re[239] = 3; re[240] = 1; re[242] = 1; re[243] = 3; re[248] = 3; re[249] = 1; re[255] = 1
		cf = self.callback_formats
		cf[4] = 'B i'


def call_industrial_dual_0_20ma_v2_bricklet(ctx, argv):
	prog_prefix = 'call industrial-dual-0-20ma-v2-bricklet <uid>'

	def get_current(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-current')

		parser.add_argument('channel', type=convert_int, help='int', metavar='<channel>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDual020mAV2Bricklet, 1, (args.channel,), 'B', 'i', args.execute, False, ['current'], [None])

	def set_current_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-current-callback-configuration')

		parser.add_argument('channel', type=convert_int, help='int', metavar='<channel>')
		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')
		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDual020mAV2Bricklet, 2, (args.channel, args.period, args.value_has_to_change, args.option, args.min, args.max), 'B I ! c i i', '', None, args.expect_response, [], [])

	def get_current_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-current-callback-configuration')

		parser.add_argument('channel', type=convert_int, help='int', metavar='<channel>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDual020mAV2Bricklet, 3, (args.channel,), 'B', 'I ! c i i', args.execute, False, ['period', 'value-has-to-change', 'option', 'min', 'max'], [None, None, {'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def set_sample_rate(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-sample-rate')

		parser.add_argument('rate', type=create_symbol_converter(ctx, convert_int, {'sample-rate-4-sps': 3, 'sample-rate-240-sps': 0, 'sample-rate-60-sps': 1, 'sample-rate-15-sps': 2}), help='int (sample-rate-240-sps: 0, sample-rate-60-sps: 1, sample-rate-15-sps: 2, sample-rate-4-sps: 3)', metavar='<rate>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDual020mAV2Bricklet, 5, (args.rate,), 'B', '', None, args.expect_response, [], [])

	def get_sample_rate(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-sample-rate')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDual020mAV2Bricklet, 6, (), '', 'B', args.execute, False, ['rate'], [{0: 'sample-rate-240-sps', 1: 'sample-rate-60-sps', 2: 'sample-rate-15-sps', 3: 'sample-rate-4-sps'}])

	def set_gain(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-gain')

		parser.add_argument('gain', type=create_symbol_converter(ctx, convert_int, {'gain-8x': 3, 'gain-4x': 2, 'gain-1x': 0, 'gain-2x': 1}), help='int (gain-1x: 0, gain-2x: 1, gain-4x: 2, gain-8x: 3)', metavar='<gain>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDual020mAV2Bricklet, 7, (args.gain,), 'B', '', None, args.expect_response, [], [])

	def get_gain(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-gain')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDual020mAV2Bricklet, 8, (), '', 'B', args.execute, False, ['gain'], [{0: 'gain-1x', 1: 'gain-2x', 2: 'gain-4x', 3: 'gain-8x'}])

	def set_channel_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-channel-led-config')

		parser.add_argument('channel', type=convert_int, help='int', metavar='<channel>')
		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'channel-led-config-show-heartbeat': 2, 'channel-led-config-show-channel-status': 3, 'channel-led-config-off': 0, 'channel-led-config-on': 1}), help='int (channel-led-config-off: 0, channel-led-config-on: 1, channel-led-config-show-heartbeat: 2, channel-led-config-show-channel-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDual020mAV2Bricklet, 9, (args.channel, args.config), 'B B', '', None, args.expect_response, [], [])

	def get_channel_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-channel-led-config')

		parser.add_argument('channel', type=convert_int, help='int', metavar='<channel>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDual020mAV2Bricklet, 10, (args.channel,), 'B', 'B', args.execute, False, ['config'], [{0: 'channel-led-config-off', 1: 'channel-led-config-on', 2: 'channel-led-config-show-heartbeat', 3: 'channel-led-config-show-channel-status'}])

	def set_channel_led_status_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-channel-led-status-config')

		parser.add_argument('channel', type=convert_int, help='int', metavar='<channel>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')
		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'channel-led-status-config-intensity': 1, 'channel-led-status-config-threshold': 0}), help='int (channel-led-status-config-threshold: 0, channel-led-status-config-intensity: 1)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDual020mAV2Bricklet, 11, (args.channel, args.min, args.max, args.config), 'B i i B', '', None, args.expect_response, [], [])

	def get_channel_led_status_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-channel-led-status-config')

		parser.add_argument('channel', type=convert_int, help='int', metavar='<channel>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDual020mAV2Bricklet, 12, (args.channel,), 'B', 'i i B', args.execute, False, ['min', 'max', 'config'], [None, None, {0: 'channel-led-status-config-threshold', 1: 'channel-led-status-config-intensity'}])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDual020mAV2Bricklet, 234, (), '', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def set_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-bootloader-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'bootloader-mode-firmware-wait-for-reboot': 3, 'bootloader-mode-firmware': 1, 'bootloader-mode-firmware-wait-for-erase-and-reboot': 4, 'bootloader-mode-bootloader-wait-for-reboot': 2, 'bootloader-mode-bootloader': 0}), help='int (bootloader-mode-bootloader: 0, bootloader-mode-firmware: 1, bootloader-mode-bootloader-wait-for-reboot: 2, bootloader-mode-firmware-wait-for-reboot: 3, bootloader-mode-firmware-wait-for-erase-and-reboot: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDual020mAV2Bricklet, 235, (args.mode,), 'B', 'B', args.execute, False, ['status'], [{0: 'bootloader-status-ok', 1: 'bootloader-status-invalid-mode', 2: 'bootloader-status-no-change', 3: 'bootloader-status-entry-function-not-present', 4: 'bootloader-status-device-identifier-incorrect', 5: 'bootloader-status-crc-mismatch'}])

	def get_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-bootloader-mode')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDual020mAV2Bricklet, 236, (), '', 'B', args.execute, False, ['mode'], [{0: 'bootloader-mode-bootloader', 1: 'bootloader-mode-firmware', 2: 'bootloader-mode-bootloader-wait-for-reboot', 3: 'bootloader-mode-firmware-wait-for-reboot', 4: 'bootloader-mode-firmware-wait-for-erase-and-reboot'}])

	def set_write_firmware_pointer(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-write-firmware-pointer')

		parser.add_argument('pointer', type=convert_int, help='int', metavar='<pointer>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDual020mAV2Bricklet, 237, (args.pointer,), 'I', '', None, args.expect_response, [], [])

	def write_firmware(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-firmware')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDual020mAV2Bricklet, 238, (args.data,), '64B', 'B', args.execute, False, ['status'], [None])

	def set_status_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'status-led-config-on': 1, 'status-led-config-show-heartbeat': 2, 'status-led-config-off': 0, 'status-led-config-show-status': 3}), help='int (status-led-config-off: 0, status-led-config-on: 1, status-led-config-show-heartbeat: 2, status-led-config-show-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDual020mAV2Bricklet, 239, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_status_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDual020mAV2Bricklet, 240, (), '', 'B', args.execute, False, ['config'], [{0: 'status-led-config-off', 1: 'status-led-config-on', 2: 'status-led-config-show-heartbeat', 3: 'status-led-config-show-status'}])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDual020mAV2Bricklet, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDual020mAV2Bricklet, 243, (), '', '', None, args.expect_response, [], [])

	def write_uid(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-uid')

		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDual020mAV2Bricklet, 248, (args.uid,), 'I', '', None, args.expect_response, [], [])

	def read_uid(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-uid')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDual020mAV2Bricklet, 249, (), '', 'I', args.execute, False, ['uid'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, IndustrialDual020mAV2Bricklet, argv)

	functions = {
	'get-current': get_current,
	'set-current-callback-configuration': set_current_callback_configuration,
	'get-current-callback-configuration': get_current_callback_configuration,
	'set-sample-rate': set_sample_rate,
	'get-sample-rate': get_sample_rate,
	'set-gain': set_gain,
	'get-gain': get_gain,
	'set-channel-led-config': set_channel_led_config,
	'get-channel-led-config': get_channel_led_config,
	'set-channel-led-status-config': set_channel_led_status_config,
	'get-channel-led-status-config': get_channel_led_status_config,
	'get-spitfp-error-count': get_spitfp_error_count,
	'set-bootloader-mode': set_bootloader_mode,
	'get-bootloader-mode': get_bootloader_mode,
	'set-write-firmware-pointer': set_write_firmware_pointer,
	'write-firmware': write_firmware,
	'set-status-led-config': set_status_led_config,
	'get-status-led-config': get_status_led_config,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'write-uid': write_uid,
	'read-uid': read_uid,
	'get-identity': get_identity
	}

	call_generic(ctx, 'industrial-dual-0-20ma-v2-bricklet', functions, argv)

def dispatch_industrial_dual_0_20ma_v2_bricklet(ctx, argv):
	prog_prefix = 'dispatch industrial-dual-0-20ma-v2-bricklet <uid>'

	def current(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' current')

		args = parser.parse_args(argv)

		device_dispatch(ctx, IndustrialDual020mAV2Bricklet, 4, args.execute, ['channel', 'current'], [None, None])

	callbacks = {
	'current': current
	}

	dispatch_generic(ctx, 'industrial-dual-0-20ma-v2-bricklet', callbacks, argv)

class IndustrialDualAnalogInBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 2; re[3] = 1; re[4] = 2; re[5] = 1; re[6] = 2; re[7] = 1; re[8] = 3; re[9] = 1; re[10] = 3; re[11] = 1; re[12] = 1; re[255] = 1
		cf = self.callback_formats
		cf[13] = 'B i'; cf[14] = 'B i'


def call_industrial_dual_analog_in_bricklet(ctx, argv):
	prog_prefix = 'call industrial-dual-analog-in-bricklet <uid>'

	def get_voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-voltage')

		parser.add_argument('channel', type=convert_int, help='int', metavar='<channel>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDualAnalogInBricklet, 1, (args.channel,), 'B', 'i', args.execute, False, ['voltage'], [None])

	def set_voltage_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-voltage-callback-period')

		parser.add_argument('channel', type=convert_int, help='int', metavar='<channel>')
		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDualAnalogInBricklet, 2, (args.channel, args.period), 'B I', '', None, args.expect_response, [], [])

	def get_voltage_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-voltage-callback-period')

		parser.add_argument('channel', type=convert_int, help='int', metavar='<channel>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDualAnalogInBricklet, 3, (args.channel,), 'B', 'I', args.execute, False, ['period'], [None])

	def set_voltage_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-voltage-callback-threshold')

		parser.add_argument('channel', type=convert_int, help='int', metavar='<channel>')
		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDualAnalogInBricklet, 4, (args.channel, args.option, args.min, args.max), 'B c i i', '', None, args.expect_response, [], [])

	def get_voltage_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-voltage-callback-threshold')

		parser.add_argument('channel', type=convert_int, help='int', metavar='<channel>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDualAnalogInBricklet, 5, (args.channel,), 'B', 'c i i', args.execute, False, ['option', 'min', 'max'], [{'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def set_debounce_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-debounce-period')

		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDualAnalogInBricklet, 6, (args.debounce,), 'I', '', None, args.expect_response, [], [])

	def get_debounce_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-debounce-period')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDualAnalogInBricklet, 7, (), '', 'I', args.execute, False, ['debounce'], [None])

	def set_sample_rate(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-sample-rate')

		parser.add_argument('rate', type=create_symbol_converter(ctx, convert_int, {'sample-rate-4-sps': 5, 'sample-rate-488-sps': 1, 'sample-rate-61-sps': 4, 'sample-rate-1-sps': 7, 'sample-rate-2-sps': 6, 'sample-rate-122-sps': 3, 'sample-rate-244-sps': 2, 'sample-rate-976-sps': 0}), help='int (sample-rate-976-sps: 0, sample-rate-488-sps: 1, sample-rate-244-sps: 2, sample-rate-122-sps: 3, sample-rate-61-sps: 4, sample-rate-4-sps: 5, sample-rate-2-sps: 6, sample-rate-1-sps: 7)', metavar='<rate>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDualAnalogInBricklet, 8, (args.rate,), 'B', '', None, args.expect_response, [], [])

	def get_sample_rate(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-sample-rate')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDualAnalogInBricklet, 9, (), '', 'B', args.execute, False, ['rate'], [{0: 'sample-rate-976-sps', 1: 'sample-rate-488-sps', 2: 'sample-rate-244-sps', 3: 'sample-rate-122-sps', 4: 'sample-rate-61-sps', 5: 'sample-rate-4-sps', 6: 'sample-rate-2-sps', 7: 'sample-rate-1-sps'}])

	def set_calibration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-calibration')

		parser.add_argument('offset', type=create_array_converter(ctx, convert_int, '0', 2), help=get_array_type_name(ctx, 'int', 2), metavar='<offset>')
		parser.add_argument('gain', type=create_array_converter(ctx, convert_int, '0', 2), help=get_array_type_name(ctx, 'int', 2), metavar='<gain>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDualAnalogInBricklet, 10, (args.offset, args.gain), '2i 2i', '', None, args.expect_response, [], [])

	def get_calibration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-calibration')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDualAnalogInBricklet, 11, (), '', '2i 2i', args.execute, False, ['offset', 'gain'], [None, None])

	def get_adc_values(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-adc-values')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDualAnalogInBricklet, 12, (), '', '2i', args.execute, False, ['value'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, IndustrialDualAnalogInBricklet, argv)

	functions = {
	'get-voltage': get_voltage,
	'set-voltage-callback-period': set_voltage_callback_period,
	'get-voltage-callback-period': get_voltage_callback_period,
	'set-voltage-callback-threshold': set_voltage_callback_threshold,
	'get-voltage-callback-threshold': get_voltage_callback_threshold,
	'set-debounce-period': set_debounce_period,
	'get-debounce-period': get_debounce_period,
	'set-sample-rate': set_sample_rate,
	'get-sample-rate': get_sample_rate,
	'set-calibration': set_calibration,
	'get-calibration': get_calibration,
	'get-adc-values': get_adc_values,
	'get-identity': get_identity
	}

	call_generic(ctx, 'industrial-dual-analog-in-bricklet', functions, argv)

def dispatch_industrial_dual_analog_in_bricklet(ctx, argv):
	prog_prefix = 'dispatch industrial-dual-analog-in-bricklet <uid>'

	def voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' voltage')

		args = parser.parse_args(argv)

		device_dispatch(ctx, IndustrialDualAnalogInBricklet, 13, args.execute, ['channel', 'voltage'], [None, None])

	def voltage_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' voltage-reached')

		args = parser.parse_args(argv)

		device_dispatch(ctx, IndustrialDualAnalogInBricklet, 14, args.execute, ['channel', 'voltage'], [None, None])

	callbacks = {
	'voltage': voltage,
	'voltage-reached': voltage_reached
	}

	dispatch_generic(ctx, 'industrial-dual-analog-in-bricklet', callbacks, argv)

class IndustrialDualAnalogInV2Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 2; re[3] = 1; re[5] = 3; re[6] = 1; re[7] = 3; re[8] = 1; re[9] = 1; re[10] = 3; re[11] = 1; re[12] = 3; re[13] = 1; re[234] = 1; re[235] = 1; re[236] = 1; re[237] = 3; re[238] = 1; re[239] = 3; re[240] = 1; re[242] = 1; re[243] = 3; re[248] = 3; re[249] = 1; re[255] = 1
		cf = self.callback_formats
		cf[4] = 'B i'


def call_industrial_dual_analog_in_v2_bricklet(ctx, argv):
	prog_prefix = 'call industrial-dual-analog-in-v2-bricklet <uid>'

	def get_voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-voltage')

		parser.add_argument('channel', type=convert_int, help='int', metavar='<channel>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDualAnalogInV2Bricklet, 1, (args.channel,), 'B', 'i', args.execute, False, ['voltage'], [None])

	def set_voltage_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-voltage-callback-configuration')

		parser.add_argument('channel', type=convert_int, help='int', metavar='<channel>')
		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')
		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDualAnalogInV2Bricklet, 2, (args.channel, args.period, args.value_has_to_change, args.option, args.min, args.max), 'B I ! c i i', '', None, args.expect_response, [], [])

	def get_voltage_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-voltage-callback-configuration')

		parser.add_argument('channel', type=convert_int, help='int', metavar='<channel>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDualAnalogInV2Bricklet, 3, (args.channel,), 'B', 'I ! c i i', args.execute, False, ['period', 'value-has-to-change', 'option', 'min', 'max'], [None, None, {'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def set_sample_rate(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-sample-rate')

		parser.add_argument('rate', type=create_symbol_converter(ctx, convert_int, {'sample-rate-4-sps': 5, 'sample-rate-488-sps': 1, 'sample-rate-61-sps': 4, 'sample-rate-1-sps': 7, 'sample-rate-2-sps': 6, 'sample-rate-122-sps': 3, 'sample-rate-244-sps': 2, 'sample-rate-976-sps': 0}), help='int (sample-rate-976-sps: 0, sample-rate-488-sps: 1, sample-rate-244-sps: 2, sample-rate-122-sps: 3, sample-rate-61-sps: 4, sample-rate-4-sps: 5, sample-rate-2-sps: 6, sample-rate-1-sps: 7)', metavar='<rate>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDualAnalogInV2Bricklet, 5, (args.rate,), 'B', '', None, args.expect_response, [], [])

	def get_sample_rate(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-sample-rate')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDualAnalogInV2Bricklet, 6, (), '', 'B', args.execute, False, ['rate'], [{0: 'sample-rate-976-sps', 1: 'sample-rate-488-sps', 2: 'sample-rate-244-sps', 3: 'sample-rate-122-sps', 4: 'sample-rate-61-sps', 5: 'sample-rate-4-sps', 6: 'sample-rate-2-sps', 7: 'sample-rate-1-sps'}])

	def set_calibration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-calibration')

		parser.add_argument('offset', type=create_array_converter(ctx, convert_int, '0', 2), help=get_array_type_name(ctx, 'int', 2), metavar='<offset>')
		parser.add_argument('gain', type=create_array_converter(ctx, convert_int, '0', 2), help=get_array_type_name(ctx, 'int', 2), metavar='<gain>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDualAnalogInV2Bricklet, 7, (args.offset, args.gain), '2i 2i', '', None, args.expect_response, [], [])

	def get_calibration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-calibration')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDualAnalogInV2Bricklet, 8, (), '', '2i 2i', args.execute, False, ['offset', 'gain'], [None, None])

	def get_adc_values(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-adc-values')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDualAnalogInV2Bricklet, 9, (), '', '2i', args.execute, False, ['value'], [None])

	def set_channel_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-channel-led-config')

		parser.add_argument('channel', type=convert_int, help='int', metavar='<channel>')
		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'channel-led-config-show-heartbeat': 2, 'channel-led-config-show-channel-status': 3, 'channel-led-config-off': 0, 'channel-led-config-on': 1}), help='int (channel-led-config-off: 0, channel-led-config-on: 1, channel-led-config-show-heartbeat: 2, channel-led-config-show-channel-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDualAnalogInV2Bricklet, 10, (args.channel, args.config), 'B B', '', None, args.expect_response, [], [])

	def get_channel_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-channel-led-config')

		parser.add_argument('channel', type=convert_int, help='int', metavar='<channel>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDualAnalogInV2Bricklet, 11, (args.channel,), 'B', 'B', args.execute, False, ['config'], [{0: 'channel-led-config-off', 1: 'channel-led-config-on', 2: 'channel-led-config-show-heartbeat', 3: 'channel-led-config-show-channel-status'}])

	def set_channel_led_status_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-channel-led-status-config')

		parser.add_argument('channel', type=convert_int, help='int', metavar='<channel>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')
		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'channel-led-status-config-intensity': 1, 'channel-led-status-config-threshold': 0}), help='int (channel-led-status-config-threshold: 0, channel-led-status-config-intensity: 1)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDualAnalogInV2Bricklet, 12, (args.channel, args.min, args.max, args.config), 'B i i B', '', None, args.expect_response, [], [])

	def get_channel_led_status_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-channel-led-status-config')

		parser.add_argument('channel', type=convert_int, help='int', metavar='<channel>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDualAnalogInV2Bricklet, 13, (args.channel,), 'B', 'i i B', args.execute, False, ['min', 'max', 'config'], [None, None, {0: 'channel-led-status-config-threshold', 1: 'channel-led-status-config-intensity'}])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDualAnalogInV2Bricklet, 234, (), '', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def set_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-bootloader-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'bootloader-mode-firmware-wait-for-reboot': 3, 'bootloader-mode-firmware': 1, 'bootloader-mode-firmware-wait-for-erase-and-reboot': 4, 'bootloader-mode-bootloader-wait-for-reboot': 2, 'bootloader-mode-bootloader': 0}), help='int (bootloader-mode-bootloader: 0, bootloader-mode-firmware: 1, bootloader-mode-bootloader-wait-for-reboot: 2, bootloader-mode-firmware-wait-for-reboot: 3, bootloader-mode-firmware-wait-for-erase-and-reboot: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDualAnalogInV2Bricklet, 235, (args.mode,), 'B', 'B', args.execute, False, ['status'], [{0: 'bootloader-status-ok', 1: 'bootloader-status-invalid-mode', 2: 'bootloader-status-no-change', 3: 'bootloader-status-entry-function-not-present', 4: 'bootloader-status-device-identifier-incorrect', 5: 'bootloader-status-crc-mismatch'}])

	def get_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-bootloader-mode')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDualAnalogInV2Bricklet, 236, (), '', 'B', args.execute, False, ['mode'], [{0: 'bootloader-mode-bootloader', 1: 'bootloader-mode-firmware', 2: 'bootloader-mode-bootloader-wait-for-reboot', 3: 'bootloader-mode-firmware-wait-for-reboot', 4: 'bootloader-mode-firmware-wait-for-erase-and-reboot'}])

	def set_write_firmware_pointer(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-write-firmware-pointer')

		parser.add_argument('pointer', type=convert_int, help='int', metavar='<pointer>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDualAnalogInV2Bricklet, 237, (args.pointer,), 'I', '', None, args.expect_response, [], [])

	def write_firmware(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-firmware')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDualAnalogInV2Bricklet, 238, (args.data,), '64B', 'B', args.execute, False, ['status'], [None])

	def set_status_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'status-led-config-on': 1, 'status-led-config-show-heartbeat': 2, 'status-led-config-off': 0, 'status-led-config-show-status': 3}), help='int (status-led-config-off: 0, status-led-config-on: 1, status-led-config-show-heartbeat: 2, status-led-config-show-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDualAnalogInV2Bricklet, 239, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_status_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDualAnalogInV2Bricklet, 240, (), '', 'B', args.execute, False, ['config'], [{0: 'status-led-config-off', 1: 'status-led-config-on', 2: 'status-led-config-show-heartbeat', 3: 'status-led-config-show-status'}])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDualAnalogInV2Bricklet, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDualAnalogInV2Bricklet, 243, (), '', '', None, args.expect_response, [], [])

	def write_uid(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-uid')

		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDualAnalogInV2Bricklet, 248, (args.uid,), 'I', '', None, args.expect_response, [], [])

	def read_uid(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-uid')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDualAnalogInV2Bricklet, 249, (), '', 'I', args.execute, False, ['uid'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, IndustrialDualAnalogInV2Bricklet, argv)

	functions = {
	'get-voltage': get_voltage,
	'set-voltage-callback-configuration': set_voltage_callback_configuration,
	'get-voltage-callback-configuration': get_voltage_callback_configuration,
	'set-sample-rate': set_sample_rate,
	'get-sample-rate': get_sample_rate,
	'set-calibration': set_calibration,
	'get-calibration': get_calibration,
	'get-adc-values': get_adc_values,
	'set-channel-led-config': set_channel_led_config,
	'get-channel-led-config': get_channel_led_config,
	'set-channel-led-status-config': set_channel_led_status_config,
	'get-channel-led-status-config': get_channel_led_status_config,
	'get-spitfp-error-count': get_spitfp_error_count,
	'set-bootloader-mode': set_bootloader_mode,
	'get-bootloader-mode': get_bootloader_mode,
	'set-write-firmware-pointer': set_write_firmware_pointer,
	'write-firmware': write_firmware,
	'set-status-led-config': set_status_led_config,
	'get-status-led-config': get_status_led_config,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'write-uid': write_uid,
	'read-uid': read_uid,
	'get-identity': get_identity
	}

	call_generic(ctx, 'industrial-dual-analog-in-v2-bricklet', functions, argv)

def dispatch_industrial_dual_analog_in_v2_bricklet(ctx, argv):
	prog_prefix = 'dispatch industrial-dual-analog-in-v2-bricklet <uid>'

	def voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' voltage')

		args = parser.parse_args(argv)

		device_dispatch(ctx, IndustrialDualAnalogInV2Bricklet, 4, args.execute, ['channel', 'voltage'], [None, None])

	callbacks = {
	'voltage': voltage
	}

	dispatch_generic(ctx, 'industrial-dual-analog-in-v2-bricklet', callbacks, argv)

class IndustrialDualRelayBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 3; re[2] = 1; re[3] = 3; re[4] = 1; re[6] = 3; re[234] = 1; re[235] = 1; re[236] = 1; re[237] = 3; re[238] = 1; re[239] = 3; re[240] = 1; re[242] = 1; re[243] = 3; re[248] = 3; re[249] = 1; re[255] = 1
		cf = self.callback_formats
		cf[5] = 'B !'


def call_industrial_dual_relay_bricklet(ctx, argv):
	prog_prefix = 'call industrial-dual-relay-bricklet <uid>'

	def set_value(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-value')

		parser.add_argument('channel0', type=convert_bool, help='bool', metavar='<channel0>')
		parser.add_argument('channel1', type=convert_bool, help='bool', metavar='<channel1>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDualRelayBricklet, 1, (args.channel0, args.channel1), '! !', '', None, args.expect_response, [], [])

	def get_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-value')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDualRelayBricklet, 2, (), '', '! !', args.execute, False, ['channel0', 'channel1'], [None, None])

	def set_monoflop(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-monoflop')

		parser.add_argument('channel', type=convert_int, help='int', metavar='<channel>')
		parser.add_argument('value', type=convert_bool, help='bool', metavar='<value>')
		parser.add_argument('time', type=convert_int, help='int', metavar='<time>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDualRelayBricklet, 3, (args.channel, args.value, args.time), 'B ! I', '', None, args.expect_response, [], [])

	def get_monoflop(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-monoflop')

		parser.add_argument('channel', type=convert_int, help='int', metavar='<channel>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDualRelayBricklet, 4, (args.channel,), 'B', '! I I', args.execute, False, ['value', 'time', 'time-remaining'], [None, None, None])

	def set_selected_value(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-selected-value')

		parser.add_argument('channel', type=convert_int, help='int', metavar='<channel>')
		parser.add_argument('value', type=convert_bool, help='bool', metavar='<value>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDualRelayBricklet, 6, (args.channel, args.value), 'B !', '', None, args.expect_response, [], [])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDualRelayBricklet, 234, (), '', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def set_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-bootloader-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'bootloader-mode-firmware-wait-for-reboot': 3, 'bootloader-mode-firmware': 1, 'bootloader-mode-firmware-wait-for-erase-and-reboot': 4, 'bootloader-mode-bootloader-wait-for-reboot': 2, 'bootloader-mode-bootloader': 0}), help='int (bootloader-mode-bootloader: 0, bootloader-mode-firmware: 1, bootloader-mode-bootloader-wait-for-reboot: 2, bootloader-mode-firmware-wait-for-reboot: 3, bootloader-mode-firmware-wait-for-erase-and-reboot: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDualRelayBricklet, 235, (args.mode,), 'B', 'B', args.execute, False, ['status'], [{0: 'bootloader-status-ok', 1: 'bootloader-status-invalid-mode', 2: 'bootloader-status-no-change', 3: 'bootloader-status-entry-function-not-present', 4: 'bootloader-status-device-identifier-incorrect', 5: 'bootloader-status-crc-mismatch'}])

	def get_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-bootloader-mode')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDualRelayBricklet, 236, (), '', 'B', args.execute, False, ['mode'], [{0: 'bootloader-mode-bootloader', 1: 'bootloader-mode-firmware', 2: 'bootloader-mode-bootloader-wait-for-reboot', 3: 'bootloader-mode-firmware-wait-for-reboot', 4: 'bootloader-mode-firmware-wait-for-erase-and-reboot'}])

	def set_write_firmware_pointer(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-write-firmware-pointer')

		parser.add_argument('pointer', type=convert_int, help='int', metavar='<pointer>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDualRelayBricklet, 237, (args.pointer,), 'I', '', None, args.expect_response, [], [])

	def write_firmware(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-firmware')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDualRelayBricklet, 238, (args.data,), '64B', 'B', args.execute, False, ['status'], [None])

	def set_status_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'status-led-config-on': 1, 'status-led-config-show-heartbeat': 2, 'status-led-config-off': 0, 'status-led-config-show-status': 3}), help='int (status-led-config-off: 0, status-led-config-on: 1, status-led-config-show-heartbeat: 2, status-led-config-show-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDualRelayBricklet, 239, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_status_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDualRelayBricklet, 240, (), '', 'B', args.execute, False, ['config'], [{0: 'status-led-config-off', 1: 'status-led-config-on', 2: 'status-led-config-show-heartbeat', 3: 'status-led-config-show-status'}])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDualRelayBricklet, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDualRelayBricklet, 243, (), '', '', None, args.expect_response, [], [])

	def write_uid(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-uid')

		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDualRelayBricklet, 248, (args.uid,), 'I', '', None, args.expect_response, [], [])

	def read_uid(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-uid')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialDualRelayBricklet, 249, (), '', 'I', args.execute, False, ['uid'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, IndustrialDualRelayBricklet, argv)

	functions = {
	'set-value': set_value,
	'get-value': get_value,
	'set-monoflop': set_monoflop,
	'get-monoflop': get_monoflop,
	'set-selected-value': set_selected_value,
	'get-spitfp-error-count': get_spitfp_error_count,
	'set-bootloader-mode': set_bootloader_mode,
	'get-bootloader-mode': get_bootloader_mode,
	'set-write-firmware-pointer': set_write_firmware_pointer,
	'write-firmware': write_firmware,
	'set-status-led-config': set_status_led_config,
	'get-status-led-config': get_status_led_config,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'write-uid': write_uid,
	'read-uid': read_uid,
	'get-identity': get_identity
	}

	call_generic(ctx, 'industrial-dual-relay-bricklet', functions, argv)

def dispatch_industrial_dual_relay_bricklet(ctx, argv):
	prog_prefix = 'dispatch industrial-dual-relay-bricklet <uid>'

	def monoflop_done(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' monoflop-done')

		args = parser.parse_args(argv)

		device_dispatch(ctx, IndustrialDualRelayBricklet, 5, args.execute, ['channel', 'value'], [None, None])

	callbacks = {
	'monoflop-done': monoflop_done
	}

	dispatch_generic(ctx, 'industrial-dual-relay-bricklet', callbacks, argv)

class IndustrialQuadRelayBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 3; re[2] = 1; re[3] = 3; re[4] = 1; re[5] = 3; re[6] = 1; re[7] = 1; re[9] = 3; re[255] = 1
		cf = self.callback_formats
		cf[8] = 'H H'


def call_industrial_quad_relay_bricklet(ctx, argv):
	prog_prefix = 'call industrial-quad-relay-bricklet <uid>'

	def set_value(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-value')

		parser.add_argument('value_mask', type=convert_int, help='int', metavar='<value-mask>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialQuadRelayBricklet, 1, (args.value_mask,), 'H', '', None, args.expect_response, [], [])

	def get_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-value')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialQuadRelayBricklet, 2, (), '', 'H', args.execute, False, ['value-mask'], [None])

	def set_monoflop(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-monoflop')

		parser.add_argument('selection_mask', type=convert_int, help='int', metavar='<selection-mask>')
		parser.add_argument('value_mask', type=convert_int, help='int', metavar='<value-mask>')
		parser.add_argument('time', type=convert_int, help='int', metavar='<time>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialQuadRelayBricklet, 3, (args.selection_mask, args.value_mask, args.time), 'H H I', '', None, args.expect_response, [], [])

	def get_monoflop(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-monoflop')

		parser.add_argument('pin', type=convert_int, help='int', metavar='<pin>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialQuadRelayBricklet, 4, (args.pin,), 'B', 'H I I', args.execute, False, ['value', 'time', 'time-remaining'], [None, None, None])

	def set_group(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-group')

		parser.add_argument('group', type=create_array_converter(ctx, create_char_converter(ctx), '\0', 4), help=get_array_type_name(ctx, 'char', 4), metavar='<group>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialQuadRelayBricklet, 5, (args.group,), '4c', '', None, args.expect_response, [], [])

	def get_group(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-group')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialQuadRelayBricklet, 6, (), '', '4c', args.execute, False, ['group'], [None])

	def get_available_for_group(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-available-for-group')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialQuadRelayBricklet, 7, (), '', 'B', args.execute, False, ['available'], [None])

	def set_selected_values(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-selected-values')

		parser.add_argument('selection_mask', type=convert_int, help='int', metavar='<selection-mask>')
		parser.add_argument('value_mask', type=convert_int, help='int', metavar='<value-mask>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialQuadRelayBricklet, 9, (args.selection_mask, args.value_mask), 'H H', '', None, args.expect_response, [], [])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, IndustrialQuadRelayBricklet, argv)

	functions = {
	'set-value': set_value,
	'get-value': get_value,
	'set-monoflop': set_monoflop,
	'get-monoflop': get_monoflop,
	'set-group': set_group,
	'get-group': get_group,
	'get-available-for-group': get_available_for_group,
	'set-selected-values': set_selected_values,
	'get-identity': get_identity
	}

	call_generic(ctx, 'industrial-quad-relay-bricklet', functions, argv)

def dispatch_industrial_quad_relay_bricklet(ctx, argv):
	prog_prefix = 'dispatch industrial-quad-relay-bricklet <uid>'

	def monoflop_done(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' monoflop-done')

		args = parser.parse_args(argv)

		device_dispatch(ctx, IndustrialQuadRelayBricklet, 8, args.execute, ['selection-mask', 'value-mask'], [None, None])

	callbacks = {
	'monoflop-done': monoflop_done
	}

	dispatch_generic(ctx, 'industrial-quad-relay-bricklet', callbacks, argv)

class IndustrialQuadRelayV2Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 3; re[2] = 1; re[3] = 3; re[4] = 1; re[5] = 3; re[6] = 3; re[7] = 1; re[234] = 1; re[235] = 1; re[236] = 1; re[237] = 3; re[238] = 1; re[239] = 3; re[240] = 1; re[242] = 1; re[243] = 3; re[248] = 3; re[249] = 1; re[255] = 1
		cf = self.callback_formats
		cf[8] = 'B !'


def call_industrial_quad_relay_v2_bricklet(ctx, argv):
	prog_prefix = 'call industrial-quad-relay-v2-bricklet <uid>'

	def set_value(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-value')

		parser.add_argument('value', type=create_array_converter(ctx, convert_bool, 'false', 4), help=get_array_type_name(ctx, 'bool', 4), metavar='<value>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialQuadRelayV2Bricklet, 1, (args.value,), '4!', '', None, args.expect_response, [], [])

	def get_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-value')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialQuadRelayV2Bricklet, 2, (), '', '4!', args.execute, False, ['value'], [None])

	def set_monoflop(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-monoflop')

		parser.add_argument('channel', type=convert_int, help='int', metavar='<channel>')
		parser.add_argument('value', type=convert_bool, help='bool', metavar='<value>')
		parser.add_argument('time', type=convert_int, help='int', metavar='<time>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialQuadRelayV2Bricklet, 3, (args.channel, args.value, args.time), 'B ! I', '', None, args.expect_response, [], [])

	def get_monoflop(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-monoflop')

		parser.add_argument('channel', type=convert_int, help='int', metavar='<channel>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialQuadRelayV2Bricklet, 4, (args.channel,), 'B', '! I I', args.execute, False, ['value', 'time', 'time-remaining'], [None, None, None])

	def set_selected_value(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-selected-value')

		parser.add_argument('channel', type=convert_int, help='int', metavar='<channel>')
		parser.add_argument('value', type=convert_bool, help='bool', metavar='<value>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialQuadRelayV2Bricklet, 5, (args.channel, args.value), 'B !', '', None, args.expect_response, [], [])

	def set_channel_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-channel-led-config')

		parser.add_argument('channel', type=convert_int, help='int', metavar='<channel>')
		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'channel-led-config-show-heartbeat': 2, 'channel-led-config-show-channel-status': 3, 'channel-led-config-off': 0, 'channel-led-config-on': 1}), help='int (channel-led-config-off: 0, channel-led-config-on: 1, channel-led-config-show-heartbeat: 2, channel-led-config-show-channel-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialQuadRelayV2Bricklet, 6, (args.channel, args.config), 'B B', '', None, args.expect_response, [], [])

	def get_channel_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-channel-led-config')

		parser.add_argument('channel', type=convert_int, help='int', metavar='<channel>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialQuadRelayV2Bricklet, 7, (args.channel,), 'B', 'B', args.execute, False, ['config'], [{0: 'channel-led-config-off', 1: 'channel-led-config-on', 2: 'channel-led-config-show-heartbeat', 3: 'channel-led-config-show-channel-status'}])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialQuadRelayV2Bricklet, 234, (), '', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def set_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-bootloader-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'bootloader-mode-firmware-wait-for-reboot': 3, 'bootloader-mode-firmware': 1, 'bootloader-mode-firmware-wait-for-erase-and-reboot': 4, 'bootloader-mode-bootloader-wait-for-reboot': 2, 'bootloader-mode-bootloader': 0}), help='int (bootloader-mode-bootloader: 0, bootloader-mode-firmware: 1, bootloader-mode-bootloader-wait-for-reboot: 2, bootloader-mode-firmware-wait-for-reboot: 3, bootloader-mode-firmware-wait-for-erase-and-reboot: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialQuadRelayV2Bricklet, 235, (args.mode,), 'B', 'B', args.execute, False, ['status'], [{0: 'bootloader-status-ok', 1: 'bootloader-status-invalid-mode', 2: 'bootloader-status-no-change', 3: 'bootloader-status-entry-function-not-present', 4: 'bootloader-status-device-identifier-incorrect', 5: 'bootloader-status-crc-mismatch'}])

	def get_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-bootloader-mode')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialQuadRelayV2Bricklet, 236, (), '', 'B', args.execute, False, ['mode'], [{0: 'bootloader-mode-bootloader', 1: 'bootloader-mode-firmware', 2: 'bootloader-mode-bootloader-wait-for-reboot', 3: 'bootloader-mode-firmware-wait-for-reboot', 4: 'bootloader-mode-firmware-wait-for-erase-and-reboot'}])

	def set_write_firmware_pointer(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-write-firmware-pointer')

		parser.add_argument('pointer', type=convert_int, help='int', metavar='<pointer>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialQuadRelayV2Bricklet, 237, (args.pointer,), 'I', '', None, args.expect_response, [], [])

	def write_firmware(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-firmware')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialQuadRelayV2Bricklet, 238, (args.data,), '64B', 'B', args.execute, False, ['status'], [None])

	def set_status_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'status-led-config-on': 1, 'status-led-config-show-heartbeat': 2, 'status-led-config-off': 0, 'status-led-config-show-status': 3}), help='int (status-led-config-off: 0, status-led-config-on: 1, status-led-config-show-heartbeat: 2, status-led-config-show-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialQuadRelayV2Bricklet, 239, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_status_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialQuadRelayV2Bricklet, 240, (), '', 'B', args.execute, False, ['config'], [{0: 'status-led-config-off', 1: 'status-led-config-on', 2: 'status-led-config-show-heartbeat', 3: 'status-led-config-show-status'}])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialQuadRelayV2Bricklet, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialQuadRelayV2Bricklet, 243, (), '', '', None, args.expect_response, [], [])

	def write_uid(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-uid')

		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialQuadRelayV2Bricklet, 248, (args.uid,), 'I', '', None, args.expect_response, [], [])

	def read_uid(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-uid')

		args = parser.parse_args(argv)

		device_call(ctx, IndustrialQuadRelayV2Bricklet, 249, (), '', 'I', args.execute, False, ['uid'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, IndustrialQuadRelayV2Bricklet, argv)

	functions = {
	'set-value': set_value,
	'get-value': get_value,
	'set-monoflop': set_monoflop,
	'get-monoflop': get_monoflop,
	'set-selected-value': set_selected_value,
	'set-channel-led-config': set_channel_led_config,
	'get-channel-led-config': get_channel_led_config,
	'get-spitfp-error-count': get_spitfp_error_count,
	'set-bootloader-mode': set_bootloader_mode,
	'get-bootloader-mode': get_bootloader_mode,
	'set-write-firmware-pointer': set_write_firmware_pointer,
	'write-firmware': write_firmware,
	'set-status-led-config': set_status_led_config,
	'get-status-led-config': get_status_led_config,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'write-uid': write_uid,
	'read-uid': read_uid,
	'get-identity': get_identity
	}

	call_generic(ctx, 'industrial-quad-relay-v2-bricklet', functions, argv)

def dispatch_industrial_quad_relay_v2_bricklet(ctx, argv):
	prog_prefix = 'dispatch industrial-quad-relay-v2-bricklet <uid>'

	def monoflop_done(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' monoflop-done')

		args = parser.parse_args(argv)

		device_dispatch(ctx, IndustrialQuadRelayV2Bricklet, 8, args.execute, ['channel', 'value'], [None, None])

	callbacks = {
	'monoflop-done': monoflop_done
	}

	dispatch_generic(ctx, 'industrial-quad-relay-v2-bricklet', callbacks, argv)

class IO16Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 3; re[2] = 1; re[3] = 3; re[4] = 1; re[5] = 2; re[6] = 1; re[7] = 2; re[8] = 1; re[10] = 3; re[11] = 1; re[13] = 3; re[14] = 1; re[15] = 3; re[16] = 1; re[255] = 1
		cf = self.callback_formats
		cf[9] = 'c B B'; cf[12] = 'c B B'


def call_io16_bricklet(ctx, argv):
	prog_prefix = 'call io16-bricklet <uid>'

	def set_port(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-port')

		parser.add_argument('port', type=create_char_converter(ctx), help='char', metavar='<port>')
		parser.add_argument('value_mask', type=convert_int, help='int', metavar='<value-mask>')

		args = parser.parse_args(argv)

		device_call(ctx, IO16Bricklet, 1, (args.port, args.value_mask), 'c B', '', None, args.expect_response, [], [])

	def get_port(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-port')

		parser.add_argument('port', type=create_char_converter(ctx), help='char', metavar='<port>')

		args = parser.parse_args(argv)

		device_call(ctx, IO16Bricklet, 2, (args.port,), 'c', 'B', args.execute, False, ['value-mask'], [None])

	def set_port_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-port-configuration')

		parser.add_argument('port', type=create_char_converter(ctx), help='char', metavar='<port>')
		parser.add_argument('selection_mask', type=convert_int, help='int', metavar='<selection-mask>')
		parser.add_argument('direction', type=create_symbol_converter(ctx, create_char_converter(ctx), {'direction-in': 'i', 'direction-out': 'o'}), help='char (direction-in: i, direction-out: o)', metavar='<direction>')
		parser.add_argument('value', type=convert_bool, help='bool', metavar='<value>')

		args = parser.parse_args(argv)

		device_call(ctx, IO16Bricklet, 3, (args.port, args.selection_mask, args.direction, args.value), 'c B c !', '', None, args.expect_response, [], [])

	def get_port_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-port-configuration')

		parser.add_argument('port', type=create_char_converter(ctx), help='char', metavar='<port>')

		args = parser.parse_args(argv)

		device_call(ctx, IO16Bricklet, 4, (args.port,), 'c', 'B B', args.execute, False, ['direction-mask', 'value-mask'], [None, None])

	def set_debounce_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-debounce-period')

		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_call(ctx, IO16Bricklet, 5, (args.debounce,), 'I', '', None, args.expect_response, [], [])

	def get_debounce_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-debounce-period')

		args = parser.parse_args(argv)

		device_call(ctx, IO16Bricklet, 6, (), '', 'I', args.execute, False, ['debounce'], [None])

	def set_port_interrupt(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-port-interrupt')

		parser.add_argument('port', type=create_char_converter(ctx), help='char', metavar='<port>')
		parser.add_argument('interrupt_mask', type=convert_int, help='int', metavar='<interrupt-mask>')

		args = parser.parse_args(argv)

		device_call(ctx, IO16Bricklet, 7, (args.port, args.interrupt_mask), 'c B', '', None, args.expect_response, [], [])

	def get_port_interrupt(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-port-interrupt')

		parser.add_argument('port', type=create_char_converter(ctx), help='char', metavar='<port>')

		args = parser.parse_args(argv)

		device_call(ctx, IO16Bricklet, 8, (args.port,), 'c', 'B', args.execute, False, ['interrupt-mask'], [None])

	def set_port_monoflop(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-port-monoflop')

		parser.add_argument('port', type=create_char_converter(ctx), help='char', metavar='<port>')
		parser.add_argument('selection_mask', type=convert_int, help='int', metavar='<selection-mask>')
		parser.add_argument('value_mask', type=convert_int, help='int', metavar='<value-mask>')
		parser.add_argument('time', type=convert_int, help='int', metavar='<time>')

		args = parser.parse_args(argv)

		device_call(ctx, IO16Bricklet, 10, (args.port, args.selection_mask, args.value_mask, args.time), 'c B B I', '', None, args.expect_response, [], [])

	def get_port_monoflop(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-port-monoflop')

		parser.add_argument('port', type=create_char_converter(ctx), help='char', metavar='<port>')
		parser.add_argument('pin', type=convert_int, help='int', metavar='<pin>')

		args = parser.parse_args(argv)

		device_call(ctx, IO16Bricklet, 11, (args.port, args.pin), 'c B', 'B I I', args.execute, False, ['value', 'time', 'time-remaining'], [None, None, None])

	def set_selected_values(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-selected-values')

		parser.add_argument('port', type=create_char_converter(ctx), help='char', metavar='<port>')
		parser.add_argument('selection_mask', type=convert_int, help='int', metavar='<selection-mask>')
		parser.add_argument('value_mask', type=convert_int, help='int', metavar='<value-mask>')

		args = parser.parse_args(argv)

		device_call(ctx, IO16Bricklet, 13, (args.port, args.selection_mask, args.value_mask), 'c B B', '', None, args.expect_response, [], [])

	def get_edge_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-edge-count')

		parser.add_argument('pin', type=convert_int, help='int', metavar='<pin>')
		parser.add_argument('reset_counter', type=convert_bool, help='bool', metavar='<reset-counter>')

		args = parser.parse_args(argv)

		device_call(ctx, IO16Bricklet, 14, (args.pin, args.reset_counter), 'B !', 'I', args.execute, False, ['count'], [None])

	def set_edge_count_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-edge-count-config')

		parser.add_argument('pin', type=convert_int, help='int', metavar='<pin>')
		parser.add_argument('edge_type', type=create_symbol_converter(ctx, convert_int, {'edge-type-both': 2, 'edge-type-falling': 1, 'edge-type-rising': 0}), help='int (edge-type-rising: 0, edge-type-falling: 1, edge-type-both: 2)', metavar='<edge-type>')
		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_call(ctx, IO16Bricklet, 15, (args.pin, args.edge_type, args.debounce), 'B B B', '', None, args.expect_response, [], [])

	def get_edge_count_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-edge-count-config')

		parser.add_argument('pin', type=convert_int, help='int', metavar='<pin>')

		args = parser.parse_args(argv)

		device_call(ctx, IO16Bricklet, 16, (args.pin,), 'B', 'B B', args.execute, False, ['edge-type', 'debounce'], [{0: 'edge-type-rising', 1: 'edge-type-falling', 2: 'edge-type-both'}, None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, IO16Bricklet, argv)

	functions = {
	'set-port': set_port,
	'get-port': get_port,
	'set-port-configuration': set_port_configuration,
	'get-port-configuration': get_port_configuration,
	'set-debounce-period': set_debounce_period,
	'get-debounce-period': get_debounce_period,
	'set-port-interrupt': set_port_interrupt,
	'get-port-interrupt': get_port_interrupt,
	'set-port-monoflop': set_port_monoflop,
	'get-port-monoflop': get_port_monoflop,
	'set-selected-values': set_selected_values,
	'get-edge-count': get_edge_count,
	'set-edge-count-config': set_edge_count_config,
	'get-edge-count-config': get_edge_count_config,
	'get-identity': get_identity
	}

	call_generic(ctx, 'io16-bricklet', functions, argv)

def dispatch_io16_bricklet(ctx, argv):
	prog_prefix = 'dispatch io16-bricklet <uid>'

	def interrupt(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' interrupt')

		args = parser.parse_args(argv)

		device_dispatch(ctx, IO16Bricklet, 9, args.execute, ['port', 'interrupt-mask', 'value-mask'], [None, None, None])

	def monoflop_done(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' monoflop-done')

		args = parser.parse_args(argv)

		device_dispatch(ctx, IO16Bricklet, 12, args.execute, ['port', 'selection-mask', 'value-mask'], [None, None, None])

	callbacks = {
	'interrupt': interrupt,
	'monoflop-done': monoflop_done
	}

	dispatch_generic(ctx, 'io16-bricklet', callbacks, argv)

class IO16V2Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 3; re[2] = 1; re[3] = 3; re[4] = 3; re[5] = 1; re[6] = 2; re[7] = 1; re[8] = 2; re[9] = 1; re[10] = 3; re[11] = 1; re[12] = 1; re[13] = 3; re[14] = 1; re[234] = 1; re[235] = 1; re[236] = 1; re[237] = 3; re[238] = 1; re[239] = 3; re[240] = 1; re[242] = 1; re[243] = 3; re[248] = 3; re[249] = 1; re[255] = 1
		cf = self.callback_formats
		cf[15] = 'B ! !'; cf[16] = '16! 16!'; cf[17] = 'B !'


def call_io16_v2_bricklet(ctx, argv):
	prog_prefix = 'call io16-v2-bricklet <uid>'

	def set_value(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-value')

		parser.add_argument('value', type=create_array_converter(ctx, convert_bool, 'false', 16), help=get_array_type_name(ctx, 'bool', 16), metavar='<value>')

		args = parser.parse_args(argv)

		device_call(ctx, IO16V2Bricklet, 1, (args.value,), '16!', '', None, args.expect_response, [], [])

	def get_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-value')

		args = parser.parse_args(argv)

		device_call(ctx, IO16V2Bricklet, 2, (), '', '16!', args.execute, False, ['value'], [None])

	def set_selected_value(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-selected-value')

		parser.add_argument('channel', type=convert_int, help='int', metavar='<channel>')
		parser.add_argument('value', type=convert_bool, help='bool', metavar='<value>')

		args = parser.parse_args(argv)

		device_call(ctx, IO16V2Bricklet, 3, (args.channel, args.value), 'B !', '', None, args.expect_response, [], [])

	def set_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-configuration')

		parser.add_argument('channel', type=convert_int, help='int', metavar='<channel>')
		parser.add_argument('direction', type=create_symbol_converter(ctx, create_char_converter(ctx), {'direction-in': 'i', 'direction-out': 'o'}), help='char (direction-in: i, direction-out: o)', metavar='<direction>')
		parser.add_argument('value', type=convert_bool, help='bool', metavar='<value>')

		args = parser.parse_args(argv)

		device_call(ctx, IO16V2Bricklet, 4, (args.channel, args.direction, args.value), 'B c !', '', None, args.expect_response, [], [])

	def get_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-configuration')

		parser.add_argument('channel', type=convert_int, help='int', metavar='<channel>')

		args = parser.parse_args(argv)

		device_call(ctx, IO16V2Bricklet, 5, (args.channel,), 'B', 'c !', args.execute, False, ['direction', 'value'], [{'i': 'direction-in', 'o': 'direction-out'}, None])

	def set_input_value_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-input-value-callback-configuration')

		parser.add_argument('channel', type=convert_int, help='int', metavar='<channel>')
		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')

		args = parser.parse_args(argv)

		device_call(ctx, IO16V2Bricklet, 6, (args.channel, args.period, args.value_has_to_change), 'B I !', '', None, args.expect_response, [], [])

	def get_input_value_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-input-value-callback-configuration')

		parser.add_argument('channel', type=convert_int, help='int', metavar='<channel>')

		args = parser.parse_args(argv)

		device_call(ctx, IO16V2Bricklet, 7, (args.channel,), 'B', 'I !', args.execute, False, ['period', 'value-has-to-change'], [None, None])

	def set_all_input_value_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-all-input-value-callback-configuration')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')

		args = parser.parse_args(argv)

		device_call(ctx, IO16V2Bricklet, 8, (args.period, args.value_has_to_change), 'I !', '', None, args.expect_response, [], [])

	def get_all_input_value_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-all-input-value-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, IO16V2Bricklet, 9, (), '', 'I !', args.execute, False, ['period', 'value-has-to-change'], [None, None])

	def set_monoflop(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-monoflop')

		parser.add_argument('channel', type=convert_int, help='int', metavar='<channel>')
		parser.add_argument('value', type=convert_bool, help='bool', metavar='<value>')
		parser.add_argument('time', type=convert_int, help='int', metavar='<time>')

		args = parser.parse_args(argv)

		device_call(ctx, IO16V2Bricklet, 10, (args.channel, args.value, args.time), 'B ! I', '', None, args.expect_response, [], [])

	def get_monoflop(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-monoflop')

		parser.add_argument('channel', type=convert_int, help='int', metavar='<channel>')

		args = parser.parse_args(argv)

		device_call(ctx, IO16V2Bricklet, 11, (args.channel,), 'B', '! I I', args.execute, False, ['value', 'time', 'time-remaining'], [None, None, None])

	def get_edge_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-edge-count')

		parser.add_argument('channel', type=convert_int, help='int', metavar='<channel>')
		parser.add_argument('reset_counter', type=convert_bool, help='bool', metavar='<reset-counter>')

		args = parser.parse_args(argv)

		device_call(ctx, IO16V2Bricklet, 12, (args.channel, args.reset_counter), 'B !', 'I', args.execute, False, ['count'], [None])

	def set_edge_count_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-edge-count-configuration')

		parser.add_argument('channel', type=convert_int, help='int', metavar='<channel>')
		parser.add_argument('edge_type', type=create_symbol_converter(ctx, convert_int, {'edge-type-both': 2, 'edge-type-falling': 1, 'edge-type-rising': 0}), help='int (edge-type-rising: 0, edge-type-falling: 1, edge-type-both: 2)', metavar='<edge-type>')
		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_call(ctx, IO16V2Bricklet, 13, (args.channel, args.edge_type, args.debounce), 'B B B', '', None, args.expect_response, [], [])

	def get_edge_count_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-edge-count-configuration')

		parser.add_argument('channel', type=convert_int, help='int', metavar='<channel>')

		args = parser.parse_args(argv)

		device_call(ctx, IO16V2Bricklet, 14, (args.channel,), 'B', 'B B', args.execute, False, ['edge-type', 'debounce'], [{0: 'edge-type-rising', 1: 'edge-type-falling', 2: 'edge-type-both'}, None])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, IO16V2Bricklet, 234, (), '', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def set_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-bootloader-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'bootloader-mode-firmware-wait-for-reboot': 3, 'bootloader-mode-firmware': 1, 'bootloader-mode-firmware-wait-for-erase-and-reboot': 4, 'bootloader-mode-bootloader-wait-for-reboot': 2, 'bootloader-mode-bootloader': 0}), help='int (bootloader-mode-bootloader: 0, bootloader-mode-firmware: 1, bootloader-mode-bootloader-wait-for-reboot: 2, bootloader-mode-firmware-wait-for-reboot: 3, bootloader-mode-firmware-wait-for-erase-and-reboot: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, IO16V2Bricklet, 235, (args.mode,), 'B', 'B', args.execute, False, ['status'], [{0: 'bootloader-status-ok', 1: 'bootloader-status-invalid-mode', 2: 'bootloader-status-no-change', 3: 'bootloader-status-entry-function-not-present', 4: 'bootloader-status-device-identifier-incorrect', 5: 'bootloader-status-crc-mismatch'}])

	def get_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-bootloader-mode')

		args = parser.parse_args(argv)

		device_call(ctx, IO16V2Bricklet, 236, (), '', 'B', args.execute, False, ['mode'], [{0: 'bootloader-mode-bootloader', 1: 'bootloader-mode-firmware', 2: 'bootloader-mode-bootloader-wait-for-reboot', 3: 'bootloader-mode-firmware-wait-for-reboot', 4: 'bootloader-mode-firmware-wait-for-erase-and-reboot'}])

	def set_write_firmware_pointer(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-write-firmware-pointer')

		parser.add_argument('pointer', type=convert_int, help='int', metavar='<pointer>')

		args = parser.parse_args(argv)

		device_call(ctx, IO16V2Bricklet, 237, (args.pointer,), 'I', '', None, args.expect_response, [], [])

	def write_firmware(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-firmware')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, IO16V2Bricklet, 238, (args.data,), '64B', 'B', args.execute, False, ['status'], [None])

	def set_status_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'status-led-config-on': 1, 'status-led-config-show-heartbeat': 2, 'status-led-config-off': 0, 'status-led-config-show-status': 3}), help='int (status-led-config-off: 0, status-led-config-on: 1, status-led-config-show-heartbeat: 2, status-led-config-show-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, IO16V2Bricklet, 239, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_status_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, IO16V2Bricklet, 240, (), '', 'B', args.execute, False, ['config'], [{0: 'status-led-config-off', 1: 'status-led-config-on', 2: 'status-led-config-show-heartbeat', 3: 'status-led-config-show-status'}])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, IO16V2Bricklet, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, IO16V2Bricklet, 243, (), '', '', None, args.expect_response, [], [])

	def write_uid(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-uid')

		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')

		args = parser.parse_args(argv)

		device_call(ctx, IO16V2Bricklet, 248, (args.uid,), 'I', '', None, args.expect_response, [], [])

	def read_uid(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-uid')

		args = parser.parse_args(argv)

		device_call(ctx, IO16V2Bricklet, 249, (), '', 'I', args.execute, False, ['uid'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, IO16V2Bricklet, argv)

	functions = {
	'set-value': set_value,
	'get-value': get_value,
	'set-selected-value': set_selected_value,
	'set-configuration': set_configuration,
	'get-configuration': get_configuration,
	'set-input-value-callback-configuration': set_input_value_callback_configuration,
	'get-input-value-callback-configuration': get_input_value_callback_configuration,
	'set-all-input-value-callback-configuration': set_all_input_value_callback_configuration,
	'get-all-input-value-callback-configuration': get_all_input_value_callback_configuration,
	'set-monoflop': set_monoflop,
	'get-monoflop': get_monoflop,
	'get-edge-count': get_edge_count,
	'set-edge-count-configuration': set_edge_count_configuration,
	'get-edge-count-configuration': get_edge_count_configuration,
	'get-spitfp-error-count': get_spitfp_error_count,
	'set-bootloader-mode': set_bootloader_mode,
	'get-bootloader-mode': get_bootloader_mode,
	'set-write-firmware-pointer': set_write_firmware_pointer,
	'write-firmware': write_firmware,
	'set-status-led-config': set_status_led_config,
	'get-status-led-config': get_status_led_config,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'write-uid': write_uid,
	'read-uid': read_uid,
	'get-identity': get_identity
	}

	call_generic(ctx, 'io16-v2-bricklet', functions, argv)

def dispatch_io16_v2_bricklet(ctx, argv):
	prog_prefix = 'dispatch io16-v2-bricklet <uid>'

	def input_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' input-value')

		args = parser.parse_args(argv)

		device_dispatch(ctx, IO16V2Bricklet, 15, args.execute, ['channel', 'changed', 'value'], [None, None, None])

	def all_input_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' all-input-value')

		args = parser.parse_args(argv)

		device_dispatch(ctx, IO16V2Bricklet, 16, args.execute, ['changed', 'value'], [None, None])

	def monoflop_done(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' monoflop-done')

		args = parser.parse_args(argv)

		device_dispatch(ctx, IO16V2Bricklet, 17, args.execute, ['channel', 'value'], [None, None])

	callbacks = {
	'input-value': input_value,
	'all-input-value': all_input_value,
	'monoflop-done': monoflop_done
	}

	dispatch_generic(ctx, 'io16-v2-bricklet', callbacks, argv)

class IO4Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 3; re[2] = 1; re[3] = 3; re[4] = 1; re[5] = 2; re[6] = 1; re[7] = 2; re[8] = 1; re[10] = 3; re[11] = 1; re[13] = 3; re[14] = 1; re[15] = 3; re[16] = 1; re[255] = 1
		cf = self.callback_formats
		cf[9] = 'B B'; cf[12] = 'B B'


def call_io4_bricklet(ctx, argv):
	prog_prefix = 'call io4-bricklet <uid>'

	def set_value(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-value')

		parser.add_argument('value_mask', type=convert_int, help='int', metavar='<value-mask>')

		args = parser.parse_args(argv)

		device_call(ctx, IO4Bricklet, 1, (args.value_mask,), 'B', '', None, args.expect_response, [], [])

	def get_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-value')

		args = parser.parse_args(argv)

		device_call(ctx, IO4Bricklet, 2, (), '', 'B', args.execute, False, ['value-mask'], [None])

	def set_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-configuration')

		parser.add_argument('selection_mask', type=convert_int, help='int', metavar='<selection-mask>')
		parser.add_argument('direction', type=create_symbol_converter(ctx, create_char_converter(ctx), {'direction-in': 'i', 'direction-out': 'o'}), help='char (direction-in: i, direction-out: o)', metavar='<direction>')
		parser.add_argument('value', type=convert_bool, help='bool', metavar='<value>')

		args = parser.parse_args(argv)

		device_call(ctx, IO4Bricklet, 3, (args.selection_mask, args.direction, args.value), 'B c !', '', None, args.expect_response, [], [])

	def get_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, IO4Bricklet, 4, (), '', 'B B', args.execute, False, ['direction-mask', 'value-mask'], [None, None])

	def set_debounce_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-debounce-period')

		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_call(ctx, IO4Bricklet, 5, (args.debounce,), 'I', '', None, args.expect_response, [], [])

	def get_debounce_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-debounce-period')

		args = parser.parse_args(argv)

		device_call(ctx, IO4Bricklet, 6, (), '', 'I', args.execute, False, ['debounce'], [None])

	def set_interrupt(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-interrupt')

		parser.add_argument('interrupt_mask', type=convert_int, help='int', metavar='<interrupt-mask>')

		args = parser.parse_args(argv)

		device_call(ctx, IO4Bricklet, 7, (args.interrupt_mask,), 'B', '', None, args.expect_response, [], [])

	def get_interrupt(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-interrupt')

		args = parser.parse_args(argv)

		device_call(ctx, IO4Bricklet, 8, (), '', 'B', args.execute, False, ['interrupt-mask'], [None])

	def set_monoflop(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-monoflop')

		parser.add_argument('selection_mask', type=convert_int, help='int', metavar='<selection-mask>')
		parser.add_argument('value_mask', type=convert_int, help='int', metavar='<value-mask>')
		parser.add_argument('time', type=convert_int, help='int', metavar='<time>')

		args = parser.parse_args(argv)

		device_call(ctx, IO4Bricklet, 10, (args.selection_mask, args.value_mask, args.time), 'B B I', '', None, args.expect_response, [], [])

	def get_monoflop(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-monoflop')

		parser.add_argument('pin', type=convert_int, help='int', metavar='<pin>')

		args = parser.parse_args(argv)

		device_call(ctx, IO4Bricklet, 11, (args.pin,), 'B', 'B I I', args.execute, False, ['value', 'time', 'time-remaining'], [None, None, None])

	def set_selected_values(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-selected-values')

		parser.add_argument('selection_mask', type=convert_int, help='int', metavar='<selection-mask>')
		parser.add_argument('value_mask', type=convert_int, help='int', metavar='<value-mask>')

		args = parser.parse_args(argv)

		device_call(ctx, IO4Bricklet, 13, (args.selection_mask, args.value_mask), 'B B', '', None, args.expect_response, [], [])

	def get_edge_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-edge-count')

		parser.add_argument('pin', type=convert_int, help='int', metavar='<pin>')
		parser.add_argument('reset_counter', type=convert_bool, help='bool', metavar='<reset-counter>')

		args = parser.parse_args(argv)

		device_call(ctx, IO4Bricklet, 14, (args.pin, args.reset_counter), 'B !', 'I', args.execute, False, ['count'], [None])

	def set_edge_count_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-edge-count-config')

		parser.add_argument('selection_mask', type=convert_int, help='int', metavar='<selection-mask>')
		parser.add_argument('edge_type', type=create_symbol_converter(ctx, convert_int, {'edge-type-both': 2, 'edge-type-falling': 1, 'edge-type-rising': 0}), help='int (edge-type-rising: 0, edge-type-falling: 1, edge-type-both: 2)', metavar='<edge-type>')
		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_call(ctx, IO4Bricklet, 15, (args.selection_mask, args.edge_type, args.debounce), 'B B B', '', None, args.expect_response, [], [])

	def get_edge_count_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-edge-count-config')

		parser.add_argument('pin', type=convert_int, help='int', metavar='<pin>')

		args = parser.parse_args(argv)

		device_call(ctx, IO4Bricklet, 16, (args.pin,), 'B', 'B B', args.execute, False, ['edge-type', 'debounce'], [{0: 'edge-type-rising', 1: 'edge-type-falling', 2: 'edge-type-both'}, None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, IO4Bricklet, argv)

	functions = {
	'set-value': set_value,
	'get-value': get_value,
	'set-configuration': set_configuration,
	'get-configuration': get_configuration,
	'set-debounce-period': set_debounce_period,
	'get-debounce-period': get_debounce_period,
	'set-interrupt': set_interrupt,
	'get-interrupt': get_interrupt,
	'set-monoflop': set_monoflop,
	'get-monoflop': get_monoflop,
	'set-selected-values': set_selected_values,
	'get-edge-count': get_edge_count,
	'set-edge-count-config': set_edge_count_config,
	'get-edge-count-config': get_edge_count_config,
	'get-identity': get_identity
	}

	call_generic(ctx, 'io4-bricklet', functions, argv)

def dispatch_io4_bricklet(ctx, argv):
	prog_prefix = 'dispatch io4-bricklet <uid>'

	def interrupt(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' interrupt')

		args = parser.parse_args(argv)

		device_dispatch(ctx, IO4Bricklet, 9, args.execute, ['interrupt-mask', 'value-mask'], [None, None])

	def monoflop_done(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' monoflop-done')

		args = parser.parse_args(argv)

		device_dispatch(ctx, IO4Bricklet, 12, args.execute, ['selection-mask', 'value-mask'], [None, None])

	callbacks = {
	'interrupt': interrupt,
	'monoflop-done': monoflop_done
	}

	dispatch_generic(ctx, 'io4-bricklet', callbacks, argv)

class IO4V2Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 3; re[2] = 1; re[3] = 3; re[4] = 3; re[5] = 1; re[6] = 2; re[7] = 1; re[8] = 2; re[9] = 1; re[10] = 3; re[11] = 1; re[12] = 1; re[13] = 3; re[14] = 1; re[15] = 3; re[16] = 1; re[234] = 1; re[235] = 1; re[236] = 1; re[237] = 3; re[238] = 1; re[239] = 3; re[240] = 1; re[242] = 1; re[243] = 3; re[248] = 3; re[249] = 1; re[255] = 1
		cf = self.callback_formats
		cf[17] = 'B ! !'; cf[18] = '4! 4!'; cf[19] = 'B !'


def call_io4_v2_bricklet(ctx, argv):
	prog_prefix = 'call io4-v2-bricklet <uid>'

	def set_value(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-value')

		parser.add_argument('value', type=create_array_converter(ctx, convert_bool, 'false', 4), help=get_array_type_name(ctx, 'bool', 4), metavar='<value>')

		args = parser.parse_args(argv)

		device_call(ctx, IO4V2Bricklet, 1, (args.value,), '4!', '', None, args.expect_response, [], [])

	def get_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-value')

		args = parser.parse_args(argv)

		device_call(ctx, IO4V2Bricklet, 2, (), '', '4!', args.execute, False, ['value'], [None])

	def set_selected_value(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-selected-value')

		parser.add_argument('channel', type=convert_int, help='int', metavar='<channel>')
		parser.add_argument('value', type=convert_bool, help='bool', metavar='<value>')

		args = parser.parse_args(argv)

		device_call(ctx, IO4V2Bricklet, 3, (args.channel, args.value), 'B !', '', None, args.expect_response, [], [])

	def set_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-configuration')

		parser.add_argument('channel', type=convert_int, help='int', metavar='<channel>')
		parser.add_argument('direction', type=create_symbol_converter(ctx, create_char_converter(ctx), {'direction-in': 'i', 'direction-out': 'o'}), help='char (direction-in: i, direction-out: o)', metavar='<direction>')
		parser.add_argument('value', type=convert_bool, help='bool', metavar='<value>')

		args = parser.parse_args(argv)

		device_call(ctx, IO4V2Bricklet, 4, (args.channel, args.direction, args.value), 'B c !', '', None, args.expect_response, [], [])

	def get_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-configuration')

		parser.add_argument('channel', type=convert_int, help='int', metavar='<channel>')

		args = parser.parse_args(argv)

		device_call(ctx, IO4V2Bricklet, 5, (args.channel,), 'B', 'c !', args.execute, False, ['direction', 'value'], [{'i': 'direction-in', 'o': 'direction-out'}, None])

	def set_input_value_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-input-value-callback-configuration')

		parser.add_argument('channel', type=convert_int, help='int', metavar='<channel>')
		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')

		args = parser.parse_args(argv)

		device_call(ctx, IO4V2Bricklet, 6, (args.channel, args.period, args.value_has_to_change), 'B I !', '', None, args.expect_response, [], [])

	def get_input_value_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-input-value-callback-configuration')

		parser.add_argument('channel', type=convert_int, help='int', metavar='<channel>')

		args = parser.parse_args(argv)

		device_call(ctx, IO4V2Bricklet, 7, (args.channel,), 'B', 'I !', args.execute, False, ['period', 'value-has-to-change'], [None, None])

	def set_all_input_value_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-all-input-value-callback-configuration')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')

		args = parser.parse_args(argv)

		device_call(ctx, IO4V2Bricklet, 8, (args.period, args.value_has_to_change), 'I !', '', None, args.expect_response, [], [])

	def get_all_input_value_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-all-input-value-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, IO4V2Bricklet, 9, (), '', 'I !', args.execute, False, ['period', 'value-has-to-change'], [None, None])

	def set_monoflop(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-monoflop')

		parser.add_argument('channel', type=convert_int, help='int', metavar='<channel>')
		parser.add_argument('value', type=convert_bool, help='bool', metavar='<value>')
		parser.add_argument('time', type=convert_int, help='int', metavar='<time>')

		args = parser.parse_args(argv)

		device_call(ctx, IO4V2Bricklet, 10, (args.channel, args.value, args.time), 'B ! I', '', None, args.expect_response, [], [])

	def get_monoflop(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-monoflop')

		parser.add_argument('channel', type=convert_int, help='int', metavar='<channel>')

		args = parser.parse_args(argv)

		device_call(ctx, IO4V2Bricklet, 11, (args.channel,), 'B', '! I I', args.execute, False, ['value', 'time', 'time-remaining'], [None, None, None])

	def get_edge_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-edge-count')

		parser.add_argument('channel', type=convert_int, help='int', metavar='<channel>')
		parser.add_argument('reset_counter', type=convert_bool, help='bool', metavar='<reset-counter>')

		args = parser.parse_args(argv)

		device_call(ctx, IO4V2Bricklet, 12, (args.channel, args.reset_counter), 'B !', 'I', args.execute, False, ['count'], [None])

	def set_edge_count_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-edge-count-configuration')

		parser.add_argument('channel', type=convert_int, help='int', metavar='<channel>')
		parser.add_argument('edge_type', type=create_symbol_converter(ctx, convert_int, {'edge-type-both': 2, 'edge-type-falling': 1, 'edge-type-rising': 0}), help='int (edge-type-rising: 0, edge-type-falling: 1, edge-type-both: 2)', metavar='<edge-type>')
		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_call(ctx, IO4V2Bricklet, 13, (args.channel, args.edge_type, args.debounce), 'B B B', '', None, args.expect_response, [], [])

	def get_edge_count_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-edge-count-configuration')

		parser.add_argument('channel', type=convert_int, help='int', metavar='<channel>')

		args = parser.parse_args(argv)

		device_call(ctx, IO4V2Bricklet, 14, (args.channel,), 'B', 'B B', args.execute, False, ['edge-type', 'debounce'], [{0: 'edge-type-rising', 1: 'edge-type-falling', 2: 'edge-type-both'}, None])

	def set_pwm_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-pwm-configuration')

		parser.add_argument('channel', type=convert_int, help='int', metavar='<channel>')
		parser.add_argument('frequency', type=convert_int, help='int', metavar='<frequency>')
		parser.add_argument('duty_cycle', type=convert_int, help='int', metavar='<duty-cycle>')

		args = parser.parse_args(argv)

		device_call(ctx, IO4V2Bricklet, 15, (args.channel, args.frequency, args.duty_cycle), 'B I H', '', None, args.expect_response, [], [])

	def get_pwm_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-pwm-configuration')

		parser.add_argument('channel', type=convert_int, help='int', metavar='<channel>')

		args = parser.parse_args(argv)

		device_call(ctx, IO4V2Bricklet, 16, (args.channel,), 'B', 'I H', args.execute, False, ['frequency', 'duty-cycle'], [None, None])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, IO4V2Bricklet, 234, (), '', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def set_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-bootloader-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'bootloader-mode-firmware-wait-for-reboot': 3, 'bootloader-mode-firmware': 1, 'bootloader-mode-firmware-wait-for-erase-and-reboot': 4, 'bootloader-mode-bootloader-wait-for-reboot': 2, 'bootloader-mode-bootloader': 0}), help='int (bootloader-mode-bootloader: 0, bootloader-mode-firmware: 1, bootloader-mode-bootloader-wait-for-reboot: 2, bootloader-mode-firmware-wait-for-reboot: 3, bootloader-mode-firmware-wait-for-erase-and-reboot: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, IO4V2Bricklet, 235, (args.mode,), 'B', 'B', args.execute, False, ['status'], [{0: 'bootloader-status-ok', 1: 'bootloader-status-invalid-mode', 2: 'bootloader-status-no-change', 3: 'bootloader-status-entry-function-not-present', 4: 'bootloader-status-device-identifier-incorrect', 5: 'bootloader-status-crc-mismatch'}])

	def get_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-bootloader-mode')

		args = parser.parse_args(argv)

		device_call(ctx, IO4V2Bricklet, 236, (), '', 'B', args.execute, False, ['mode'], [{0: 'bootloader-mode-bootloader', 1: 'bootloader-mode-firmware', 2: 'bootloader-mode-bootloader-wait-for-reboot', 3: 'bootloader-mode-firmware-wait-for-reboot', 4: 'bootloader-mode-firmware-wait-for-erase-and-reboot'}])

	def set_write_firmware_pointer(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-write-firmware-pointer')

		parser.add_argument('pointer', type=convert_int, help='int', metavar='<pointer>')

		args = parser.parse_args(argv)

		device_call(ctx, IO4V2Bricklet, 237, (args.pointer,), 'I', '', None, args.expect_response, [], [])

	def write_firmware(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-firmware')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, IO4V2Bricklet, 238, (args.data,), '64B', 'B', args.execute, False, ['status'], [None])

	def set_status_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'status-led-config-on': 1, 'status-led-config-show-heartbeat': 2, 'status-led-config-off': 0, 'status-led-config-show-status': 3}), help='int (status-led-config-off: 0, status-led-config-on: 1, status-led-config-show-heartbeat: 2, status-led-config-show-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, IO4V2Bricklet, 239, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_status_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, IO4V2Bricklet, 240, (), '', 'B', args.execute, False, ['config'], [{0: 'status-led-config-off', 1: 'status-led-config-on', 2: 'status-led-config-show-heartbeat', 3: 'status-led-config-show-status'}])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, IO4V2Bricklet, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, IO4V2Bricklet, 243, (), '', '', None, args.expect_response, [], [])

	def write_uid(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-uid')

		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')

		args = parser.parse_args(argv)

		device_call(ctx, IO4V2Bricklet, 248, (args.uid,), 'I', '', None, args.expect_response, [], [])

	def read_uid(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-uid')

		args = parser.parse_args(argv)

		device_call(ctx, IO4V2Bricklet, 249, (), '', 'I', args.execute, False, ['uid'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, IO4V2Bricklet, argv)

	functions = {
	'set-value': set_value,
	'get-value': get_value,
	'set-selected-value': set_selected_value,
	'set-configuration': set_configuration,
	'get-configuration': get_configuration,
	'set-input-value-callback-configuration': set_input_value_callback_configuration,
	'get-input-value-callback-configuration': get_input_value_callback_configuration,
	'set-all-input-value-callback-configuration': set_all_input_value_callback_configuration,
	'get-all-input-value-callback-configuration': get_all_input_value_callback_configuration,
	'set-monoflop': set_monoflop,
	'get-monoflop': get_monoflop,
	'get-edge-count': get_edge_count,
	'set-edge-count-configuration': set_edge_count_configuration,
	'get-edge-count-configuration': get_edge_count_configuration,
	'set-pwm-configuration': set_pwm_configuration,
	'get-pwm-configuration': get_pwm_configuration,
	'get-spitfp-error-count': get_spitfp_error_count,
	'set-bootloader-mode': set_bootloader_mode,
	'get-bootloader-mode': get_bootloader_mode,
	'set-write-firmware-pointer': set_write_firmware_pointer,
	'write-firmware': write_firmware,
	'set-status-led-config': set_status_led_config,
	'get-status-led-config': get_status_led_config,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'write-uid': write_uid,
	'read-uid': read_uid,
	'get-identity': get_identity
	}

	call_generic(ctx, 'io4-v2-bricklet', functions, argv)

def dispatch_io4_v2_bricklet(ctx, argv):
	prog_prefix = 'dispatch io4-v2-bricklet <uid>'

	def input_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' input-value')

		args = parser.parse_args(argv)

		device_dispatch(ctx, IO4V2Bricklet, 17, args.execute, ['channel', 'changed', 'value'], [None, None, None])

	def all_input_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' all-input-value')

		args = parser.parse_args(argv)

		device_dispatch(ctx, IO4V2Bricklet, 18, args.execute, ['changed', 'value'], [None, None])

	def monoflop_done(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' monoflop-done')

		args = parser.parse_args(argv)

		device_dispatch(ctx, IO4V2Bricklet, 19, args.execute, ['channel', 'value'], [None, None])

	callbacks = {
	'input-value': input_value,
	'all-input-value': all_input_value,
	'monoflop-done': monoflop_done
	}

	dispatch_generic(ctx, 'io4-v2-bricklet', callbacks, argv)

class IsolatorBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 3; re[3] = 1; re[4] = 3; re[5] = 1; re[6] = 1; re[234] = 1; re[235] = 1; re[236] = 1; re[237] = 3; re[238] = 1; re[239] = 3; re[240] = 1; re[242] = 1; re[243] = 3; re[248] = 3; re[249] = 1; re[255] = 1



def call_isolator_bricklet(ctx, argv):
	prog_prefix = 'call isolator-bricklet <uid>'

	def get_statistics(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-statistics')

		args = parser.parse_args(argv)

		device_call(ctx, IsolatorBricklet, 1, (), '', 'I I H 8s', args.execute, False, ['messages-from-brick', 'messages-from-bricklet', 'connected-bricklet-device-identifier', 'connected-bricklet-uid'], [None, None, None, None])

	def set_spitfp_baudrate_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-spitfp-baudrate-config')

		parser.add_argument('enable_dynamic_baudrate', type=convert_bool, help='bool', metavar='<enable-dynamic-baudrate>')
		parser.add_argument('minimum_dynamic_baudrate', type=convert_int, help='int', metavar='<minimum-dynamic-baudrate>')

		args = parser.parse_args(argv)

		device_call(ctx, IsolatorBricklet, 2, (args.enable_dynamic_baudrate, args.minimum_dynamic_baudrate), '! I', '', None, args.expect_response, [], [])

	def get_spitfp_baudrate_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-baudrate-config')

		args = parser.parse_args(argv)

		device_call(ctx, IsolatorBricklet, 3, (), '', '! I', args.execute, False, ['enable-dynamic-baudrate', 'minimum-dynamic-baudrate'], [None, None])

	def set_spitfp_baudrate(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-spitfp-baudrate')

		parser.add_argument('baudrate', type=convert_int, help='int', metavar='<baudrate>')

		args = parser.parse_args(argv)

		device_call(ctx, IsolatorBricklet, 4, (args.baudrate,), 'I', '', None, args.expect_response, [], [])

	def get_spitfp_baudrate(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-baudrate')

		args = parser.parse_args(argv)

		device_call(ctx, IsolatorBricklet, 5, (), '', 'I', args.execute, False, ['baudrate'], [None])

	def get_isolator_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-isolator-spitfp-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, IsolatorBricklet, 6, (), '', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, IsolatorBricklet, 234, (), '', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def set_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-bootloader-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'bootloader-mode-firmware-wait-for-reboot': 3, 'bootloader-mode-firmware': 1, 'bootloader-mode-firmware-wait-for-erase-and-reboot': 4, 'bootloader-mode-bootloader-wait-for-reboot': 2, 'bootloader-mode-bootloader': 0}), help='int (bootloader-mode-bootloader: 0, bootloader-mode-firmware: 1, bootloader-mode-bootloader-wait-for-reboot: 2, bootloader-mode-firmware-wait-for-reboot: 3, bootloader-mode-firmware-wait-for-erase-and-reboot: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, IsolatorBricklet, 235, (args.mode,), 'B', 'B', args.execute, False, ['status'], [{0: 'bootloader-status-ok', 1: 'bootloader-status-invalid-mode', 2: 'bootloader-status-no-change', 3: 'bootloader-status-entry-function-not-present', 4: 'bootloader-status-device-identifier-incorrect', 5: 'bootloader-status-crc-mismatch'}])

	def get_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-bootloader-mode')

		args = parser.parse_args(argv)

		device_call(ctx, IsolatorBricklet, 236, (), '', 'B', args.execute, False, ['mode'], [{0: 'bootloader-mode-bootloader', 1: 'bootloader-mode-firmware', 2: 'bootloader-mode-bootloader-wait-for-reboot', 3: 'bootloader-mode-firmware-wait-for-reboot', 4: 'bootloader-mode-firmware-wait-for-erase-and-reboot'}])

	def set_write_firmware_pointer(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-write-firmware-pointer')

		parser.add_argument('pointer', type=convert_int, help='int', metavar='<pointer>')

		args = parser.parse_args(argv)

		device_call(ctx, IsolatorBricklet, 237, (args.pointer,), 'I', '', None, args.expect_response, [], [])

	def write_firmware(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-firmware')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, IsolatorBricklet, 238, (args.data,), '64B', 'B', args.execute, False, ['status'], [None])

	def set_status_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'status-led-config-on': 1, 'status-led-config-show-heartbeat': 2, 'status-led-config-off': 0, 'status-led-config-show-status': 3}), help='int (status-led-config-off: 0, status-led-config-on: 1, status-led-config-show-heartbeat: 2, status-led-config-show-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, IsolatorBricklet, 239, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_status_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, IsolatorBricklet, 240, (), '', 'B', args.execute, False, ['config'], [{0: 'status-led-config-off', 1: 'status-led-config-on', 2: 'status-led-config-show-heartbeat', 3: 'status-led-config-show-status'}])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, IsolatorBricklet, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, IsolatorBricklet, 243, (), '', '', None, args.expect_response, [], [])

	def write_uid(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-uid')

		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')

		args = parser.parse_args(argv)

		device_call(ctx, IsolatorBricklet, 248, (args.uid,), 'I', '', None, args.expect_response, [], [])

	def read_uid(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-uid')

		args = parser.parse_args(argv)

		device_call(ctx, IsolatorBricklet, 249, (), '', 'I', args.execute, False, ['uid'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, IsolatorBricklet, argv)

	functions = {
	'get-statistics': get_statistics,
	'set-spitfp-baudrate-config': set_spitfp_baudrate_config,
	'get-spitfp-baudrate-config': get_spitfp_baudrate_config,
	'set-spitfp-baudrate': set_spitfp_baudrate,
	'get-spitfp-baudrate': get_spitfp_baudrate,
	'get-isolator-spitfp-error-count': get_isolator_spitfp_error_count,
	'get-spitfp-error-count': get_spitfp_error_count,
	'set-bootloader-mode': set_bootloader_mode,
	'get-bootloader-mode': get_bootloader_mode,
	'set-write-firmware-pointer': set_write_firmware_pointer,
	'write-firmware': write_firmware,
	'set-status-led-config': set_status_led_config,
	'get-status-led-config': get_status_led_config,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'write-uid': write_uid,
	'read-uid': read_uid,
	'get-identity': get_identity
	}

	call_generic(ctx, 'isolator-bricklet', functions, argv)

def dispatch_isolator_bricklet(ctx, argv):
	prog_prefix = 'dispatch isolator-bricklet <uid>'


	callbacks = {

	}

	dispatch_generic(ctx, 'isolator-bricklet', callbacks, argv)

class JoystickBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 1; re[3] = 1; re[4] = 3; re[5] = 2; re[6] = 1; re[7] = 2; re[8] = 1; re[9] = 2; re[10] = 1; re[11] = 2; re[12] = 1; re[13] = 2; re[14] = 1; re[255] = 1
		cf = self.callback_formats
		cf[15] = 'h h'; cf[16] = 'H H'; cf[17] = 'h h'; cf[18] = 'H H'; cf[19] = ''; cf[20] = ''


def call_joystick_bricklet(ctx, argv):
	prog_prefix = 'call joystick-bricklet <uid>'

	def get_position(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-position')

		args = parser.parse_args(argv)

		device_call(ctx, JoystickBricklet, 1, (), '', 'h h', args.execute, False, ['x', 'y'], [None, None])

	def is_pressed(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' is-pressed')

		args = parser.parse_args(argv)

		device_call(ctx, JoystickBricklet, 2, (), '', '!', args.execute, False, ['pressed'], [None])

	def get_analog_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-analog-value')

		args = parser.parse_args(argv)

		device_call(ctx, JoystickBricklet, 3, (), '', 'H H', args.execute, False, ['x', 'y'], [None, None])

	def calibrate(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' calibrate')

		args = parser.parse_args(argv)

		device_call(ctx, JoystickBricklet, 4, (), '', '', None, args.expect_response, [], [])

	def set_position_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-position-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, JoystickBricklet, 5, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_position_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-position-callback-period')

		args = parser.parse_args(argv)

		device_call(ctx, JoystickBricklet, 6, (), '', 'I', args.execute, False, ['period'], [None])

	def set_analog_value_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-analog-value-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, JoystickBricklet, 7, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_analog_value_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-analog-value-callback-period')

		args = parser.parse_args(argv)

		device_call(ctx, JoystickBricklet, 8, (), '', 'I', args.execute, False, ['period'], [None])

	def set_position_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-position-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min_x', type=convert_int, help='int', metavar='<min-x>')
		parser.add_argument('max_x', type=convert_int, help='int', metavar='<max-x>')
		parser.add_argument('min_y', type=convert_int, help='int', metavar='<min-y>')
		parser.add_argument('max_y', type=convert_int, help='int', metavar='<max-y>')

		args = parser.parse_args(argv)

		device_call(ctx, JoystickBricklet, 9, (args.option, args.min_x, args.max_x, args.min_y, args.max_y), 'c h h h h', '', None, args.expect_response, [], [])

	def get_position_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-position-callback-threshold')

		args = parser.parse_args(argv)

		device_call(ctx, JoystickBricklet, 10, (), '', 'c h h h h', args.execute, False, ['option', 'min-x', 'max-x', 'min-y', 'max-y'], [{'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None, None, None])

	def set_analog_value_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-analog-value-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min_x', type=convert_int, help='int', metavar='<min-x>')
		parser.add_argument('max_x', type=convert_int, help='int', metavar='<max-x>')
		parser.add_argument('min_y', type=convert_int, help='int', metavar='<min-y>')
		parser.add_argument('max_y', type=convert_int, help='int', metavar='<max-y>')

		args = parser.parse_args(argv)

		device_call(ctx, JoystickBricklet, 11, (args.option, args.min_x, args.max_x, args.min_y, args.max_y), 'c H H H H', '', None, args.expect_response, [], [])

	def get_analog_value_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-analog-value-callback-threshold')

		args = parser.parse_args(argv)

		device_call(ctx, JoystickBricklet, 12, (), '', 'c H H H H', args.execute, False, ['option', 'min-x', 'max-x', 'min-y', 'max-y'], [{'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None, None, None])

	def set_debounce_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-debounce-period')

		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_call(ctx, JoystickBricklet, 13, (args.debounce,), 'I', '', None, args.expect_response, [], [])

	def get_debounce_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-debounce-period')

		args = parser.parse_args(argv)

		device_call(ctx, JoystickBricklet, 14, (), '', 'I', args.execute, False, ['debounce'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, JoystickBricklet, argv)

	functions = {
	'get-position': get_position,
	'is-pressed': is_pressed,
	'get-analog-value': get_analog_value,
	'calibrate': calibrate,
	'set-position-callback-period': set_position_callback_period,
	'get-position-callback-period': get_position_callback_period,
	'set-analog-value-callback-period': set_analog_value_callback_period,
	'get-analog-value-callback-period': get_analog_value_callback_period,
	'set-position-callback-threshold': set_position_callback_threshold,
	'get-position-callback-threshold': get_position_callback_threshold,
	'set-analog-value-callback-threshold': set_analog_value_callback_threshold,
	'get-analog-value-callback-threshold': get_analog_value_callback_threshold,
	'set-debounce-period': set_debounce_period,
	'get-debounce-period': get_debounce_period,
	'get-identity': get_identity
	}

	call_generic(ctx, 'joystick-bricklet', functions, argv)

def dispatch_joystick_bricklet(ctx, argv):
	prog_prefix = 'dispatch joystick-bricklet <uid>'

	def position(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' position')

		args = parser.parse_args(argv)

		device_dispatch(ctx, JoystickBricklet, 15, args.execute, ['x', 'y'], [None, None])

	def analog_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' analog-value')

		args = parser.parse_args(argv)

		device_dispatch(ctx, JoystickBricklet, 16, args.execute, ['x', 'y'], [None, None])

	def position_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' position-reached')

		args = parser.parse_args(argv)

		device_dispatch(ctx, JoystickBricklet, 17, args.execute, ['x', 'y'], [None, None])

	def analog_value_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' analog-value-reached')

		args = parser.parse_args(argv)

		device_dispatch(ctx, JoystickBricklet, 18, args.execute, ['x', 'y'], [None, None])

	def pressed(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' pressed')

		args = parser.parse_args(argv)

		device_dispatch(ctx, JoystickBricklet, 19, args.execute, [], [])

	def released(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' released')

		args = parser.parse_args(argv)

		device_dispatch(ctx, JoystickBricklet, 20, args.execute, [], [])

	callbacks = {
	'position': position,
	'analog-value': analog_value,
	'position-reached': position_reached,
	'analog-value-reached': analog_value_reached,
	'pressed': pressed,
	'released': released
	}

	dispatch_generic(ctx, 'joystick-bricklet', callbacks, argv)

class JoystickV2Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 1; re[3] = 3; re[4] = 2; re[5] = 1; re[7] = 2; re[8] = 1; re[234] = 1; re[235] = 1; re[236] = 1; re[237] = 3; re[238] = 1; re[239] = 3; re[240] = 1; re[242] = 1; re[243] = 3; re[248] = 3; re[249] = 1; re[255] = 1
		cf = self.callback_formats
		cf[6] = 'h h'; cf[9] = '!'


def call_joystick_v2_bricklet(ctx, argv):
	prog_prefix = 'call joystick-v2-bricklet <uid>'

	def get_position(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-position')

		args = parser.parse_args(argv)

		device_call(ctx, JoystickV2Bricklet, 1, (), '', 'h h', args.execute, False, ['x', 'y'], [None, None])

	def is_pressed(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' is-pressed')

		args = parser.parse_args(argv)

		device_call(ctx, JoystickV2Bricklet, 2, (), '', '!', args.execute, False, ['pressed'], [None])

	def calibrate(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' calibrate')

		args = parser.parse_args(argv)

		device_call(ctx, JoystickV2Bricklet, 3, (), '', '', None, args.expect_response, [], [])

	def set_position_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-position-callback-configuration')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')

		args = parser.parse_args(argv)

		device_call(ctx, JoystickV2Bricklet, 4, (args.period, args.value_has_to_change), 'I !', '', None, args.expect_response, [], [])

	def get_position_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-position-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, JoystickV2Bricklet, 5, (), '', 'I !', args.execute, False, ['period', 'value-has-to-change'], [None, None])

	def set_pressed_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-pressed-callback-configuration')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')

		args = parser.parse_args(argv)

		device_call(ctx, JoystickV2Bricklet, 7, (args.period, args.value_has_to_change), 'I !', '', None, args.expect_response, [], [])

	def get_pressed_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-pressed-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, JoystickV2Bricklet, 8, (), '', 'I !', args.execute, False, ['period', 'value-has-to-change'], [None, None])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, JoystickV2Bricklet, 234, (), '', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def set_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-bootloader-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'bootloader-mode-firmware-wait-for-reboot': 3, 'bootloader-mode-firmware': 1, 'bootloader-mode-firmware-wait-for-erase-and-reboot': 4, 'bootloader-mode-bootloader-wait-for-reboot': 2, 'bootloader-mode-bootloader': 0}), help='int (bootloader-mode-bootloader: 0, bootloader-mode-firmware: 1, bootloader-mode-bootloader-wait-for-reboot: 2, bootloader-mode-firmware-wait-for-reboot: 3, bootloader-mode-firmware-wait-for-erase-and-reboot: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, JoystickV2Bricklet, 235, (args.mode,), 'B', 'B', args.execute, False, ['status'], [{0: 'bootloader-status-ok', 1: 'bootloader-status-invalid-mode', 2: 'bootloader-status-no-change', 3: 'bootloader-status-entry-function-not-present', 4: 'bootloader-status-device-identifier-incorrect', 5: 'bootloader-status-crc-mismatch'}])

	def get_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-bootloader-mode')

		args = parser.parse_args(argv)

		device_call(ctx, JoystickV2Bricklet, 236, (), '', 'B', args.execute, False, ['mode'], [{0: 'bootloader-mode-bootloader', 1: 'bootloader-mode-firmware', 2: 'bootloader-mode-bootloader-wait-for-reboot', 3: 'bootloader-mode-firmware-wait-for-reboot', 4: 'bootloader-mode-firmware-wait-for-erase-and-reboot'}])

	def set_write_firmware_pointer(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-write-firmware-pointer')

		parser.add_argument('pointer', type=convert_int, help='int', metavar='<pointer>')

		args = parser.parse_args(argv)

		device_call(ctx, JoystickV2Bricklet, 237, (args.pointer,), 'I', '', None, args.expect_response, [], [])

	def write_firmware(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-firmware')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, JoystickV2Bricklet, 238, (args.data,), '64B', 'B', args.execute, False, ['status'], [None])

	def set_status_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'status-led-config-on': 1, 'status-led-config-show-heartbeat': 2, 'status-led-config-off': 0, 'status-led-config-show-status': 3}), help='int (status-led-config-off: 0, status-led-config-on: 1, status-led-config-show-heartbeat: 2, status-led-config-show-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, JoystickV2Bricklet, 239, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_status_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, JoystickV2Bricklet, 240, (), '', 'B', args.execute, False, ['config'], [{0: 'status-led-config-off', 1: 'status-led-config-on', 2: 'status-led-config-show-heartbeat', 3: 'status-led-config-show-status'}])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, JoystickV2Bricklet, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, JoystickV2Bricklet, 243, (), '', '', None, args.expect_response, [], [])

	def write_uid(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-uid')

		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')

		args = parser.parse_args(argv)

		device_call(ctx, JoystickV2Bricklet, 248, (args.uid,), 'I', '', None, args.expect_response, [], [])

	def read_uid(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-uid')

		args = parser.parse_args(argv)

		device_call(ctx, JoystickV2Bricklet, 249, (), '', 'I', args.execute, False, ['uid'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, JoystickV2Bricklet, argv)

	functions = {
	'get-position': get_position,
	'is-pressed': is_pressed,
	'calibrate': calibrate,
	'set-position-callback-configuration': set_position_callback_configuration,
	'get-position-callback-configuration': get_position_callback_configuration,
	'set-pressed-callback-configuration': set_pressed_callback_configuration,
	'get-pressed-callback-configuration': get_pressed_callback_configuration,
	'get-spitfp-error-count': get_spitfp_error_count,
	'set-bootloader-mode': set_bootloader_mode,
	'get-bootloader-mode': get_bootloader_mode,
	'set-write-firmware-pointer': set_write_firmware_pointer,
	'write-firmware': write_firmware,
	'set-status-led-config': set_status_led_config,
	'get-status-led-config': get_status_led_config,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'write-uid': write_uid,
	'read-uid': read_uid,
	'get-identity': get_identity
	}

	call_generic(ctx, 'joystick-v2-bricklet', functions, argv)

def dispatch_joystick_v2_bricklet(ctx, argv):
	prog_prefix = 'dispatch joystick-v2-bricklet <uid>'

	def position(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' position')

		args = parser.parse_args(argv)

		device_dispatch(ctx, JoystickV2Bricklet, 6, args.execute, ['x', 'y'], [None, None])

	def pressed(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' pressed')

		args = parser.parse_args(argv)

		device_dispatch(ctx, JoystickV2Bricklet, 9, args.execute, ['pressed'], [None])

	callbacks = {
	'position': position,
	'pressed': pressed
	}

	dispatch_generic(ctx, 'joystick-v2-bricklet', callbacks, argv)

class LaserRangeFinderBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 1; re[3] = 2; re[4] = 1; re[5] = 2; re[6] = 1; re[7] = 2; re[8] = 1; re[9] = 2; re[10] = 1; re[11] = 2; re[12] = 1; re[13] = 3; re[14] = 1; re[15] = 3; re[16] = 1; re[17] = 3; re[18] = 3; re[19] = 1; re[24] = 1; re[25] = 3; re[26] = 1; re[255] = 1
		cf = self.callback_formats
		cf[20] = 'H'; cf[21] = 'h'; cf[22] = 'H'; cf[23] = 'h'


def call_laser_range_finder_bricklet(ctx, argv):
	prog_prefix = 'call laser-range-finder-bricklet <uid>'

	def get_distance(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-distance')

		args = parser.parse_args(argv)

		device_call(ctx, LaserRangeFinderBricklet, 1, (), '', 'H', args.execute, False, ['distance'], [None])

	def get_velocity(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-velocity')

		args = parser.parse_args(argv)

		device_call(ctx, LaserRangeFinderBricklet, 2, (), '', 'h', args.execute, False, ['velocity'], [None])

	def set_distance_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-distance-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, LaserRangeFinderBricklet, 3, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_distance_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-distance-callback-period')

		args = parser.parse_args(argv)

		device_call(ctx, LaserRangeFinderBricklet, 4, (), '', 'I', args.execute, False, ['period'], [None])

	def set_velocity_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-velocity-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, LaserRangeFinderBricklet, 5, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_velocity_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-velocity-callback-period')

		args = parser.parse_args(argv)

		device_call(ctx, LaserRangeFinderBricklet, 6, (), '', 'I', args.execute, False, ['period'], [None])

	def set_distance_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-distance-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, LaserRangeFinderBricklet, 7, (args.option, args.min, args.max), 'c H H', '', None, args.expect_response, [], [])

	def get_distance_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-distance-callback-threshold')

		args = parser.parse_args(argv)

		device_call(ctx, LaserRangeFinderBricklet, 8, (), '', 'c H H', args.execute, False, ['option', 'min', 'max'], [{'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def set_velocity_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-velocity-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, LaserRangeFinderBricklet, 9, (args.option, args.min, args.max), 'c h h', '', None, args.expect_response, [], [])

	def get_velocity_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-velocity-callback-threshold')

		args = parser.parse_args(argv)

		device_call(ctx, LaserRangeFinderBricklet, 10, (), '', 'c h h', args.execute, False, ['option', 'min', 'max'], [{'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def set_debounce_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-debounce-period')

		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_call(ctx, LaserRangeFinderBricklet, 11, (args.debounce,), 'I', '', None, args.expect_response, [], [])

	def get_debounce_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-debounce-period')

		args = parser.parse_args(argv)

		device_call(ctx, LaserRangeFinderBricklet, 12, (), '', 'I', args.execute, False, ['debounce'], [None])

	def set_moving_average(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-moving-average')

		parser.add_argument('distance_average_length', type=convert_int, help='int', metavar='<distance-average-length>')
		parser.add_argument('velocity_average_length', type=convert_int, help='int', metavar='<velocity-average-length>')

		args = parser.parse_args(argv)

		device_call(ctx, LaserRangeFinderBricklet, 13, (args.distance_average_length, args.velocity_average_length), 'B B', '', None, args.expect_response, [], [])

	def get_moving_average(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-moving-average')

		args = parser.parse_args(argv)

		device_call(ctx, LaserRangeFinderBricklet, 14, (), '', 'B B', args.execute, False, ['distance-average-length', 'velocity-average-length'], [None, None])

	def set_mode(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'mode-velocity-max-32ms': 2, 'mode-velocity-max-64ms': 3, 'mode-velocity-max-127ms': 4, 'mode-velocity-max-13ms': 1, 'mode-distance': 0}), help='int (mode-distance: 0, mode-velocity-max-13ms: 1, mode-velocity-max-32ms: 2, mode-velocity-max-64ms: 3, mode-velocity-max-127ms: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, LaserRangeFinderBricklet, 15, (args.mode,), 'B', '', None, args.expect_response, [], [])

	def get_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-mode')

		args = parser.parse_args(argv)

		device_call(ctx, LaserRangeFinderBricklet, 16, (), '', 'B', args.execute, False, ['mode'], [{0: 'mode-distance', 1: 'mode-velocity-max-13ms', 2: 'mode-velocity-max-32ms', 3: 'mode-velocity-max-64ms', 4: 'mode-velocity-max-127ms'}])

	def enable_laser(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' enable-laser')

		args = parser.parse_args(argv)

		device_call(ctx, LaserRangeFinderBricklet, 17, (), '', '', None, args.expect_response, [], [])

	def disable_laser(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' disable-laser')

		args = parser.parse_args(argv)

		device_call(ctx, LaserRangeFinderBricklet, 18, (), '', '', None, args.expect_response, [], [])

	def is_laser_enabled(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' is-laser-enabled')

		args = parser.parse_args(argv)

		device_call(ctx, LaserRangeFinderBricklet, 19, (), '', '!', args.execute, False, ['laser-enabled'], [None])

	def get_sensor_hardware_version(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-sensor-hardware-version')

		args = parser.parse_args(argv)

		device_call(ctx, LaserRangeFinderBricklet, 24, (), '', 'B', args.execute, False, ['version'], [{1: 'version-1', 3: 'version-3'}])

	def set_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-configuration')

		parser.add_argument('acquisition_count', type=convert_int, help='int', metavar='<acquisition-count>')
		parser.add_argument('enable_quick_termination', type=convert_bool, help='bool', metavar='<enable-quick-termination>')
		parser.add_argument('threshold_value', type=convert_int, help='int', metavar='<threshold-value>')
		parser.add_argument('measurement_frequency', type=convert_int, help='int', metavar='<measurement-frequency>')

		args = parser.parse_args(argv)

		device_call(ctx, LaserRangeFinderBricklet, 25, (args.acquisition_count, args.enable_quick_termination, args.threshold_value, args.measurement_frequency), 'B ! B H', '', None, args.expect_response, [], [])

	def get_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, LaserRangeFinderBricklet, 26, (), '', 'B ! B H', args.execute, False, ['acquisition-count', 'enable-quick-termination', 'threshold-value', 'measurement-frequency'], [None, None, None, None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, LaserRangeFinderBricklet, argv)

	functions = {
	'get-distance': get_distance,
	'get-velocity': get_velocity,
	'set-distance-callback-period': set_distance_callback_period,
	'get-distance-callback-period': get_distance_callback_period,
	'set-velocity-callback-period': set_velocity_callback_period,
	'get-velocity-callback-period': get_velocity_callback_period,
	'set-distance-callback-threshold': set_distance_callback_threshold,
	'get-distance-callback-threshold': get_distance_callback_threshold,
	'set-velocity-callback-threshold': set_velocity_callback_threshold,
	'get-velocity-callback-threshold': get_velocity_callback_threshold,
	'set-debounce-period': set_debounce_period,
	'get-debounce-period': get_debounce_period,
	'set-moving-average': set_moving_average,
	'get-moving-average': get_moving_average,
	'set-mode': set_mode,
	'get-mode': get_mode,
	'enable-laser': enable_laser,
	'disable-laser': disable_laser,
	'is-laser-enabled': is_laser_enabled,
	'get-sensor-hardware-version': get_sensor_hardware_version,
	'set-configuration': set_configuration,
	'get-configuration': get_configuration,
	'get-identity': get_identity
	}

	call_generic(ctx, 'laser-range-finder-bricklet', functions, argv)

def dispatch_laser_range_finder_bricklet(ctx, argv):
	prog_prefix = 'dispatch laser-range-finder-bricklet <uid>'

	def distance(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' distance')

		args = parser.parse_args(argv)

		device_dispatch(ctx, LaserRangeFinderBricklet, 20, args.execute, ['distance'], [None])

	def velocity(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' velocity')

		args = parser.parse_args(argv)

		device_dispatch(ctx, LaserRangeFinderBricklet, 21, args.execute, ['velocity'], [None])

	def distance_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' distance-reached')

		args = parser.parse_args(argv)

		device_dispatch(ctx, LaserRangeFinderBricklet, 22, args.execute, ['distance'], [None])

	def velocity_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' velocity-reached')

		args = parser.parse_args(argv)

		device_dispatch(ctx, LaserRangeFinderBricklet, 23, args.execute, ['velocity'], [None])

	callbacks = {
	'distance': distance,
	'velocity': velocity,
	'distance-reached': distance_reached,
	'velocity-reached': velocity_reached
	}

	dispatch_generic(ctx, 'laser-range-finder-bricklet', callbacks, argv)

class LaserRangeFinderV2Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 2; re[3] = 1; re[5] = 1; re[6] = 2; re[7] = 1; re[9] = 3; re[10] = 1; re[11] = 3; re[12] = 1; re[13] = 3; re[14] = 1; re[15] = 3; re[16] = 1; re[17] = 3; re[18] = 1; re[234] = 1; re[235] = 1; re[236] = 1; re[237] = 3; re[238] = 1; re[239] = 3; re[240] = 1; re[242] = 1; re[243] = 3; re[248] = 3; re[249] = 1; re[255] = 1
		cf = self.callback_formats
		cf[4] = 'h'; cf[8] = 'h'


def call_laser_range_finder_v2_bricklet(ctx, argv):
	prog_prefix = 'call laser-range-finder-v2-bricklet <uid>'

	def get_distance(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-distance')

		args = parser.parse_args(argv)

		device_call(ctx, LaserRangeFinderV2Bricklet, 1, (), '', 'h', args.execute, False, ['distance'], [None])

	def set_distance_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-distance-callback-configuration')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')
		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, LaserRangeFinderV2Bricklet, 2, (args.period, args.value_has_to_change, args.option, args.min, args.max), 'I ! c h h', '', None, args.expect_response, [], [])

	def get_distance_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-distance-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, LaserRangeFinderV2Bricklet, 3, (), '', 'I ! c h h', args.execute, False, ['period', 'value-has-to-change', 'option', 'min', 'max'], [None, None, {'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def get_velocity(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-velocity')

		args = parser.parse_args(argv)

		device_call(ctx, LaserRangeFinderV2Bricklet, 5, (), '', 'h', args.execute, False, ['velocity'], [None])

	def set_velocity_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-velocity-callback-configuration')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')
		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, LaserRangeFinderV2Bricklet, 6, (args.period, args.value_has_to_change, args.option, args.min, args.max), 'I ! c h h', '', None, args.expect_response, [], [])

	def get_velocity_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-velocity-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, LaserRangeFinderV2Bricklet, 7, (), '', 'I ! c h h', args.execute, False, ['period', 'value-has-to-change', 'option', 'min', 'max'], [None, None, {'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def set_enable(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-enable')

		parser.add_argument('enable', type=convert_bool, help='bool', metavar='<enable>')

		args = parser.parse_args(argv)

		device_call(ctx, LaserRangeFinderV2Bricklet, 9, (args.enable,), '!', '', None, args.expect_response, [], [])

	def get_enable(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-enable')

		args = parser.parse_args(argv)

		device_call(ctx, LaserRangeFinderV2Bricklet, 10, (), '', '!', args.execute, False, ['enable'], [None])

	def set_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-configuration')

		parser.add_argument('acquisition_count', type=convert_int, help='int', metavar='<acquisition-count>')
		parser.add_argument('enable_quick_termination', type=convert_bool, help='bool', metavar='<enable-quick-termination>')
		parser.add_argument('threshold_value', type=convert_int, help='int', metavar='<threshold-value>')
		parser.add_argument('measurement_frequency', type=convert_int, help='int', metavar='<measurement-frequency>')

		args = parser.parse_args(argv)

		device_call(ctx, LaserRangeFinderV2Bricklet, 11, (args.acquisition_count, args.enable_quick_termination, args.threshold_value, args.measurement_frequency), 'B ! B H', '', None, args.expect_response, [], [])

	def get_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, LaserRangeFinderV2Bricklet, 12, (), '', 'B ! B H', args.execute, False, ['acquisition-count', 'enable-quick-termination', 'threshold-value', 'measurement-frequency'], [None, None, None, None])

	def set_moving_average(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-moving-average')

		parser.add_argument('distance_average_length', type=convert_int, help='int', metavar='<distance-average-length>')
		parser.add_argument('velocity_average_length', type=convert_int, help='int', metavar='<velocity-average-length>')

		args = parser.parse_args(argv)

		device_call(ctx, LaserRangeFinderV2Bricklet, 13, (args.distance_average_length, args.velocity_average_length), 'B B', '', None, args.expect_response, [], [])

	def get_moving_average(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-moving-average')

		args = parser.parse_args(argv)

		device_call(ctx, LaserRangeFinderV2Bricklet, 14, (), '', 'B B', args.execute, False, ['distance-average-length', 'velocity-average-length'], [None, None])

	def set_offset_calibration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-offset-calibration')

		parser.add_argument('offset', type=convert_int, help='int', metavar='<offset>')

		args = parser.parse_args(argv)

		device_call(ctx, LaserRangeFinderV2Bricklet, 15, (args.offset,), 'h', '', None, args.expect_response, [], [])

	def get_offset_calibration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-offset-calibration')

		args = parser.parse_args(argv)

		device_call(ctx, LaserRangeFinderV2Bricklet, 16, (), '', 'h', args.execute, False, ['offset'], [None])

	def set_distance_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-distance-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'distance-led-config-show-heartbeat': 2, 'distance-led-config-on': 1, 'distance-led-config-show-distance': 3, 'distance-led-config-off': 0}), help='int (distance-led-config-off: 0, distance-led-config-on: 1, distance-led-config-show-heartbeat: 2, distance-led-config-show-distance: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, LaserRangeFinderV2Bricklet, 17, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_distance_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-distance-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, LaserRangeFinderV2Bricklet, 18, (), '', 'B', args.execute, False, ['config'], [{0: 'distance-led-config-off', 1: 'distance-led-config-on', 2: 'distance-led-config-show-heartbeat', 3: 'distance-led-config-show-distance'}])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, LaserRangeFinderV2Bricklet, 234, (), '', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def set_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-bootloader-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'bootloader-mode-firmware-wait-for-reboot': 3, 'bootloader-mode-firmware': 1, 'bootloader-mode-firmware-wait-for-erase-and-reboot': 4, 'bootloader-mode-bootloader-wait-for-reboot': 2, 'bootloader-mode-bootloader': 0}), help='int (bootloader-mode-bootloader: 0, bootloader-mode-firmware: 1, bootloader-mode-bootloader-wait-for-reboot: 2, bootloader-mode-firmware-wait-for-reboot: 3, bootloader-mode-firmware-wait-for-erase-and-reboot: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, LaserRangeFinderV2Bricklet, 235, (args.mode,), 'B', 'B', args.execute, False, ['status'], [{0: 'bootloader-status-ok', 1: 'bootloader-status-invalid-mode', 2: 'bootloader-status-no-change', 3: 'bootloader-status-entry-function-not-present', 4: 'bootloader-status-device-identifier-incorrect', 5: 'bootloader-status-crc-mismatch'}])

	def get_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-bootloader-mode')

		args = parser.parse_args(argv)

		device_call(ctx, LaserRangeFinderV2Bricklet, 236, (), '', 'B', args.execute, False, ['mode'], [{0: 'bootloader-mode-bootloader', 1: 'bootloader-mode-firmware', 2: 'bootloader-mode-bootloader-wait-for-reboot', 3: 'bootloader-mode-firmware-wait-for-reboot', 4: 'bootloader-mode-firmware-wait-for-erase-and-reboot'}])

	def set_write_firmware_pointer(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-write-firmware-pointer')

		parser.add_argument('pointer', type=convert_int, help='int', metavar='<pointer>')

		args = parser.parse_args(argv)

		device_call(ctx, LaserRangeFinderV2Bricklet, 237, (args.pointer,), 'I', '', None, args.expect_response, [], [])

	def write_firmware(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-firmware')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, LaserRangeFinderV2Bricklet, 238, (args.data,), '64B', 'B', args.execute, False, ['status'], [None])

	def set_status_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'status-led-config-on': 1, 'status-led-config-show-heartbeat': 2, 'status-led-config-off': 0, 'status-led-config-show-status': 3}), help='int (status-led-config-off: 0, status-led-config-on: 1, status-led-config-show-heartbeat: 2, status-led-config-show-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, LaserRangeFinderV2Bricklet, 239, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_status_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, LaserRangeFinderV2Bricklet, 240, (), '', 'B', args.execute, False, ['config'], [{0: 'status-led-config-off', 1: 'status-led-config-on', 2: 'status-led-config-show-heartbeat', 3: 'status-led-config-show-status'}])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, LaserRangeFinderV2Bricklet, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, LaserRangeFinderV2Bricklet, 243, (), '', '', None, args.expect_response, [], [])

	def write_uid(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-uid')

		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')

		args = parser.parse_args(argv)

		device_call(ctx, LaserRangeFinderV2Bricklet, 248, (args.uid,), 'I', '', None, args.expect_response, [], [])

	def read_uid(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-uid')

		args = parser.parse_args(argv)

		device_call(ctx, LaserRangeFinderV2Bricklet, 249, (), '', 'I', args.execute, False, ['uid'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, LaserRangeFinderV2Bricklet, argv)

	functions = {
	'get-distance': get_distance,
	'set-distance-callback-configuration': set_distance_callback_configuration,
	'get-distance-callback-configuration': get_distance_callback_configuration,
	'get-velocity': get_velocity,
	'set-velocity-callback-configuration': set_velocity_callback_configuration,
	'get-velocity-callback-configuration': get_velocity_callback_configuration,
	'set-enable': set_enable,
	'get-enable': get_enable,
	'set-configuration': set_configuration,
	'get-configuration': get_configuration,
	'set-moving-average': set_moving_average,
	'get-moving-average': get_moving_average,
	'set-offset-calibration': set_offset_calibration,
	'get-offset-calibration': get_offset_calibration,
	'set-distance-led-config': set_distance_led_config,
	'get-distance-led-config': get_distance_led_config,
	'get-spitfp-error-count': get_spitfp_error_count,
	'set-bootloader-mode': set_bootloader_mode,
	'get-bootloader-mode': get_bootloader_mode,
	'set-write-firmware-pointer': set_write_firmware_pointer,
	'write-firmware': write_firmware,
	'set-status-led-config': set_status_led_config,
	'get-status-led-config': get_status_led_config,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'write-uid': write_uid,
	'read-uid': read_uid,
	'get-identity': get_identity
	}

	call_generic(ctx, 'laser-range-finder-v2-bricklet', functions, argv)

def dispatch_laser_range_finder_v2_bricklet(ctx, argv):
	prog_prefix = 'dispatch laser-range-finder-v2-bricklet <uid>'

	def distance(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' distance')

		args = parser.parse_args(argv)

		device_dispatch(ctx, LaserRangeFinderV2Bricklet, 4, args.execute, ['distance'], [None])

	def velocity(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' velocity')

		args = parser.parse_args(argv)

		device_dispatch(ctx, LaserRangeFinderV2Bricklet, 8, args.execute, ['velocity'], [None])

	callbacks = {
	'distance': distance,
	'velocity': velocity
	}

	dispatch_generic(ctx, 'laser-range-finder-v2-bricklet', callbacks, argv)

class LCD128x64Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 2; re[2] = 1; re[3] = 3; re[4] = 3; re[5] = 1; re[6] = 3; re[7] = 3; re[8] = 1; re[9] = 2; re[10] = 1; re[12] = 1; re[13] = 2; re[14] = 1; re[16] = 3; re[17] = 3; re[18] = 3; re[19] = 3; re[20] = 1; re[21] = 3; re[22] = 2; re[23] = 1; re[24] = 1; re[26] = 3; re[27] = 1; re[28] = 3; re[29] = 2; re[30] = 1; re[31] = 1; re[33] = 3; re[34] = 1; re[35] = 3; re[36] = 1; re[37] = 3; re[38] = 1; re[39] = 3; re[40] = 3; re[41] = 2; re[42] = 1; re[43] = 1; re[45] = 3; re[46] = 1; re[47] = 2; re[48] = 1; re[49] = 3; re[50] = 3; re[51] = 3; re[52] = 1; re[234] = 1; re[235] = 1; re[236] = 1; re[237] = 3; re[238] = 1; re[239] = 3; re[240] = 1; re[242] = 1; re[243] = 3; re[248] = 3; re[249] = 1; re[255] = 1
		cf = self.callback_formats
		cf[11] = 'H H H I'; cf[15] = 'B I H H H H H I'; cf[25] = 'B !'; cf[32] = 'B B'; cf[44] = 'b'


def call_lcd_128x64_bricklet(ctx, argv):
	prog_prefix = 'call lcd-128x64-bricklet <uid>'

	def write_pixels_low_level(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-pixels-low-level')

		parser.add_argument('x_start', type=convert_int, help='int', metavar='<x-start>')
		parser.add_argument('y_start', type=convert_int, help='int', metavar='<y-start>')
		parser.add_argument('x_end', type=convert_int, help='int', metavar='<x-end>')
		parser.add_argument('y_end', type=convert_int, help='int', metavar='<y-end>')
		parser.add_argument('pixels_length', type=convert_int, help='int', metavar='<pixels-length>')
		parser.add_argument('pixels_chunk_offset', type=convert_int, help='int', metavar='<pixels-chunk-offset>')
		parser.add_argument('pixels_chunk_data', type=create_array_converter(ctx, convert_bool, 'false', 448), help=get_array_type_name(ctx, 'bool', 448), metavar='<pixels-chunk-data>')

		args = parser.parse_args(argv)

		device_call(ctx, LCD128x64Bricklet, 1, (args.x_start, args.y_start, args.x_end, args.y_end, args.pixels_length, args.pixels_chunk_offset, args.pixels_chunk_data), 'B B B B H H 448!', '', None, args.expect_response, [], [])

	def write_pixels(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-pixels')

		parser.add_argument('x_start', type=convert_int, help='int', metavar='<x-start>')
		parser.add_argument('y_start', type=convert_int, help='int', metavar='<y-start>')
		parser.add_argument('x_end', type=convert_int, help='int', metavar='<x-end>')
		parser.add_argument('y_end', type=convert_int, help='int', metavar='<y-end>')
		parser.add_argument('pixels', type=create_array_converter(ctx, convert_bool, None, -65535), help=get_array_type_name(ctx, 'bool', -65535), metavar='<pixels>')

		args = parser.parse_args(argv)

		device_stream_call(ctx, LCD128x64Bricklet, 1, 'in', (args.x_start, args.y_start, args.x_end, args.y_end, args.pixels), (None, None, None, None, 'stream_data'), (), (None, None, None, None, 'stream_length', 'stream_chunk_offset', 'stream_chunk_data'), (), 'B B B B H H 448!', '', None, args.expect_response, [], [], 'false', 448, None, False, False, None)

	def read_pixels_low_level(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-pixels-low-level')

		parser.add_argument('x_start', type=convert_int, help='int', metavar='<x-start>')
		parser.add_argument('y_start', type=convert_int, help='int', metavar='<y-start>')
		parser.add_argument('x_end', type=convert_int, help='int', metavar='<x-end>')
		parser.add_argument('y_end', type=convert_int, help='int', metavar='<y-end>')

		args = parser.parse_args(argv)

		device_call(ctx, LCD128x64Bricklet, 2, (args.x_start, args.y_start, args.x_end, args.y_end), 'B B B B', 'H H 480!', args.execute, False, ['pixels-length', 'pixels-chunk-offset', 'pixels-chunk-data'], [None, None, None])

	def read_pixels(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-pixels')

		parser.add_argument('x_start', type=convert_int, help='int', metavar='<x-start>')
		parser.add_argument('y_start', type=convert_int, help='int', metavar='<y-start>')
		parser.add_argument('x_end', type=convert_int, help='int', metavar='<x-end>')
		parser.add_argument('y_end', type=convert_int, help='int', metavar='<y-end>')

		args = parser.parse_args(argv)

		device_stream_call(ctx, LCD128x64Bricklet, 2, 'out', (args.x_start, args.y_start, args.x_end, args.y_end), (None, None, None, None), ('stream_data',), (None, None, None, None), ('stream_length', 'stream_chunk_offset', 'stream_chunk_data'), 'B B B B', 'H H 480!', args.execute, False, ['pixels'], [None], None, 480, None, False, False, None)

	def clear_display(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' clear-display')

		args = parser.parse_args(argv)

		device_call(ctx, LCD128x64Bricklet, 3, (), '', '', None, args.expect_response, [], [])

	def set_display_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-display-configuration')

		parser.add_argument('contrast', type=convert_int, help='int', metavar='<contrast>')
		parser.add_argument('backlight', type=convert_int, help='int', metavar='<backlight>')
		parser.add_argument('invert', type=convert_bool, help='bool', metavar='<invert>')
		parser.add_argument('automatic_draw', type=convert_bool, help='bool', metavar='<automatic-draw>')

		args = parser.parse_args(argv)

		device_call(ctx, LCD128x64Bricklet, 4, (args.contrast, args.backlight, args.invert, args.automatic_draw), 'B B ! !', '', None, args.expect_response, [], [])

	def get_display_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-display-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, LCD128x64Bricklet, 5, (), '', 'B B ! !', args.execute, False, ['contrast', 'backlight', 'invert', 'automatic-draw'], [None, None, None, None])

	def write_line(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-line')

		parser.add_argument('line', type=convert_int, help='int', metavar='<line>')
		parser.add_argument('position', type=convert_int, help='int', metavar='<position>')
		parser.add_argument('text', type=create_string_converter(ctx, str, 22), help='string', metavar='<text>')

		args = parser.parse_args(argv)

		device_call(ctx, LCD128x64Bricklet, 6, (args.line, args.position, args.text), 'B B 22s', '', None, args.expect_response, [], [])

	def draw_buffered_frame(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' draw-buffered-frame')

		parser.add_argument('force_complete_redraw', type=convert_bool, help='bool', metavar='<force-complete-redraw>')

		args = parser.parse_args(argv)

		device_call(ctx, LCD128x64Bricklet, 7, (args.force_complete_redraw,), '!', '', None, args.expect_response, [], [])

	def get_touch_position(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-touch-position')

		args = parser.parse_args(argv)

		device_call(ctx, LCD128x64Bricklet, 8, (), '', 'H H H I', args.execute, False, ['pressure', 'x', 'y', 'age'], [None, None, None, None])

	def set_touch_position_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-touch-position-callback-configuration')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')

		args = parser.parse_args(argv)

		device_call(ctx, LCD128x64Bricklet, 9, (args.period, args.value_has_to_change), 'I !', '', None, args.expect_response, [], [])

	def get_touch_position_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-touch-position-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, LCD128x64Bricklet, 10, (), '', 'I !', args.execute, False, ['period', 'value-has-to-change'], [None, None])

	def get_touch_gesture(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-touch-gesture')

		args = parser.parse_args(argv)

		device_call(ctx, LCD128x64Bricklet, 12, (), '', 'B I H H H H H I', args.execute, False, ['gesture', 'duration', 'pressure-max', 'x-start', 'y-start', 'x-end', 'y-end', 'age'], [{0: 'gesture-left-to-right', 1: 'gesture-right-to-left', 2: 'gesture-top-to-bottom', 3: 'gesture-bottom-to-top'}, None, None, None, None, None, None, None])

	def set_touch_gesture_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-touch-gesture-callback-configuration')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')

		args = parser.parse_args(argv)

		device_call(ctx, LCD128x64Bricklet, 13, (args.period, args.value_has_to_change), 'I !', '', None, args.expect_response, [], [])

	def get_touch_gesture_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-touch-gesture-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, LCD128x64Bricklet, 14, (), '', 'I !', args.execute, False, ['period', 'value-has-to-change'], [None, None])

	def draw_line(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' draw-line')

		parser.add_argument('position_x_start', type=convert_int, help='int', metavar='<position-x-start>')
		parser.add_argument('position_y_start', type=convert_int, help='int', metavar='<position-y-start>')
		parser.add_argument('position_x_end', type=convert_int, help='int', metavar='<position-x-end>')
		parser.add_argument('position_y_end', type=convert_int, help='int', metavar='<position-y-end>')
		parser.add_argument('color', type=create_symbol_converter(ctx, convert_bool, {'color-black': True, 'color-white': False}), help='bool (color-white: false, color-black: true)', metavar='<color>')

		args = parser.parse_args(argv)

		device_call(ctx, LCD128x64Bricklet, 16, (args.position_x_start, args.position_y_start, args.position_x_end, args.position_y_end, args.color), 'B B B B !', '', None, args.expect_response, [], [])

	def draw_box(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' draw-box')

		parser.add_argument('position_x_start', type=convert_int, help='int', metavar='<position-x-start>')
		parser.add_argument('position_y_start', type=convert_int, help='int', metavar='<position-y-start>')
		parser.add_argument('position_x_end', type=convert_int, help='int', metavar='<position-x-end>')
		parser.add_argument('position_y_end', type=convert_int, help='int', metavar='<position-y-end>')
		parser.add_argument('fill', type=convert_bool, help='bool', metavar='<fill>')
		parser.add_argument('color', type=create_symbol_converter(ctx, convert_bool, {'color-black': True, 'color-white': False}), help='bool (color-white: false, color-black: true)', metavar='<color>')

		args = parser.parse_args(argv)

		device_call(ctx, LCD128x64Bricklet, 17, (args.position_x_start, args.position_y_start, args.position_x_end, args.position_y_end, args.fill, args.color), 'B B B B ! !', '', None, args.expect_response, [], [])

	def draw_text(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' draw-text')

		parser.add_argument('position_x', type=convert_int, help='int', metavar='<position-x>')
		parser.add_argument('position_y', type=convert_int, help='int', metavar='<position-y>')
		parser.add_argument('font', type=create_symbol_converter(ctx, convert_int, {'font-18x32': 8, 'font-18x24': 7, 'font-12x24': 5, 'font-12x16': 4, 'font-6x8': 0, 'font-6x16': 1, 'font-24x32': 9, 'font-12x32': 6, 'font-6x24': 2, 'font-6x32': 3}), help='int (font-6x8: 0, font-6x16: 1, font-6x24: 2, font-6x32: 3, font-12x16: 4, font-12x24: 5, font-12x32: 6, font-18x24: 7, font-18x32: 8, font-24x32: 9)', metavar='<font>')
		parser.add_argument('color', type=create_symbol_converter(ctx, convert_bool, {'color-black': True, 'color-white': False}), help='bool (color-white: false, color-black: true)', metavar='<color>')
		parser.add_argument('text', type=create_string_converter(ctx, str, 22), help='string', metavar='<text>')

		args = parser.parse_args(argv)

		device_call(ctx, LCD128x64Bricklet, 18, (args.position_x, args.position_y, args.font, args.color, args.text), 'B B B ! 22s', '', None, args.expect_response, [], [])

	def set_gui_button(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-gui-button')

		parser.add_argument('index', type=convert_int, help='int', metavar='<index>')
		parser.add_argument('position_x', type=convert_int, help='int', metavar='<position-x>')
		parser.add_argument('position_y', type=convert_int, help='int', metavar='<position-y>')
		parser.add_argument('width', type=convert_int, help='int', metavar='<width>')
		parser.add_argument('height', type=convert_int, help='int', metavar='<height>')
		parser.add_argument('text', type=create_string_converter(ctx, str, 16), help='string', metavar='<text>')

		args = parser.parse_args(argv)

		device_call(ctx, LCD128x64Bricklet, 19, (args.index, args.position_x, args.position_y, args.width, args.height, args.text), 'B B B B B 16s', '', None, args.expect_response, [], [])

	def get_gui_button(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-gui-button')

		parser.add_argument('index', type=convert_int, help='int', metavar='<index>')

		args = parser.parse_args(argv)

		device_call(ctx, LCD128x64Bricklet, 20, (args.index,), 'B', '! B B B B 16s', args.execute, False, ['active', 'position-x', 'position-y', 'width', 'height', 'text'], [None, None, None, None, None, None])

	def remove_gui_button(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' remove-gui-button')

		parser.add_argument('index', type=convert_int, help='int', metavar='<index>')

		args = parser.parse_args(argv)

		device_call(ctx, LCD128x64Bricklet, 21, (args.index,), 'B', '', None, args.expect_response, [], [])

	def set_gui_button_pressed_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-gui-button-pressed-callback-configuration')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')

		args = parser.parse_args(argv)

		device_call(ctx, LCD128x64Bricklet, 22, (args.period, args.value_has_to_change), 'I !', '', None, args.expect_response, [], [])

	def get_gui_button_pressed_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-gui-button-pressed-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, LCD128x64Bricklet, 23, (), '', 'I !', args.execute, False, ['period', 'value-has-to-change'], [None, None])

	def get_gui_button_pressed(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-gui-button-pressed')

		parser.add_argument('index', type=convert_int, help='int', metavar='<index>')

		args = parser.parse_args(argv)

		device_call(ctx, LCD128x64Bricklet, 24, (args.index,), 'B', '!', args.execute, False, ['pressed'], [None])

	def set_gui_slider(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-gui-slider')

		parser.add_argument('index', type=convert_int, help='int', metavar='<index>')
		parser.add_argument('position_x', type=convert_int, help='int', metavar='<position-x>')
		parser.add_argument('position_y', type=convert_int, help='int', metavar='<position-y>')
		parser.add_argument('length', type=convert_int, help='int', metavar='<length>')
		parser.add_argument('direction', type=create_symbol_converter(ctx, convert_int, {'direction-horizontal': 0, 'direction-vertical': 1}), help='int (direction-horizontal: 0, direction-vertical: 1)', metavar='<direction>')
		parser.add_argument('value', type=convert_int, help='int', metavar='<value>')

		args = parser.parse_args(argv)

		device_call(ctx, LCD128x64Bricklet, 26, (args.index, args.position_x, args.position_y, args.length, args.direction, args.value), 'B B B B B B', '', None, args.expect_response, [], [])

	def get_gui_slider(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-gui-slider')

		parser.add_argument('index', type=convert_int, help='int', metavar='<index>')

		args = parser.parse_args(argv)

		device_call(ctx, LCD128x64Bricklet, 27, (args.index,), 'B', '! B B B B B', args.execute, False, ['active', 'position-x', 'position-y', 'length', 'direction', 'value'], [None, None, None, None, {0: 'direction-horizontal', 1: 'direction-vertical'}, None])

	def remove_gui_slider(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' remove-gui-slider')

		parser.add_argument('index', type=convert_int, help='int', metavar='<index>')

		args = parser.parse_args(argv)

		device_call(ctx, LCD128x64Bricklet, 28, (args.index,), 'B', '', None, args.expect_response, [], [])

	def set_gui_slider_value_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-gui-slider-value-callback-configuration')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')

		args = parser.parse_args(argv)

		device_call(ctx, LCD128x64Bricklet, 29, (args.period, args.value_has_to_change), 'I !', '', None, args.expect_response, [], [])

	def get_gui_slider_value_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-gui-slider-value-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, LCD128x64Bricklet, 30, (), '', 'I !', args.execute, False, ['period', 'value-has-to-change'], [None, None])

	def get_gui_slider_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-gui-slider-value')

		parser.add_argument('index', type=convert_int, help='int', metavar='<index>')

		args = parser.parse_args(argv)

		device_call(ctx, LCD128x64Bricklet, 31, (args.index,), 'B', 'B', args.execute, False, ['value'], [None])

	def set_gui_tab_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-gui-tab-configuration')

		parser.add_argument('change_tab_config', type=create_symbol_converter(ctx, convert_int, {'change-tab-on-swipe': 2, 'change-tab-on-click': 1, 'change-tab-on-click-and-swipe': 3}), help='int (change-tab-on-click: 1, change-tab-on-swipe: 2, change-tab-on-click-and-swipe: 3)', metavar='<change-tab-config>')
		parser.add_argument('clear_gui', type=convert_bool, help='bool', metavar='<clear-gui>')

		args = parser.parse_args(argv)

		device_call(ctx, LCD128x64Bricklet, 33, (args.change_tab_config, args.clear_gui), 'B !', '', None, args.expect_response, [], [])

	def get_gui_tab_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-gui-tab-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, LCD128x64Bricklet, 34, (), '', 'B !', args.execute, False, ['change-tab-config', 'clear-gui'], [{1: 'change-tab-on-click', 2: 'change-tab-on-swipe', 3: 'change-tab-on-click-and-swipe'}, None])

	def set_gui_tab_text(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-gui-tab-text')

		parser.add_argument('index', type=convert_int, help='int', metavar='<index>')
		parser.add_argument('text', type=create_string_converter(ctx, str, 5), help='string', metavar='<text>')

		args = parser.parse_args(argv)

		device_call(ctx, LCD128x64Bricklet, 35, (args.index, args.text), 'B 5s', '', None, args.expect_response, [], [])

	def get_gui_tab_text(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-gui-tab-text')

		parser.add_argument('index', type=convert_int, help='int', metavar='<index>')

		args = parser.parse_args(argv)

		device_call(ctx, LCD128x64Bricklet, 36, (args.index,), 'B', '! 5s', args.execute, False, ['active', 'text'], [None, None])

	def set_gui_tab_icon(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-gui-tab-icon')

		parser.add_argument('index', type=convert_int, help='int', metavar='<index>')
		parser.add_argument('icon', type=create_array_converter(ctx, convert_bool, 'false', 168), help=get_array_type_name(ctx, 'bool', 168), metavar='<icon>')

		args = parser.parse_args(argv)

		device_call(ctx, LCD128x64Bricklet, 37, (args.index, args.icon), 'B 168!', '', None, args.expect_response, [], [])

	def get_gui_tab_icon(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-gui-tab-icon')

		parser.add_argument('index', type=convert_int, help='int', metavar='<index>')

		args = parser.parse_args(argv)

		device_call(ctx, LCD128x64Bricklet, 38, (args.index,), 'B', '! 168!', args.execute, False, ['active', 'icon'], [None, None])

	def remove_gui_tab(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' remove-gui-tab')

		parser.add_argument('index', type=convert_int, help='int', metavar='<index>')

		args = parser.parse_args(argv)

		device_call(ctx, LCD128x64Bricklet, 39, (args.index,), 'B', '', None, args.expect_response, [], [])

	def set_gui_tab_selected(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-gui-tab-selected')

		parser.add_argument('index', type=convert_int, help='int', metavar='<index>')

		args = parser.parse_args(argv)

		device_call(ctx, LCD128x64Bricklet, 40, (args.index,), 'B', '', None, args.expect_response, [], [])

	def set_gui_tab_selected_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-gui-tab-selected-callback-configuration')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')

		args = parser.parse_args(argv)

		device_call(ctx, LCD128x64Bricklet, 41, (args.period, args.value_has_to_change), 'I !', '', None, args.expect_response, [], [])

	def get_gui_tab_selected_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-gui-tab-selected-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, LCD128x64Bricklet, 42, (), '', 'I !', args.execute, False, ['period', 'value-has-to-change'], [None, None])

	def get_gui_tab_selected(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-gui-tab-selected')

		args = parser.parse_args(argv)

		device_call(ctx, LCD128x64Bricklet, 43, (), '', 'b', args.execute, False, ['index'], [None])

	def set_gui_graph_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-gui-graph-configuration')

		parser.add_argument('index', type=convert_int, help='int', metavar='<index>')
		parser.add_argument('graph_type', type=create_symbol_converter(ctx, convert_int, {'graph-type-bar': 2, 'graph-type-dot': 0, 'graph-type-line': 1}), help='int (graph-type-dot: 0, graph-type-line: 1, graph-type-bar: 2)', metavar='<graph-type>')
		parser.add_argument('position_x', type=convert_int, help='int', metavar='<position-x>')
		parser.add_argument('position_y', type=convert_int, help='int', metavar='<position-y>')
		parser.add_argument('width', type=convert_int, help='int', metavar='<width>')
		parser.add_argument('height', type=convert_int, help='int', metavar='<height>')
		parser.add_argument('text_x', type=create_string_converter(ctx, str, 4), help='string', metavar='<text-x>')
		parser.add_argument('text_y', type=create_string_converter(ctx, str, 4), help='string', metavar='<text-y>')

		args = parser.parse_args(argv)

		device_call(ctx, LCD128x64Bricklet, 45, (args.index, args.graph_type, args.position_x, args.position_y, args.width, args.height, args.text_x, args.text_y), 'B B B B B B 4s 4s', '', None, args.expect_response, [], [])

	def get_gui_graph_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-gui-graph-configuration')

		parser.add_argument('index', type=convert_int, help='int', metavar='<index>')

		args = parser.parse_args(argv)

		device_call(ctx, LCD128x64Bricklet, 46, (args.index,), 'B', '! B B B B B 4s 4s', args.execute, False, ['active', 'graph-type', 'position-x', 'position-y', 'width', 'height', 'text-x', 'text-y'], [None, {0: 'graph-type-dot', 1: 'graph-type-line', 2: 'graph-type-bar'}, None, None, None, None, None, None])

	def set_gui_graph_data_low_level(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-gui-graph-data-low-level')

		parser.add_argument('index', type=convert_int, help='int', metavar='<index>')
		parser.add_argument('data_length', type=convert_int, help='int', metavar='<data-length>')
		parser.add_argument('data_chunk_offset', type=convert_int, help='int', metavar='<data-chunk-offset>')
		parser.add_argument('data_chunk_data', type=create_array_converter(ctx, convert_int, '0', 59), help=get_array_type_name(ctx, 'int', 59), metavar='<data-chunk-data>')

		args = parser.parse_args(argv)

		device_call(ctx, LCD128x64Bricklet, 47, (args.index, args.data_length, args.data_chunk_offset, args.data_chunk_data), 'B H H 59B', '', None, args.expect_response, [], [])

	def set_gui_graph_data(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-gui-graph-data')

		parser.add_argument('index', type=convert_int, help='int', metavar='<index>')
		parser.add_argument('data', type=create_array_converter(ctx, convert_int, None, -65535), help=get_array_type_name(ctx, 'int', -65535), metavar='<data>')

		args = parser.parse_args(argv)

		device_stream_call(ctx, LCD128x64Bricklet, 47, 'in', (args.index, args.data), (None, 'stream_data'), (), (None, 'stream_length', 'stream_chunk_offset', 'stream_chunk_data'), (), 'B H H 59B', '', None, args.expect_response, [], [], '0', 59, None, False, False, None)

	def get_gui_graph_data_low_level(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-gui-graph-data-low-level')

		parser.add_argument('index', type=convert_int, help='int', metavar='<index>')

		args = parser.parse_args(argv)

		device_call(ctx, LCD128x64Bricklet, 48, (args.index,), 'B', 'H H 59B', args.execute, False, ['data-length', 'data-chunk-offset', 'data-chunk-data'], [None, None, None])

	def get_gui_graph_data(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-gui-graph-data')

		parser.add_argument('index', type=convert_int, help='int', metavar='<index>')

		args = parser.parse_args(argv)

		device_stream_call(ctx, LCD128x64Bricklet, 48, 'out', (args.index,), (None,), ('stream_data',), (None,), ('stream_length', 'stream_chunk_offset', 'stream_chunk_data'), 'B', 'H H 59B', args.execute, False, ['data'], [None], None, 59, None, False, False, None)

	def remove_gui_graph(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' remove-gui-graph')

		parser.add_argument('index', type=convert_int, help='int', metavar='<index>')

		args = parser.parse_args(argv)

		device_call(ctx, LCD128x64Bricklet, 49, (args.index,), 'B', '', None, args.expect_response, [], [])

	def remove_all_gui(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' remove-all-gui')

		args = parser.parse_args(argv)

		device_call(ctx, LCD128x64Bricklet, 50, (), '', '', None, args.expect_response, [], [])

	def set_touch_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-touch-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'touch-led-config-off': 0, 'touch-led-config-show-heartbeat': 2, 'touch-led-config-show-touch': 3, 'touch-led-config-on': 1}), help='int (touch-led-config-off: 0, touch-led-config-on: 1, touch-led-config-show-heartbeat: 2, touch-led-config-show-touch: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, LCD128x64Bricklet, 51, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_touch_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-touch-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, LCD128x64Bricklet, 52, (), '', 'B', args.execute, False, ['config'], [{0: 'touch-led-config-off', 1: 'touch-led-config-on', 2: 'touch-led-config-show-heartbeat', 3: 'touch-led-config-show-touch'}])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, LCD128x64Bricklet, 234, (), '', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def set_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-bootloader-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'bootloader-mode-firmware-wait-for-reboot': 3, 'bootloader-mode-firmware': 1, 'bootloader-mode-firmware-wait-for-erase-and-reboot': 4, 'bootloader-mode-bootloader-wait-for-reboot': 2, 'bootloader-mode-bootloader': 0}), help='int (bootloader-mode-bootloader: 0, bootloader-mode-firmware: 1, bootloader-mode-bootloader-wait-for-reboot: 2, bootloader-mode-firmware-wait-for-reboot: 3, bootloader-mode-firmware-wait-for-erase-and-reboot: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, LCD128x64Bricklet, 235, (args.mode,), 'B', 'B', args.execute, False, ['status'], [{0: 'bootloader-status-ok', 1: 'bootloader-status-invalid-mode', 2: 'bootloader-status-no-change', 3: 'bootloader-status-entry-function-not-present', 4: 'bootloader-status-device-identifier-incorrect', 5: 'bootloader-status-crc-mismatch'}])

	def get_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-bootloader-mode')

		args = parser.parse_args(argv)

		device_call(ctx, LCD128x64Bricklet, 236, (), '', 'B', args.execute, False, ['mode'], [{0: 'bootloader-mode-bootloader', 1: 'bootloader-mode-firmware', 2: 'bootloader-mode-bootloader-wait-for-reboot', 3: 'bootloader-mode-firmware-wait-for-reboot', 4: 'bootloader-mode-firmware-wait-for-erase-and-reboot'}])

	def set_write_firmware_pointer(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-write-firmware-pointer')

		parser.add_argument('pointer', type=convert_int, help='int', metavar='<pointer>')

		args = parser.parse_args(argv)

		device_call(ctx, LCD128x64Bricklet, 237, (args.pointer,), 'I', '', None, args.expect_response, [], [])

	def write_firmware(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-firmware')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, LCD128x64Bricklet, 238, (args.data,), '64B', 'B', args.execute, False, ['status'], [None])

	def set_status_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'status-led-config-on': 1, 'status-led-config-show-heartbeat': 2, 'status-led-config-off': 0, 'status-led-config-show-status': 3}), help='int (status-led-config-off: 0, status-led-config-on: 1, status-led-config-show-heartbeat: 2, status-led-config-show-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, LCD128x64Bricklet, 239, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_status_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, LCD128x64Bricklet, 240, (), '', 'B', args.execute, False, ['config'], [{0: 'status-led-config-off', 1: 'status-led-config-on', 2: 'status-led-config-show-heartbeat', 3: 'status-led-config-show-status'}])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, LCD128x64Bricklet, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, LCD128x64Bricklet, 243, (), '', '', None, args.expect_response, [], [])

	def write_uid(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-uid')

		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')

		args = parser.parse_args(argv)

		device_call(ctx, LCD128x64Bricklet, 248, (args.uid,), 'I', '', None, args.expect_response, [], [])

	def read_uid(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-uid')

		args = parser.parse_args(argv)

		device_call(ctx, LCD128x64Bricklet, 249, (), '', 'I', args.execute, False, ['uid'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, LCD128x64Bricklet, argv)

	functions = {
	'write-pixels-low-level': write_pixels_low_level,
	'write-pixels': write_pixels,
	'read-pixels-low-level': read_pixels_low_level,
	'read-pixels': read_pixels,
	'clear-display': clear_display,
	'set-display-configuration': set_display_configuration,
	'get-display-configuration': get_display_configuration,
	'write-line': write_line,
	'draw-buffered-frame': draw_buffered_frame,
	'get-touch-position': get_touch_position,
	'set-touch-position-callback-configuration': set_touch_position_callback_configuration,
	'get-touch-position-callback-configuration': get_touch_position_callback_configuration,
	'get-touch-gesture': get_touch_gesture,
	'set-touch-gesture-callback-configuration': set_touch_gesture_callback_configuration,
	'get-touch-gesture-callback-configuration': get_touch_gesture_callback_configuration,
	'draw-line': draw_line,
	'draw-box': draw_box,
	'draw-text': draw_text,
	'set-gui-button': set_gui_button,
	'get-gui-button': get_gui_button,
	'remove-gui-button': remove_gui_button,
	'set-gui-button-pressed-callback-configuration': set_gui_button_pressed_callback_configuration,
	'get-gui-button-pressed-callback-configuration': get_gui_button_pressed_callback_configuration,
	'get-gui-button-pressed': get_gui_button_pressed,
	'set-gui-slider': set_gui_slider,
	'get-gui-slider': get_gui_slider,
	'remove-gui-slider': remove_gui_slider,
	'set-gui-slider-value-callback-configuration': set_gui_slider_value_callback_configuration,
	'get-gui-slider-value-callback-configuration': get_gui_slider_value_callback_configuration,
	'get-gui-slider-value': get_gui_slider_value,
	'set-gui-tab-configuration': set_gui_tab_configuration,
	'get-gui-tab-configuration': get_gui_tab_configuration,
	'set-gui-tab-text': set_gui_tab_text,
	'get-gui-tab-text': get_gui_tab_text,
	'set-gui-tab-icon': set_gui_tab_icon,
	'get-gui-tab-icon': get_gui_tab_icon,
	'remove-gui-tab': remove_gui_tab,
	'set-gui-tab-selected': set_gui_tab_selected,
	'set-gui-tab-selected-callback-configuration': set_gui_tab_selected_callback_configuration,
	'get-gui-tab-selected-callback-configuration': get_gui_tab_selected_callback_configuration,
	'get-gui-tab-selected': get_gui_tab_selected,
	'set-gui-graph-configuration': set_gui_graph_configuration,
	'get-gui-graph-configuration': get_gui_graph_configuration,
	'set-gui-graph-data-low-level': set_gui_graph_data_low_level,
	'set-gui-graph-data': set_gui_graph_data,
	'get-gui-graph-data-low-level': get_gui_graph_data_low_level,
	'get-gui-graph-data': get_gui_graph_data,
	'remove-gui-graph': remove_gui_graph,
	'remove-all-gui': remove_all_gui,
	'set-touch-led-config': set_touch_led_config,
	'get-touch-led-config': get_touch_led_config,
	'get-spitfp-error-count': get_spitfp_error_count,
	'set-bootloader-mode': set_bootloader_mode,
	'get-bootloader-mode': get_bootloader_mode,
	'set-write-firmware-pointer': set_write_firmware_pointer,
	'write-firmware': write_firmware,
	'set-status-led-config': set_status_led_config,
	'get-status-led-config': get_status_led_config,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'write-uid': write_uid,
	'read-uid': read_uid,
	'get-identity': get_identity
	}

	call_generic(ctx, 'lcd-128x64-bricklet', functions, argv)

def dispatch_lcd_128x64_bricklet(ctx, argv):
	prog_prefix = 'dispatch lcd-128x64-bricklet <uid>'

	def touch_position(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' touch-position')

		args = parser.parse_args(argv)

		device_dispatch(ctx, LCD128x64Bricklet, 11, args.execute, ['pressure', 'x', 'y', 'age'], [None, None, None, None])

	def touch_gesture(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' touch-gesture')

		args = parser.parse_args(argv)

		device_dispatch(ctx, LCD128x64Bricklet, 15, args.execute, ['gesture', 'duration', 'pressure-max', 'x-start', 'y-start', 'x-end', 'y-end', 'age'], [{0: 'gesture-left-to-right', 1: 'gesture-right-to-left', 2: 'gesture-top-to-bottom', 3: 'gesture-bottom-to-top'}, None, None, None, None, None, None, None])

	def gui_button_pressed(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' gui-button-pressed')

		args = parser.parse_args(argv)

		device_dispatch(ctx, LCD128x64Bricklet, 25, args.execute, ['index', 'pressed'], [None, None])

	def gui_slider_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' gui-slider-value')

		args = parser.parse_args(argv)

		device_dispatch(ctx, LCD128x64Bricklet, 32, args.execute, ['index', 'value'], [None, None])

	def gui_tab_selected(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' gui-tab-selected')

		args = parser.parse_args(argv)

		device_dispatch(ctx, LCD128x64Bricklet, 44, args.execute, ['index'], [None])

	callbacks = {
	'touch-position': touch_position,
	'touch-gesture': touch_gesture,
	'gui-button-pressed': gui_button_pressed,
	'gui-slider-value': gui_slider_value,
	'gui-tab-selected': gui_tab_selected
	}

	dispatch_generic(ctx, 'lcd-128x64-bricklet', callbacks, argv)

class LCD16x2Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 3; re[2] = 3; re[3] = 3; re[4] = 3; re[5] = 1; re[6] = 3; re[7] = 1; re[8] = 1; re[11] = 3; re[12] = 1; re[255] = 1
		cf = self.callback_formats
		cf[9] = 'B'; cf[10] = 'B'


def call_lcd_16x2_bricklet(ctx, argv):
	prog_prefix = 'call lcd-16x2-bricklet <uid>'

	def write_line(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-line')

		parser.add_argument('line', type=convert_int, help='int', metavar='<line>')
		parser.add_argument('position', type=convert_int, help='int', metavar='<position>')
		parser.add_argument('text', type=create_string_converter(ctx, str, 16), help='string', metavar='<text>')

		args = parser.parse_args(argv)

		device_call(ctx, LCD16x2Bricklet, 1, (args.line, args.position, args.text), 'B B 16s', '', None, args.expect_response, [], [])

	def clear_display(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' clear-display')

		args = parser.parse_args(argv)

		device_call(ctx, LCD16x2Bricklet, 2, (), '', '', None, args.expect_response, [], [])

	def backlight_on(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' backlight-on')

		args = parser.parse_args(argv)

		device_call(ctx, LCD16x2Bricklet, 3, (), '', '', None, args.expect_response, [], [])

	def backlight_off(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' backlight-off')

		args = parser.parse_args(argv)

		device_call(ctx, LCD16x2Bricklet, 4, (), '', '', None, args.expect_response, [], [])

	def is_backlight_on(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' is-backlight-on')

		args = parser.parse_args(argv)

		device_call(ctx, LCD16x2Bricklet, 5, (), '', '!', args.execute, False, ['backlight'], [None])

	def set_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-config')

		parser.add_argument('cursor', type=convert_bool, help='bool', metavar='<cursor>')
		parser.add_argument('blinking', type=convert_bool, help='bool', metavar='<blinking>')

		args = parser.parse_args(argv)

		device_call(ctx, LCD16x2Bricklet, 6, (args.cursor, args.blinking), '! !', '', None, args.expect_response, [], [])

	def get_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-config')

		args = parser.parse_args(argv)

		device_call(ctx, LCD16x2Bricklet, 7, (), '', '! !', args.execute, False, ['cursor', 'blinking'], [None, None])

	def is_button_pressed(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' is-button-pressed')

		parser.add_argument('button', type=convert_int, help='int', metavar='<button>')

		args = parser.parse_args(argv)

		device_call(ctx, LCD16x2Bricklet, 8, (args.button,), 'B', '!', args.execute, False, ['pressed'], [None])

	def set_custom_character(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-custom-character')

		parser.add_argument('index', type=convert_int, help='int', metavar='<index>')
		parser.add_argument('character', type=create_array_converter(ctx, convert_int, '0', 8), help=get_array_type_name(ctx, 'int', 8), metavar='<character>')

		args = parser.parse_args(argv)

		device_call(ctx, LCD16x2Bricklet, 11, (args.index, args.character), 'B 8B', '', None, args.expect_response, [], [])

	def get_custom_character(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-custom-character')

		parser.add_argument('index', type=convert_int, help='int', metavar='<index>')

		args = parser.parse_args(argv)

		device_call(ctx, LCD16x2Bricklet, 12, (args.index,), 'B', '8B', args.execute, False, ['character'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, LCD16x2Bricklet, argv)

	functions = {
	'write-line': write_line,
	'clear-display': clear_display,
	'backlight-on': backlight_on,
	'backlight-off': backlight_off,
	'is-backlight-on': is_backlight_on,
	'set-config': set_config,
	'get-config': get_config,
	'is-button-pressed': is_button_pressed,
	'set-custom-character': set_custom_character,
	'get-custom-character': get_custom_character,
	'get-identity': get_identity
	}

	call_generic(ctx, 'lcd-16x2-bricklet', functions, argv)

def dispatch_lcd_16x2_bricklet(ctx, argv):
	prog_prefix = 'dispatch lcd-16x2-bricklet <uid>'

	def button_pressed(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' button-pressed')

		args = parser.parse_args(argv)

		device_dispatch(ctx, LCD16x2Bricklet, 9, args.execute, ['button'], [None])

	def button_released(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' button-released')

		args = parser.parse_args(argv)

		device_dispatch(ctx, LCD16x2Bricklet, 10, args.execute, ['button'], [None])

	callbacks = {
	'button-pressed': button_pressed,
	'button-released': button_released
	}

	dispatch_generic(ctx, 'lcd-16x2-bricklet', callbacks, argv)

class LCD20x4Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 3; re[2] = 3; re[3] = 3; re[4] = 3; re[5] = 1; re[6] = 3; re[7] = 1; re[8] = 1; re[11] = 3; re[12] = 1; re[13] = 3; re[14] = 1; re[15] = 3; re[16] = 1; re[255] = 1
		cf = self.callback_formats
		cf[9] = 'B'; cf[10] = 'B'


def call_lcd_20x4_bricklet(ctx, argv):
	prog_prefix = 'call lcd-20x4-bricklet <uid>'

	def write_line(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-line')

		parser.add_argument('line', type=convert_int, help='int', metavar='<line>')
		parser.add_argument('position', type=convert_int, help='int', metavar='<position>')
		parser.add_argument('text', type=create_string_converter(ctx, str, 20), help='string', metavar='<text>')

		args = parser.parse_args(argv)

		device_call(ctx, LCD20x4Bricklet, 1, (args.line, args.position, args.text), 'B B 20s', '', None, args.expect_response, [], [])

	def clear_display(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' clear-display')

		args = parser.parse_args(argv)

		device_call(ctx, LCD20x4Bricklet, 2, (), '', '', None, args.expect_response, [], [])

	def backlight_on(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' backlight-on')

		args = parser.parse_args(argv)

		device_call(ctx, LCD20x4Bricklet, 3, (), '', '', None, args.expect_response, [], [])

	def backlight_off(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' backlight-off')

		args = parser.parse_args(argv)

		device_call(ctx, LCD20x4Bricklet, 4, (), '', '', None, args.expect_response, [], [])

	def is_backlight_on(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' is-backlight-on')

		args = parser.parse_args(argv)

		device_call(ctx, LCD20x4Bricklet, 5, (), '', '!', args.execute, False, ['backlight'], [None])

	def set_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-config')

		parser.add_argument('cursor', type=convert_bool, help='bool', metavar='<cursor>')
		parser.add_argument('blinking', type=convert_bool, help='bool', metavar='<blinking>')

		args = parser.parse_args(argv)

		device_call(ctx, LCD20x4Bricklet, 6, (args.cursor, args.blinking), '! !', '', None, args.expect_response, [], [])

	def get_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-config')

		args = parser.parse_args(argv)

		device_call(ctx, LCD20x4Bricklet, 7, (), '', '! !', args.execute, False, ['cursor', 'blinking'], [None, None])

	def is_button_pressed(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' is-button-pressed')

		parser.add_argument('button', type=convert_int, help='int', metavar='<button>')

		args = parser.parse_args(argv)

		device_call(ctx, LCD20x4Bricklet, 8, (args.button,), 'B', '!', args.execute, False, ['pressed'], [None])

	def set_custom_character(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-custom-character')

		parser.add_argument('index', type=convert_int, help='int', metavar='<index>')
		parser.add_argument('character', type=create_array_converter(ctx, convert_int, '0', 8), help=get_array_type_name(ctx, 'int', 8), metavar='<character>')

		args = parser.parse_args(argv)

		device_call(ctx, LCD20x4Bricklet, 11, (args.index, args.character), 'B 8B', '', None, args.expect_response, [], [])

	def get_custom_character(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-custom-character')

		parser.add_argument('index', type=convert_int, help='int', metavar='<index>')

		args = parser.parse_args(argv)

		device_call(ctx, LCD20x4Bricklet, 12, (args.index,), 'B', '8B', args.execute, False, ['character'], [None])

	def set_default_text(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-default-text')

		parser.add_argument('line', type=convert_int, help='int', metavar='<line>')
		parser.add_argument('text', type=create_string_converter(ctx, str, 20), help='string', metavar='<text>')

		args = parser.parse_args(argv)

		device_call(ctx, LCD20x4Bricklet, 13, (args.line, args.text), 'B 20s', '', None, args.expect_response, [], [])

	def get_default_text(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-default-text')

		parser.add_argument('line', type=convert_int, help='int', metavar='<line>')

		args = parser.parse_args(argv)

		device_call(ctx, LCD20x4Bricklet, 14, (args.line,), 'B', '20s', args.execute, False, ['text'], [None])

	def set_default_text_counter(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-default-text-counter')

		parser.add_argument('counter', type=convert_int, help='int', metavar='<counter>')

		args = parser.parse_args(argv)

		device_call(ctx, LCD20x4Bricklet, 15, (args.counter,), 'i', '', None, args.expect_response, [], [])

	def get_default_text_counter(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-default-text-counter')

		args = parser.parse_args(argv)

		device_call(ctx, LCD20x4Bricklet, 16, (), '', 'i', args.execute, False, ['counter'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, LCD20x4Bricklet, argv)

	functions = {
	'write-line': write_line,
	'clear-display': clear_display,
	'backlight-on': backlight_on,
	'backlight-off': backlight_off,
	'is-backlight-on': is_backlight_on,
	'set-config': set_config,
	'get-config': get_config,
	'is-button-pressed': is_button_pressed,
	'set-custom-character': set_custom_character,
	'get-custom-character': get_custom_character,
	'set-default-text': set_default_text,
	'get-default-text': get_default_text,
	'set-default-text-counter': set_default_text_counter,
	'get-default-text-counter': get_default_text_counter,
	'get-identity': get_identity
	}

	call_generic(ctx, 'lcd-20x4-bricklet', functions, argv)

def dispatch_lcd_20x4_bricklet(ctx, argv):
	prog_prefix = 'dispatch lcd-20x4-bricklet <uid>'

	def button_pressed(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' button-pressed')

		args = parser.parse_args(argv)

		device_dispatch(ctx, LCD20x4Bricklet, 9, args.execute, ['button'], [None])

	def button_released(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' button-released')

		args = parser.parse_args(argv)

		device_dispatch(ctx, LCD20x4Bricklet, 10, args.execute, ['button'], [None])

	callbacks = {
	'button-pressed': button_pressed,
	'button-released': button_released
	}

	dispatch_generic(ctx, 'lcd-20x4-bricklet', callbacks, argv)

class LEDStripBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 3; re[2] = 1; re[3] = 3; re[4] = 1; re[5] = 1; re[7] = 3; re[8] = 1; re[9] = 3; re[10] = 1; re[11] = 3; re[12] = 1; re[13] = 3; re[14] = 1; re[15] = 2; re[16] = 2; re[17] = 1; re[255] = 1
		cf = self.callback_formats
		cf[6] = 'H'


def call_led_strip_bricklet(ctx, argv):
	prog_prefix = 'call led-strip-bricklet <uid>'

	def set_rgb_values(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-rgb-values')

		parser.add_argument('index', type=convert_int, help='int', metavar='<index>')
		parser.add_argument('length', type=convert_int, help='int', metavar='<length>')
		parser.add_argument('r', type=create_array_converter(ctx, convert_int, '0', 16), help=get_array_type_name(ctx, 'int', 16), metavar='<r>')
		parser.add_argument('g', type=create_array_converter(ctx, convert_int, '0', 16), help=get_array_type_name(ctx, 'int', 16), metavar='<g>')
		parser.add_argument('b', type=create_array_converter(ctx, convert_int, '0', 16), help=get_array_type_name(ctx, 'int', 16), metavar='<b>')

		args = parser.parse_args(argv)

		device_call(ctx, LEDStripBricklet, 1, (args.index, args.length, args.r, args.g, args.b), 'H B 16B 16B 16B', '', None, args.expect_response, [], [])

	def get_rgb_values(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-rgb-values')

		parser.add_argument('index', type=convert_int, help='int', metavar='<index>')
		parser.add_argument('length', type=convert_int, help='int', metavar='<length>')

		args = parser.parse_args(argv)

		device_call(ctx, LEDStripBricklet, 2, (args.index, args.length), 'H B', '16B 16B 16B', args.execute, False, ['r', 'g', 'b'], [None, None, None])

	def set_frame_duration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-frame-duration')

		parser.add_argument('duration', type=convert_int, help='int', metavar='<duration>')

		args = parser.parse_args(argv)

		device_call(ctx, LEDStripBricklet, 3, (args.duration,), 'H', '', None, args.expect_response, [], [])

	def get_frame_duration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-frame-duration')

		args = parser.parse_args(argv)

		device_call(ctx, LEDStripBricklet, 4, (), '', 'H', args.execute, False, ['duration'], [None])

	def get_supply_voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-supply-voltage')

		args = parser.parse_args(argv)

		device_call(ctx, LEDStripBricklet, 5, (), '', 'H', args.execute, False, ['voltage'], [None])

	def set_clock_frequency(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-clock-frequency')

		parser.add_argument('frequency', type=convert_int, help='int', metavar='<frequency>')

		args = parser.parse_args(argv)

		device_call(ctx, LEDStripBricklet, 7, (args.frequency,), 'I', '', None, args.expect_response, [], [])

	def get_clock_frequency(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-clock-frequency')

		args = parser.parse_args(argv)

		device_call(ctx, LEDStripBricklet, 8, (), '', 'I', args.execute, False, ['frequency'], [None])

	def set_chip_type(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-chip-type')

		parser.add_argument('chip', type=create_symbol_converter(ctx, convert_int, {'chip-type-ws2801': 2801, 'chip-type-ws2811': 2811, 'chip-type-lpd8806': 8806, 'chip-type-apa102': 102, 'chip-type-ws2812': 2812}), help='int (chip-type-ws2801: 2801, chip-type-ws2811: 2811, chip-type-ws2812: 2812, chip-type-lpd8806: 8806, chip-type-apa102: 102)', metavar='<chip>')

		args = parser.parse_args(argv)

		device_call(ctx, LEDStripBricklet, 9, (args.chip,), 'H', '', None, args.expect_response, [], [])

	def get_chip_type(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-type')

		args = parser.parse_args(argv)

		device_call(ctx, LEDStripBricklet, 10, (), '', 'H', args.execute, False, ['chip'], [{2801: 'chip-type-ws2801', 2811: 'chip-type-ws2811', 2812: 'chip-type-ws2812', 102: 'chip-type-apa102', 8806: 'chip-type-lpd8806'}])

	def set_rgbw_values(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-rgbw-values')

		parser.add_argument('index', type=convert_int, help='int', metavar='<index>')
		parser.add_argument('length', type=convert_int, help='int', metavar='<length>')
		parser.add_argument('r', type=create_array_converter(ctx, convert_int, '0', 12), help=get_array_type_name(ctx, 'int', 12), metavar='<r>')
		parser.add_argument('g', type=create_array_converter(ctx, convert_int, '0', 12), help=get_array_type_name(ctx, 'int', 12), metavar='<g>')
		parser.add_argument('b', type=create_array_converter(ctx, convert_int, '0', 12), help=get_array_type_name(ctx, 'int', 12), metavar='<b>')
		parser.add_argument('w', type=create_array_converter(ctx, convert_int, '0', 12), help=get_array_type_name(ctx, 'int', 12), metavar='<w>')

		args = parser.parse_args(argv)

		device_call(ctx, LEDStripBricklet, 11, (args.index, args.length, args.r, args.g, args.b, args.w), 'H B 12B 12B 12B 12B', '', None, args.expect_response, [], [])

	def get_rgbw_values(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-rgbw-values')

		parser.add_argument('index', type=convert_int, help='int', metavar='<index>')
		parser.add_argument('length', type=convert_int, help='int', metavar='<length>')

		args = parser.parse_args(argv)

		device_call(ctx, LEDStripBricklet, 12, (args.index, args.length), 'H B', '12B 12B 12B 12B', args.execute, False, ['r', 'g', 'b', 'w'], [None, None, None, None])

	def set_channel_mapping(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-channel-mapping')

		parser.add_argument('mapping', type=create_symbol_converter(ctx, convert_int, {'channel-mapping-grb': 18, 'channel-mapping-bgrw': 147, 'channel-mapping-gbrw': 99, 'channel-mapping-wrgb': 198, 'channel-mapping-rwgb': 54, 'channel-mapping-bwgr': 180, 'channel-mapping-bgr': 36, 'channel-mapping-gwrb': 114, 'channel-mapping-rbgw': 39, 'channel-mapping-wgbr': 216, 'channel-mapping-grwb': 78, 'channel-mapping-rbg': 9, 'channel-mapping-brgw': 135, 'channel-mapping-bgwr': 156, 'channel-mapping-rwbg': 57, 'channel-mapping-gbr': 24, 'channel-mapping-rgb': 6, 'channel-mapping-gwbr': 120, 'channel-mapping-grbw': 75, 'channel-mapping-wgrb': 210, 'channel-mapping-wbgr': 228, 'channel-mapping-gbwr': 108, 'channel-mapping-brg': 33, 'channel-mapping-rgbw': 27, 'channel-mapping-brwg': 141, 'channel-mapping-wbrg': 225, 'channel-mapping-rbwg': 45, 'channel-mapping-wrbg': 201, 'channel-mapping-bwrg': 177, 'channel-mapping-rgwb': 30}), help='int (channel-mapping-rgb: 6, channel-mapping-rbg: 9, channel-mapping-brg: 33, channel-mapping-bgr: 36, channel-mapping-grb: 18, channel-mapping-gbr: 24, channel-mapping-rgbw: 27, channel-mapping-rgwb: 30, channel-mapping-rbgw: 39, channel-mapping-rbwg: 45, channel-mapping-rwgb: 54, channel-mapping-rwbg: 57, channel-mapping-grwb: 78, channel-mapping-grbw: 75, channel-mapping-gbwr: 108, channel-mapping-gbrw: 99, channel-mapping-gwbr: 120, channel-mapping-gwrb: 114, channel-mapping-brgw: 135, channel-mapping-brwg: 141, channel-mapping-bgrw: 147, channel-mapping-bgwr: 156, channel-mapping-bwrg: 177, channel-mapping-bwgr: 180, channel-mapping-wrbg: 201, channel-mapping-wrgb: 198, channel-mapping-wgbr: 216, channel-mapping-wgrb: 210, channel-mapping-wbgr: 228, channel-mapping-wbrg: 225)', metavar='<mapping>')

		args = parser.parse_args(argv)

		device_call(ctx, LEDStripBricklet, 13, (args.mapping,), 'B', '', None, args.expect_response, [], [])

	def get_channel_mapping(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-channel-mapping')

		args = parser.parse_args(argv)

		device_call(ctx, LEDStripBricklet, 14, (), '', 'B', args.execute, False, ['mapping'], [{6: 'channel-mapping-rgb', 135: 'channel-mapping-brgw', 9: 'channel-mapping-rbg', 141: 'channel-mapping-brwg', 18: 'channel-mapping-grb', 147: 'channel-mapping-bgrw', 24: 'channel-mapping-gbr', 27: 'channel-mapping-rgbw', 156: 'channel-mapping-bgwr', 30: 'channel-mapping-rgwb', 33: 'channel-mapping-brg', 36: 'channel-mapping-bgr', 39: 'channel-mapping-rbgw', 45: 'channel-mapping-rbwg', 177: 'channel-mapping-bwrg', 180: 'channel-mapping-bwgr', 54: 'channel-mapping-rwgb', 57: 'channel-mapping-rwbg', 198: 'channel-mapping-wrgb', 201: 'channel-mapping-wrbg', 75: 'channel-mapping-grbw', 78: 'channel-mapping-grwb', 210: 'channel-mapping-wgrb', 216: 'channel-mapping-wgbr', 225: 'channel-mapping-wbrg', 99: 'channel-mapping-gbrw', 228: 'channel-mapping-wbgr', 108: 'channel-mapping-gbwr', 114: 'channel-mapping-gwrb', 120: 'channel-mapping-gwbr'}])

	def enable_frame_rendered_callback(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' enable-frame-rendered-callback')

		args = parser.parse_args(argv)

		device_call(ctx, LEDStripBricklet, 15, (), '', '', None, args.expect_response, [], [])

	def disable_frame_rendered_callback(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' disable-frame-rendered-callback')

		args = parser.parse_args(argv)

		device_call(ctx, LEDStripBricklet, 16, (), '', '', None, args.expect_response, [], [])

	def is_frame_rendered_callback_enabled(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' is-frame-rendered-callback-enabled')

		args = parser.parse_args(argv)

		device_call(ctx, LEDStripBricklet, 17, (), '', '!', args.execute, False, ['enabled'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, LEDStripBricklet, argv)

	functions = {
	'set-rgb-values': set_rgb_values,
	'get-rgb-values': get_rgb_values,
	'set-frame-duration': set_frame_duration,
	'get-frame-duration': get_frame_duration,
	'get-supply-voltage': get_supply_voltage,
	'set-clock-frequency': set_clock_frequency,
	'get-clock-frequency': get_clock_frequency,
	'set-chip-type': set_chip_type,
	'get-chip-type': get_chip_type,
	'set-rgbw-values': set_rgbw_values,
	'get-rgbw-values': get_rgbw_values,
	'set-channel-mapping': set_channel_mapping,
	'get-channel-mapping': get_channel_mapping,
	'enable-frame-rendered-callback': enable_frame_rendered_callback,
	'disable-frame-rendered-callback': disable_frame_rendered_callback,
	'is-frame-rendered-callback-enabled': is_frame_rendered_callback_enabled,
	'get-identity': get_identity
	}

	call_generic(ctx, 'led-strip-bricklet', functions, argv)

def dispatch_led_strip_bricklet(ctx, argv):
	prog_prefix = 'dispatch led-strip-bricklet <uid>'

	def frame_rendered(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' frame-rendered')

		args = parser.parse_args(argv)

		device_dispatch(ctx, LEDStripBricklet, 6, args.execute, ['length'], [None])

	callbacks = {
	'frame-rendered': frame_rendered
	}

	dispatch_generic(ctx, 'led-strip-bricklet', callbacks, argv)

class LEDStripV2Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 2; re[2] = 1; re[3] = 3; re[4] = 1; re[5] = 1; re[7] = 3; re[8] = 1; re[9] = 3; re[10] = 1; re[11] = 3; re[12] = 1; re[13] = 2; re[14] = 1; re[234] = 1; re[235] = 1; re[236] = 1; re[237] = 3; re[238] = 1; re[239] = 3; re[240] = 1; re[242] = 1; re[243] = 3; re[248] = 3; re[249] = 1; re[255] = 1
		cf = self.callback_formats
		cf[6] = 'H'


def call_led_strip_v2_bricklet(ctx, argv):
	prog_prefix = 'call led-strip-v2-bricklet <uid>'

	def set_led_values_low_level(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-led-values-low-level')

		parser.add_argument('index', type=convert_int, help='int', metavar='<index>')
		parser.add_argument('value_length', type=convert_int, help='int', metavar='<value-length>')
		parser.add_argument('value_chunk_offset', type=convert_int, help='int', metavar='<value-chunk-offset>')
		parser.add_argument('value_chunk_data', type=create_array_converter(ctx, convert_int, '0', 58), help=get_array_type_name(ctx, 'int', 58), metavar='<value-chunk-data>')

		args = parser.parse_args(argv)

		device_call(ctx, LEDStripV2Bricklet, 1, (args.index, args.value_length, args.value_chunk_offset, args.value_chunk_data), 'H H H 58B', '', None, args.expect_response, [], [])

	def set_led_values(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-led-values')

		parser.add_argument('index', type=convert_int, help='int', metavar='<index>')
		parser.add_argument('value', type=create_array_converter(ctx, convert_int, None, -65535), help=get_array_type_name(ctx, 'int', -65535), metavar='<value>')

		args = parser.parse_args(argv)

		device_stream_call(ctx, LEDStripV2Bricklet, 1, 'in', (args.index, args.value), (None, 'stream_data'), (), (None, 'stream_length', 'stream_chunk_offset', 'stream_chunk_data'), (), 'H H H 58B', '', None, args.expect_response, [], [], '0', 58, None, False, False, None)

	def get_led_values_low_level(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-led-values-low-level')

		parser.add_argument('index', type=convert_int, help='int', metavar='<index>')
		parser.add_argument('length', type=convert_int, help='int', metavar='<length>')

		args = parser.parse_args(argv)

		device_call(ctx, LEDStripV2Bricklet, 2, (args.index, args.length), 'H H', 'H H 60B', args.execute, False, ['value-length', 'value-chunk-offset', 'value-chunk-data'], [None, None, None])

	def get_led_values(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-led-values')

		parser.add_argument('index', type=convert_int, help='int', metavar='<index>')
		parser.add_argument('length', type=convert_int, help='int', metavar='<length>')

		args = parser.parse_args(argv)

		device_stream_call(ctx, LEDStripV2Bricklet, 2, 'out', (args.index, args.length), (None, None), ('stream_data',), (None, None), ('stream_length', 'stream_chunk_offset', 'stream_chunk_data'), 'H H', 'H H 60B', args.execute, False, ['value'], [None], None, 60, None, False, False, None)

	def set_frame_duration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-frame-duration')

		parser.add_argument('duration', type=convert_int, help='int', metavar='<duration>')

		args = parser.parse_args(argv)

		device_call(ctx, LEDStripV2Bricklet, 3, (args.duration,), 'H', '', None, args.expect_response, [], [])

	def get_frame_duration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-frame-duration')

		args = parser.parse_args(argv)

		device_call(ctx, LEDStripV2Bricklet, 4, (), '', 'H', args.execute, False, ['duration'], [None])

	def get_supply_voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-supply-voltage')

		args = parser.parse_args(argv)

		device_call(ctx, LEDStripV2Bricklet, 5, (), '', 'H', args.execute, False, ['voltage'], [None])

	def set_clock_frequency(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-clock-frequency')

		parser.add_argument('frequency', type=convert_int, help='int', metavar='<frequency>')

		args = parser.parse_args(argv)

		device_call(ctx, LEDStripV2Bricklet, 7, (args.frequency,), 'I', '', None, args.expect_response, [], [])

	def get_clock_frequency(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-clock-frequency')

		args = parser.parse_args(argv)

		device_call(ctx, LEDStripV2Bricklet, 8, (), '', 'I', args.execute, False, ['frequency'], [None])

	def set_chip_type(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-chip-type')

		parser.add_argument('chip', type=create_symbol_converter(ctx, convert_int, {'chip-type-ws2801': 2801, 'chip-type-ws2811': 2811, 'chip-type-lpd8806': 8806, 'chip-type-apa102': 102, 'chip-type-ws2812': 2812}), help='int (chip-type-ws2801: 2801, chip-type-ws2811: 2811, chip-type-ws2812: 2812, chip-type-lpd8806: 8806, chip-type-apa102: 102)', metavar='<chip>')

		args = parser.parse_args(argv)

		device_call(ctx, LEDStripV2Bricklet, 9, (args.chip,), 'H', '', None, args.expect_response, [], [])

	def get_chip_type(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-type')

		args = parser.parse_args(argv)

		device_call(ctx, LEDStripV2Bricklet, 10, (), '', 'H', args.execute, False, ['chip'], [{2801: 'chip-type-ws2801', 2811: 'chip-type-ws2811', 2812: 'chip-type-ws2812', 102: 'chip-type-apa102', 8806: 'chip-type-lpd8806'}])

	def set_channel_mapping(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-channel-mapping')

		parser.add_argument('mapping', type=create_symbol_converter(ctx, convert_int, {'channel-mapping-grb': 18, 'channel-mapping-bgrw': 147, 'channel-mapping-gbrw': 99, 'channel-mapping-wrgb': 198, 'channel-mapping-rwgb': 54, 'channel-mapping-bwgr': 180, 'channel-mapping-bgr': 36, 'channel-mapping-gwrb': 114, 'channel-mapping-rbgw': 39, 'channel-mapping-wgbr': 216, 'channel-mapping-grwb': 78, 'channel-mapping-rbg': 9, 'channel-mapping-brgw': 135, 'channel-mapping-bgwr': 156, 'channel-mapping-rwbg': 57, 'channel-mapping-gbr': 24, 'channel-mapping-rgb': 6, 'channel-mapping-gwbr': 120, 'channel-mapping-grbw': 75, 'channel-mapping-wgrb': 210, 'channel-mapping-wbgr': 228, 'channel-mapping-gbwr': 108, 'channel-mapping-brg': 33, 'channel-mapping-rgbw': 27, 'channel-mapping-brwg': 141, 'channel-mapping-wbrg': 225, 'channel-mapping-rbwg': 45, 'channel-mapping-wrbg': 201, 'channel-mapping-bwrg': 177, 'channel-mapping-rgwb': 30}), help='int (channel-mapping-rgb: 6, channel-mapping-rbg: 9, channel-mapping-brg: 33, channel-mapping-bgr: 36, channel-mapping-grb: 18, channel-mapping-gbr: 24, channel-mapping-rgbw: 27, channel-mapping-rgwb: 30, channel-mapping-rbgw: 39, channel-mapping-rbwg: 45, channel-mapping-rwgb: 54, channel-mapping-rwbg: 57, channel-mapping-grwb: 78, channel-mapping-grbw: 75, channel-mapping-gbwr: 108, channel-mapping-gbrw: 99, channel-mapping-gwbr: 120, channel-mapping-gwrb: 114, channel-mapping-brgw: 135, channel-mapping-brwg: 141, channel-mapping-bgrw: 147, channel-mapping-bgwr: 156, channel-mapping-bwrg: 177, channel-mapping-bwgr: 180, channel-mapping-wrbg: 201, channel-mapping-wrgb: 198, channel-mapping-wgbr: 216, channel-mapping-wgrb: 210, channel-mapping-wbgr: 228, channel-mapping-wbrg: 225)', metavar='<mapping>')

		args = parser.parse_args(argv)

		device_call(ctx, LEDStripV2Bricklet, 11, (args.mapping,), 'B', '', None, args.expect_response, [], [])

	def get_channel_mapping(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-channel-mapping')

		args = parser.parse_args(argv)

		device_call(ctx, LEDStripV2Bricklet, 12, (), '', 'B', args.execute, False, ['mapping'], [{6: 'channel-mapping-rgb', 135: 'channel-mapping-brgw', 9: 'channel-mapping-rbg', 141: 'channel-mapping-brwg', 18: 'channel-mapping-grb', 147: 'channel-mapping-bgrw', 24: 'channel-mapping-gbr', 27: 'channel-mapping-rgbw', 156: 'channel-mapping-bgwr', 30: 'channel-mapping-rgwb', 33: 'channel-mapping-brg', 36: 'channel-mapping-bgr', 39: 'channel-mapping-rbgw', 45: 'channel-mapping-rbwg', 177: 'channel-mapping-bwrg', 180: 'channel-mapping-bwgr', 54: 'channel-mapping-rwgb', 57: 'channel-mapping-rwbg', 198: 'channel-mapping-wrgb', 201: 'channel-mapping-wrbg', 75: 'channel-mapping-grbw', 78: 'channel-mapping-grwb', 210: 'channel-mapping-wgrb', 216: 'channel-mapping-wgbr', 225: 'channel-mapping-wbrg', 99: 'channel-mapping-gbrw', 228: 'channel-mapping-wbgr', 108: 'channel-mapping-gbwr', 114: 'channel-mapping-gwrb', 120: 'channel-mapping-gwbr'}])

	def set_frame_started_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-frame-started-callback-configuration')

		parser.add_argument('enable', type=convert_bool, help='bool', metavar='<enable>')

		args = parser.parse_args(argv)

		device_call(ctx, LEDStripV2Bricklet, 13, (args.enable,), '!', '', None, args.expect_response, [], [])

	def get_frame_started_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-frame-started-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, LEDStripV2Bricklet, 14, (), '', '!', args.execute, False, ['enable'], [None])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, LEDStripV2Bricklet, 234, (), '', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def set_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-bootloader-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'bootloader-mode-firmware-wait-for-reboot': 3, 'bootloader-mode-firmware': 1, 'bootloader-mode-firmware-wait-for-erase-and-reboot': 4, 'bootloader-mode-bootloader-wait-for-reboot': 2, 'bootloader-mode-bootloader': 0}), help='int (bootloader-mode-bootloader: 0, bootloader-mode-firmware: 1, bootloader-mode-bootloader-wait-for-reboot: 2, bootloader-mode-firmware-wait-for-reboot: 3, bootloader-mode-firmware-wait-for-erase-and-reboot: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, LEDStripV2Bricklet, 235, (args.mode,), 'B', 'B', args.execute, False, ['status'], [{0: 'bootloader-status-ok', 1: 'bootloader-status-invalid-mode', 2: 'bootloader-status-no-change', 3: 'bootloader-status-entry-function-not-present', 4: 'bootloader-status-device-identifier-incorrect', 5: 'bootloader-status-crc-mismatch'}])

	def get_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-bootloader-mode')

		args = parser.parse_args(argv)

		device_call(ctx, LEDStripV2Bricklet, 236, (), '', 'B', args.execute, False, ['mode'], [{0: 'bootloader-mode-bootloader', 1: 'bootloader-mode-firmware', 2: 'bootloader-mode-bootloader-wait-for-reboot', 3: 'bootloader-mode-firmware-wait-for-reboot', 4: 'bootloader-mode-firmware-wait-for-erase-and-reboot'}])

	def set_write_firmware_pointer(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-write-firmware-pointer')

		parser.add_argument('pointer', type=convert_int, help='int', metavar='<pointer>')

		args = parser.parse_args(argv)

		device_call(ctx, LEDStripV2Bricklet, 237, (args.pointer,), 'I', '', None, args.expect_response, [], [])

	def write_firmware(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-firmware')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, LEDStripV2Bricklet, 238, (args.data,), '64B', 'B', args.execute, False, ['status'], [None])

	def set_status_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'status-led-config-on': 1, 'status-led-config-show-heartbeat': 2, 'status-led-config-off': 0, 'status-led-config-show-status': 3}), help='int (status-led-config-off: 0, status-led-config-on: 1, status-led-config-show-heartbeat: 2, status-led-config-show-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, LEDStripV2Bricklet, 239, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_status_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, LEDStripV2Bricklet, 240, (), '', 'B', args.execute, False, ['config'], [{0: 'status-led-config-off', 1: 'status-led-config-on', 2: 'status-led-config-show-heartbeat', 3: 'status-led-config-show-status'}])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, LEDStripV2Bricklet, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, LEDStripV2Bricklet, 243, (), '', '', None, args.expect_response, [], [])

	def write_uid(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-uid')

		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')

		args = parser.parse_args(argv)

		device_call(ctx, LEDStripV2Bricklet, 248, (args.uid,), 'I', '', None, args.expect_response, [], [])

	def read_uid(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-uid')

		args = parser.parse_args(argv)

		device_call(ctx, LEDStripV2Bricklet, 249, (), '', 'I', args.execute, False, ['uid'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, LEDStripV2Bricklet, argv)

	functions = {
	'set-led-values-low-level': set_led_values_low_level,
	'set-led-values': set_led_values,
	'get-led-values-low-level': get_led_values_low_level,
	'get-led-values': get_led_values,
	'set-frame-duration': set_frame_duration,
	'get-frame-duration': get_frame_duration,
	'get-supply-voltage': get_supply_voltage,
	'set-clock-frequency': set_clock_frequency,
	'get-clock-frequency': get_clock_frequency,
	'set-chip-type': set_chip_type,
	'get-chip-type': get_chip_type,
	'set-channel-mapping': set_channel_mapping,
	'get-channel-mapping': get_channel_mapping,
	'set-frame-started-callback-configuration': set_frame_started_callback_configuration,
	'get-frame-started-callback-configuration': get_frame_started_callback_configuration,
	'get-spitfp-error-count': get_spitfp_error_count,
	'set-bootloader-mode': set_bootloader_mode,
	'get-bootloader-mode': get_bootloader_mode,
	'set-write-firmware-pointer': set_write_firmware_pointer,
	'write-firmware': write_firmware,
	'set-status-led-config': set_status_led_config,
	'get-status-led-config': get_status_led_config,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'write-uid': write_uid,
	'read-uid': read_uid,
	'get-identity': get_identity
	}

	call_generic(ctx, 'led-strip-v2-bricklet', functions, argv)

def dispatch_led_strip_v2_bricklet(ctx, argv):
	prog_prefix = 'dispatch led-strip-v2-bricklet <uid>'

	def frame_started(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' frame-started')

		args = parser.parse_args(argv)

		device_dispatch(ctx, LEDStripV2Bricklet, 6, args.execute, ['length'], [None])

	callbacks = {
	'frame-started': frame_started
	}

	dispatch_generic(ctx, 'led-strip-v2-bricklet', callbacks, argv)

class LineBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 2; re[3] = 1; re[4] = 2; re[5] = 1; re[6] = 2; re[7] = 1; re[255] = 1
		cf = self.callback_formats
		cf[8] = 'H'; cf[9] = 'H'


def call_line_bricklet(ctx, argv):
	prog_prefix = 'call line-bricklet <uid>'

	def get_reflectivity(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-reflectivity')

		args = parser.parse_args(argv)

		device_call(ctx, LineBricklet, 1, (), '', 'H', args.execute, False, ['reflectivity'], [None])

	def set_reflectivity_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-reflectivity-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, LineBricklet, 2, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_reflectivity_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-reflectivity-callback-period')

		args = parser.parse_args(argv)

		device_call(ctx, LineBricklet, 3, (), '', 'I', args.execute, False, ['period'], [None])

	def set_reflectivity_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-reflectivity-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, LineBricklet, 4, (args.option, args.min, args.max), 'c H H', '', None, args.expect_response, [], [])

	def get_reflectivity_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-reflectivity-callback-threshold')

		args = parser.parse_args(argv)

		device_call(ctx, LineBricklet, 5, (), '', 'c H H', args.execute, False, ['option', 'min', 'max'], [{'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def set_debounce_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-debounce-period')

		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_call(ctx, LineBricklet, 6, (args.debounce,), 'I', '', None, args.expect_response, [], [])

	def get_debounce_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-debounce-period')

		args = parser.parse_args(argv)

		device_call(ctx, LineBricklet, 7, (), '', 'I', args.execute, False, ['debounce'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, LineBricklet, argv)

	functions = {
	'get-reflectivity': get_reflectivity,
	'set-reflectivity-callback-period': set_reflectivity_callback_period,
	'get-reflectivity-callback-period': get_reflectivity_callback_period,
	'set-reflectivity-callback-threshold': set_reflectivity_callback_threshold,
	'get-reflectivity-callback-threshold': get_reflectivity_callback_threshold,
	'set-debounce-period': set_debounce_period,
	'get-debounce-period': get_debounce_period,
	'get-identity': get_identity
	}

	call_generic(ctx, 'line-bricklet', functions, argv)

def dispatch_line_bricklet(ctx, argv):
	prog_prefix = 'dispatch line-bricklet <uid>'

	def reflectivity(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' reflectivity')

		args = parser.parse_args(argv)

		device_dispatch(ctx, LineBricklet, 8, args.execute, ['reflectivity'], [None])

	def reflectivity_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' reflectivity-reached')

		args = parser.parse_args(argv)

		device_dispatch(ctx, LineBricklet, 9, args.execute, ['reflectivity'], [None])

	callbacks = {
	'reflectivity': reflectivity,
	'reflectivity-reached': reflectivity_reached
	}

	dispatch_generic(ctx, 'line-bricklet', callbacks, argv)

class LinearPotiBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 1; re[3] = 2; re[4] = 1; re[5] = 2; re[6] = 1; re[7] = 2; re[8] = 1; re[9] = 2; re[10] = 1; re[11] = 2; re[12] = 1; re[255] = 1
		cf = self.callback_formats
		cf[13] = 'H'; cf[14] = 'H'; cf[15] = 'H'; cf[16] = 'H'


def call_linear_poti_bricklet(ctx, argv):
	prog_prefix = 'call linear-poti-bricklet <uid>'

	def get_position(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-position')

		args = parser.parse_args(argv)

		device_call(ctx, LinearPotiBricklet, 1, (), '', 'H', args.execute, False, ['position'], [None])

	def get_analog_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-analog-value')

		args = parser.parse_args(argv)

		device_call(ctx, LinearPotiBricklet, 2, (), '', 'H', args.execute, False, ['value'], [None])

	def set_position_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-position-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, LinearPotiBricklet, 3, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_position_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-position-callback-period')

		args = parser.parse_args(argv)

		device_call(ctx, LinearPotiBricklet, 4, (), '', 'I', args.execute, False, ['period'], [None])

	def set_analog_value_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-analog-value-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, LinearPotiBricklet, 5, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_analog_value_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-analog-value-callback-period')

		args = parser.parse_args(argv)

		device_call(ctx, LinearPotiBricklet, 6, (), '', 'I', args.execute, False, ['period'], [None])

	def set_position_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-position-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, LinearPotiBricklet, 7, (args.option, args.min, args.max), 'c H H', '', None, args.expect_response, [], [])

	def get_position_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-position-callback-threshold')

		args = parser.parse_args(argv)

		device_call(ctx, LinearPotiBricklet, 8, (), '', 'c H H', args.execute, False, ['option', 'min', 'max'], [{'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def set_analog_value_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-analog-value-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, LinearPotiBricklet, 9, (args.option, args.min, args.max), 'c H H', '', None, args.expect_response, [], [])

	def get_analog_value_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-analog-value-callback-threshold')

		args = parser.parse_args(argv)

		device_call(ctx, LinearPotiBricklet, 10, (), '', 'c H H', args.execute, False, ['option', 'min', 'max'], [{'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def set_debounce_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-debounce-period')

		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_call(ctx, LinearPotiBricklet, 11, (args.debounce,), 'I', '', None, args.expect_response, [], [])

	def get_debounce_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-debounce-period')

		args = parser.parse_args(argv)

		device_call(ctx, LinearPotiBricklet, 12, (), '', 'I', args.execute, False, ['debounce'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, LinearPotiBricklet, argv)

	functions = {
	'get-position': get_position,
	'get-analog-value': get_analog_value,
	'set-position-callback-period': set_position_callback_period,
	'get-position-callback-period': get_position_callback_period,
	'set-analog-value-callback-period': set_analog_value_callback_period,
	'get-analog-value-callback-period': get_analog_value_callback_period,
	'set-position-callback-threshold': set_position_callback_threshold,
	'get-position-callback-threshold': get_position_callback_threshold,
	'set-analog-value-callback-threshold': set_analog_value_callback_threshold,
	'get-analog-value-callback-threshold': get_analog_value_callback_threshold,
	'set-debounce-period': set_debounce_period,
	'get-debounce-period': get_debounce_period,
	'get-identity': get_identity
	}

	call_generic(ctx, 'linear-poti-bricklet', functions, argv)

def dispatch_linear_poti_bricklet(ctx, argv):
	prog_prefix = 'dispatch linear-poti-bricklet <uid>'

	def position(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' position')

		args = parser.parse_args(argv)

		device_dispatch(ctx, LinearPotiBricklet, 13, args.execute, ['position'], [None])

	def analog_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' analog-value')

		args = parser.parse_args(argv)

		device_dispatch(ctx, LinearPotiBricklet, 14, args.execute, ['value'], [None])

	def position_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' position-reached')

		args = parser.parse_args(argv)

		device_dispatch(ctx, LinearPotiBricklet, 15, args.execute, ['position'], [None])

	def analog_value_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' analog-value-reached')

		args = parser.parse_args(argv)

		device_dispatch(ctx, LinearPotiBricklet, 16, args.execute, ['value'], [None])

	callbacks = {
	'position': position,
	'analog-value': analog_value,
	'position-reached': position_reached,
	'analog-value-reached': analog_value_reached
	}

	dispatch_generic(ctx, 'linear-poti-bricklet', callbacks, argv)

class LinearPotiV2Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 2; re[3] = 1; re[234] = 1; re[235] = 1; re[236] = 1; re[237] = 3; re[238] = 1; re[239] = 3; re[240] = 1; re[242] = 1; re[243] = 3; re[248] = 3; re[249] = 1; re[255] = 1
		cf = self.callback_formats
		cf[4] = 'B'


def call_linear_poti_v2_bricklet(ctx, argv):
	prog_prefix = 'call linear-poti-v2-bricklet <uid>'

	def get_position(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-position')

		args = parser.parse_args(argv)

		device_call(ctx, LinearPotiV2Bricklet, 1, (), '', 'B', args.execute, False, ['position'], [None])

	def set_position_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-position-callback-configuration')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')
		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, LinearPotiV2Bricklet, 2, (args.period, args.value_has_to_change, args.option, args.min, args.max), 'I ! c B B', '', None, args.expect_response, [], [])

	def get_position_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-position-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, LinearPotiV2Bricklet, 3, (), '', 'I ! c B B', args.execute, False, ['period', 'value-has-to-change', 'option', 'min', 'max'], [None, None, {'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, LinearPotiV2Bricklet, 234, (), '', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def set_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-bootloader-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'bootloader-mode-firmware-wait-for-reboot': 3, 'bootloader-mode-firmware': 1, 'bootloader-mode-firmware-wait-for-erase-and-reboot': 4, 'bootloader-mode-bootloader-wait-for-reboot': 2, 'bootloader-mode-bootloader': 0}), help='int (bootloader-mode-bootloader: 0, bootloader-mode-firmware: 1, bootloader-mode-bootloader-wait-for-reboot: 2, bootloader-mode-firmware-wait-for-reboot: 3, bootloader-mode-firmware-wait-for-erase-and-reboot: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, LinearPotiV2Bricklet, 235, (args.mode,), 'B', 'B', args.execute, False, ['status'], [{0: 'bootloader-status-ok', 1: 'bootloader-status-invalid-mode', 2: 'bootloader-status-no-change', 3: 'bootloader-status-entry-function-not-present', 4: 'bootloader-status-device-identifier-incorrect', 5: 'bootloader-status-crc-mismatch'}])

	def get_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-bootloader-mode')

		args = parser.parse_args(argv)

		device_call(ctx, LinearPotiV2Bricklet, 236, (), '', 'B', args.execute, False, ['mode'], [{0: 'bootloader-mode-bootloader', 1: 'bootloader-mode-firmware', 2: 'bootloader-mode-bootloader-wait-for-reboot', 3: 'bootloader-mode-firmware-wait-for-reboot', 4: 'bootloader-mode-firmware-wait-for-erase-and-reboot'}])

	def set_write_firmware_pointer(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-write-firmware-pointer')

		parser.add_argument('pointer', type=convert_int, help='int', metavar='<pointer>')

		args = parser.parse_args(argv)

		device_call(ctx, LinearPotiV2Bricklet, 237, (args.pointer,), 'I', '', None, args.expect_response, [], [])

	def write_firmware(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-firmware')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, LinearPotiV2Bricklet, 238, (args.data,), '64B', 'B', args.execute, False, ['status'], [None])

	def set_status_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'status-led-config-on': 1, 'status-led-config-show-heartbeat': 2, 'status-led-config-off': 0, 'status-led-config-show-status': 3}), help='int (status-led-config-off: 0, status-led-config-on: 1, status-led-config-show-heartbeat: 2, status-led-config-show-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, LinearPotiV2Bricklet, 239, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_status_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, LinearPotiV2Bricklet, 240, (), '', 'B', args.execute, False, ['config'], [{0: 'status-led-config-off', 1: 'status-led-config-on', 2: 'status-led-config-show-heartbeat', 3: 'status-led-config-show-status'}])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, LinearPotiV2Bricklet, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, LinearPotiV2Bricklet, 243, (), '', '', None, args.expect_response, [], [])

	def write_uid(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-uid')

		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')

		args = parser.parse_args(argv)

		device_call(ctx, LinearPotiV2Bricklet, 248, (args.uid,), 'I', '', None, args.expect_response, [], [])

	def read_uid(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-uid')

		args = parser.parse_args(argv)

		device_call(ctx, LinearPotiV2Bricklet, 249, (), '', 'I', args.execute, False, ['uid'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, LinearPotiV2Bricklet, argv)

	functions = {
	'get-position': get_position,
	'set-position-callback-configuration': set_position_callback_configuration,
	'get-position-callback-configuration': get_position_callback_configuration,
	'get-spitfp-error-count': get_spitfp_error_count,
	'set-bootloader-mode': set_bootloader_mode,
	'get-bootloader-mode': get_bootloader_mode,
	'set-write-firmware-pointer': set_write_firmware_pointer,
	'write-firmware': write_firmware,
	'set-status-led-config': set_status_led_config,
	'get-status-led-config': get_status_led_config,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'write-uid': write_uid,
	'read-uid': read_uid,
	'get-identity': get_identity
	}

	call_generic(ctx, 'linear-poti-v2-bricklet', functions, argv)

def dispatch_linear_poti_v2_bricklet(ctx, argv):
	prog_prefix = 'dispatch linear-poti-v2-bricklet <uid>'

	def position(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' position')

		args = parser.parse_args(argv)

		device_dispatch(ctx, LinearPotiV2Bricklet, 4, args.execute, ['position'], [None])

	callbacks = {
	'position': position
	}

	dispatch_generic(ctx, 'linear-poti-v2-bricklet', callbacks, argv)

class LoadCellBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 2; re[3] = 1; re[4] = 2; re[5] = 1; re[6] = 2; re[7] = 1; re[8] = 3; re[9] = 1; re[10] = 3; re[11] = 3; re[12] = 1; re[13] = 3; re[14] = 3; re[15] = 3; re[16] = 1; re[255] = 1
		cf = self.callback_formats
		cf[17] = 'i'; cf[18] = 'i'


def call_load_cell_bricklet(ctx, argv):
	prog_prefix = 'call load-cell-bricklet <uid>'

	def get_weight(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-weight')

		args = parser.parse_args(argv)

		device_call(ctx, LoadCellBricklet, 1, (), '', 'i', args.execute, False, ['weight'], [None])

	def set_weight_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-weight-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, LoadCellBricklet, 2, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_weight_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-weight-callback-period')

		args = parser.parse_args(argv)

		device_call(ctx, LoadCellBricklet, 3, (), '', 'I', args.execute, False, ['period'], [None])

	def set_weight_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-weight-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, LoadCellBricklet, 4, (args.option, args.min, args.max), 'c i i', '', None, args.expect_response, [], [])

	def get_weight_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-weight-callback-threshold')

		args = parser.parse_args(argv)

		device_call(ctx, LoadCellBricklet, 5, (), '', 'c i i', args.execute, False, ['option', 'min', 'max'], [{'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def set_debounce_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-debounce-period')

		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_call(ctx, LoadCellBricklet, 6, (args.debounce,), 'I', '', None, args.expect_response, [], [])

	def get_debounce_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-debounce-period')

		args = parser.parse_args(argv)

		device_call(ctx, LoadCellBricklet, 7, (), '', 'I', args.execute, False, ['debounce'], [None])

	def set_moving_average(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-moving-average')

		parser.add_argument('average', type=convert_int, help='int', metavar='<average>')

		args = parser.parse_args(argv)

		device_call(ctx, LoadCellBricklet, 8, (args.average,), 'B', '', None, args.expect_response, [], [])

	def get_moving_average(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-moving-average')

		args = parser.parse_args(argv)

		device_call(ctx, LoadCellBricklet, 9, (), '', 'B', args.execute, False, ['average'], [None])

	def led_on(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' led-on')

		args = parser.parse_args(argv)

		device_call(ctx, LoadCellBricklet, 10, (), '', '', None, args.expect_response, [], [])

	def led_off(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' led-off')

		args = parser.parse_args(argv)

		device_call(ctx, LoadCellBricklet, 11, (), '', '', None, args.expect_response, [], [])

	def is_led_on(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' is-led-on')

		args = parser.parse_args(argv)

		device_call(ctx, LoadCellBricklet, 12, (), '', '!', args.execute, False, ['on'], [None])

	def calibrate(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' calibrate')

		parser.add_argument('weight', type=convert_int, help='int', metavar='<weight>')

		args = parser.parse_args(argv)

		device_call(ctx, LoadCellBricklet, 13, (args.weight,), 'I', '', None, args.expect_response, [], [])

	def tare(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' tare')

		args = parser.parse_args(argv)

		device_call(ctx, LoadCellBricklet, 14, (), '', '', None, args.expect_response, [], [])

	def set_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-configuration')

		parser.add_argument('rate', type=create_symbol_converter(ctx, convert_int, {'rate-80hz': 1, 'rate-10hz': 0}), help='int (rate-10hz: 0, rate-80hz: 1)', metavar='<rate>')
		parser.add_argument('gain', type=create_symbol_converter(ctx, convert_int, {'gain-64x': 1, 'gain-128x': 0, 'gain-32x': 2}), help='int (gain-128x: 0, gain-64x: 1, gain-32x: 2)', metavar='<gain>')

		args = parser.parse_args(argv)

		device_call(ctx, LoadCellBricklet, 15, (args.rate, args.gain), 'B B', '', None, args.expect_response, [], [])

	def get_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, LoadCellBricklet, 16, (), '', 'B B', args.execute, False, ['rate', 'gain'], [{0: 'rate-10hz', 1: 'rate-80hz'}, {0: 'gain-128x', 1: 'gain-64x', 2: 'gain-32x'}])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, LoadCellBricklet, argv)

	functions = {
	'get-weight': get_weight,
	'set-weight-callback-period': set_weight_callback_period,
	'get-weight-callback-period': get_weight_callback_period,
	'set-weight-callback-threshold': set_weight_callback_threshold,
	'get-weight-callback-threshold': get_weight_callback_threshold,
	'set-debounce-period': set_debounce_period,
	'get-debounce-period': get_debounce_period,
	'set-moving-average': set_moving_average,
	'get-moving-average': get_moving_average,
	'led-on': led_on,
	'led-off': led_off,
	'is-led-on': is_led_on,
	'calibrate': calibrate,
	'tare': tare,
	'set-configuration': set_configuration,
	'get-configuration': get_configuration,
	'get-identity': get_identity
	}

	call_generic(ctx, 'load-cell-bricklet', functions, argv)

def dispatch_load_cell_bricklet(ctx, argv):
	prog_prefix = 'dispatch load-cell-bricklet <uid>'

	def weight(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' weight')

		args = parser.parse_args(argv)

		device_dispatch(ctx, LoadCellBricklet, 17, args.execute, ['weight'], [None])

	def weight_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' weight-reached')

		args = parser.parse_args(argv)

		device_dispatch(ctx, LoadCellBricklet, 18, args.execute, ['weight'], [None])

	callbacks = {
	'weight': weight,
	'weight-reached': weight_reached
	}

	dispatch_generic(ctx, 'load-cell-bricklet', callbacks, argv)

class LoadCellV2Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 2; re[3] = 1; re[5] = 3; re[6] = 1; re[7] = 3; re[8] = 1; re[9] = 3; re[10] = 3; re[11] = 3; re[12] = 1; re[234] = 1; re[235] = 1; re[236] = 1; re[237] = 3; re[238] = 1; re[239] = 3; re[240] = 1; re[242] = 1; re[243] = 3; re[248] = 3; re[249] = 1; re[255] = 1
		cf = self.callback_formats
		cf[4] = 'i'


def call_load_cell_v2_bricklet(ctx, argv):
	prog_prefix = 'call load-cell-v2-bricklet <uid>'

	def get_weight(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-weight')

		args = parser.parse_args(argv)

		device_call(ctx, LoadCellV2Bricklet, 1, (), '', 'i', args.execute, False, ['weight'], [None])

	def set_weight_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-weight-callback-configuration')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')
		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, LoadCellV2Bricklet, 2, (args.period, args.value_has_to_change, args.option, args.min, args.max), 'I ! c i i', '', None, args.expect_response, [], [])

	def get_weight_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-weight-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, LoadCellV2Bricklet, 3, (), '', 'I ! c i i', args.execute, False, ['period', 'value-has-to-change', 'option', 'min', 'max'], [None, None, {'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def set_moving_average(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-moving-average')

		parser.add_argument('average', type=convert_int, help='int', metavar='<average>')

		args = parser.parse_args(argv)

		device_call(ctx, LoadCellV2Bricklet, 5, (args.average,), 'H', '', None, args.expect_response, [], [])

	def get_moving_average(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-moving-average')

		args = parser.parse_args(argv)

		device_call(ctx, LoadCellV2Bricklet, 6, (), '', 'H', args.execute, False, ['average'], [None])

	def set_info_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-info-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'info-led-config-off': 0, 'info-led-config-on': 1, 'info-led-config-show-heartbeat': 2}), help='int (info-led-config-off: 0, info-led-config-on: 1, info-led-config-show-heartbeat: 2)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, LoadCellV2Bricklet, 7, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_info_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-info-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, LoadCellV2Bricklet, 8, (), '', 'B', args.execute, False, ['config'], [{0: 'info-led-config-off', 1: 'info-led-config-on', 2: 'info-led-config-show-heartbeat'}])

	def calibrate(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' calibrate')

		parser.add_argument('weight', type=convert_int, help='int', metavar='<weight>')

		args = parser.parse_args(argv)

		device_call(ctx, LoadCellV2Bricklet, 9, (args.weight,), 'I', '', None, args.expect_response, [], [])

	def tare(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' tare')

		args = parser.parse_args(argv)

		device_call(ctx, LoadCellV2Bricklet, 10, (), '', '', None, args.expect_response, [], [])

	def set_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-configuration')

		parser.add_argument('rate', type=create_symbol_converter(ctx, convert_int, {'rate-80hz': 1, 'rate-10hz': 0}), help='int (rate-10hz: 0, rate-80hz: 1)', metavar='<rate>')
		parser.add_argument('gain', type=create_symbol_converter(ctx, convert_int, {'gain-64x': 1, 'gain-128x': 0, 'gain-32x': 2}), help='int (gain-128x: 0, gain-64x: 1, gain-32x: 2)', metavar='<gain>')

		args = parser.parse_args(argv)

		device_call(ctx, LoadCellV2Bricklet, 11, (args.rate, args.gain), 'B B', '', None, args.expect_response, [], [])

	def get_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, LoadCellV2Bricklet, 12, (), '', 'B B', args.execute, False, ['rate', 'gain'], [{0: 'rate-10hz', 1: 'rate-80hz'}, {0: 'gain-128x', 1: 'gain-64x', 2: 'gain-32x'}])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, LoadCellV2Bricklet, 234, (), '', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def set_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-bootloader-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'bootloader-mode-firmware-wait-for-reboot': 3, 'bootloader-mode-firmware': 1, 'bootloader-mode-firmware-wait-for-erase-and-reboot': 4, 'bootloader-mode-bootloader-wait-for-reboot': 2, 'bootloader-mode-bootloader': 0}), help='int (bootloader-mode-bootloader: 0, bootloader-mode-firmware: 1, bootloader-mode-bootloader-wait-for-reboot: 2, bootloader-mode-firmware-wait-for-reboot: 3, bootloader-mode-firmware-wait-for-erase-and-reboot: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, LoadCellV2Bricklet, 235, (args.mode,), 'B', 'B', args.execute, False, ['status'], [{0: 'bootloader-status-ok', 1: 'bootloader-status-invalid-mode', 2: 'bootloader-status-no-change', 3: 'bootloader-status-entry-function-not-present', 4: 'bootloader-status-device-identifier-incorrect', 5: 'bootloader-status-crc-mismatch'}])

	def get_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-bootloader-mode')

		args = parser.parse_args(argv)

		device_call(ctx, LoadCellV2Bricklet, 236, (), '', 'B', args.execute, False, ['mode'], [{0: 'bootloader-mode-bootloader', 1: 'bootloader-mode-firmware', 2: 'bootloader-mode-bootloader-wait-for-reboot', 3: 'bootloader-mode-firmware-wait-for-reboot', 4: 'bootloader-mode-firmware-wait-for-erase-and-reboot'}])

	def set_write_firmware_pointer(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-write-firmware-pointer')

		parser.add_argument('pointer', type=convert_int, help='int', metavar='<pointer>')

		args = parser.parse_args(argv)

		device_call(ctx, LoadCellV2Bricklet, 237, (args.pointer,), 'I', '', None, args.expect_response, [], [])

	def write_firmware(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-firmware')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, LoadCellV2Bricklet, 238, (args.data,), '64B', 'B', args.execute, False, ['status'], [None])

	def set_status_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'status-led-config-on': 1, 'status-led-config-show-heartbeat': 2, 'status-led-config-off': 0, 'status-led-config-show-status': 3}), help='int (status-led-config-off: 0, status-led-config-on: 1, status-led-config-show-heartbeat: 2, status-led-config-show-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, LoadCellV2Bricklet, 239, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_status_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, LoadCellV2Bricklet, 240, (), '', 'B', args.execute, False, ['config'], [{0: 'status-led-config-off', 1: 'status-led-config-on', 2: 'status-led-config-show-heartbeat', 3: 'status-led-config-show-status'}])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, LoadCellV2Bricklet, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, LoadCellV2Bricklet, 243, (), '', '', None, args.expect_response, [], [])

	def write_uid(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-uid')

		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')

		args = parser.parse_args(argv)

		device_call(ctx, LoadCellV2Bricklet, 248, (args.uid,), 'I', '', None, args.expect_response, [], [])

	def read_uid(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-uid')

		args = parser.parse_args(argv)

		device_call(ctx, LoadCellV2Bricklet, 249, (), '', 'I', args.execute, False, ['uid'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, LoadCellV2Bricklet, argv)

	functions = {
	'get-weight': get_weight,
	'set-weight-callback-configuration': set_weight_callback_configuration,
	'get-weight-callback-configuration': get_weight_callback_configuration,
	'set-moving-average': set_moving_average,
	'get-moving-average': get_moving_average,
	'set-info-led-config': set_info_led_config,
	'get-info-led-config': get_info_led_config,
	'calibrate': calibrate,
	'tare': tare,
	'set-configuration': set_configuration,
	'get-configuration': get_configuration,
	'get-spitfp-error-count': get_spitfp_error_count,
	'set-bootloader-mode': set_bootloader_mode,
	'get-bootloader-mode': get_bootloader_mode,
	'set-write-firmware-pointer': set_write_firmware_pointer,
	'write-firmware': write_firmware,
	'set-status-led-config': set_status_led_config,
	'get-status-led-config': get_status_led_config,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'write-uid': write_uid,
	'read-uid': read_uid,
	'get-identity': get_identity
	}

	call_generic(ctx, 'load-cell-v2-bricklet', functions, argv)

def dispatch_load_cell_v2_bricklet(ctx, argv):
	prog_prefix = 'dispatch load-cell-v2-bricklet <uid>'

	def weight(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' weight')

		args = parser.parse_args(argv)

		device_dispatch(ctx, LoadCellV2Bricklet, 4, args.execute, ['weight'], [None])

	callbacks = {
	'weight': weight
	}

	dispatch_generic(ctx, 'load-cell-v2-bricklet', callbacks, argv)

class MasterBrick(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 1; re[3] = 3; re[4] = 1; re[5] = 1; re[6] = 3; re[7] = 1; re[8] = 3; re[9] = 1; re[10] = 3; re[11] = 1; re[12] = 1; re[13] = 1; re[14] = 3; re[15] = 1; re[16] = 3; re[17] = 1; re[18] = 1; re[19] = 3; re[20] = 1; re[21] = 3; re[22] = 1; re[23] = 1; re[24] = 3; re[25] = 1; re[26] = 1; re[27] = 3; re[28] = 1; re[29] = 3; re[30] = 1; re[31] = 1; re[32] = 3; re[33] = 3; re[34] = 1; re[35] = 3; re[36] = 1; re[37] = 1; re[38] = 3; re[39] = 1; re[40] = 1; re[41] = 3; re[42] = 1; re[43] = 3; re[44] = 1; re[45] = 2; re[46] = 1; re[47] = 2; re[48] = 1; re[49] = 2; re[50] = 1; re[51] = 2; re[52] = 1; re[53] = 2; re[54] = 1; re[55] = 2; re[56] = 1; re[57] = 2; re[58] = 1; re[65] = 1; re[66] = 3; re[67] = 1; re[68] = 1; re[69] = 3; re[70] = 3; re[71] = 3; re[72] = 1; re[73] = 3; re[74] = 1; re[75] = 3; re[76] = 1; re[77] = 1; re[78] = 1; re[79] = 1; re[80] = 1; re[81] = 1; re[82] = 3; re[83] = 1; re[84] = 3; re[85] = 1; re[86] = 1; re[87] = 3; re[88] = 1; re[89] = 3; re[90] = 1; re[91] = 3; re[92] = 1; re[93] = 3; re[94] = 1; re[95] = 3; re[96] = 1; re[97] = 1; re[98] = 1; re[99] = 3; re[100] = 3; re[101] = 1; re[102] = 3; re[103] = 1; re[104] = 3; re[105] = 1; re[106] = 3; re[107] = 1; re[108] = 1; re[109] = 1; re[110] = 1; re[231] = 3; re[232] = 1; re[233] = 1; re[234] = 3; re[235] = 1; re[237] = 1; re[238] = 3; re[239] = 3; re[240] = 1; re[241] = 1; re[242] = 1; re[243] = 3; re[255] = 1
		cf = self.callback_formats
		cf[59] = 'H'; cf[60] = 'H'; cf[61] = 'H'; cf[62] = 'H'; cf[63] = 'H'; cf[64] = 'H'


def call_master_brick(ctx, argv):
	prog_prefix = 'call master-brick <uid>'

	def get_stack_voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-stack-voltage')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 1, (), '', 'H', args.execute, False, ['voltage'], [None])

	def get_stack_current(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-stack-current')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 2, (), '', 'H', args.execute, False, ['current'], [None])

	def set_extension_type(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-extension-type')

		parser.add_argument('extension', type=convert_int, help='int', metavar='<extension>')
		parser.add_argument('exttype', type=create_symbol_converter(ctx, convert_int, {'extension-type-rs485': 2, 'extension-type-chibi': 1, 'extension-type-wifi2': 5, 'extension-type-wifi': 3, 'extension-type-ethernet': 4}), help='int (extension-type-chibi: 1, extension-type-rs485: 2, extension-type-wifi: 3, extension-type-ethernet: 4, extension-type-wifi2: 5)', metavar='<exttype>')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 3, (args.extension, args.exttype), 'B I', '', None, args.expect_response, [], [])

	def get_extension_type(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-extension-type')

		parser.add_argument('extension', type=convert_int, help='int', metavar='<extension>')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 4, (args.extension,), 'B', 'I', args.execute, False, ['exttype'], [{1: 'extension-type-chibi', 2: 'extension-type-rs485', 3: 'extension-type-wifi', 4: 'extension-type-ethernet', 5: 'extension-type-wifi2'}])

	def is_chibi_present(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' is-chibi-present')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 5, (), '', '!', args.execute, False, ['present'], [None])

	def set_chibi_address(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-chibi-address')

		parser.add_argument('address', type=convert_int, help='int', metavar='<address>')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 6, (args.address,), 'B', '', None, args.expect_response, [], [])

	def get_chibi_address(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chibi-address')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 7, (), '', 'B', args.execute, False, ['address'], [None])

	def set_chibi_master_address(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-chibi-master-address')

		parser.add_argument('address', type=convert_int, help='int', metavar='<address>')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 8, (args.address,), 'B', '', None, args.expect_response, [], [])

	def get_chibi_master_address(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chibi-master-address')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 9, (), '', 'B', args.execute, False, ['address'], [None])

	def set_chibi_slave_address(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-chibi-slave-address')

		parser.add_argument('num', type=convert_int, help='int', metavar='<num>')
		parser.add_argument('address', type=convert_int, help='int', metavar='<address>')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 10, (args.num, args.address), 'B B', '', None, args.expect_response, [], [])

	def get_chibi_slave_address(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chibi-slave-address')

		parser.add_argument('num', type=convert_int, help='int', metavar='<num>')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 11, (args.num,), 'B', 'B', args.execute, False, ['address'], [None])

	def get_chibi_signal_strength(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chibi-signal-strength')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 12, (), '', 'B', args.execute, False, ['signal-strength'], [None])

	def get_chibi_error_log(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chibi-error-log')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 13, (), '', 'H H H H', args.execute, False, ['underrun', 'crc-error', 'no-ack', 'overflow'], [None, None, None, None])

	def set_chibi_frequency(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-chibi-frequency')

		parser.add_argument('frequency', type=create_symbol_converter(ctx, convert_int, {'chibi-frequency-oqpsk-915-mhz': 1, 'chibi-frequency-oqpsk-868-mhz': 0, 'chibi-frequency-bpsk40-915-mhz': 3, 'chibi-frequency-oqpsk-780-mhz': 2}), help='int (chibi-frequency-oqpsk-868-mhz: 0, chibi-frequency-oqpsk-915-mhz: 1, chibi-frequency-oqpsk-780-mhz: 2, chibi-frequency-bpsk40-915-mhz: 3)', metavar='<frequency>')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 14, (args.frequency,), 'B', '', None, args.expect_response, [], [])

	def get_chibi_frequency(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chibi-frequency')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 15, (), '', 'B', args.execute, False, ['frequency'], [{0: 'chibi-frequency-oqpsk-868-mhz', 1: 'chibi-frequency-oqpsk-915-mhz', 2: 'chibi-frequency-oqpsk-780-mhz', 3: 'chibi-frequency-bpsk40-915-mhz'}])

	def set_chibi_channel(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-chibi-channel')

		parser.add_argument('channel', type=convert_int, help='int', metavar='<channel>')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 16, (args.channel,), 'B', '', None, args.expect_response, [], [])

	def get_chibi_channel(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chibi-channel')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 17, (), '', 'B', args.execute, False, ['channel'], [None])

	def is_rs485_present(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' is-rs485-present')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 18, (), '', '!', args.execute, False, ['present'], [None])

	def set_rs485_address(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-rs485-address')

		parser.add_argument('address', type=convert_int, help='int', metavar='<address>')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 19, (args.address,), 'B', '', None, args.expect_response, [], [])

	def get_rs485_address(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-rs485-address')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 20, (), '', 'B', args.execute, False, ['address'], [None])

	def set_rs485_slave_address(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-rs485-slave-address')

		parser.add_argument('num', type=convert_int, help='int', metavar='<num>')
		parser.add_argument('address', type=convert_int, help='int', metavar='<address>')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 21, (args.num, args.address), 'B B', '', None, args.expect_response, [], [])

	def get_rs485_slave_address(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-rs485-slave-address')

		parser.add_argument('num', type=convert_int, help='int', metavar='<num>')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 22, (args.num,), 'B', 'B', args.execute, False, ['address'], [None])

	def get_rs485_error_log(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-rs485-error-log')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 23, (), '', 'H', args.execute, False, ['crc-error'], [None])

	def set_rs485_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-rs485-configuration')

		parser.add_argument('speed', type=convert_int, help='int', metavar='<speed>')
		parser.add_argument('parity', type=create_symbol_converter(ctx, create_char_converter(ctx), {'rs485-parity-odd': 'o', 'rs485-parity-even': 'e', 'rs485-parity-none': 'n'}), help='char (rs485-parity-none: n, rs485-parity-even: e, rs485-parity-odd: o)', metavar='<parity>')
		parser.add_argument('stopbits', type=convert_int, help='int', metavar='<stopbits>')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 24, (args.speed, args.parity, args.stopbits), 'I c B', '', None, args.expect_response, [], [])

	def get_rs485_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-rs485-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 25, (), '', 'I c B', args.execute, False, ['speed', 'parity', 'stopbits'], [None, {'e': 'rs485-parity-even', 'o': 'rs485-parity-odd', 'n': 'rs485-parity-none'}, None])

	def is_wifi_present(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' is-wifi-present')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 26, (), '', '!', args.execute, False, ['present'], [None])

	def set_wifi_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-wifi-configuration')

		parser.add_argument('ssid', type=create_string_converter(ctx, str, 32), help='string', metavar='<ssid>')
		parser.add_argument('connection', type=create_symbol_converter(ctx, convert_int, {'wifi-connection-access-point-static-ip': 3, 'wifi-connection-ad-hoc-static-ip': 5, 'wifi-connection-static-ip': 1, 'wifi-connection-dhcp': 0, 'wifi-connection-access-point-dhcp': 2, 'wifi-connection-ad-hoc-dhcp': 4}), help='int (wifi-connection-dhcp: 0, wifi-connection-static-ip: 1, wifi-connection-access-point-dhcp: 2, wifi-connection-access-point-static-ip: 3, wifi-connection-ad-hoc-dhcp: 4, wifi-connection-ad-hoc-static-ip: 5)', metavar='<connection>')
		parser.add_argument('ip', type=create_array_converter(ctx, convert_int, '0', 4), help=get_array_type_name(ctx, 'int', 4), metavar='<ip>')
		parser.add_argument('subnet_mask', type=create_array_converter(ctx, convert_int, '0', 4), help=get_array_type_name(ctx, 'int', 4), metavar='<subnet-mask>')
		parser.add_argument('gateway', type=create_array_converter(ctx, convert_int, '0', 4), help=get_array_type_name(ctx, 'int', 4), metavar='<gateway>')
		parser.add_argument('port', type=convert_int, help='int', metavar='<port>')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 27, (args.ssid, args.connection, args.ip, args.subnet_mask, args.gateway, args.port), '32s B 4B 4B 4B H', '', None, args.expect_response, [], [])

	def get_wifi_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-wifi-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 28, (), '', '32s B 4B 4B 4B H', args.execute, False, ['ssid', 'connection', 'ip', 'subnet-mask', 'gateway', 'port'], [None, {0: 'wifi-connection-dhcp', 1: 'wifi-connection-static-ip', 2: 'wifi-connection-access-point-dhcp', 3: 'wifi-connection-access-point-static-ip', 4: 'wifi-connection-ad-hoc-dhcp', 5: 'wifi-connection-ad-hoc-static-ip'}, None, None, None, None])

	def set_wifi_encryption(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-wifi-encryption')

		parser.add_argument('encryption', type=create_symbol_converter(ctx, convert_int, {'wifi-encryption-no-encryption': 3, 'wifi-encryption-wep': 2, 'wifi-encryption-wpa-enterprise': 1, 'wifi-encryption-wpa-wpa2': 0}), help='int (wifi-encryption-wpa-wpa2: 0, wifi-encryption-wpa-enterprise: 1, wifi-encryption-wep: 2, wifi-encryption-no-encryption: 3)', metavar='<encryption>')
		parser.add_argument('key', type=create_string_converter(ctx, str, 50), help='string', metavar='<key>')
		parser.add_argument('key_index', type=convert_int, help='int', metavar='<key-index>')
		parser.add_argument('eap_options', type=create_symbol_converter(ctx, convert_int, {'wifi-eap-option-outer-auth-eap-fast': 0, 'wifi-eap-option-outer-auth-eap-tls': 1, 'wifi-eap-option-outer-auth-eap-peap': 3, 'wifi-eap-option-inner-auth-eap-gtc': 4, 'wifi-eap-option-cert-type-client-cert': 8, 'wifi-eap-option-inner-auth-eap-mschap': 0, 'wifi-eap-option-cert-type-ca-cert': 0, 'wifi-eap-option-outer-auth-eap-ttls': 2, 'wifi-eap-option-cert-type-private-key': 16}), help='int (wifi-eap-option-outer-auth-eap-fast: 0, wifi-eap-option-outer-auth-eap-tls: 1, wifi-eap-option-outer-auth-eap-ttls: 2, wifi-eap-option-outer-auth-eap-peap: 3, wifi-eap-option-inner-auth-eap-mschap: 0, wifi-eap-option-inner-auth-eap-gtc: 4, wifi-eap-option-cert-type-ca-cert: 0, wifi-eap-option-cert-type-client-cert: 8, wifi-eap-option-cert-type-private-key: 16)', metavar='<eap-options>')
		parser.add_argument('ca_certificate_length', type=convert_int, help='int', metavar='<ca-certificate-length>')
		parser.add_argument('client_certificate_length', type=convert_int, help='int', metavar='<client-certificate-length>')
		parser.add_argument('private_key_length', type=convert_int, help='int', metavar='<private-key-length>')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 29, (args.encryption, args.key, args.key_index, args.eap_options, args.ca_certificate_length, args.client_certificate_length, args.private_key_length), 'B 50s B B H H H', '', None, args.expect_response, [], [])

	def get_wifi_encryption(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-wifi-encryption')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 30, (), '', 'B 50s B B H H H', args.execute, False, ['encryption', 'key', 'key-index', 'eap-options', 'ca-certificate-length', 'client-certificate-length', 'private-key-length'], [{0: 'wifi-encryption-wpa-wpa2', 1: 'wifi-encryption-wpa-enterprise', 2: 'wifi-encryption-wep', 3: 'wifi-encryption-no-encryption'}, None, None, {0: 'wifi-eap-option-cert-type-ca-cert', 1: 'wifi-eap-option-outer-auth-eap-tls', 2: 'wifi-eap-option-outer-auth-eap-ttls', 3: 'wifi-eap-option-outer-auth-eap-peap', 4: 'wifi-eap-option-inner-auth-eap-gtc', 8: 'wifi-eap-option-cert-type-client-cert', 16: 'wifi-eap-option-cert-type-private-key'}, None, None, None])

	def get_wifi_status(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-wifi-status')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 31, (), '', '6B 6B B h 4B 4B 4B I I B', args.execute, False, ['mac-address', 'bssid', 'channel', 'rssi', 'ip', 'subnet-mask', 'gateway', 'rx-count', 'tx-count', 'state'], [None, None, None, None, None, None, None, None, None, {0: 'wifi-state-disassociated', 1: 'wifi-state-associated', 2: 'wifi-state-associating', 3: 'wifi-state-error', 255: 'wifi-state-not-initialized-yet'}])

	def refresh_wifi_status(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' refresh-wifi-status')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 32, (), '', '', None, args.expect_response, [], [])

	def set_wifi_certificate(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-wifi-certificate')

		parser.add_argument('index', type=convert_int, help='int', metavar='<index>')
		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 32), help=get_array_type_name(ctx, 'int', 32), metavar='<data>')
		parser.add_argument('data_length', type=convert_int, help='int', metavar='<data-length>')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 33, (args.index, args.data, args.data_length), 'H 32B B', '', None, args.expect_response, [], [])

	def get_wifi_certificate(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-wifi-certificate')

		parser.add_argument('index', type=convert_int, help='int', metavar='<index>')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 34, (args.index,), 'H', '32B B', args.execute, False, ['data', 'data-length'], [None, None])

	def set_wifi_power_mode(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-wifi-power-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'wifi-power-mode-full-speed': 0, 'wifi-power-mode-low-power': 1}), help='int (wifi-power-mode-full-speed: 0, wifi-power-mode-low-power: 1)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 35, (args.mode,), 'B', '', None, args.expect_response, [], [])

	def get_wifi_power_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-wifi-power-mode')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 36, (), '', 'B', args.execute, False, ['mode'], [{0: 'wifi-power-mode-full-speed', 1: 'wifi-power-mode-low-power'}])

	def get_wifi_buffer_info(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-wifi-buffer-info')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 37, (), '', 'I H H', args.execute, False, ['overflow', 'low-watermark', 'used'], [None, None, None])

	def set_wifi_regulatory_domain(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-wifi-regulatory-domain')

		parser.add_argument('domain', type=create_symbol_converter(ctx, convert_int, {'wifi-domain-channel-1to14': 2, 'wifi-domain-channel-1to11': 0, 'wifi-domain-channel-1to13': 1}), help='int (wifi-domain-channel-1to11: 0, wifi-domain-channel-1to13: 1, wifi-domain-channel-1to14: 2)', metavar='<domain>')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 38, (args.domain,), 'B', '', None, args.expect_response, [], [])

	def get_wifi_regulatory_domain(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-wifi-regulatory-domain')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 39, (), '', 'B', args.execute, False, ['domain'], [{0: 'wifi-domain-channel-1to11', 1: 'wifi-domain-channel-1to13', 2: 'wifi-domain-channel-1to14'}])

	def get_usb_voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-usb-voltage')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 40, (), '', 'H', args.execute, False, ['voltage'], [None])

	def set_long_wifi_key(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-long-wifi-key')

		parser.add_argument('key', type=create_string_converter(ctx, str, 64), help='string', metavar='<key>')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 41, (args.key,), '64s', '', None, args.expect_response, [], [])

	def get_long_wifi_key(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-long-wifi-key')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 42, (), '', '64s', args.execute, False, ['key'], [None])

	def set_wifi_hostname(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-wifi-hostname')

		parser.add_argument('hostname', type=create_string_converter(ctx, str, 16), help='string', metavar='<hostname>')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 43, (args.hostname,), '16s', '', None, args.expect_response, [], [])

	def get_wifi_hostname(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-wifi-hostname')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 44, (), '', '16s', args.execute, False, ['hostname'], [None])

	def set_stack_current_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-stack-current-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 45, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_stack_current_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-stack-current-callback-period')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 46, (), '', 'I', args.execute, False, ['period'], [None])

	def set_stack_voltage_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-stack-voltage-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 47, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_stack_voltage_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-stack-voltage-callback-period')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 48, (), '', 'I', args.execute, False, ['period'], [None])

	def set_usb_voltage_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-usb-voltage-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 49, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_usb_voltage_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-usb-voltage-callback-period')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 50, (), '', 'I', args.execute, False, ['period'], [None])

	def set_stack_current_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-stack-current-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 51, (args.option, args.min, args.max), 'c H H', '', None, args.expect_response, [], [])

	def get_stack_current_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-stack-current-callback-threshold')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 52, (), '', 'c H H', args.execute, False, ['option', 'min', 'max'], [{'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def set_stack_voltage_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-stack-voltage-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 53, (args.option, args.min, args.max), 'c H H', '', None, args.expect_response, [], [])

	def get_stack_voltage_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-stack-voltage-callback-threshold')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 54, (), '', 'c H H', args.execute, False, ['option', 'min', 'max'], [{'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def set_usb_voltage_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-usb-voltage-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 55, (args.option, args.min, args.max), 'c H H', '', None, args.expect_response, [], [])

	def get_usb_voltage_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-usb-voltage-callback-threshold')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 56, (), '', 'c H H', args.execute, False, ['option', 'min', 'max'], [{'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def set_debounce_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-debounce-period')

		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 57, (args.debounce,), 'I', '', None, args.expect_response, [], [])

	def get_debounce_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-debounce-period')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 58, (), '', 'I', args.execute, False, ['debounce'], [None])

	def is_ethernet_present(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' is-ethernet-present')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 65, (), '', '!', args.execute, False, ['present'], [None])

	def set_ethernet_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-ethernet-configuration')

		parser.add_argument('connection', type=create_symbol_converter(ctx, convert_int, {'ethernet-connection-static-ip': 1, 'ethernet-connection-dhcp': 0}), help='int (ethernet-connection-dhcp: 0, ethernet-connection-static-ip: 1)', metavar='<connection>')
		parser.add_argument('ip', type=create_array_converter(ctx, convert_int, '0', 4), help=get_array_type_name(ctx, 'int', 4), metavar='<ip>')
		parser.add_argument('subnet_mask', type=create_array_converter(ctx, convert_int, '0', 4), help=get_array_type_name(ctx, 'int', 4), metavar='<subnet-mask>')
		parser.add_argument('gateway', type=create_array_converter(ctx, convert_int, '0', 4), help=get_array_type_name(ctx, 'int', 4), metavar='<gateway>')
		parser.add_argument('port', type=convert_int, help='int', metavar='<port>')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 66, (args.connection, args.ip, args.subnet_mask, args.gateway, args.port), 'B 4B 4B 4B H', '', None, args.expect_response, [], [])

	def get_ethernet_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-ethernet-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 67, (), '', 'B 4B 4B 4B H', args.execute, False, ['connection', 'ip', 'subnet-mask', 'gateway', 'port'], [{0: 'ethernet-connection-dhcp', 1: 'ethernet-connection-static-ip'}, None, None, None, None])

	def get_ethernet_status(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-ethernet-status')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 68, (), '', '6B 4B 4B 4B I I 32s', args.execute, False, ['mac-address', 'ip', 'subnet-mask', 'gateway', 'rx-count', 'tx-count', 'hostname'], [None, None, None, None, None, None, None])

	def set_ethernet_hostname(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-ethernet-hostname')

		parser.add_argument('hostname', type=create_string_converter(ctx, str, 32), help='string', metavar='<hostname>')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 69, (args.hostname,), '32s', '', None, args.expect_response, [], [])

	def set_ethernet_mac_address(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-ethernet-mac-address')

		parser.add_argument('mac_address', type=create_array_converter(ctx, convert_int, '0', 6), help=get_array_type_name(ctx, 'int', 6), metavar='<mac-address>')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 70, (args.mac_address,), '6B', '', None, args.expect_response, [], [])

	def set_ethernet_websocket_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-ethernet-websocket-configuration')

		parser.add_argument('sockets', type=convert_int, help='int', metavar='<sockets>')
		parser.add_argument('port', type=convert_int, help='int', metavar='<port>')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 71, (args.sockets, args.port), 'B H', '', None, args.expect_response, [], [])

	def get_ethernet_websocket_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-ethernet-websocket-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 72, (), '', 'B H', args.execute, False, ['sockets', 'port'], [None, None])

	def set_ethernet_authentication_secret(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-ethernet-authentication-secret')

		parser.add_argument('secret', type=create_string_converter(ctx, str, 64), help='string', metavar='<secret>')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 73, (args.secret,), '64s', '', None, args.expect_response, [], [])

	def get_ethernet_authentication_secret(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-ethernet-authentication-secret')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 74, (), '', '64s', args.execute, False, ['secret'], [None])

	def set_wifi_authentication_secret(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-wifi-authentication-secret')

		parser.add_argument('secret', type=create_string_converter(ctx, str, 64), help='string', metavar='<secret>')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 75, (args.secret,), '64s', '', None, args.expect_response, [], [])

	def get_wifi_authentication_secret(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-wifi-authentication-secret')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 76, (), '', '64s', args.execute, False, ['secret'], [None])

	def get_connection_type(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-connection-type')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 77, (), '', 'B', args.execute, False, ['connection-type'], [{0: 'connection-type-none', 1: 'connection-type-usb', 2: 'connection-type-spi-stack', 3: 'connection-type-chibi', 4: 'connection-type-rs485', 5: 'connection-type-wifi', 6: 'connection-type-ethernet', 7: 'connection-type-wifi2'}])

	def is_wifi2_present(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' is-wifi2-present')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 78, (), '', '!', args.execute, False, ['present'], [None])

	def start_wifi2_bootloader(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' start-wifi2-bootloader')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 79, (), '', 'b', args.execute, False, ['result'], [None])

	def write_wifi2_serial_port(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-wifi2-serial-port')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 60), help=get_array_type_name(ctx, 'int', 60), metavar='<data>')
		parser.add_argument('length', type=convert_int, help='int', metavar='<length>')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 80, (args.data, args.length), '60B B', 'b', args.execute, False, ['result'], [None])

	def read_wifi2_serial_port(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-wifi2-serial-port')

		parser.add_argument('length', type=convert_int, help='int', metavar='<length>')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 81, (args.length,), 'B', '60B B', args.execute, False, ['data', 'result'], [None, None])

	def set_wifi2_authentication_secret(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-wifi2-authentication-secret')

		parser.add_argument('secret', type=create_string_converter(ctx, str, 64), help='string', metavar='<secret>')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 82, (args.secret,), '64s', '', None, args.expect_response, [], [])

	def get_wifi2_authentication_secret(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-wifi2-authentication-secret')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 83, (), '', '64s', args.execute, False, ['secret'], [None])

	def set_wifi2_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-wifi2-configuration')

		parser.add_argument('port', type=convert_int, help='int', metavar='<port>')
		parser.add_argument('websocket_port', type=convert_int, help='int', metavar='<websocket-port>')
		parser.add_argument('website_port', type=convert_int, help='int', metavar='<website-port>')
		parser.add_argument('phy_mode', type=create_symbol_converter(ctx, convert_int, {'wifi2-phy-mode-n': 2, 'wifi2-phy-mode-g': 1, 'wifi2-phy-mode-b': 0}), help='int (wifi2-phy-mode-b: 0, wifi2-phy-mode-g: 1, wifi2-phy-mode-n: 2)', metavar='<phy-mode>')
		parser.add_argument('sleep_mode', type=convert_int, help='int', metavar='<sleep-mode>')
		parser.add_argument('website', type=convert_int, help='int', metavar='<website>')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 84, (args.port, args.websocket_port, args.website_port, args.phy_mode, args.sleep_mode, args.website), 'H H H B B B', '', None, args.expect_response, [], [])

	def get_wifi2_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-wifi2-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 85, (), '', 'H H H B B B', args.execute, False, ['port', 'websocket-port', 'website-port', 'phy-mode', 'sleep-mode', 'website'], [None, None, None, {0: 'wifi2-phy-mode-b', 1: 'wifi2-phy-mode-g', 2: 'wifi2-phy-mode-n'}, None, None])

	def get_wifi2_status(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-wifi2-status')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 86, (), '', '! B 4B 4B 4B 6B I I b ! 4B 4B 4B 6B I I B', args.execute, False, ['client-enabled', 'client-status', 'client-ip', 'client-subnet-mask', 'client-gateway', 'client-mac-address', 'client-rx-count', 'client-tx-count', 'client-rssi', 'ap-enabled', 'ap-ip', 'ap-subnet-mask', 'ap-gateway', 'ap-mac-address', 'ap-rx-count', 'ap-tx-count', 'ap-connected-count'], [None, {0: 'wifi2-client-status-idle', 1: 'wifi2-client-status-connecting', 2: 'wifi2-client-status-wrong-password', 3: 'wifi2-client-status-no-ap-found', 4: 'wifi2-client-status-connect-failed', 5: 'wifi2-client-status-got-ip', 255: 'wifi2-client-status-unknown'}, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None])

	def set_wifi2_client_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-wifi2-client-configuration')

		parser.add_argument('enable', type=convert_bool, help='bool', metavar='<enable>')
		parser.add_argument('ssid', type=create_string_converter(ctx, str, 32), help='string', metavar='<ssid>')
		parser.add_argument('ip', type=create_array_converter(ctx, convert_int, '0', 4), help=get_array_type_name(ctx, 'int', 4), metavar='<ip>')
		parser.add_argument('subnet_mask', type=create_array_converter(ctx, convert_int, '0', 4), help=get_array_type_name(ctx, 'int', 4), metavar='<subnet-mask>')
		parser.add_argument('gateway', type=create_array_converter(ctx, convert_int, '0', 4), help=get_array_type_name(ctx, 'int', 4), metavar='<gateway>')
		parser.add_argument('mac_address', type=create_array_converter(ctx, convert_int, '0', 6), help=get_array_type_name(ctx, 'int', 6), metavar='<mac-address>')
		parser.add_argument('bssid', type=create_array_converter(ctx, convert_int, '0', 6), help=get_array_type_name(ctx, 'int', 6), metavar='<bssid>')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 87, (args.enable, args.ssid, args.ip, args.subnet_mask, args.gateway, args.mac_address, args.bssid), '! 32s 4B 4B 4B 6B 6B', '', None, args.expect_response, [], [])

	def get_wifi2_client_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-wifi2-client-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 88, (), '', '! 32s 4B 4B 4B 6B 6B', args.execute, False, ['enable', 'ssid', 'ip', 'subnet-mask', 'gateway', 'mac-address', 'bssid'], [None, None, None, None, None, None, None])

	def set_wifi2_client_hostname(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-wifi2-client-hostname')

		parser.add_argument('hostname', type=create_string_converter(ctx, str, 32), help='string', metavar='<hostname>')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 89, (args.hostname,), '32s', '', None, args.expect_response, [], [])

	def get_wifi2_client_hostname(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-wifi2-client-hostname')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 90, (), '', '32s', args.execute, False, ['hostname'], [None])

	def set_wifi2_client_password(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-wifi2-client-password')

		parser.add_argument('password', type=create_string_converter(ctx, str, 64), help='string', metavar='<password>')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 91, (args.password,), '64s', '', None, args.expect_response, [], [])

	def get_wifi2_client_password(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-wifi2-client-password')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 92, (), '', '64s', args.execute, False, ['password'], [None])

	def set_wifi2_ap_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-wifi2-ap-configuration')

		parser.add_argument('enable', type=convert_bool, help='bool', metavar='<enable>')
		parser.add_argument('ssid', type=create_string_converter(ctx, str, 32), help='string', metavar='<ssid>')
		parser.add_argument('ip', type=create_array_converter(ctx, convert_int, '0', 4), help=get_array_type_name(ctx, 'int', 4), metavar='<ip>')
		parser.add_argument('subnet_mask', type=create_array_converter(ctx, convert_int, '0', 4), help=get_array_type_name(ctx, 'int', 4), metavar='<subnet-mask>')
		parser.add_argument('gateway', type=create_array_converter(ctx, convert_int, '0', 4), help=get_array_type_name(ctx, 'int', 4), metavar='<gateway>')
		parser.add_argument('encryption', type=create_symbol_converter(ctx, convert_int, {'wifi2-ap-encryption-open': 0, 'wifi2-ap-encryption-wpa-psk': 2, 'wifi2-ap-encryption-wpa2-psk': 3, 'wifi2-ap-encryption-wpa-wpa2-psk': 4, 'wifi2-ap-encryption-wep': 1}), help='int (wifi2-ap-encryption-open: 0, wifi2-ap-encryption-wep: 1, wifi2-ap-encryption-wpa-psk: 2, wifi2-ap-encryption-wpa2-psk: 3, wifi2-ap-encryption-wpa-wpa2-psk: 4)', metavar='<encryption>')
		parser.add_argument('hidden', type=convert_bool, help='bool', metavar='<hidden>')
		parser.add_argument('channel', type=convert_int, help='int', metavar='<channel>')
		parser.add_argument('mac_address', type=create_array_converter(ctx, convert_int, '0', 6), help=get_array_type_name(ctx, 'int', 6), metavar='<mac-address>')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 93, (args.enable, args.ssid, args.ip, args.subnet_mask, args.gateway, args.encryption, args.hidden, args.channel, args.mac_address), '! 32s 4B 4B 4B B ! B 6B', '', None, args.expect_response, [], [])

	def get_wifi2_ap_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-wifi2-ap-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 94, (), '', '! 32s 4B 4B 4B B ! B 6B', args.execute, False, ['enable', 'ssid', 'ip', 'subnet-mask', 'gateway', 'encryption', 'hidden', 'channel', 'mac-address'], [None, None, None, None, None, {0: 'wifi2-ap-encryption-open', 1: 'wifi2-ap-encryption-wep', 2: 'wifi2-ap-encryption-wpa-psk', 3: 'wifi2-ap-encryption-wpa2-psk', 4: 'wifi2-ap-encryption-wpa-wpa2-psk'}, None, None, None])

	def set_wifi2_ap_password(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-wifi2-ap-password')

		parser.add_argument('password', type=create_string_converter(ctx, str, 64), help='string', metavar='<password>')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 95, (args.password,), '64s', '', None, args.expect_response, [], [])

	def get_wifi2_ap_password(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-wifi2-ap-password')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 96, (), '', '64s', args.execute, False, ['password'], [None])

	def save_wifi2_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' save-wifi2-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 97, (), '', 'B', args.execute, False, ['result'], [None])

	def get_wifi2_firmware_version(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-wifi2-firmware-version')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 98, (), '', '3B', args.execute, False, ['firmware-version'], [None])

	def enable_wifi2_status_led(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' enable-wifi2-status-led')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 99, (), '', '', None, args.expect_response, [], [])

	def disable_wifi2_status_led(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' disable-wifi2-status-led')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 100, (), '', '', None, args.expect_response, [], [])

	def is_wifi2_status_led_enabled(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' is-wifi2-status-led-enabled')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 101, (), '', '!', args.execute, False, ['enabled'], [None])

	def set_wifi2_mesh_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-wifi2-mesh-configuration')

		parser.add_argument('enable', type=convert_bool, help='bool', metavar='<enable>')
		parser.add_argument('root_ip', type=create_array_converter(ctx, convert_int, '0', 4), help=get_array_type_name(ctx, 'int', 4), metavar='<root-ip>')
		parser.add_argument('root_subnet_mask', type=create_array_converter(ctx, convert_int, '0', 4), help=get_array_type_name(ctx, 'int', 4), metavar='<root-subnet-mask>')
		parser.add_argument('root_gateway', type=create_array_converter(ctx, convert_int, '0', 4), help=get_array_type_name(ctx, 'int', 4), metavar='<root-gateway>')
		parser.add_argument('router_bssid', type=create_array_converter(ctx, convert_int, '0', 6), help=get_array_type_name(ctx, 'int', 6), metavar='<router-bssid>')
		parser.add_argument('group_id', type=create_array_converter(ctx, convert_int, '0', 6), help=get_array_type_name(ctx, 'int', 6), metavar='<group-id>')
		parser.add_argument('group_ssid_prefix', type=create_string_converter(ctx, str, 16), help='string', metavar='<group-ssid-prefix>')
		parser.add_argument('gateway_ip', type=create_array_converter(ctx, convert_int, '0', 4), help=get_array_type_name(ctx, 'int', 4), metavar='<gateway-ip>')
		parser.add_argument('gateway_port', type=convert_int, help='int', metavar='<gateway-port>')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 102, (args.enable, args.root_ip, args.root_subnet_mask, args.root_gateway, args.router_bssid, args.group_id, args.group_ssid_prefix, args.gateway_ip, args.gateway_port), '! 4B 4B 4B 6B 6B 16s 4B H', '', None, args.expect_response, [], [])

	def get_wifi2_mesh_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-wifi2-mesh-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 103, (), '', '! 4B 4B 4B 6B 6B 16s 4B H', args.execute, False, ['enable', 'root-ip', 'root-subnet-mask', 'root-gateway', 'router-bssid', 'group-id', 'group-ssid-prefix', 'gateway-ip', 'gateway-port'], [None, None, None, None, None, None, None, None, None])

	def set_wifi2_mesh_router_ssid(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-wifi2-mesh-router-ssid')

		parser.add_argument('ssid', type=create_string_converter(ctx, str, 32), help='string', metavar='<ssid>')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 104, (args.ssid,), '32s', '', None, args.expect_response, [], [])

	def get_wifi2_mesh_router_ssid(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-wifi2-mesh-router-ssid')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 105, (), '', '32s', args.execute, False, ['ssid'], [None])

	def set_wifi2_mesh_router_password(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-wifi2-mesh-router-password')

		parser.add_argument('password', type=create_string_converter(ctx, str, 64), help='string', metavar='<password>')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 106, (args.password,), '64s', '', None, args.expect_response, [], [])

	def get_wifi2_mesh_router_password(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-wifi2-mesh-router-password')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 107, (), '', '64s', args.execute, False, ['password'], [None])

	def get_wifi2_mesh_common_status(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-wifi2-mesh-common-status')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 108, (), '', 'B ! ! H I I', args.execute, False, ['status', 'root-node', 'root-candidate', 'connected-nodes', 'rx-count', 'tx-count'], [{0: 'wifi2-mesh-status-disabled', 1: 'wifi2-mesh-status-wifi-connecting', 2: 'wifi2-mesh-status-got-ip', 3: 'wifi2-mesh-status-mesh-local', 4: 'wifi2-mesh-status-mesh-online', 5: 'wifi2-mesh-status-ap-available', 6: 'wifi2-mesh-status-ap-setup', 7: 'wifi2-mesh-status-leaf-available'}, None, None, None, None, None])

	def get_wifi2_mesh_client_status(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-wifi2-mesh-client-status')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 109, (), '', '32s 4B 4B 4B 6B', args.execute, False, ['hostname', 'ip', 'subnet-mask', 'gateway', 'mac-address'], [None, None, None, None, None])

	def get_wifi2_mesh_ap_status(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-wifi2-mesh-ap-status')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 110, (), '', '32s 4B 4B 4B 6B', args.execute, False, ['ssid', 'ip', 'subnet-mask', 'gateway', 'mac-address'], [None, None, None, None, None])

	def set_spitfp_baudrate_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-spitfp-baudrate-config')

		parser.add_argument('enable_dynamic_baudrate', type=convert_bool, help='bool', metavar='<enable-dynamic-baudrate>')
		parser.add_argument('minimum_dynamic_baudrate', type=convert_int, help='int', metavar='<minimum-dynamic-baudrate>')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 231, (args.enable_dynamic_baudrate, args.minimum_dynamic_baudrate), '! I', '', None, args.expect_response, [], [])

	def get_spitfp_baudrate_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-baudrate-config')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 232, (), '', '! I', args.execute, False, ['enable-dynamic-baudrate', 'minimum-dynamic-baudrate'], [None, None])

	def get_send_timeout_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-send-timeout-count')

		parser.add_argument('communication_method', type=create_symbol_converter(ctx, convert_int, {'communication-method-none': 0, 'communication-method-rs485': 4, 'communication-method-usb': 1, 'communication-method-wifi-v2': 7, 'communication-method-spi-stack': 2, 'communication-method-wifi': 5, 'communication-method-chibi': 3, 'communication-method-ethernet': 6}), help='int (communication-method-none: 0, communication-method-usb: 1, communication-method-spi-stack: 2, communication-method-chibi: 3, communication-method-rs485: 4, communication-method-wifi: 5, communication-method-ethernet: 6, communication-method-wifi-v2: 7)', metavar='<communication-method>')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 233, (args.communication_method,), 'B', 'I', args.execute, False, ['timeout-count'], [None])

	def set_spitfp_baudrate(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-spitfp-baudrate')

		parser.add_argument('bricklet_port', type=create_char_converter(ctx), help='char', metavar='<bricklet-port>')
		parser.add_argument('baudrate', type=convert_int, help='int', metavar='<baudrate>')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 234, (args.bricklet_port, args.baudrate), 'c I', '', None, args.expect_response, [], [])

	def get_spitfp_baudrate(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-baudrate')

		parser.add_argument('bricklet_port', type=create_char_converter(ctx), help='char', metavar='<bricklet-port>')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 235, (args.bricklet_port,), 'c', 'I', args.execute, False, ['baudrate'], [None])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		parser.add_argument('bricklet_port', type=create_char_converter(ctx), help='char', metavar='<bricklet-port>')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 237, (args.bricklet_port,), 'c', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def enable_status_led(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' enable-status-led')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 238, (), '', '', None, args.expect_response, [], [])

	def disable_status_led(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' disable-status-led')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 239, (), '', '', None, args.expect_response, [], [])

	def is_status_led_enabled(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' is-status-led-enabled')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 240, (), '', '!', args.execute, False, ['enabled'], [None])

	def get_protocol1_bricklet_name(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-protocol1-bricklet-name')

		parser.add_argument('port', type=create_char_converter(ctx), help='char', metavar='<port>')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 241, (args.port,), 'c', 'B 3B 40s', args.execute, False, ['protocol-version', 'firmware-version', 'name'], [None, None, None])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, MasterBrick, 243, (), '', '', None, args.expect_response, [], [])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, MasterBrick, argv)

	functions = {
	'get-stack-voltage': get_stack_voltage,
	'get-stack-current': get_stack_current,
	'set-extension-type': set_extension_type,
	'get-extension-type': get_extension_type,
	'is-chibi-present': is_chibi_present,
	'set-chibi-address': set_chibi_address,
	'get-chibi-address': get_chibi_address,
	'set-chibi-master-address': set_chibi_master_address,
	'get-chibi-master-address': get_chibi_master_address,
	'set-chibi-slave-address': set_chibi_slave_address,
	'get-chibi-slave-address': get_chibi_slave_address,
	'get-chibi-signal-strength': get_chibi_signal_strength,
	'get-chibi-error-log': get_chibi_error_log,
	'set-chibi-frequency': set_chibi_frequency,
	'get-chibi-frequency': get_chibi_frequency,
	'set-chibi-channel': set_chibi_channel,
	'get-chibi-channel': get_chibi_channel,
	'is-rs485-present': is_rs485_present,
	'set-rs485-address': set_rs485_address,
	'get-rs485-address': get_rs485_address,
	'set-rs485-slave-address': set_rs485_slave_address,
	'get-rs485-slave-address': get_rs485_slave_address,
	'get-rs485-error-log': get_rs485_error_log,
	'set-rs485-configuration': set_rs485_configuration,
	'get-rs485-configuration': get_rs485_configuration,
	'is-wifi-present': is_wifi_present,
	'set-wifi-configuration': set_wifi_configuration,
	'get-wifi-configuration': get_wifi_configuration,
	'set-wifi-encryption': set_wifi_encryption,
	'get-wifi-encryption': get_wifi_encryption,
	'get-wifi-status': get_wifi_status,
	'refresh-wifi-status': refresh_wifi_status,
	'set-wifi-certificate': set_wifi_certificate,
	'get-wifi-certificate': get_wifi_certificate,
	'set-wifi-power-mode': set_wifi_power_mode,
	'get-wifi-power-mode': get_wifi_power_mode,
	'get-wifi-buffer-info': get_wifi_buffer_info,
	'set-wifi-regulatory-domain': set_wifi_regulatory_domain,
	'get-wifi-regulatory-domain': get_wifi_regulatory_domain,
	'get-usb-voltage': get_usb_voltage,
	'set-long-wifi-key': set_long_wifi_key,
	'get-long-wifi-key': get_long_wifi_key,
	'set-wifi-hostname': set_wifi_hostname,
	'get-wifi-hostname': get_wifi_hostname,
	'set-stack-current-callback-period': set_stack_current_callback_period,
	'get-stack-current-callback-period': get_stack_current_callback_period,
	'set-stack-voltage-callback-period': set_stack_voltage_callback_period,
	'get-stack-voltage-callback-period': get_stack_voltage_callback_period,
	'set-usb-voltage-callback-period': set_usb_voltage_callback_period,
	'get-usb-voltage-callback-period': get_usb_voltage_callback_period,
	'set-stack-current-callback-threshold': set_stack_current_callback_threshold,
	'get-stack-current-callback-threshold': get_stack_current_callback_threshold,
	'set-stack-voltage-callback-threshold': set_stack_voltage_callback_threshold,
	'get-stack-voltage-callback-threshold': get_stack_voltage_callback_threshold,
	'set-usb-voltage-callback-threshold': set_usb_voltage_callback_threshold,
	'get-usb-voltage-callback-threshold': get_usb_voltage_callback_threshold,
	'set-debounce-period': set_debounce_period,
	'get-debounce-period': get_debounce_period,
	'is-ethernet-present': is_ethernet_present,
	'set-ethernet-configuration': set_ethernet_configuration,
	'get-ethernet-configuration': get_ethernet_configuration,
	'get-ethernet-status': get_ethernet_status,
	'set-ethernet-hostname': set_ethernet_hostname,
	'set-ethernet-mac-address': set_ethernet_mac_address,
	'set-ethernet-websocket-configuration': set_ethernet_websocket_configuration,
	'get-ethernet-websocket-configuration': get_ethernet_websocket_configuration,
	'set-ethernet-authentication-secret': set_ethernet_authentication_secret,
	'get-ethernet-authentication-secret': get_ethernet_authentication_secret,
	'set-wifi-authentication-secret': set_wifi_authentication_secret,
	'get-wifi-authentication-secret': get_wifi_authentication_secret,
	'get-connection-type': get_connection_type,
	'is-wifi2-present': is_wifi2_present,
	'start-wifi2-bootloader': start_wifi2_bootloader,
	'write-wifi2-serial-port': write_wifi2_serial_port,
	'read-wifi2-serial-port': read_wifi2_serial_port,
	'set-wifi2-authentication-secret': set_wifi2_authentication_secret,
	'get-wifi2-authentication-secret': get_wifi2_authentication_secret,
	'set-wifi2-configuration': set_wifi2_configuration,
	'get-wifi2-configuration': get_wifi2_configuration,
	'get-wifi2-status': get_wifi2_status,
	'set-wifi2-client-configuration': set_wifi2_client_configuration,
	'get-wifi2-client-configuration': get_wifi2_client_configuration,
	'set-wifi2-client-hostname': set_wifi2_client_hostname,
	'get-wifi2-client-hostname': get_wifi2_client_hostname,
	'set-wifi2-client-password': set_wifi2_client_password,
	'get-wifi2-client-password': get_wifi2_client_password,
	'set-wifi2-ap-configuration': set_wifi2_ap_configuration,
	'get-wifi2-ap-configuration': get_wifi2_ap_configuration,
	'set-wifi2-ap-password': set_wifi2_ap_password,
	'get-wifi2-ap-password': get_wifi2_ap_password,
	'save-wifi2-configuration': save_wifi2_configuration,
	'get-wifi2-firmware-version': get_wifi2_firmware_version,
	'enable-wifi2-status-led': enable_wifi2_status_led,
	'disable-wifi2-status-led': disable_wifi2_status_led,
	'is-wifi2-status-led-enabled': is_wifi2_status_led_enabled,
	'set-wifi2-mesh-configuration': set_wifi2_mesh_configuration,
	'get-wifi2-mesh-configuration': get_wifi2_mesh_configuration,
	'set-wifi2-mesh-router-ssid': set_wifi2_mesh_router_ssid,
	'get-wifi2-mesh-router-ssid': get_wifi2_mesh_router_ssid,
	'set-wifi2-mesh-router-password': set_wifi2_mesh_router_password,
	'get-wifi2-mesh-router-password': get_wifi2_mesh_router_password,
	'get-wifi2-mesh-common-status': get_wifi2_mesh_common_status,
	'get-wifi2-mesh-client-status': get_wifi2_mesh_client_status,
	'get-wifi2-mesh-ap-status': get_wifi2_mesh_ap_status,
	'set-spitfp-baudrate-config': set_spitfp_baudrate_config,
	'get-spitfp-baudrate-config': get_spitfp_baudrate_config,
	'get-send-timeout-count': get_send_timeout_count,
	'set-spitfp-baudrate': set_spitfp_baudrate,
	'get-spitfp-baudrate': get_spitfp_baudrate,
	'get-spitfp-error-count': get_spitfp_error_count,
	'enable-status-led': enable_status_led,
	'disable-status-led': disable_status_led,
	'is-status-led-enabled': is_status_led_enabled,
	'get-protocol1-bricklet-name': get_protocol1_bricklet_name,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'get-identity': get_identity
	}

	call_generic(ctx, 'master-brick', functions, argv)

def dispatch_master_brick(ctx, argv):
	prog_prefix = 'dispatch master-brick <uid>'

	def stack_current(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' stack-current')

		args = parser.parse_args(argv)

		device_dispatch(ctx, MasterBrick, 59, args.execute, ['current'], [None])

	def stack_voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' stack-voltage')

		args = parser.parse_args(argv)

		device_dispatch(ctx, MasterBrick, 60, args.execute, ['voltage'], [None])

	def usb_voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' usb-voltage')

		args = parser.parse_args(argv)

		device_dispatch(ctx, MasterBrick, 61, args.execute, ['voltage'], [None])

	def stack_current_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' stack-current-reached')

		args = parser.parse_args(argv)

		device_dispatch(ctx, MasterBrick, 62, args.execute, ['current'], [None])

	def stack_voltage_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' stack-voltage-reached')

		args = parser.parse_args(argv)

		device_dispatch(ctx, MasterBrick, 63, args.execute, ['voltage'], [None])

	def usb_voltage_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' usb-voltage-reached')

		args = parser.parse_args(argv)

		device_dispatch(ctx, MasterBrick, 64, args.execute, ['voltage'], [None])

	callbacks = {
	'stack-current': stack_current,
	'stack-voltage': stack_voltage,
	'usb-voltage': usb_voltage,
	'stack-current-reached': stack_current_reached,
	'stack-voltage-reached': stack_voltage_reached,
	'usb-voltage-reached': usb_voltage_reached
	}

	dispatch_generic(ctx, 'master-brick', callbacks, argv)

class MoistureBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 2; re[3] = 1; re[4] = 2; re[5] = 1; re[6] = 2; re[7] = 1; re[10] = 3; re[11] = 1; re[255] = 1
		cf = self.callback_formats
		cf[8] = 'H'; cf[9] = 'H'


def call_moisture_bricklet(ctx, argv):
	prog_prefix = 'call moisture-bricklet <uid>'

	def get_moisture_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-moisture-value')

		args = parser.parse_args(argv)

		device_call(ctx, MoistureBricklet, 1, (), '', 'H', args.execute, False, ['moisture'], [None])

	def set_moisture_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-moisture-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, MoistureBricklet, 2, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_moisture_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-moisture-callback-period')

		args = parser.parse_args(argv)

		device_call(ctx, MoistureBricklet, 3, (), '', 'I', args.execute, False, ['period'], [None])

	def set_moisture_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-moisture-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, MoistureBricklet, 4, (args.option, args.min, args.max), 'c H H', '', None, args.expect_response, [], [])

	def get_moisture_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-moisture-callback-threshold')

		args = parser.parse_args(argv)

		device_call(ctx, MoistureBricklet, 5, (), '', 'c H H', args.execute, False, ['option', 'min', 'max'], [{'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def set_debounce_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-debounce-period')

		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_call(ctx, MoistureBricklet, 6, (args.debounce,), 'I', '', None, args.expect_response, [], [])

	def get_debounce_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-debounce-period')

		args = parser.parse_args(argv)

		device_call(ctx, MoistureBricklet, 7, (), '', 'I', args.execute, False, ['debounce'], [None])

	def set_moving_average(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-moving-average')

		parser.add_argument('average', type=convert_int, help='int', metavar='<average>')

		args = parser.parse_args(argv)

		device_call(ctx, MoistureBricklet, 10, (args.average,), 'B', '', None, args.expect_response, [], [])

	def get_moving_average(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-moving-average')

		args = parser.parse_args(argv)

		device_call(ctx, MoistureBricklet, 11, (), '', 'B', args.execute, False, ['average'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, MoistureBricklet, argv)

	functions = {
	'get-moisture-value': get_moisture_value,
	'set-moisture-callback-period': set_moisture_callback_period,
	'get-moisture-callback-period': get_moisture_callback_period,
	'set-moisture-callback-threshold': set_moisture_callback_threshold,
	'get-moisture-callback-threshold': get_moisture_callback_threshold,
	'set-debounce-period': set_debounce_period,
	'get-debounce-period': get_debounce_period,
	'set-moving-average': set_moving_average,
	'get-moving-average': get_moving_average,
	'get-identity': get_identity
	}

	call_generic(ctx, 'moisture-bricklet', functions, argv)

def dispatch_moisture_bricklet(ctx, argv):
	prog_prefix = 'dispatch moisture-bricklet <uid>'

	def moisture(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' moisture')

		args = parser.parse_args(argv)

		device_dispatch(ctx, MoistureBricklet, 8, args.execute, ['moisture'], [None])

	def moisture_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' moisture-reached')

		args = parser.parse_args(argv)

		device_dispatch(ctx, MoistureBricklet, 9, args.execute, ['moisture'], [None])

	callbacks = {
	'moisture': moisture,
	'moisture-reached': moisture_reached
	}

	dispatch_generic(ctx, 'moisture-bricklet', callbacks, argv)

class MotionDetectorBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[4] = 3; re[5] = 1; re[255] = 1
		cf = self.callback_formats
		cf[2] = ''; cf[3] = ''


def call_motion_detector_bricklet(ctx, argv):
	prog_prefix = 'call motion-detector-bricklet <uid>'

	def get_motion_detected(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-motion-detected')

		args = parser.parse_args(argv)

		device_call(ctx, MotionDetectorBricklet, 1, (), '', 'B', args.execute, False, ['motion'], [{0: 'motion-not-detected', 1: 'motion-detected'}])

	def set_status_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'status-led-config-on': 1, 'status-led-config-off': 0, 'status-led-config-show-status': 2}), help='int (status-led-config-off: 0, status-led-config-on: 1, status-led-config-show-status: 2)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, MotionDetectorBricklet, 4, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_status_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, MotionDetectorBricklet, 5, (), '', 'B', args.execute, False, ['config'], [{0: 'status-led-config-off', 1: 'status-led-config-on', 2: 'status-led-config-show-status'}])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, MotionDetectorBricklet, argv)

	functions = {
	'get-motion-detected': get_motion_detected,
	'set-status-led-config': set_status_led_config,
	'get-status-led-config': get_status_led_config,
	'get-identity': get_identity
	}

	call_generic(ctx, 'motion-detector-bricklet', functions, argv)

def dispatch_motion_detector_bricklet(ctx, argv):
	prog_prefix = 'dispatch motion-detector-bricklet <uid>'

	def motion_detected(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' motion-detected')

		args = parser.parse_args(argv)

		device_dispatch(ctx, MotionDetectorBricklet, 2, args.execute, [], [])

	def detection_cycle_ended(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' detection-cycle-ended')

		args = parser.parse_args(argv)

		device_dispatch(ctx, MotionDetectorBricklet, 3, args.execute, [], [])

	callbacks = {
	'motion-detected': motion_detected,
	'detection-cycle-ended': detection_cycle_ended
	}

	dispatch_generic(ctx, 'motion-detector-bricklet', callbacks, argv)

class MotionDetectorV2Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 3; re[3] = 1; re[4] = 3; re[5] = 1; re[234] = 1; re[235] = 1; re[236] = 1; re[237] = 3; re[238] = 1; re[239] = 3; re[240] = 1; re[242] = 1; re[243] = 3; re[248] = 3; re[249] = 1; re[255] = 1
		cf = self.callback_formats
		cf[6] = ''; cf[7] = ''


def call_motion_detector_v2_bricklet(ctx, argv):
	prog_prefix = 'call motion-detector-v2-bricklet <uid>'

	def get_motion_detected(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-motion-detected')

		args = parser.parse_args(argv)

		device_call(ctx, MotionDetectorV2Bricklet, 1, (), '', 'B', args.execute, False, ['motion'], [{0: 'motion-not-detected', 1: 'motion-detected'}])

	def set_sensitivity(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-sensitivity')

		parser.add_argument('sensitivity', type=convert_int, help='int', metavar='<sensitivity>')

		args = parser.parse_args(argv)

		device_call(ctx, MotionDetectorV2Bricklet, 2, (args.sensitivity,), 'B', '', None, args.expect_response, [], [])

	def get_sensitivity(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-sensitivity')

		args = parser.parse_args(argv)

		device_call(ctx, MotionDetectorV2Bricklet, 3, (), '', 'B', args.execute, False, ['sensitivity'], [None])

	def set_indicator(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-indicator')

		parser.add_argument('top_left', type=convert_int, help='int', metavar='<top-left>')
		parser.add_argument('top_right', type=convert_int, help='int', metavar='<top-right>')
		parser.add_argument('bottom', type=convert_int, help='int', metavar='<bottom>')

		args = parser.parse_args(argv)

		device_call(ctx, MotionDetectorV2Bricklet, 4, (args.top_left, args.top_right, args.bottom), 'B B B', '', None, args.expect_response, [], [])

	def get_indicator(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-indicator')

		args = parser.parse_args(argv)

		device_call(ctx, MotionDetectorV2Bricklet, 5, (), '', 'B B B', args.execute, False, ['top-left', 'top-right', 'bottom'], [None, None, None])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, MotionDetectorV2Bricklet, 234, (), '', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def set_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-bootloader-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'bootloader-mode-firmware-wait-for-reboot': 3, 'bootloader-mode-firmware': 1, 'bootloader-mode-firmware-wait-for-erase-and-reboot': 4, 'bootloader-mode-bootloader-wait-for-reboot': 2, 'bootloader-mode-bootloader': 0}), help='int (bootloader-mode-bootloader: 0, bootloader-mode-firmware: 1, bootloader-mode-bootloader-wait-for-reboot: 2, bootloader-mode-firmware-wait-for-reboot: 3, bootloader-mode-firmware-wait-for-erase-and-reboot: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, MotionDetectorV2Bricklet, 235, (args.mode,), 'B', 'B', args.execute, False, ['status'], [{0: 'bootloader-status-ok', 1: 'bootloader-status-invalid-mode', 2: 'bootloader-status-no-change', 3: 'bootloader-status-entry-function-not-present', 4: 'bootloader-status-device-identifier-incorrect', 5: 'bootloader-status-crc-mismatch'}])

	def get_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-bootloader-mode')

		args = parser.parse_args(argv)

		device_call(ctx, MotionDetectorV2Bricklet, 236, (), '', 'B', args.execute, False, ['mode'], [{0: 'bootloader-mode-bootloader', 1: 'bootloader-mode-firmware', 2: 'bootloader-mode-bootloader-wait-for-reboot', 3: 'bootloader-mode-firmware-wait-for-reboot', 4: 'bootloader-mode-firmware-wait-for-erase-and-reboot'}])

	def set_write_firmware_pointer(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-write-firmware-pointer')

		parser.add_argument('pointer', type=convert_int, help='int', metavar='<pointer>')

		args = parser.parse_args(argv)

		device_call(ctx, MotionDetectorV2Bricklet, 237, (args.pointer,), 'I', '', None, args.expect_response, [], [])

	def write_firmware(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-firmware')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, MotionDetectorV2Bricklet, 238, (args.data,), '64B', 'B', args.execute, False, ['status'], [None])

	def set_status_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'status-led-config-on': 1, 'status-led-config-show-heartbeat': 2, 'status-led-config-off': 0, 'status-led-config-show-status': 3}), help='int (status-led-config-off: 0, status-led-config-on: 1, status-led-config-show-heartbeat: 2, status-led-config-show-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, MotionDetectorV2Bricklet, 239, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_status_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, MotionDetectorV2Bricklet, 240, (), '', 'B', args.execute, False, ['config'], [{0: 'status-led-config-off', 1: 'status-led-config-on', 2: 'status-led-config-show-heartbeat', 3: 'status-led-config-show-status'}])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, MotionDetectorV2Bricklet, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, MotionDetectorV2Bricklet, 243, (), '', '', None, args.expect_response, [], [])

	def write_uid(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-uid')

		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')

		args = parser.parse_args(argv)

		device_call(ctx, MotionDetectorV2Bricklet, 248, (args.uid,), 'I', '', None, args.expect_response, [], [])

	def read_uid(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-uid')

		args = parser.parse_args(argv)

		device_call(ctx, MotionDetectorV2Bricklet, 249, (), '', 'I', args.execute, False, ['uid'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, MotionDetectorV2Bricklet, argv)

	functions = {
	'get-motion-detected': get_motion_detected,
	'set-sensitivity': set_sensitivity,
	'get-sensitivity': get_sensitivity,
	'set-indicator': set_indicator,
	'get-indicator': get_indicator,
	'get-spitfp-error-count': get_spitfp_error_count,
	'set-bootloader-mode': set_bootloader_mode,
	'get-bootloader-mode': get_bootloader_mode,
	'set-write-firmware-pointer': set_write_firmware_pointer,
	'write-firmware': write_firmware,
	'set-status-led-config': set_status_led_config,
	'get-status-led-config': get_status_led_config,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'write-uid': write_uid,
	'read-uid': read_uid,
	'get-identity': get_identity
	}

	call_generic(ctx, 'motion-detector-v2-bricklet', functions, argv)

def dispatch_motion_detector_v2_bricklet(ctx, argv):
	prog_prefix = 'dispatch motion-detector-v2-bricklet <uid>'

	def motion_detected(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' motion-detected')

		args = parser.parse_args(argv)

		device_dispatch(ctx, MotionDetectorV2Bricklet, 6, args.execute, [], [])

	def detection_cycle_ended(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' detection-cycle-ended')

		args = parser.parse_args(argv)

		device_dispatch(ctx, MotionDetectorV2Bricklet, 7, args.execute, [], [])

	callbacks = {
	'motion-detected': motion_detected,
	'detection-cycle-ended': detection_cycle_ended
	}

	dispatch_generic(ctx, 'motion-detector-v2-bricklet', callbacks, argv)

class MotorizedLinearPotiBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 2; re[3] = 1; re[5] = 3; re[6] = 1; re[7] = 3; re[8] = 2; re[9] = 1; re[234] = 1; re[235] = 1; re[236] = 1; re[237] = 3; re[238] = 1; re[239] = 3; re[240] = 1; re[242] = 1; re[243] = 3; re[248] = 3; re[249] = 1; re[255] = 1
		cf = self.callback_formats
		cf[4] = 'H'; cf[10] = 'H'


def call_motorized_linear_poti_bricklet(ctx, argv):
	prog_prefix = 'call motorized-linear-poti-bricklet <uid>'

	def get_position(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-position')

		args = parser.parse_args(argv)

		device_call(ctx, MotorizedLinearPotiBricklet, 1, (), '', 'H', args.execute, False, ['position'], [None])

	def set_position_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-position-callback-configuration')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')
		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, MotorizedLinearPotiBricklet, 2, (args.period, args.value_has_to_change, args.option, args.min, args.max), 'I ! c H H', '', None, args.expect_response, [], [])

	def get_position_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-position-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, MotorizedLinearPotiBricklet, 3, (), '', 'I ! c H H', args.execute, False, ['period', 'value-has-to-change', 'option', 'min', 'max'], [None, None, {'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def set_motor_position(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-motor-position')

		parser.add_argument('position', type=convert_int, help='int', metavar='<position>')
		parser.add_argument('drive_mode', type=create_symbol_converter(ctx, convert_int, {'drive-mode-fast': 0, 'drive-mode-smooth': 1}), help='int (drive-mode-fast: 0, drive-mode-smooth: 1)', metavar='<drive-mode>')
		parser.add_argument('hold_position', type=convert_bool, help='bool', metavar='<hold-position>')

		args = parser.parse_args(argv)

		device_call(ctx, MotorizedLinearPotiBricklet, 5, (args.position, args.drive_mode, args.hold_position), 'H B !', '', None, args.expect_response, [], [])

	def get_motor_position(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-motor-position')

		args = parser.parse_args(argv)

		device_call(ctx, MotorizedLinearPotiBricklet, 6, (), '', 'H B ! !', args.execute, False, ['position', 'drive-mode', 'hold-position', 'position-reached'], [None, {0: 'drive-mode-fast', 1: 'drive-mode-smooth'}, None, None])

	def calibrate(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' calibrate')

		args = parser.parse_args(argv)

		device_call(ctx, MotorizedLinearPotiBricklet, 7, (), '', '', None, args.expect_response, [], [])

	def set_position_reached_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-position-reached-callback-configuration')

		parser.add_argument('enabled', type=convert_bool, help='bool', metavar='<enabled>')

		args = parser.parse_args(argv)

		device_call(ctx, MotorizedLinearPotiBricklet, 8, (args.enabled,), '!', '', None, args.expect_response, [], [])

	def get_position_reached_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-position-reached-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, MotorizedLinearPotiBricklet, 9, (), '', '!', args.execute, False, ['enabled'], [None])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, MotorizedLinearPotiBricklet, 234, (), '', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def set_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-bootloader-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'bootloader-mode-firmware-wait-for-reboot': 3, 'bootloader-mode-firmware': 1, 'bootloader-mode-firmware-wait-for-erase-and-reboot': 4, 'bootloader-mode-bootloader-wait-for-reboot': 2, 'bootloader-mode-bootloader': 0}), help='int (bootloader-mode-bootloader: 0, bootloader-mode-firmware: 1, bootloader-mode-bootloader-wait-for-reboot: 2, bootloader-mode-firmware-wait-for-reboot: 3, bootloader-mode-firmware-wait-for-erase-and-reboot: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, MotorizedLinearPotiBricklet, 235, (args.mode,), 'B', 'B', args.execute, False, ['status'], [{0: 'bootloader-status-ok', 1: 'bootloader-status-invalid-mode', 2: 'bootloader-status-no-change', 3: 'bootloader-status-entry-function-not-present', 4: 'bootloader-status-device-identifier-incorrect', 5: 'bootloader-status-crc-mismatch'}])

	def get_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-bootloader-mode')

		args = parser.parse_args(argv)

		device_call(ctx, MotorizedLinearPotiBricklet, 236, (), '', 'B', args.execute, False, ['mode'], [{0: 'bootloader-mode-bootloader', 1: 'bootloader-mode-firmware', 2: 'bootloader-mode-bootloader-wait-for-reboot', 3: 'bootloader-mode-firmware-wait-for-reboot', 4: 'bootloader-mode-firmware-wait-for-erase-and-reboot'}])

	def set_write_firmware_pointer(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-write-firmware-pointer')

		parser.add_argument('pointer', type=convert_int, help='int', metavar='<pointer>')

		args = parser.parse_args(argv)

		device_call(ctx, MotorizedLinearPotiBricklet, 237, (args.pointer,), 'I', '', None, args.expect_response, [], [])

	def write_firmware(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-firmware')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, MotorizedLinearPotiBricklet, 238, (args.data,), '64B', 'B', args.execute, False, ['status'], [None])

	def set_status_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'status-led-config-on': 1, 'status-led-config-show-heartbeat': 2, 'status-led-config-off': 0, 'status-led-config-show-status': 3}), help='int (status-led-config-off: 0, status-led-config-on: 1, status-led-config-show-heartbeat: 2, status-led-config-show-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, MotorizedLinearPotiBricklet, 239, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_status_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, MotorizedLinearPotiBricklet, 240, (), '', 'B', args.execute, False, ['config'], [{0: 'status-led-config-off', 1: 'status-led-config-on', 2: 'status-led-config-show-heartbeat', 3: 'status-led-config-show-status'}])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, MotorizedLinearPotiBricklet, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, MotorizedLinearPotiBricklet, 243, (), '', '', None, args.expect_response, [], [])

	def write_uid(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-uid')

		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')

		args = parser.parse_args(argv)

		device_call(ctx, MotorizedLinearPotiBricklet, 248, (args.uid,), 'I', '', None, args.expect_response, [], [])

	def read_uid(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-uid')

		args = parser.parse_args(argv)

		device_call(ctx, MotorizedLinearPotiBricklet, 249, (), '', 'I', args.execute, False, ['uid'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, MotorizedLinearPotiBricklet, argv)

	functions = {
	'get-position': get_position,
	'set-position-callback-configuration': set_position_callback_configuration,
	'get-position-callback-configuration': get_position_callback_configuration,
	'set-motor-position': set_motor_position,
	'get-motor-position': get_motor_position,
	'calibrate': calibrate,
	'set-position-reached-callback-configuration': set_position_reached_callback_configuration,
	'get-position-reached-callback-configuration': get_position_reached_callback_configuration,
	'get-spitfp-error-count': get_spitfp_error_count,
	'set-bootloader-mode': set_bootloader_mode,
	'get-bootloader-mode': get_bootloader_mode,
	'set-write-firmware-pointer': set_write_firmware_pointer,
	'write-firmware': write_firmware,
	'set-status-led-config': set_status_led_config,
	'get-status-led-config': get_status_led_config,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'write-uid': write_uid,
	'read-uid': read_uid,
	'get-identity': get_identity
	}

	call_generic(ctx, 'motorized-linear-poti-bricklet', functions, argv)

def dispatch_motorized_linear_poti_bricklet(ctx, argv):
	prog_prefix = 'dispatch motorized-linear-poti-bricklet <uid>'

	def position(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' position')

		args = parser.parse_args(argv)

		device_dispatch(ctx, MotorizedLinearPotiBricklet, 4, args.execute, ['position'], [None])

	def position_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' position-reached')

		args = parser.parse_args(argv)

		device_dispatch(ctx, MotorizedLinearPotiBricklet, 10, args.execute, ['position'], [None])

	callbacks = {
	'position': position,
	'position-reached': position_reached
	}

	dispatch_generic(ctx, 'motorized-linear-poti-bricklet', callbacks, argv)

class MultiTouchBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 3; re[3] = 3; re[4] = 1; re[6] = 3; re[7] = 1; re[255] = 1
		cf = self.callback_formats
		cf[5] = 'H'


def call_multi_touch_bricklet(ctx, argv):
	prog_prefix = 'call multi-touch-bricklet <uid>'

	def get_touch_state(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-touch-state')

		args = parser.parse_args(argv)

		device_call(ctx, MultiTouchBricklet, 1, (), '', 'H', args.execute, False, ['state'], [None])

	def recalibrate(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' recalibrate')

		args = parser.parse_args(argv)

		device_call(ctx, MultiTouchBricklet, 2, (), '', '', None, args.expect_response, [], [])

	def set_electrode_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-electrode-config')

		parser.add_argument('enabled_electrodes', type=convert_int, help='int', metavar='<enabled-electrodes>')

		args = parser.parse_args(argv)

		device_call(ctx, MultiTouchBricklet, 3, (args.enabled_electrodes,), 'H', '', None, args.expect_response, [], [])

	def get_electrode_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-electrode-config')

		args = parser.parse_args(argv)

		device_call(ctx, MultiTouchBricklet, 4, (), '', 'H', args.execute, False, ['enabled-electrodes'], [None])

	def set_electrode_sensitivity(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-electrode-sensitivity')

		parser.add_argument('sensitivity', type=convert_int, help='int', metavar='<sensitivity>')

		args = parser.parse_args(argv)

		device_call(ctx, MultiTouchBricklet, 6, (args.sensitivity,), 'B', '', None, args.expect_response, [], [])

	def get_electrode_sensitivity(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-electrode-sensitivity')

		args = parser.parse_args(argv)

		device_call(ctx, MultiTouchBricklet, 7, (), '', 'B', args.execute, False, ['sensitivity'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, MultiTouchBricklet, argv)

	functions = {
	'get-touch-state': get_touch_state,
	'recalibrate': recalibrate,
	'set-electrode-config': set_electrode_config,
	'get-electrode-config': get_electrode_config,
	'set-electrode-sensitivity': set_electrode_sensitivity,
	'get-electrode-sensitivity': get_electrode_sensitivity,
	'get-identity': get_identity
	}

	call_generic(ctx, 'multi-touch-bricklet', functions, argv)

def dispatch_multi_touch_bricklet(ctx, argv):
	prog_prefix = 'dispatch multi-touch-bricklet <uid>'

	def touch_state(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' touch-state')

		args = parser.parse_args(argv)

		device_dispatch(ctx, MultiTouchBricklet, 5, args.execute, ['state'], [None])

	callbacks = {
	'touch-state': touch_state
	}

	dispatch_generic(ctx, 'multi-touch-bricklet', callbacks, argv)

class MultiTouchV2Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 2; re[3] = 1; re[5] = 3; re[6] = 3; re[7] = 1; re[8] = 3; re[9] = 1; re[10] = 3; re[11] = 1; re[234] = 1; re[235] = 1; re[236] = 1; re[237] = 3; re[238] = 1; re[239] = 3; re[240] = 1; re[242] = 1; re[243] = 3; re[248] = 3; re[249] = 1; re[255] = 1
		cf = self.callback_formats
		cf[4] = '13!'


def call_multi_touch_v2_bricklet(ctx, argv):
	prog_prefix = 'call multi-touch-v2-bricklet <uid>'

	def get_touch_state(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-touch-state')

		args = parser.parse_args(argv)

		device_call(ctx, MultiTouchV2Bricklet, 1, (), '', '13!', args.execute, False, ['state'], [None])

	def set_touch_state_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-touch-state-callback-configuration')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')

		args = parser.parse_args(argv)

		device_call(ctx, MultiTouchV2Bricklet, 2, (args.period, args.value_has_to_change), 'I !', '', None, args.expect_response, [], [])

	def get_touch_state_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-touch-state-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, MultiTouchV2Bricklet, 3, (), '', 'I !', args.execute, False, ['period', 'value-has-to-change'], [None, None])

	def recalibrate(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' recalibrate')

		args = parser.parse_args(argv)

		device_call(ctx, MultiTouchV2Bricklet, 5, (), '', '', None, args.expect_response, [], [])

	def set_electrode_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-electrode-config')

		parser.add_argument('enabled_electrodes', type=create_array_converter(ctx, convert_bool, 'false', 13), help=get_array_type_name(ctx, 'bool', 13), metavar='<enabled-electrodes>')

		args = parser.parse_args(argv)

		device_call(ctx, MultiTouchV2Bricklet, 6, (args.enabled_electrodes,), '13!', '', None, args.expect_response, [], [])

	def get_electrode_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-electrode-config')

		args = parser.parse_args(argv)

		device_call(ctx, MultiTouchV2Bricklet, 7, (), '', '13!', args.execute, False, ['enabled-electrodes'], [None])

	def set_electrode_sensitivity(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-electrode-sensitivity')

		parser.add_argument('sensitivity', type=convert_int, help='int', metavar='<sensitivity>')

		args = parser.parse_args(argv)

		device_call(ctx, MultiTouchV2Bricklet, 8, (args.sensitivity,), 'B', '', None, args.expect_response, [], [])

	def get_electrode_sensitivity(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-electrode-sensitivity')

		args = parser.parse_args(argv)

		device_call(ctx, MultiTouchV2Bricklet, 9, (), '', 'B', args.execute, False, ['sensitivity'], [None])

	def set_touch_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-touch-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'touch-led-config-off': 0, 'touch-led-config-show-heartbeat': 2, 'touch-led-config-show-touch': 3, 'touch-led-config-on': 1}), help='int (touch-led-config-off: 0, touch-led-config-on: 1, touch-led-config-show-heartbeat: 2, touch-led-config-show-touch: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, MultiTouchV2Bricklet, 10, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_touch_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-touch-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, MultiTouchV2Bricklet, 11, (), '', 'B', args.execute, False, ['config'], [{0: 'touch-led-config-off', 1: 'touch-led-config-on', 2: 'touch-led-config-show-heartbeat', 3: 'touch-led-config-show-touch'}])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, MultiTouchV2Bricklet, 234, (), '', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def set_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-bootloader-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'bootloader-mode-firmware-wait-for-reboot': 3, 'bootloader-mode-firmware': 1, 'bootloader-mode-firmware-wait-for-erase-and-reboot': 4, 'bootloader-mode-bootloader-wait-for-reboot': 2, 'bootloader-mode-bootloader': 0}), help='int (bootloader-mode-bootloader: 0, bootloader-mode-firmware: 1, bootloader-mode-bootloader-wait-for-reboot: 2, bootloader-mode-firmware-wait-for-reboot: 3, bootloader-mode-firmware-wait-for-erase-and-reboot: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, MultiTouchV2Bricklet, 235, (args.mode,), 'B', 'B', args.execute, False, ['status'], [{0: 'bootloader-status-ok', 1: 'bootloader-status-invalid-mode', 2: 'bootloader-status-no-change', 3: 'bootloader-status-entry-function-not-present', 4: 'bootloader-status-device-identifier-incorrect', 5: 'bootloader-status-crc-mismatch'}])

	def get_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-bootloader-mode')

		args = parser.parse_args(argv)

		device_call(ctx, MultiTouchV2Bricklet, 236, (), '', 'B', args.execute, False, ['mode'], [{0: 'bootloader-mode-bootloader', 1: 'bootloader-mode-firmware', 2: 'bootloader-mode-bootloader-wait-for-reboot', 3: 'bootloader-mode-firmware-wait-for-reboot', 4: 'bootloader-mode-firmware-wait-for-erase-and-reboot'}])

	def set_write_firmware_pointer(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-write-firmware-pointer')

		parser.add_argument('pointer', type=convert_int, help='int', metavar='<pointer>')

		args = parser.parse_args(argv)

		device_call(ctx, MultiTouchV2Bricklet, 237, (args.pointer,), 'I', '', None, args.expect_response, [], [])

	def write_firmware(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-firmware')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, MultiTouchV2Bricklet, 238, (args.data,), '64B', 'B', args.execute, False, ['status'], [None])

	def set_status_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'status-led-config-on': 1, 'status-led-config-show-heartbeat': 2, 'status-led-config-off': 0, 'status-led-config-show-status': 3}), help='int (status-led-config-off: 0, status-led-config-on: 1, status-led-config-show-heartbeat: 2, status-led-config-show-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, MultiTouchV2Bricklet, 239, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_status_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, MultiTouchV2Bricklet, 240, (), '', 'B', args.execute, False, ['config'], [{0: 'status-led-config-off', 1: 'status-led-config-on', 2: 'status-led-config-show-heartbeat', 3: 'status-led-config-show-status'}])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, MultiTouchV2Bricklet, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, MultiTouchV2Bricklet, 243, (), '', '', None, args.expect_response, [], [])

	def write_uid(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-uid')

		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')

		args = parser.parse_args(argv)

		device_call(ctx, MultiTouchV2Bricklet, 248, (args.uid,), 'I', '', None, args.expect_response, [], [])

	def read_uid(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-uid')

		args = parser.parse_args(argv)

		device_call(ctx, MultiTouchV2Bricklet, 249, (), '', 'I', args.execute, False, ['uid'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, MultiTouchV2Bricklet, argv)

	functions = {
	'get-touch-state': get_touch_state,
	'set-touch-state-callback-configuration': set_touch_state_callback_configuration,
	'get-touch-state-callback-configuration': get_touch_state_callback_configuration,
	'recalibrate': recalibrate,
	'set-electrode-config': set_electrode_config,
	'get-electrode-config': get_electrode_config,
	'set-electrode-sensitivity': set_electrode_sensitivity,
	'get-electrode-sensitivity': get_electrode_sensitivity,
	'set-touch-led-config': set_touch_led_config,
	'get-touch-led-config': get_touch_led_config,
	'get-spitfp-error-count': get_spitfp_error_count,
	'set-bootloader-mode': set_bootloader_mode,
	'get-bootloader-mode': get_bootloader_mode,
	'set-write-firmware-pointer': set_write_firmware_pointer,
	'write-firmware': write_firmware,
	'set-status-led-config': set_status_led_config,
	'get-status-led-config': get_status_led_config,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'write-uid': write_uid,
	'read-uid': read_uid,
	'get-identity': get_identity
	}

	call_generic(ctx, 'multi-touch-v2-bricklet', functions, argv)

def dispatch_multi_touch_v2_bricklet(ctx, argv):
	prog_prefix = 'dispatch multi-touch-v2-bricklet <uid>'

	def touch_state(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' touch-state')

		args = parser.parse_args(argv)

		device_dispatch(ctx, MultiTouchV2Bricklet, 4, args.execute, ['state'], [None])

	callbacks = {
	'touch-state': touch_state
	}

	dispatch_generic(ctx, 'multi-touch-v2-bricklet', callbacks, argv)

class NFCBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 3; re[2] = 1; re[3] = 3; re[4] = 1; re[5] = 1; re[6] = 2; re[7] = 3; re[8] = 1; re[9] = 3; re[10] = 2; re[11] = 3; re[12] = 1; re[14] = 1; re[15] = 3; re[16] = 2; re[17] = 3; re[19] = 1; re[20] = 3; re[21] = 2; re[22] = 3; re[23] = 1; re[25] = 3; re[26] = 1; re[27] = 3; re[28] = 1; re[234] = 1; re[235] = 1; re[236] = 1; re[237] = 3; re[238] = 1; re[239] = 3; re[240] = 1; re[242] = 1; re[243] = 3; re[248] = 3; re[249] = 1; re[255] = 1
		cf = self.callback_formats
		cf[13] = 'B !'; cf[18] = 'B !'; cf[24] = 'B !'


def call_nfc_bricklet(ctx, argv):
	prog_prefix = 'call nfc-bricklet <uid>'

	def set_mode(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'mode-reader': 3, 'mode-p2p': 2, 'mode-off': 0, 'mode-cardemu': 1}), help='int (mode-off: 0, mode-cardemu: 1, mode-p2p: 2, mode-reader: 3)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, NFCBricklet, 1, (args.mode,), 'B', '', None, args.expect_response, [], [])

	def get_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-mode')

		args = parser.parse_args(argv)

		device_call(ctx, NFCBricklet, 2, (), '', 'B', args.execute, False, ['mode'], [{0: 'mode-off', 1: 'mode-cardemu', 2: 'mode-p2p', 3: 'mode-reader'}])

	def reader_request_tag_id(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reader-request-tag-id')

		args = parser.parse_args(argv)

		device_call(ctx, NFCBricklet, 3, (), '', '', None, args.expect_response, [], [])

	def reader_get_tag_id_low_level(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' reader-get-tag-id-low-level')

		args = parser.parse_args(argv)

		device_call(ctx, NFCBricklet, 4, (), '', 'B B 32B', args.execute, False, ['tag-type', 'tag-id-length', 'tag-id-data'], [{0: 'tag-type-mifare-classic', 1: 'tag-type-type1', 2: 'tag-type-type2', 3: 'tag-type-type3', 4: 'tag-type-type4'}, None, None])

	def reader_get_tag_id(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' reader-get-tag-id')

		args = parser.parse_args(argv)

		device_stream_call(ctx, NFCBricklet, 4, 'out', (), (), (None, 'stream_data'), (), (None, 'stream_length', 'stream_chunk_data'), '', 'B B 32B', args.execute, False, ['tag-type', 'tag-id'], [{0: 'tag-type-mifare-classic', 1: 'tag-type-type1', 2: 'tag-type-type2', 3: 'tag-type-type3', 4: 'tag-type-type4'}, None], None, 32, None, False, True, None)

	def reader_get_state(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' reader-get-state')

		args = parser.parse_args(argv)

		device_call(ctx, NFCBricklet, 5, (), '', 'B !', args.execute, False, ['state', 'idle'], [{0: 'reader-state-initialization', 128: 'reader-state-idle', 2: 'reader-state-request-tag-id', 3: 'reader-state-authenticate-mifare-classic-page', 4: 'reader-state-write-page', 5: 'reader-state-request-page', 195: 'reader-state-authenticate-mifare-classic-page-error', 7: 'reader-state-request-ndef', 194: 'reader-state-request-tag-id-error', 197: 'reader-state-request-page-error', 192: 'reader-state-error', 130: 'reader-state-request-tag-id-ready', 131: 'reader-state-authenticate-mifare-classic-page-ready', 196: 'reader-state-write-page-error', 199: 'reader-state-request-ndef-error', 135: 'reader-state-request-ndef-ready', 132: 'reader-state-write-page-ready', 6: 'reader-state-write-ndef', 198: 'reader-state-write-ndef-error', 134: 'reader-state-write-ndef-ready', 133: 'reader-state-request-page-ready'}, None])

	def reader_write_ndef_low_level(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reader-write-ndef-low-level')

		parser.add_argument('ndef_length', type=convert_int, help='int', metavar='<ndef-length>')
		parser.add_argument('ndef_chunk_offset', type=convert_int, help='int', metavar='<ndef-chunk-offset>')
		parser.add_argument('ndef_chunk_data', type=create_array_converter(ctx, convert_int, '0', 60), help=get_array_type_name(ctx, 'int', 60), metavar='<ndef-chunk-data>')

		args = parser.parse_args(argv)

		device_call(ctx, NFCBricklet, 6, (args.ndef_length, args.ndef_chunk_offset, args.ndef_chunk_data), 'H H 60B', '', None, args.expect_response, [], [])

	def reader_write_ndef(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reader-write-ndef')

		parser.add_argument('ndef', type=create_array_converter(ctx, convert_int, None, -65535), help=get_array_type_name(ctx, 'int', -65535), metavar='<ndef>')

		args = parser.parse_args(argv)

		device_stream_call(ctx, NFCBricklet, 6, 'in', (args.ndef,), ('stream_data',), (), ('stream_length', 'stream_chunk_offset', 'stream_chunk_data'), (), 'H H 60B', '', None, args.expect_response, [], [], '0', 60, None, False, False, None)

	def reader_request_ndef(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reader-request-ndef')

		args = parser.parse_args(argv)

		device_call(ctx, NFCBricklet, 7, (), '', '', None, args.expect_response, [], [])

	def reader_read_ndef_low_level(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' reader-read-ndef-low-level')

		args = parser.parse_args(argv)

		device_call(ctx, NFCBricklet, 8, (), '', 'H H 60B', args.execute, False, ['ndef-length', 'ndef-chunk-offset', 'ndef-chunk-data'], [None, None, None])

	def reader_read_ndef(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' reader-read-ndef')

		args = parser.parse_args(argv)

		device_stream_call(ctx, NFCBricklet, 8, 'out', (), (), ('stream_data',), (), ('stream_length', 'stream_chunk_offset', 'stream_chunk_data'), '', 'H H 60B', args.execute, False, ['ndef'], [None], None, 60, None, False, False, None)

	def reader_authenticate_mifare_classic_page(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reader-authenticate-mifare-classic-page')

		parser.add_argument('page', type=convert_int, help='int', metavar='<page>')
		parser.add_argument('key_number', type=create_symbol_converter(ctx, convert_int, {'key-b': 1, 'key-a': 0}), help='int (key-a: 0, key-b: 1)', metavar='<key-number>')
		parser.add_argument('key', type=create_array_converter(ctx, convert_int, '0', 6), help=get_array_type_name(ctx, 'int', 6), metavar='<key>')

		args = parser.parse_args(argv)

		device_call(ctx, NFCBricklet, 9, (args.page, args.key_number, args.key), 'H B 6B', '', None, args.expect_response, [], [])

	def reader_write_page_low_level(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reader-write-page-low-level')

		parser.add_argument('page', type=create_symbol_converter(ctx, convert_int, {'reader-write-type4-capability-container': 3, 'reader-write-type4-ndef': 4}), help='int (reader-write-type4-capability-container: 3, reader-write-type4-ndef: 4)', metavar='<page>')
		parser.add_argument('data_length', type=convert_int, help='int', metavar='<data-length>')
		parser.add_argument('data_chunk_offset', type=convert_int, help='int', metavar='<data-chunk-offset>')
		parser.add_argument('data_chunk_data', type=create_array_converter(ctx, convert_int, '0', 58), help=get_array_type_name(ctx, 'int', 58), metavar='<data-chunk-data>')

		args = parser.parse_args(argv)

		device_call(ctx, NFCBricklet, 10, (args.page, args.data_length, args.data_chunk_offset, args.data_chunk_data), 'H H H 58B', '', None, args.expect_response, [], [])

	def reader_write_page(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reader-write-page')

		parser.add_argument('page', type=create_symbol_converter(ctx, convert_int, {'reader-write-type4-capability-container': 3, 'reader-write-type4-ndef': 4}), help='int (reader-write-type4-capability-container: 3, reader-write-type4-ndef: 4)', metavar='<page>')
		parser.add_argument('data', type=create_array_converter(ctx, convert_int, None, -65535), help=get_array_type_name(ctx, 'int', -65535), metavar='<data>')

		args = parser.parse_args(argv)

		device_stream_call(ctx, NFCBricklet, 10, 'in', (args.page, args.data), (None, 'stream_data'), (), (None, 'stream_length', 'stream_chunk_offset', 'stream_chunk_data'), (), 'H H H 58B', '', None, args.expect_response, [], [], '0', 58, None, False, False, None)

	def reader_request_page(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reader-request-page')

		parser.add_argument('page', type=create_symbol_converter(ctx, convert_int, {'reader-request-type4-capability-container': 3, 'reader-request-type4-ndef': 4}), help='int (reader-request-type4-capability-container: 3, reader-request-type4-ndef: 4)', metavar='<page>')
		parser.add_argument('length', type=convert_int, help='int', metavar='<length>')

		args = parser.parse_args(argv)

		device_call(ctx, NFCBricklet, 11, (args.page, args.length), 'H H', '', None, args.expect_response, [], [])

	def reader_read_page_low_level(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' reader-read-page-low-level')

		args = parser.parse_args(argv)

		device_call(ctx, NFCBricklet, 12, (), '', 'H H 60B', args.execute, False, ['data-length', 'data-chunk-offset', 'data-chunk-data'], [None, None, None])

	def reader_read_page(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' reader-read-page')

		args = parser.parse_args(argv)

		device_stream_call(ctx, NFCBricklet, 12, 'out', (), (), ('stream_data',), (), ('stream_length', 'stream_chunk_offset', 'stream_chunk_data'), '', 'H H 60B', args.execute, False, ['data'], [None], None, 60, None, False, False, None)

	def cardemu_get_state(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' cardemu-get-state')

		args = parser.parse_args(argv)

		device_call(ctx, NFCBricklet, 14, (), '', 'B !', args.execute, False, ['state', 'idle'], [{0: 'cardemu-state-initialization', 128: 'cardemu-state-idle', 2: 'cardemu-state-discover', 3: 'cardemu-state-transfer-ndef', 195: 'cardemu-state-transfer-ndef-error', 194: 'cardemu-state-discover-error', 192: 'cardemu-state-error', 130: 'cardemu-state-discover-ready', 131: 'cardemu-state-transfer-ndef-ready'}, None])

	def cardemu_start_discovery(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' cardemu-start-discovery')

		args = parser.parse_args(argv)

		device_call(ctx, NFCBricklet, 15, (), '', '', None, args.expect_response, [], [])

	def cardemu_write_ndef_low_level(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' cardemu-write-ndef-low-level')

		parser.add_argument('ndef_length', type=convert_int, help='int', metavar='<ndef-length>')
		parser.add_argument('ndef_chunk_offset', type=convert_int, help='int', metavar='<ndef-chunk-offset>')
		parser.add_argument('ndef_chunk_data', type=create_array_converter(ctx, convert_int, '0', 60), help=get_array_type_name(ctx, 'int', 60), metavar='<ndef-chunk-data>')

		args = parser.parse_args(argv)

		device_call(ctx, NFCBricklet, 16, (args.ndef_length, args.ndef_chunk_offset, args.ndef_chunk_data), 'H H 60B', '', None, args.expect_response, [], [])

	def cardemu_write_ndef(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' cardemu-write-ndef')

		parser.add_argument('ndef', type=create_array_converter(ctx, convert_int, None, -65535), help=get_array_type_name(ctx, 'int', -65535), metavar='<ndef>')

		args = parser.parse_args(argv)

		device_stream_call(ctx, NFCBricklet, 16, 'in', (args.ndef,), ('stream_data',), (), ('stream_length', 'stream_chunk_offset', 'stream_chunk_data'), (), 'H H 60B', '', None, args.expect_response, [], [], '0', 60, None, False, False, None)

	def cardemu_start_transfer(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' cardemu-start-transfer')

		parser.add_argument('transfer', type=create_symbol_converter(ctx, convert_int, {'cardemu-transfer-abort': 0, 'cardemu-transfer-write': 1}), help='int (cardemu-transfer-abort: 0, cardemu-transfer-write: 1)', metavar='<transfer>')

		args = parser.parse_args(argv)

		device_call(ctx, NFCBricklet, 17, (args.transfer,), 'B', '', None, args.expect_response, [], [])

	def p2p_get_state(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' p2p-get-state')

		args = parser.parse_args(argv)

		device_call(ctx, NFCBricklet, 19, (), '', 'B !', args.execute, False, ['state', 'idle'], [{0: 'p2p-state-initialization', 128: 'p2p-state-idle', 2: 'p2p-state-discover', 3: 'p2p-state-transfer-ndef', 195: 'p2p-state-transfer-ndef-error', 194: 'p2p-state-discover-error', 192: 'p2p-state-error', 130: 'p2p-state-discover-ready', 131: 'p2p-state-transfer-ndef-ready'}, None])

	def p2p_start_discovery(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' p2p-start-discovery')

		args = parser.parse_args(argv)

		device_call(ctx, NFCBricklet, 20, (), '', '', None, args.expect_response, [], [])

	def p2p_write_ndef_low_level(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' p2p-write-ndef-low-level')

		parser.add_argument('ndef_length', type=convert_int, help='int', metavar='<ndef-length>')
		parser.add_argument('ndef_chunk_offset', type=convert_int, help='int', metavar='<ndef-chunk-offset>')
		parser.add_argument('ndef_chunk_data', type=create_array_converter(ctx, convert_int, '0', 60), help=get_array_type_name(ctx, 'int', 60), metavar='<ndef-chunk-data>')

		args = parser.parse_args(argv)

		device_call(ctx, NFCBricklet, 21, (args.ndef_length, args.ndef_chunk_offset, args.ndef_chunk_data), 'H H 60B', '', None, args.expect_response, [], [])

	def p2p_write_ndef(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' p2p-write-ndef')

		parser.add_argument('ndef', type=create_array_converter(ctx, convert_int, None, -65535), help=get_array_type_name(ctx, 'int', -65535), metavar='<ndef>')

		args = parser.parse_args(argv)

		device_stream_call(ctx, NFCBricklet, 21, 'in', (args.ndef,), ('stream_data',), (), ('stream_length', 'stream_chunk_offset', 'stream_chunk_data'), (), 'H H 60B', '', None, args.expect_response, [], [], '0', 60, None, False, False, None)

	def p2p_start_transfer(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' p2p-start-transfer')

		parser.add_argument('transfer', type=create_symbol_converter(ctx, convert_int, {'p2p-transfer-write': 1, 'p2p-transfer-read': 2, 'p2p-transfer-abort': 0}), help='int (p2p-transfer-abort: 0, p2p-transfer-write: 1, p2p-transfer-read: 2)', metavar='<transfer>')

		args = parser.parse_args(argv)

		device_call(ctx, NFCBricklet, 22, (args.transfer,), 'B', '', None, args.expect_response, [], [])

	def p2p_read_ndef_low_level(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' p2p-read-ndef-low-level')

		args = parser.parse_args(argv)

		device_call(ctx, NFCBricklet, 23, (), '', 'H H 60B', args.execute, False, ['ndef-length', 'ndef-chunk-offset', 'ndef-chunk-data'], [None, None, None])

	def p2p_read_ndef(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' p2p-read-ndef')

		args = parser.parse_args(argv)

		device_stream_call(ctx, NFCBricklet, 23, 'out', (), (), ('stream_data',), (), ('stream_length', 'stream_chunk_offset', 'stream_chunk_data'), '', 'H H 60B', args.execute, False, ['ndef'], [None], None, 60, None, False, False, None)

	def set_detection_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-detection-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'detection-led-config-off': 0, 'detection-led-config-show-heartbeat': 2, 'detection-led-config-show-detection': 3, 'detection-led-config-on': 1}), help='int (detection-led-config-off: 0, detection-led-config-on: 1, detection-led-config-show-heartbeat: 2, detection-led-config-show-detection: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, NFCBricklet, 25, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_detection_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-detection-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, NFCBricklet, 26, (), '', 'B', args.execute, False, ['config'], [{0: 'detection-led-config-off', 1: 'detection-led-config-on', 2: 'detection-led-config-show-heartbeat', 3: 'detection-led-config-show-detection'}])

	def set_maximum_timeout(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-maximum-timeout')

		parser.add_argument('timeout', type=convert_int, help='int', metavar='<timeout>')

		args = parser.parse_args(argv)

		device_call(ctx, NFCBricklet, 27, (args.timeout,), 'H', '', None, args.expect_response, [], [])

	def get_maximum_timeout(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-maximum-timeout')

		args = parser.parse_args(argv)

		device_call(ctx, NFCBricklet, 28, (), '', 'H', args.execute, False, ['timeout'], [None])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, NFCBricklet, 234, (), '', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def set_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-bootloader-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'bootloader-mode-firmware-wait-for-reboot': 3, 'bootloader-mode-firmware': 1, 'bootloader-mode-firmware-wait-for-erase-and-reboot': 4, 'bootloader-mode-bootloader-wait-for-reboot': 2, 'bootloader-mode-bootloader': 0}), help='int (bootloader-mode-bootloader: 0, bootloader-mode-firmware: 1, bootloader-mode-bootloader-wait-for-reboot: 2, bootloader-mode-firmware-wait-for-reboot: 3, bootloader-mode-firmware-wait-for-erase-and-reboot: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, NFCBricklet, 235, (args.mode,), 'B', 'B', args.execute, False, ['status'], [{0: 'bootloader-status-ok', 1: 'bootloader-status-invalid-mode', 2: 'bootloader-status-no-change', 3: 'bootloader-status-entry-function-not-present', 4: 'bootloader-status-device-identifier-incorrect', 5: 'bootloader-status-crc-mismatch'}])

	def get_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-bootloader-mode')

		args = parser.parse_args(argv)

		device_call(ctx, NFCBricklet, 236, (), '', 'B', args.execute, False, ['mode'], [{0: 'bootloader-mode-bootloader', 1: 'bootloader-mode-firmware', 2: 'bootloader-mode-bootloader-wait-for-reboot', 3: 'bootloader-mode-firmware-wait-for-reboot', 4: 'bootloader-mode-firmware-wait-for-erase-and-reboot'}])

	def set_write_firmware_pointer(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-write-firmware-pointer')

		parser.add_argument('pointer', type=convert_int, help='int', metavar='<pointer>')

		args = parser.parse_args(argv)

		device_call(ctx, NFCBricklet, 237, (args.pointer,), 'I', '', None, args.expect_response, [], [])

	def write_firmware(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-firmware')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, NFCBricklet, 238, (args.data,), '64B', 'B', args.execute, False, ['status'], [None])

	def set_status_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'status-led-config-on': 1, 'status-led-config-show-heartbeat': 2, 'status-led-config-off': 0, 'status-led-config-show-status': 3}), help='int (status-led-config-off: 0, status-led-config-on: 1, status-led-config-show-heartbeat: 2, status-led-config-show-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, NFCBricklet, 239, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_status_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, NFCBricklet, 240, (), '', 'B', args.execute, False, ['config'], [{0: 'status-led-config-off', 1: 'status-led-config-on', 2: 'status-led-config-show-heartbeat', 3: 'status-led-config-show-status'}])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, NFCBricklet, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, NFCBricklet, 243, (), '', '', None, args.expect_response, [], [])

	def write_uid(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-uid')

		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')

		args = parser.parse_args(argv)

		device_call(ctx, NFCBricklet, 248, (args.uid,), 'I', '', None, args.expect_response, [], [])

	def read_uid(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-uid')

		args = parser.parse_args(argv)

		device_call(ctx, NFCBricklet, 249, (), '', 'I', args.execute, False, ['uid'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, NFCBricklet, argv)

	functions = {
	'set-mode': set_mode,
	'get-mode': get_mode,
	'reader-request-tag-id': reader_request_tag_id,
	'reader-get-tag-id-low-level': reader_get_tag_id_low_level,
	'reader-get-tag-id': reader_get_tag_id,
	'reader-get-state': reader_get_state,
	'reader-write-ndef-low-level': reader_write_ndef_low_level,
	'reader-write-ndef': reader_write_ndef,
	'reader-request-ndef': reader_request_ndef,
	'reader-read-ndef-low-level': reader_read_ndef_low_level,
	'reader-read-ndef': reader_read_ndef,
	'reader-authenticate-mifare-classic-page': reader_authenticate_mifare_classic_page,
	'reader-write-page-low-level': reader_write_page_low_level,
	'reader-write-page': reader_write_page,
	'reader-request-page': reader_request_page,
	'reader-read-page-low-level': reader_read_page_low_level,
	'reader-read-page': reader_read_page,
	'cardemu-get-state': cardemu_get_state,
	'cardemu-start-discovery': cardemu_start_discovery,
	'cardemu-write-ndef-low-level': cardemu_write_ndef_low_level,
	'cardemu-write-ndef': cardemu_write_ndef,
	'cardemu-start-transfer': cardemu_start_transfer,
	'p2p-get-state': p2p_get_state,
	'p2p-start-discovery': p2p_start_discovery,
	'p2p-write-ndef-low-level': p2p_write_ndef_low_level,
	'p2p-write-ndef': p2p_write_ndef,
	'p2p-start-transfer': p2p_start_transfer,
	'p2p-read-ndef-low-level': p2p_read_ndef_low_level,
	'p2p-read-ndef': p2p_read_ndef,
	'set-detection-led-config': set_detection_led_config,
	'get-detection-led-config': get_detection_led_config,
	'set-maximum-timeout': set_maximum_timeout,
	'get-maximum-timeout': get_maximum_timeout,
	'get-spitfp-error-count': get_spitfp_error_count,
	'set-bootloader-mode': set_bootloader_mode,
	'get-bootloader-mode': get_bootloader_mode,
	'set-write-firmware-pointer': set_write_firmware_pointer,
	'write-firmware': write_firmware,
	'set-status-led-config': set_status_led_config,
	'get-status-led-config': get_status_led_config,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'write-uid': write_uid,
	'read-uid': read_uid,
	'get-identity': get_identity
	}

	call_generic(ctx, 'nfc-bricklet', functions, argv)

def dispatch_nfc_bricklet(ctx, argv):
	prog_prefix = 'dispatch nfc-bricklet <uid>'

	def reader_state_changed(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' reader-state-changed')

		args = parser.parse_args(argv)

		device_dispatch(ctx, NFCBricklet, 13, args.execute, ['state', 'idle'], [{0: 'reader-state-initialization', 128: 'reader-state-idle', 2: 'reader-state-request-tag-id', 3: 'reader-state-authenticate-mifare-classic-page', 4: 'reader-state-write-page', 5: 'reader-state-request-page', 195: 'reader-state-authenticate-mifare-classic-page-error', 7: 'reader-state-request-ndef', 194: 'reader-state-request-tag-id-error', 197: 'reader-state-request-page-error', 192: 'reader-state-error', 130: 'reader-state-request-tag-id-ready', 131: 'reader-state-authenticate-mifare-classic-page-ready', 196: 'reader-state-write-page-error', 199: 'reader-state-request-ndef-error', 135: 'reader-state-request-ndef-ready', 132: 'reader-state-write-page-ready', 6: 'reader-state-write-ndef', 198: 'reader-state-write-ndef-error', 134: 'reader-state-write-ndef-ready', 133: 'reader-state-request-page-ready'}, None])

	def cardemu_state_changed(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' cardemu-state-changed')

		args = parser.parse_args(argv)

		device_dispatch(ctx, NFCBricklet, 18, args.execute, ['state', 'idle'], [{0: 'cardemu-state-initialization', 128: 'cardemu-state-idle', 2: 'cardemu-state-discover', 3: 'cardemu-state-transfer-ndef', 195: 'cardemu-state-transfer-ndef-error', 194: 'cardemu-state-discover-error', 192: 'cardemu-state-error', 130: 'cardemu-state-discover-ready', 131: 'cardemu-state-transfer-ndef-ready'}, None])

	def p2p_state_changed(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' p2p-state-changed')

		args = parser.parse_args(argv)

		device_dispatch(ctx, NFCBricklet, 24, args.execute, ['state', 'idle'], [{0: 'p2p-state-initialization', 128: 'p2p-state-idle', 2: 'p2p-state-discover', 3: 'p2p-state-transfer-ndef', 195: 'p2p-state-transfer-ndef-error', 194: 'p2p-state-discover-error', 192: 'p2p-state-error', 130: 'p2p-state-discover-ready', 131: 'p2p-state-transfer-ndef-ready'}, None])

	callbacks = {
	'reader-state-changed': reader_state_changed,
	'cardemu-state-changed': cardemu_state_changed,
	'p2p-state-changed': p2p_state_changed
	}

	dispatch_generic(ctx, 'nfc-bricklet', callbacks, argv)

class NFCRFIDBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 3; re[2] = 1; re[3] = 1; re[4] = 3; re[5] = 3; re[6] = 3; re[7] = 1; re[255] = 1
		cf = self.callback_formats
		cf[8] = 'B !'


def call_nfc_rfid_bricklet(ctx, argv):
	prog_prefix = 'call nfc-rfid-bricklet <uid>'

	def request_tag_id(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' request-tag-id')

		parser.add_argument('tag_type', type=create_symbol_converter(ctx, convert_int, {'tag-type-mifare-classic': 0, 'tag-type-type1': 1, 'tag-type-type2': 2}), help='int (tag-type-mifare-classic: 0, tag-type-type1: 1, tag-type-type2: 2)', metavar='<tag-type>')

		args = parser.parse_args(argv)

		device_call(ctx, NFCRFIDBricklet, 1, (args.tag_type,), 'B', '', None, args.expect_response, [], [])

	def get_tag_id(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-tag-id')

		args = parser.parse_args(argv)

		device_call(ctx, NFCRFIDBricklet, 2, (), '', 'B B 7B', args.execute, False, ['tag-type', 'tid-length', 'tid'], [{0: 'tag-type-mifare-classic', 1: 'tag-type-type1', 2: 'tag-type-type2'}, None, None])

	def get_state(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-state')

		args = parser.parse_args(argv)

		device_call(ctx, NFCRFIDBricklet, 3, (), '', 'B !', args.execute, False, ['state', 'idle'], [{0: 'state-initialization', 128: 'state-idle', 2: 'state-request-tag-id', 3: 'state-authenticating-mifare-classic-page', 4: 'state-write-page', 5: 'state-request-page', 195: 'state-authenticating-mifare-classic-page-error', 194: 'state-request-tag-id-error', 197: 'state-request-page-error', 192: 'state-error', 130: 'state-request-tag-id-ready', 131: 'state-authenticating-mifare-classic-page-ready', 196: 'state-write-page-error', 132: 'state-write-page-ready', 133: 'state-request-page-ready'}, None])

	def authenticate_mifare_classic_page(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' authenticate-mifare-classic-page')

		parser.add_argument('page', type=convert_int, help='int', metavar='<page>')
		parser.add_argument('key_number', type=create_symbol_converter(ctx, convert_int, {'key-b': 1, 'key-a': 0}), help='int (key-a: 0, key-b: 1)', metavar='<key-number>')
		parser.add_argument('key', type=create_array_converter(ctx, convert_int, '0', 6), help=get_array_type_name(ctx, 'int', 6), metavar='<key>')

		args = parser.parse_args(argv)

		device_call(ctx, NFCRFIDBricklet, 4, (args.page, args.key_number, args.key), 'H B 6B', '', None, args.expect_response, [], [])

	def write_page(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-page')

		parser.add_argument('page', type=convert_int, help='int', metavar='<page>')
		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 16), help=get_array_type_name(ctx, 'int', 16), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, NFCRFIDBricklet, 5, (args.page, args.data), 'H 16B', '', None, args.expect_response, [], [])

	def request_page(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' request-page')

		parser.add_argument('page', type=convert_int, help='int', metavar='<page>')

		args = parser.parse_args(argv)

		device_call(ctx, NFCRFIDBricklet, 6, (args.page,), 'H', '', None, args.expect_response, [], [])

	def get_page(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-page')

		args = parser.parse_args(argv)

		device_call(ctx, NFCRFIDBricklet, 7, (), '', '16B', args.execute, False, ['data'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, NFCRFIDBricklet, argv)

	functions = {
	'request-tag-id': request_tag_id,
	'get-tag-id': get_tag_id,
	'get-state': get_state,
	'authenticate-mifare-classic-page': authenticate_mifare_classic_page,
	'write-page': write_page,
	'request-page': request_page,
	'get-page': get_page,
	'get-identity': get_identity
	}

	call_generic(ctx, 'nfc-rfid-bricklet', functions, argv)

def dispatch_nfc_rfid_bricklet(ctx, argv):
	prog_prefix = 'dispatch nfc-rfid-bricklet <uid>'

	def state_changed(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' state-changed')

		args = parser.parse_args(argv)

		device_dispatch(ctx, NFCRFIDBricklet, 8, args.execute, ['state', 'idle'], [{0: 'state-initialization', 128: 'state-idle', 2: 'state-request-tag-id', 3: 'state-authenticating-mifare-classic-page', 4: 'state-write-page', 5: 'state-request-page', 195: 'state-authenticating-mifare-classic-page-error', 194: 'state-request-tag-id-error', 197: 'state-request-page-error', 192: 'state-error', 130: 'state-request-tag-id-ready', 131: 'state-authenticating-mifare-classic-page-ready', 196: 'state-write-page-error', 132: 'state-write-page-ready', 133: 'state-request-page-ready'}, None])

	callbacks = {
	'state-changed': state_changed
	}

	dispatch_generic(ctx, 'nfc-rfid-bricklet', callbacks, argv)

class OLED128x64Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 3; re[2] = 3; re[3] = 3; re[4] = 3; re[5] = 1; re[6] = 3; re[255] = 1



def call_oled_128x64_bricklet(ctx, argv):
	prog_prefix = 'call oled-128x64-bricklet <uid>'

	def write(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, OLED128x64Bricklet, 1, (args.data,), '64B', '', None, args.expect_response, [], [])

	def new_window(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' new-window')

		parser.add_argument('column_from', type=convert_int, help='int', metavar='<column-from>')
		parser.add_argument('column_to', type=convert_int, help='int', metavar='<column-to>')
		parser.add_argument('row_from', type=convert_int, help='int', metavar='<row-from>')
		parser.add_argument('row_to', type=convert_int, help='int', metavar='<row-to>')

		args = parser.parse_args(argv)

		device_call(ctx, OLED128x64Bricklet, 2, (args.column_from, args.column_to, args.row_from, args.row_to), 'B B B B', '', None, args.expect_response, [], [])

	def clear_display(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' clear-display')

		args = parser.parse_args(argv)

		device_call(ctx, OLED128x64Bricklet, 3, (), '', '', None, args.expect_response, [], [])

	def set_display_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-display-configuration')

		parser.add_argument('contrast', type=convert_int, help='int', metavar='<contrast>')
		parser.add_argument('invert', type=convert_bool, help='bool', metavar='<invert>')

		args = parser.parse_args(argv)

		device_call(ctx, OLED128x64Bricklet, 4, (args.contrast, args.invert), 'B !', '', None, args.expect_response, [], [])

	def get_display_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-display-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, OLED128x64Bricklet, 5, (), '', 'B !', args.execute, False, ['contrast', 'invert'], [None, None])

	def write_line(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-line')

		parser.add_argument('line', type=convert_int, help='int', metavar='<line>')
		parser.add_argument('position', type=convert_int, help='int', metavar='<position>')
		parser.add_argument('text', type=create_string_converter(ctx, str, 26), help='string', metavar='<text>')

		args = parser.parse_args(argv)

		device_call(ctx, OLED128x64Bricklet, 6, (args.line, args.position, args.text), 'B B 26s', '', None, args.expect_response, [], [])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, OLED128x64Bricklet, argv)

	functions = {
	'write': write,
	'new-window': new_window,
	'clear-display': clear_display,
	'set-display-configuration': set_display_configuration,
	'get-display-configuration': get_display_configuration,
	'write-line': write_line,
	'get-identity': get_identity
	}

	call_generic(ctx, 'oled-128x64-bricklet', functions, argv)

def dispatch_oled_128x64_bricklet(ctx, argv):
	prog_prefix = 'dispatch oled-128x64-bricklet <uid>'


	callbacks = {

	}

	dispatch_generic(ctx, 'oled-128x64-bricklet', callbacks, argv)

class OLED128x64V2Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 2; re[2] = 1; re[3] = 3; re[4] = 3; re[5] = 1; re[6] = 3; re[7] = 3; re[234] = 1; re[235] = 1; re[236] = 1; re[237] = 3; re[238] = 1; re[239] = 3; re[240] = 1; re[242] = 1; re[243] = 3; re[248] = 3; re[249] = 1; re[255] = 1



def call_oled_128x64_v2_bricklet(ctx, argv):
	prog_prefix = 'call oled-128x64-v2-bricklet <uid>'

	def write_pixels_low_level(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-pixels-low-level')

		parser.add_argument('x_start', type=convert_int, help='int', metavar='<x-start>')
		parser.add_argument('y_start', type=convert_int, help='int', metavar='<y-start>')
		parser.add_argument('x_end', type=convert_int, help='int', metavar='<x-end>')
		parser.add_argument('y_end', type=convert_int, help='int', metavar='<y-end>')
		parser.add_argument('pixels_length', type=convert_int, help='int', metavar='<pixels-length>')
		parser.add_argument('pixels_chunk_offset', type=convert_int, help='int', metavar='<pixels-chunk-offset>')
		parser.add_argument('pixels_chunk_data', type=create_array_converter(ctx, convert_bool, 'false', 448), help=get_array_type_name(ctx, 'bool', 448), metavar='<pixels-chunk-data>')

		args = parser.parse_args(argv)

		device_call(ctx, OLED128x64V2Bricklet, 1, (args.x_start, args.y_start, args.x_end, args.y_end, args.pixels_length, args.pixels_chunk_offset, args.pixels_chunk_data), 'B B B B H H 448!', '', None, args.expect_response, [], [])

	def write_pixels(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-pixels')

		parser.add_argument('x_start', type=convert_int, help='int', metavar='<x-start>')
		parser.add_argument('y_start', type=convert_int, help='int', metavar='<y-start>')
		parser.add_argument('x_end', type=convert_int, help='int', metavar='<x-end>')
		parser.add_argument('y_end', type=convert_int, help='int', metavar='<y-end>')
		parser.add_argument('pixels', type=create_array_converter(ctx, convert_bool, None, -65535), help=get_array_type_name(ctx, 'bool', -65535), metavar='<pixels>')

		args = parser.parse_args(argv)

		device_stream_call(ctx, OLED128x64V2Bricklet, 1, 'in', (args.x_start, args.y_start, args.x_end, args.y_end, args.pixels), (None, None, None, None, 'stream_data'), (), (None, None, None, None, 'stream_length', 'stream_chunk_offset', 'stream_chunk_data'), (), 'B B B B H H 448!', '', None, args.expect_response, [], [], 'false', 448, None, False, False, None)

	def read_pixels_low_level(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-pixels-low-level')

		parser.add_argument('x_start', type=convert_int, help='int', metavar='<x-start>')
		parser.add_argument('y_start', type=convert_int, help='int', metavar='<y-start>')
		parser.add_argument('x_end', type=convert_int, help='int', metavar='<x-end>')
		parser.add_argument('y_end', type=convert_int, help='int', metavar='<y-end>')

		args = parser.parse_args(argv)

		device_call(ctx, OLED128x64V2Bricklet, 2, (args.x_start, args.y_start, args.x_end, args.y_end), 'B B B B', 'H H 480!', args.execute, False, ['pixels-length', 'pixels-chunk-offset', 'pixels-chunk-data'], [None, None, None])

	def read_pixels(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-pixels')

		parser.add_argument('x_start', type=convert_int, help='int', metavar='<x-start>')
		parser.add_argument('y_start', type=convert_int, help='int', metavar='<y-start>')
		parser.add_argument('x_end', type=convert_int, help='int', metavar='<x-end>')
		parser.add_argument('y_end', type=convert_int, help='int', metavar='<y-end>')

		args = parser.parse_args(argv)

		device_stream_call(ctx, OLED128x64V2Bricklet, 2, 'out', (args.x_start, args.y_start, args.x_end, args.y_end), (None, None, None, None), ('stream_data',), (None, None, None, None), ('stream_length', 'stream_chunk_offset', 'stream_chunk_data'), 'B B B B', 'H H 480!', args.execute, False, ['pixels'], [None], None, 480, None, False, False, None)

	def clear_display(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' clear-display')

		args = parser.parse_args(argv)

		device_call(ctx, OLED128x64V2Bricklet, 3, (), '', '', None, args.expect_response, [], [])

	def set_display_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-display-configuration')

		parser.add_argument('contrast', type=convert_int, help='int', metavar='<contrast>')
		parser.add_argument('invert', type=convert_bool, help='bool', metavar='<invert>')
		parser.add_argument('automatic_draw', type=convert_bool, help='bool', metavar='<automatic-draw>')

		args = parser.parse_args(argv)

		device_call(ctx, OLED128x64V2Bricklet, 4, (args.contrast, args.invert, args.automatic_draw), 'B ! !', '', None, args.expect_response, [], [])

	def get_display_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-display-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, OLED128x64V2Bricklet, 5, (), '', 'B ! !', args.execute, False, ['contrast', 'invert', 'automatic-draw'], [None, None, None])

	def write_line(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-line')

		parser.add_argument('line', type=convert_int, help='int', metavar='<line>')
		parser.add_argument('position', type=convert_int, help='int', metavar='<position>')
		parser.add_argument('text', type=create_string_converter(ctx, str, 22), help='string', metavar='<text>')

		args = parser.parse_args(argv)

		device_call(ctx, OLED128x64V2Bricklet, 6, (args.line, args.position, args.text), 'B B 22s', '', None, args.expect_response, [], [])

	def draw_buffered_frame(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' draw-buffered-frame')

		parser.add_argument('force_complete_redraw', type=convert_bool, help='bool', metavar='<force-complete-redraw>')

		args = parser.parse_args(argv)

		device_call(ctx, OLED128x64V2Bricklet, 7, (args.force_complete_redraw,), '!', '', None, args.expect_response, [], [])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, OLED128x64V2Bricklet, 234, (), '', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def set_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-bootloader-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'bootloader-mode-firmware-wait-for-reboot': 3, 'bootloader-mode-firmware': 1, 'bootloader-mode-firmware-wait-for-erase-and-reboot': 4, 'bootloader-mode-bootloader-wait-for-reboot': 2, 'bootloader-mode-bootloader': 0}), help='int (bootloader-mode-bootloader: 0, bootloader-mode-firmware: 1, bootloader-mode-bootloader-wait-for-reboot: 2, bootloader-mode-firmware-wait-for-reboot: 3, bootloader-mode-firmware-wait-for-erase-and-reboot: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, OLED128x64V2Bricklet, 235, (args.mode,), 'B', 'B', args.execute, False, ['status'], [{0: 'bootloader-status-ok', 1: 'bootloader-status-invalid-mode', 2: 'bootloader-status-no-change', 3: 'bootloader-status-entry-function-not-present', 4: 'bootloader-status-device-identifier-incorrect', 5: 'bootloader-status-crc-mismatch'}])

	def get_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-bootloader-mode')

		args = parser.parse_args(argv)

		device_call(ctx, OLED128x64V2Bricklet, 236, (), '', 'B', args.execute, False, ['mode'], [{0: 'bootloader-mode-bootloader', 1: 'bootloader-mode-firmware', 2: 'bootloader-mode-bootloader-wait-for-reboot', 3: 'bootloader-mode-firmware-wait-for-reboot', 4: 'bootloader-mode-firmware-wait-for-erase-and-reboot'}])

	def set_write_firmware_pointer(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-write-firmware-pointer')

		parser.add_argument('pointer', type=convert_int, help='int', metavar='<pointer>')

		args = parser.parse_args(argv)

		device_call(ctx, OLED128x64V2Bricklet, 237, (args.pointer,), 'I', '', None, args.expect_response, [], [])

	def write_firmware(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-firmware')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, OLED128x64V2Bricklet, 238, (args.data,), '64B', 'B', args.execute, False, ['status'], [None])

	def set_status_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'status-led-config-on': 1, 'status-led-config-show-heartbeat': 2, 'status-led-config-off': 0, 'status-led-config-show-status': 3}), help='int (status-led-config-off: 0, status-led-config-on: 1, status-led-config-show-heartbeat: 2, status-led-config-show-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, OLED128x64V2Bricklet, 239, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_status_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, OLED128x64V2Bricklet, 240, (), '', 'B', args.execute, False, ['config'], [{0: 'status-led-config-off', 1: 'status-led-config-on', 2: 'status-led-config-show-heartbeat', 3: 'status-led-config-show-status'}])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, OLED128x64V2Bricklet, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, OLED128x64V2Bricklet, 243, (), '', '', None, args.expect_response, [], [])

	def write_uid(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-uid')

		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')

		args = parser.parse_args(argv)

		device_call(ctx, OLED128x64V2Bricklet, 248, (args.uid,), 'I', '', None, args.expect_response, [], [])

	def read_uid(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-uid')

		args = parser.parse_args(argv)

		device_call(ctx, OLED128x64V2Bricklet, 249, (), '', 'I', args.execute, False, ['uid'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, OLED128x64V2Bricklet, argv)

	functions = {
	'write-pixels-low-level': write_pixels_low_level,
	'write-pixels': write_pixels,
	'read-pixels-low-level': read_pixels_low_level,
	'read-pixels': read_pixels,
	'clear-display': clear_display,
	'set-display-configuration': set_display_configuration,
	'get-display-configuration': get_display_configuration,
	'write-line': write_line,
	'draw-buffered-frame': draw_buffered_frame,
	'get-spitfp-error-count': get_spitfp_error_count,
	'set-bootloader-mode': set_bootloader_mode,
	'get-bootloader-mode': get_bootloader_mode,
	'set-write-firmware-pointer': set_write_firmware_pointer,
	'write-firmware': write_firmware,
	'set-status-led-config': set_status_led_config,
	'get-status-led-config': get_status_led_config,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'write-uid': write_uid,
	'read-uid': read_uid,
	'get-identity': get_identity
	}

	call_generic(ctx, 'oled-128x64-v2-bricklet', functions, argv)

def dispatch_oled_128x64_v2_bricklet(ctx, argv):
	prog_prefix = 'dispatch oled-128x64-v2-bricklet <uid>'


	callbacks = {

	}

	dispatch_generic(ctx, 'oled-128x64-v2-bricklet', callbacks, argv)

class OLED64x48Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 3; re[2] = 3; re[3] = 3; re[4] = 3; re[5] = 1; re[6] = 3; re[255] = 1



def call_oled_64x48_bricklet(ctx, argv):
	prog_prefix = 'call oled-64x48-bricklet <uid>'

	def write(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, OLED64x48Bricklet, 1, (args.data,), '64B', '', None, args.expect_response, [], [])

	def new_window(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' new-window')

		parser.add_argument('column_from', type=convert_int, help='int', metavar='<column-from>')
		parser.add_argument('column_to', type=convert_int, help='int', metavar='<column-to>')
		parser.add_argument('row_from', type=convert_int, help='int', metavar='<row-from>')
		parser.add_argument('row_to', type=convert_int, help='int', metavar='<row-to>')

		args = parser.parse_args(argv)

		device_call(ctx, OLED64x48Bricklet, 2, (args.column_from, args.column_to, args.row_from, args.row_to), 'B B B B', '', None, args.expect_response, [], [])

	def clear_display(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' clear-display')

		args = parser.parse_args(argv)

		device_call(ctx, OLED64x48Bricklet, 3, (), '', '', None, args.expect_response, [], [])

	def set_display_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-display-configuration')

		parser.add_argument('contrast', type=convert_int, help='int', metavar='<contrast>')
		parser.add_argument('invert', type=convert_bool, help='bool', metavar='<invert>')

		args = parser.parse_args(argv)

		device_call(ctx, OLED64x48Bricklet, 4, (args.contrast, args.invert), 'B !', '', None, args.expect_response, [], [])

	def get_display_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-display-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, OLED64x48Bricklet, 5, (), '', 'B !', args.execute, False, ['contrast', 'invert'], [None, None])

	def write_line(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-line')

		parser.add_argument('line', type=convert_int, help='int', metavar='<line>')
		parser.add_argument('position', type=convert_int, help='int', metavar='<position>')
		parser.add_argument('text', type=create_string_converter(ctx, str, 13), help='string', metavar='<text>')

		args = parser.parse_args(argv)

		device_call(ctx, OLED64x48Bricklet, 6, (args.line, args.position, args.text), 'B B 13s', '', None, args.expect_response, [], [])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, OLED64x48Bricklet, argv)

	functions = {
	'write': write,
	'new-window': new_window,
	'clear-display': clear_display,
	'set-display-configuration': set_display_configuration,
	'get-display-configuration': get_display_configuration,
	'write-line': write_line,
	'get-identity': get_identity
	}

	call_generic(ctx, 'oled-64x48-bricklet', functions, argv)

def dispatch_oled_64x48_bricklet(ctx, argv):
	prog_prefix = 'dispatch oled-64x48-bricklet <uid>'


	callbacks = {

	}

	dispatch_generic(ctx, 'oled-64x48-bricklet', callbacks, argv)

class OneWireBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 1; re[3] = 1; re[4] = 1; re[5] = 1; re[6] = 3; re[7] = 1; re[234] = 1; re[235] = 1; re[236] = 1; re[237] = 3; re[238] = 1; re[239] = 3; re[240] = 1; re[242] = 1; re[243] = 3; re[248] = 3; re[249] = 1; re[255] = 1



def call_one_wire_bricklet(ctx, argv):
	prog_prefix = 'call one-wire-bricklet <uid>'

	def search_bus_low_level(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' search-bus-low-level')

		args = parser.parse_args(argv)

		device_call(ctx, OneWireBricklet, 1, (), '', 'H H 7Q B', args.execute, False, ['identifier-length', 'identifier-chunk-offset', 'identifier-chunk-data', 'status'], [None, None, None, {0: 'status-ok', 1: 'status-busy', 2: 'status-no-presence', 3: 'status-timeout', 4: 'status-error'}])

	def search_bus(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' search-bus')

		args = parser.parse_args(argv)

		device_stream_call(ctx, OneWireBricklet, 1, 'out', (), (), ('stream_data', None), (), ('stream_length', 'stream_chunk_offset', 'stream_chunk_data', None), '', 'H H 7Q B', args.execute, False, ['identifier', 'status'], [None, {0: 'status-ok', 1: 'status-busy', 2: 'status-no-presence', 3: 'status-timeout', 4: 'status-error'}], None, 7, None, False, False, None)

	def reset_bus(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' reset-bus')

		args = parser.parse_args(argv)

		device_call(ctx, OneWireBricklet, 2, (), '', 'B', args.execute, False, ['status'], [{0: 'status-ok', 1: 'status-busy', 2: 'status-no-presence', 3: 'status-timeout', 4: 'status-error'}])

	def write(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write')

		parser.add_argument('data', type=convert_int, help='int', metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, OneWireBricklet, 3, (args.data,), 'B', 'B', args.execute, False, ['status'], [{0: 'status-ok', 1: 'status-busy', 2: 'status-no-presence', 3: 'status-timeout', 4: 'status-error'}])

	def read(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read')

		args = parser.parse_args(argv)

		device_call(ctx, OneWireBricklet, 4, (), '', 'B B', args.execute, False, ['data', 'status'], [None, {0: 'status-ok', 1: 'status-busy', 2: 'status-no-presence', 3: 'status-timeout', 4: 'status-error'}])

	def write_command(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-command')

		parser.add_argument('identifier', type=convert_int, help='int', metavar='<identifier>')
		parser.add_argument('command', type=convert_int, help='int', metavar='<command>')

		args = parser.parse_args(argv)

		device_call(ctx, OneWireBricklet, 5, (args.identifier, args.command), 'Q B', 'B', args.execute, False, ['status'], [{0: 'status-ok', 1: 'status-busy', 2: 'status-no-presence', 3: 'status-timeout', 4: 'status-error'}])

	def set_communication_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-communication-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'communication-led-config-show-communication': 3, 'communication-led-config-show-heartbeat': 2, 'communication-led-config-on': 1, 'communication-led-config-off': 0}), help='int (communication-led-config-off: 0, communication-led-config-on: 1, communication-led-config-show-heartbeat: 2, communication-led-config-show-communication: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, OneWireBricklet, 6, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_communication_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-communication-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, OneWireBricklet, 7, (), '', 'B', args.execute, False, ['config'], [{0: 'communication-led-config-off', 1: 'communication-led-config-on', 2: 'communication-led-config-show-heartbeat', 3: 'communication-led-config-show-communication'}])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, OneWireBricklet, 234, (), '', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def set_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-bootloader-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'bootloader-mode-firmware-wait-for-reboot': 3, 'bootloader-mode-firmware': 1, 'bootloader-mode-firmware-wait-for-erase-and-reboot': 4, 'bootloader-mode-bootloader-wait-for-reboot': 2, 'bootloader-mode-bootloader': 0}), help='int (bootloader-mode-bootloader: 0, bootloader-mode-firmware: 1, bootloader-mode-bootloader-wait-for-reboot: 2, bootloader-mode-firmware-wait-for-reboot: 3, bootloader-mode-firmware-wait-for-erase-and-reboot: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, OneWireBricklet, 235, (args.mode,), 'B', 'B', args.execute, False, ['status'], [{0: 'bootloader-status-ok', 1: 'bootloader-status-invalid-mode', 2: 'bootloader-status-no-change', 3: 'bootloader-status-entry-function-not-present', 4: 'bootloader-status-device-identifier-incorrect', 5: 'bootloader-status-crc-mismatch'}])

	def get_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-bootloader-mode')

		args = parser.parse_args(argv)

		device_call(ctx, OneWireBricklet, 236, (), '', 'B', args.execute, False, ['mode'], [{0: 'bootloader-mode-bootloader', 1: 'bootloader-mode-firmware', 2: 'bootloader-mode-bootloader-wait-for-reboot', 3: 'bootloader-mode-firmware-wait-for-reboot', 4: 'bootloader-mode-firmware-wait-for-erase-and-reboot'}])

	def set_write_firmware_pointer(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-write-firmware-pointer')

		parser.add_argument('pointer', type=convert_int, help='int', metavar='<pointer>')

		args = parser.parse_args(argv)

		device_call(ctx, OneWireBricklet, 237, (args.pointer,), 'I', '', None, args.expect_response, [], [])

	def write_firmware(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-firmware')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, OneWireBricklet, 238, (args.data,), '64B', 'B', args.execute, False, ['status'], [None])

	def set_status_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'status-led-config-on': 1, 'status-led-config-show-heartbeat': 2, 'status-led-config-off': 0, 'status-led-config-show-status': 3}), help='int (status-led-config-off: 0, status-led-config-on: 1, status-led-config-show-heartbeat: 2, status-led-config-show-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, OneWireBricklet, 239, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_status_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, OneWireBricklet, 240, (), '', 'B', args.execute, False, ['config'], [{0: 'status-led-config-off', 1: 'status-led-config-on', 2: 'status-led-config-show-heartbeat', 3: 'status-led-config-show-status'}])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, OneWireBricklet, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, OneWireBricklet, 243, (), '', '', None, args.expect_response, [], [])

	def write_uid(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-uid')

		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')

		args = parser.parse_args(argv)

		device_call(ctx, OneWireBricklet, 248, (args.uid,), 'I', '', None, args.expect_response, [], [])

	def read_uid(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-uid')

		args = parser.parse_args(argv)

		device_call(ctx, OneWireBricklet, 249, (), '', 'I', args.execute, False, ['uid'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, OneWireBricklet, argv)

	functions = {
	'search-bus-low-level': search_bus_low_level,
	'search-bus': search_bus,
	'reset-bus': reset_bus,
	'write': write,
	'read': read,
	'write-command': write_command,
	'set-communication-led-config': set_communication_led_config,
	'get-communication-led-config': get_communication_led_config,
	'get-spitfp-error-count': get_spitfp_error_count,
	'set-bootloader-mode': set_bootloader_mode,
	'get-bootloader-mode': get_bootloader_mode,
	'set-write-firmware-pointer': set_write_firmware_pointer,
	'write-firmware': write_firmware,
	'set-status-led-config': set_status_led_config,
	'get-status-led-config': get_status_led_config,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'write-uid': write_uid,
	'read-uid': read_uid,
	'get-identity': get_identity
	}

	call_generic(ctx, 'one-wire-bricklet', functions, argv)

def dispatch_one_wire_bricklet(ctx, argv):
	prog_prefix = 'dispatch one-wire-bricklet <uid>'


	callbacks = {

	}

	dispatch_generic(ctx, 'one-wire-bricklet', callbacks, argv)

class OutdoorWeatherBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 1; re[3] = 1; re[4] = 1; re[5] = 2; re[6] = 1; re[7] = 2; re[8] = 1; re[234] = 1; re[235] = 1; re[236] = 1; re[237] = 3; re[238] = 1; re[239] = 3; re[240] = 1; re[242] = 1; re[243] = 3; re[248] = 3; re[249] = 1; re[255] = 1
		cf = self.callback_formats
		cf[9] = 'B h B I I I B !'; cf[10] = 'B h B'


def call_outdoor_weather_bricklet(ctx, argv):
	prog_prefix = 'call outdoor-weather-bricklet <uid>'

	def get_station_identifiers_low_level(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-station-identifiers-low-level')

		args = parser.parse_args(argv)

		device_call(ctx, OutdoorWeatherBricklet, 1, (), '', 'H H 60B', args.execute, False, ['identifiers-length', 'identifiers-chunk-offset', 'identifiers-chunk-data'], [None, None, None])

	def get_station_identifiers(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-station-identifiers')

		args = parser.parse_args(argv)

		device_stream_call(ctx, OutdoorWeatherBricklet, 1, 'out', (), (), ('stream_data',), (), ('stream_length', 'stream_chunk_offset', 'stream_chunk_data'), '', 'H H 60B', args.execute, False, ['identifiers'], [None], None, 60, None, False, False, None)

	def get_sensor_identifiers_low_level(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-sensor-identifiers-low-level')

		args = parser.parse_args(argv)

		device_call(ctx, OutdoorWeatherBricklet, 2, (), '', 'H H 60B', args.execute, False, ['identifiers-length', 'identifiers-chunk-offset', 'identifiers-chunk-data'], [None, None, None])

	def get_sensor_identifiers(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-sensor-identifiers')

		args = parser.parse_args(argv)

		device_stream_call(ctx, OutdoorWeatherBricklet, 2, 'out', (), (), ('stream_data',), (), ('stream_length', 'stream_chunk_offset', 'stream_chunk_data'), '', 'H H 60B', args.execute, False, ['identifiers'], [None], None, 60, None, False, False, None)

	def get_station_data(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-station-data')

		parser.add_argument('identifier', type=convert_int, help='int', metavar='<identifier>')

		args = parser.parse_args(argv)

		device_call(ctx, OutdoorWeatherBricklet, 3, (args.identifier,), 'B', 'h B I I I B ! H', args.execute, False, ['temperature', 'humidity', 'wind-speed', 'gust-speed', 'rain', 'wind-direction', 'battery-low', 'last-change'], [None, None, None, None, None, {0: 'wind-direction-n', 1: 'wind-direction-nne', 2: 'wind-direction-ne', 3: 'wind-direction-ene', 4: 'wind-direction-e', 5: 'wind-direction-ese', 6: 'wind-direction-se', 7: 'wind-direction-sse', 8: 'wind-direction-s', 9: 'wind-direction-ssw', 10: 'wind-direction-sw', 11: 'wind-direction-wsw', 12: 'wind-direction-w', 13: 'wind-direction-wnw', 14: 'wind-direction-nw', 15: 'wind-direction-nnw', 255: 'wind-direction-error'}, None, None])

	def get_sensor_data(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-sensor-data')

		parser.add_argument('identifier', type=convert_int, help='int', metavar='<identifier>')

		args = parser.parse_args(argv)

		device_call(ctx, OutdoorWeatherBricklet, 4, (args.identifier,), 'B', 'h B H', args.execute, False, ['temperature', 'humidity', 'last-change'], [None, None, None])

	def set_station_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-station-callback-configuration')

		parser.add_argument('enable_callback', type=convert_bool, help='bool', metavar='<enable-callback>')

		args = parser.parse_args(argv)

		device_call(ctx, OutdoorWeatherBricklet, 5, (args.enable_callback,), '!', '', None, args.expect_response, [], [])

	def get_station_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-station-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, OutdoorWeatherBricklet, 6, (), '', '!', args.execute, False, ['enable-callback'], [None])

	def set_sensor_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-sensor-callback-configuration')

		parser.add_argument('enable_callback', type=convert_bool, help='bool', metavar='<enable-callback>')

		args = parser.parse_args(argv)

		device_call(ctx, OutdoorWeatherBricklet, 7, (args.enable_callback,), '!', '', None, args.expect_response, [], [])

	def get_sensor_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-sensor-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, OutdoorWeatherBricklet, 8, (), '', '!', args.execute, False, ['enable-callback'], [None])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, OutdoorWeatherBricklet, 234, (), '', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def set_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-bootloader-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'bootloader-mode-firmware-wait-for-reboot': 3, 'bootloader-mode-firmware': 1, 'bootloader-mode-firmware-wait-for-erase-and-reboot': 4, 'bootloader-mode-bootloader-wait-for-reboot': 2, 'bootloader-mode-bootloader': 0}), help='int (bootloader-mode-bootloader: 0, bootloader-mode-firmware: 1, bootloader-mode-bootloader-wait-for-reboot: 2, bootloader-mode-firmware-wait-for-reboot: 3, bootloader-mode-firmware-wait-for-erase-and-reboot: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, OutdoorWeatherBricklet, 235, (args.mode,), 'B', 'B', args.execute, False, ['status'], [{0: 'bootloader-status-ok', 1: 'bootloader-status-invalid-mode', 2: 'bootloader-status-no-change', 3: 'bootloader-status-entry-function-not-present', 4: 'bootloader-status-device-identifier-incorrect', 5: 'bootloader-status-crc-mismatch'}])

	def get_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-bootloader-mode')

		args = parser.parse_args(argv)

		device_call(ctx, OutdoorWeatherBricklet, 236, (), '', 'B', args.execute, False, ['mode'], [{0: 'bootloader-mode-bootloader', 1: 'bootloader-mode-firmware', 2: 'bootloader-mode-bootloader-wait-for-reboot', 3: 'bootloader-mode-firmware-wait-for-reboot', 4: 'bootloader-mode-firmware-wait-for-erase-and-reboot'}])

	def set_write_firmware_pointer(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-write-firmware-pointer')

		parser.add_argument('pointer', type=convert_int, help='int', metavar='<pointer>')

		args = parser.parse_args(argv)

		device_call(ctx, OutdoorWeatherBricklet, 237, (args.pointer,), 'I', '', None, args.expect_response, [], [])

	def write_firmware(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-firmware')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, OutdoorWeatherBricklet, 238, (args.data,), '64B', 'B', args.execute, False, ['status'], [None])

	def set_status_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'status-led-config-on': 1, 'status-led-config-show-heartbeat': 2, 'status-led-config-off': 0, 'status-led-config-show-status': 3}), help='int (status-led-config-off: 0, status-led-config-on: 1, status-led-config-show-heartbeat: 2, status-led-config-show-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, OutdoorWeatherBricklet, 239, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_status_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, OutdoorWeatherBricklet, 240, (), '', 'B', args.execute, False, ['config'], [{0: 'status-led-config-off', 1: 'status-led-config-on', 2: 'status-led-config-show-heartbeat', 3: 'status-led-config-show-status'}])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, OutdoorWeatherBricklet, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, OutdoorWeatherBricklet, 243, (), '', '', None, args.expect_response, [], [])

	def write_uid(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-uid')

		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')

		args = parser.parse_args(argv)

		device_call(ctx, OutdoorWeatherBricklet, 248, (args.uid,), 'I', '', None, args.expect_response, [], [])

	def read_uid(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-uid')

		args = parser.parse_args(argv)

		device_call(ctx, OutdoorWeatherBricklet, 249, (), '', 'I', args.execute, False, ['uid'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, OutdoorWeatherBricklet, argv)

	functions = {
	'get-station-identifiers-low-level': get_station_identifiers_low_level,
	'get-station-identifiers': get_station_identifiers,
	'get-sensor-identifiers-low-level': get_sensor_identifiers_low_level,
	'get-sensor-identifiers': get_sensor_identifiers,
	'get-station-data': get_station_data,
	'get-sensor-data': get_sensor_data,
	'set-station-callback-configuration': set_station_callback_configuration,
	'get-station-callback-configuration': get_station_callback_configuration,
	'set-sensor-callback-configuration': set_sensor_callback_configuration,
	'get-sensor-callback-configuration': get_sensor_callback_configuration,
	'get-spitfp-error-count': get_spitfp_error_count,
	'set-bootloader-mode': set_bootloader_mode,
	'get-bootloader-mode': get_bootloader_mode,
	'set-write-firmware-pointer': set_write_firmware_pointer,
	'write-firmware': write_firmware,
	'set-status-led-config': set_status_led_config,
	'get-status-led-config': get_status_led_config,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'write-uid': write_uid,
	'read-uid': read_uid,
	'get-identity': get_identity
	}

	call_generic(ctx, 'outdoor-weather-bricklet', functions, argv)

def dispatch_outdoor_weather_bricklet(ctx, argv):
	prog_prefix = 'dispatch outdoor-weather-bricklet <uid>'

	def station_data(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' station-data')

		args = parser.parse_args(argv)

		device_dispatch(ctx, OutdoorWeatherBricklet, 9, args.execute, ['identifier', 'temperature', 'humidity', 'wind-speed', 'gust-speed', 'rain', 'wind-direction', 'battery-low'], [None, None, None, None, None, None, {0: 'wind-direction-n', 1: 'wind-direction-nne', 2: 'wind-direction-ne', 3: 'wind-direction-ene', 4: 'wind-direction-e', 5: 'wind-direction-ese', 6: 'wind-direction-se', 7: 'wind-direction-sse', 8: 'wind-direction-s', 9: 'wind-direction-ssw', 10: 'wind-direction-sw', 11: 'wind-direction-wsw', 12: 'wind-direction-w', 13: 'wind-direction-wnw', 14: 'wind-direction-nw', 15: 'wind-direction-nnw', 255: 'wind-direction-error'}, None])

	def sensor_data(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' sensor-data')

		args = parser.parse_args(argv)

		device_dispatch(ctx, OutdoorWeatherBricklet, 10, args.execute, ['identifier', 'temperature', 'humidity'], [None, None, None])

	callbacks = {
	'station-data': station_data,
	'sensor-data': sensor_data
	}

	dispatch_generic(ctx, 'outdoor-weather-bricklet', callbacks, argv)

class ParticulateMatterBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 1; re[3] = 3; re[4] = 1; re[5] = 1; re[6] = 2; re[7] = 1; re[8] = 2; re[9] = 1; re[234] = 1; re[235] = 1; re[236] = 1; re[237] = 3; re[238] = 1; re[239] = 3; re[240] = 1; re[242] = 1; re[243] = 3; re[248] = 3; re[249] = 1; re[255] = 1
		cf = self.callback_formats
		cf[10] = 'H H H'; cf[11] = 'H H H H H H'


def call_particulate_matter_bricklet(ctx, argv):
	prog_prefix = 'call particulate-matter-bricklet <uid>'

	def get_pm_concentration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-pm-concentration')

		args = parser.parse_args(argv)

		device_call(ctx, ParticulateMatterBricklet, 1, (), '', 'H H H', args.execute, False, ['pm10', 'pm25', 'pm100'], [None, None, None])

	def get_pm_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-pm-count')

		args = parser.parse_args(argv)

		device_call(ctx, ParticulateMatterBricklet, 2, (), '', 'H H H H H H', args.execute, False, ['greater03um', 'greater05um', 'greater10um', 'greater25um', 'greater50um', 'greater100um'], [None, None, None, None, None, None])

	def set_enable(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-enable')

		parser.add_argument('enable', type=convert_bool, help='bool', metavar='<enable>')

		args = parser.parse_args(argv)

		device_call(ctx, ParticulateMatterBricklet, 3, (args.enable,), '!', '', None, args.expect_response, [], [])

	def get_enable(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-enable')

		args = parser.parse_args(argv)

		device_call(ctx, ParticulateMatterBricklet, 4, (), '', '!', args.execute, False, ['enable'], [None])

	def get_sensor_info(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-sensor-info')

		args = parser.parse_args(argv)

		device_call(ctx, ParticulateMatterBricklet, 5, (), '', 'B B B B', args.execute, False, ['sensor-version', 'last-error-code', 'framing-error-count', 'checksum-error-count'], [None, None, None, None])

	def set_pm_concentration_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-pm-concentration-callback-configuration')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')

		args = parser.parse_args(argv)

		device_call(ctx, ParticulateMatterBricklet, 6, (args.period, args.value_has_to_change), 'I !', '', None, args.expect_response, [], [])

	def get_pm_concentration_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-pm-concentration-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, ParticulateMatterBricklet, 7, (), '', 'I !', args.execute, False, ['period', 'value-has-to-change'], [None, None])

	def set_pm_count_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-pm-count-callback-configuration')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')

		args = parser.parse_args(argv)

		device_call(ctx, ParticulateMatterBricklet, 8, (args.period, args.value_has_to_change), 'I !', '', None, args.expect_response, [], [])

	def get_pm_count_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-pm-count-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, ParticulateMatterBricklet, 9, (), '', 'I !', args.execute, False, ['period', 'value-has-to-change'], [None, None])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, ParticulateMatterBricklet, 234, (), '', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def set_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-bootloader-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'bootloader-mode-firmware-wait-for-reboot': 3, 'bootloader-mode-firmware': 1, 'bootloader-mode-firmware-wait-for-erase-and-reboot': 4, 'bootloader-mode-bootloader-wait-for-reboot': 2, 'bootloader-mode-bootloader': 0}), help='int (bootloader-mode-bootloader: 0, bootloader-mode-firmware: 1, bootloader-mode-bootloader-wait-for-reboot: 2, bootloader-mode-firmware-wait-for-reboot: 3, bootloader-mode-firmware-wait-for-erase-and-reboot: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, ParticulateMatterBricklet, 235, (args.mode,), 'B', 'B', args.execute, False, ['status'], [{0: 'bootloader-status-ok', 1: 'bootloader-status-invalid-mode', 2: 'bootloader-status-no-change', 3: 'bootloader-status-entry-function-not-present', 4: 'bootloader-status-device-identifier-incorrect', 5: 'bootloader-status-crc-mismatch'}])

	def get_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-bootloader-mode')

		args = parser.parse_args(argv)

		device_call(ctx, ParticulateMatterBricklet, 236, (), '', 'B', args.execute, False, ['mode'], [{0: 'bootloader-mode-bootloader', 1: 'bootloader-mode-firmware', 2: 'bootloader-mode-bootloader-wait-for-reboot', 3: 'bootloader-mode-firmware-wait-for-reboot', 4: 'bootloader-mode-firmware-wait-for-erase-and-reboot'}])

	def set_write_firmware_pointer(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-write-firmware-pointer')

		parser.add_argument('pointer', type=convert_int, help='int', metavar='<pointer>')

		args = parser.parse_args(argv)

		device_call(ctx, ParticulateMatterBricklet, 237, (args.pointer,), 'I', '', None, args.expect_response, [], [])

	def write_firmware(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-firmware')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, ParticulateMatterBricklet, 238, (args.data,), '64B', 'B', args.execute, False, ['status'], [None])

	def set_status_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'status-led-config-on': 1, 'status-led-config-show-heartbeat': 2, 'status-led-config-off': 0, 'status-led-config-show-status': 3}), help='int (status-led-config-off: 0, status-led-config-on: 1, status-led-config-show-heartbeat: 2, status-led-config-show-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, ParticulateMatterBricklet, 239, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_status_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, ParticulateMatterBricklet, 240, (), '', 'B', args.execute, False, ['config'], [{0: 'status-led-config-off', 1: 'status-led-config-on', 2: 'status-led-config-show-heartbeat', 3: 'status-led-config-show-status'}])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, ParticulateMatterBricklet, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, ParticulateMatterBricklet, 243, (), '', '', None, args.expect_response, [], [])

	def write_uid(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-uid')

		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')

		args = parser.parse_args(argv)

		device_call(ctx, ParticulateMatterBricklet, 248, (args.uid,), 'I', '', None, args.expect_response, [], [])

	def read_uid(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-uid')

		args = parser.parse_args(argv)

		device_call(ctx, ParticulateMatterBricklet, 249, (), '', 'I', args.execute, False, ['uid'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, ParticulateMatterBricklet, argv)

	functions = {
	'get-pm-concentration': get_pm_concentration,
	'get-pm-count': get_pm_count,
	'set-enable': set_enable,
	'get-enable': get_enable,
	'get-sensor-info': get_sensor_info,
	'set-pm-concentration-callback-configuration': set_pm_concentration_callback_configuration,
	'get-pm-concentration-callback-configuration': get_pm_concentration_callback_configuration,
	'set-pm-count-callback-configuration': set_pm_count_callback_configuration,
	'get-pm-count-callback-configuration': get_pm_count_callback_configuration,
	'get-spitfp-error-count': get_spitfp_error_count,
	'set-bootloader-mode': set_bootloader_mode,
	'get-bootloader-mode': get_bootloader_mode,
	'set-write-firmware-pointer': set_write_firmware_pointer,
	'write-firmware': write_firmware,
	'set-status-led-config': set_status_led_config,
	'get-status-led-config': get_status_led_config,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'write-uid': write_uid,
	'read-uid': read_uid,
	'get-identity': get_identity
	}

	call_generic(ctx, 'particulate-matter-bricklet', functions, argv)

def dispatch_particulate_matter_bricklet(ctx, argv):
	prog_prefix = 'dispatch particulate-matter-bricklet <uid>'

	def pm_concentration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' pm-concentration')

		args = parser.parse_args(argv)

		device_dispatch(ctx, ParticulateMatterBricklet, 10, args.execute, ['pm10', 'pm25', 'pm100'], [None, None, None])

	def pm_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' pm-count')

		args = parser.parse_args(argv)

		device_dispatch(ctx, ParticulateMatterBricklet, 11, args.execute, ['greater03um', 'greater05um', 'greater10um', 'greater25um', 'greater50um', 'greater100um'], [None, None, None, None, None, None])

	callbacks = {
	'pm-concentration': pm_concentration,
	'pm-count': pm_count
	}

	dispatch_generic(ctx, 'particulate-matter-bricklet', callbacks, argv)

class PiezoBuzzerBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 3; re[2] = 3; re[255] = 1
		cf = self.callback_formats
		cf[3] = ''; cf[4] = ''


def call_piezo_buzzer_bricklet(ctx, argv):
	prog_prefix = 'call piezo-buzzer-bricklet <uid>'

	def beep(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' beep')

		parser.add_argument('duration', type=convert_int, help='int', metavar='<duration>')

		args = parser.parse_args(argv)

		device_call(ctx, PiezoBuzzerBricklet, 1, (args.duration,), 'I', '', None, args.expect_response, [], [])

	def morse_code(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' morse-code')

		parser.add_argument('morse', type=create_string_converter(ctx, str, 60), help='string', metavar='<morse>')

		args = parser.parse_args(argv)

		device_call(ctx, PiezoBuzzerBricklet, 2, (args.morse,), '60s', '', None, args.expect_response, [], [])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, PiezoBuzzerBricklet, argv)

	functions = {
	'beep': beep,
	'morse-code': morse_code,
	'get-identity': get_identity
	}

	call_generic(ctx, 'piezo-buzzer-bricklet', functions, argv)

def dispatch_piezo_buzzer_bricklet(ctx, argv):
	prog_prefix = 'dispatch piezo-buzzer-bricklet <uid>'

	def beep_finished(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' beep-finished')

		args = parser.parse_args(argv)

		device_dispatch(ctx, PiezoBuzzerBricklet, 3, args.execute, [], [])

	def morse_code_finished(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' morse-code-finished')

		args = parser.parse_args(argv)

		device_dispatch(ctx, PiezoBuzzerBricklet, 4, args.execute, [], [])

	callbacks = {
	'beep-finished': beep_finished,
	'morse-code-finished': morse_code_finished
	}

	dispatch_generic(ctx, 'piezo-buzzer-bricklet', callbacks, argv)

class PiezoSpeakerBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 3; re[2] = 3; re[3] = 1; re[255] = 1
		cf = self.callback_formats
		cf[4] = ''; cf[5] = ''


def call_piezo_speaker_bricklet(ctx, argv):
	prog_prefix = 'call piezo-speaker-bricklet <uid>'

	def beep(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' beep')

		parser.add_argument('duration', type=create_symbol_converter(ctx, convert_int, {'beep-duration-off': 0, 'beep-duration-infinite': 4294967295}), help='int (beep-duration-off: 0, beep-duration-infinite: 4294967295)', metavar='<duration>')
		parser.add_argument('frequency', type=convert_int, help='int', metavar='<frequency>')

		args = parser.parse_args(argv)

		device_call(ctx, PiezoSpeakerBricklet, 1, (args.duration, args.frequency), 'I H', '', None, args.expect_response, [], [])

	def morse_code(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' morse-code')

		parser.add_argument('morse', type=create_string_converter(ctx, str, 60), help='string', metavar='<morse>')
		parser.add_argument('frequency', type=convert_int, help='int', metavar='<frequency>')

		args = parser.parse_args(argv)

		device_call(ctx, PiezoSpeakerBricklet, 2, (args.morse, args.frequency), '60s H', '', None, args.expect_response, [], [])

	def calibrate(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' calibrate')

		args = parser.parse_args(argv)

		device_call(ctx, PiezoSpeakerBricklet, 3, (), '', '!', args.execute, False, ['calibration'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, PiezoSpeakerBricklet, argv)

	functions = {
	'beep': beep,
	'morse-code': morse_code,
	'calibrate': calibrate,
	'get-identity': get_identity
	}

	call_generic(ctx, 'piezo-speaker-bricklet', functions, argv)

def dispatch_piezo_speaker_bricklet(ctx, argv):
	prog_prefix = 'dispatch piezo-speaker-bricklet <uid>'

	def beep_finished(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' beep-finished')

		args = parser.parse_args(argv)

		device_dispatch(ctx, PiezoSpeakerBricklet, 4, args.execute, [], [])

	def morse_code_finished(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' morse-code-finished')

		args = parser.parse_args(argv)

		device_dispatch(ctx, PiezoSpeakerBricklet, 5, args.execute, [], [])

	callbacks = {
	'beep-finished': beep_finished,
	'morse-code-finished': morse_code_finished
	}

	dispatch_generic(ctx, 'piezo-speaker-bricklet', callbacks, argv)

class PiezoSpeakerV2Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 3; re[2] = 1; re[3] = 3; re[4] = 1; re[5] = 3; re[6] = 3; re[234] = 1; re[235] = 1; re[236] = 1; re[237] = 3; re[238] = 1; re[239] = 3; re[240] = 1; re[242] = 1; re[243] = 3; re[248] = 3; re[249] = 1; re[255] = 1
		cf = self.callback_formats
		cf[7] = ''; cf[8] = ''


def call_piezo_speaker_v2_bricklet(ctx, argv):
	prog_prefix = 'call piezo-speaker-v2-bricklet <uid>'

	def set_beep(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-beep')

		parser.add_argument('frequency', type=convert_int, help='int', metavar='<frequency>')
		parser.add_argument('volume', type=convert_int, help='int', metavar='<volume>')
		parser.add_argument('duration', type=create_symbol_converter(ctx, convert_int, {'beep-duration-off': 0, 'beep-duration-infinite': 4294967295}), help='int (beep-duration-off: 0, beep-duration-infinite: 4294967295)', metavar='<duration>')

		args = parser.parse_args(argv)

		device_call(ctx, PiezoSpeakerV2Bricklet, 1, (args.frequency, args.volume, args.duration), 'H B I', '', None, args.expect_response, [], [])

	def get_beep(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-beep')

		args = parser.parse_args(argv)

		device_call(ctx, PiezoSpeakerV2Bricklet, 2, (), '', 'H B I I', args.execute, False, ['frequency', 'volume', 'duration', 'duration-remaining'], [None, None, {0: 'beep-duration-off', 4294967295: 'beep-duration-infinite'}, None])

	def set_alarm(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-alarm')

		parser.add_argument('start_frequency', type=convert_int, help='int', metavar='<start-frequency>')
		parser.add_argument('end_frequency', type=convert_int, help='int', metavar='<end-frequency>')
		parser.add_argument('step_size', type=convert_int, help='int', metavar='<step-size>')
		parser.add_argument('step_delay', type=convert_int, help='int', metavar='<step-delay>')
		parser.add_argument('volume', type=convert_int, help='int', metavar='<volume>')
		parser.add_argument('duration', type=create_symbol_converter(ctx, convert_int, {'alarm-duration-infinite': 4294967295, 'alarm-duration-off': 0}), help='int (alarm-duration-off: 0, alarm-duration-infinite: 4294967295)', metavar='<duration>')

		args = parser.parse_args(argv)

		device_call(ctx, PiezoSpeakerV2Bricklet, 3, (args.start_frequency, args.end_frequency, args.step_size, args.step_delay, args.volume, args.duration), 'H H H H B I', '', None, args.expect_response, [], [])

	def get_alarm(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-alarm')

		args = parser.parse_args(argv)

		device_call(ctx, PiezoSpeakerV2Bricklet, 4, (), '', 'H H H H B I I H', args.execute, False, ['start-frequency', 'end-frequency', 'step-size', 'step-delay', 'volume', 'duration', 'duration-remaining', 'current-frequency'], [None, None, None, None, None, {0: 'alarm-duration-off', 4294967295: 'alarm-duration-infinite'}, None, None])

	def update_volume(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' update-volume')

		parser.add_argument('volume', type=convert_int, help='int', metavar='<volume>')

		args = parser.parse_args(argv)

		device_call(ctx, PiezoSpeakerV2Bricklet, 5, (args.volume,), 'B', '', None, args.expect_response, [], [])

	def update_frequency(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' update-frequency')

		parser.add_argument('frequency', type=convert_int, help='int', metavar='<frequency>')

		args = parser.parse_args(argv)

		device_call(ctx, PiezoSpeakerV2Bricklet, 6, (args.frequency,), 'H', '', None, args.expect_response, [], [])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, PiezoSpeakerV2Bricklet, 234, (), '', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def set_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-bootloader-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'bootloader-mode-firmware-wait-for-reboot': 3, 'bootloader-mode-firmware': 1, 'bootloader-mode-firmware-wait-for-erase-and-reboot': 4, 'bootloader-mode-bootloader-wait-for-reboot': 2, 'bootloader-mode-bootloader': 0}), help='int (bootloader-mode-bootloader: 0, bootloader-mode-firmware: 1, bootloader-mode-bootloader-wait-for-reboot: 2, bootloader-mode-firmware-wait-for-reboot: 3, bootloader-mode-firmware-wait-for-erase-and-reboot: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, PiezoSpeakerV2Bricklet, 235, (args.mode,), 'B', 'B', args.execute, False, ['status'], [{0: 'bootloader-status-ok', 1: 'bootloader-status-invalid-mode', 2: 'bootloader-status-no-change', 3: 'bootloader-status-entry-function-not-present', 4: 'bootloader-status-device-identifier-incorrect', 5: 'bootloader-status-crc-mismatch'}])

	def get_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-bootloader-mode')

		args = parser.parse_args(argv)

		device_call(ctx, PiezoSpeakerV2Bricklet, 236, (), '', 'B', args.execute, False, ['mode'], [{0: 'bootloader-mode-bootloader', 1: 'bootloader-mode-firmware', 2: 'bootloader-mode-bootloader-wait-for-reboot', 3: 'bootloader-mode-firmware-wait-for-reboot', 4: 'bootloader-mode-firmware-wait-for-erase-and-reboot'}])

	def set_write_firmware_pointer(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-write-firmware-pointer')

		parser.add_argument('pointer', type=convert_int, help='int', metavar='<pointer>')

		args = parser.parse_args(argv)

		device_call(ctx, PiezoSpeakerV2Bricklet, 237, (args.pointer,), 'I', '', None, args.expect_response, [], [])

	def write_firmware(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-firmware')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, PiezoSpeakerV2Bricklet, 238, (args.data,), '64B', 'B', args.execute, False, ['status'], [None])

	def set_status_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'status-led-config-on': 1, 'status-led-config-show-heartbeat': 2, 'status-led-config-off': 0, 'status-led-config-show-status': 3}), help='int (status-led-config-off: 0, status-led-config-on: 1, status-led-config-show-heartbeat: 2, status-led-config-show-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, PiezoSpeakerV2Bricklet, 239, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_status_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, PiezoSpeakerV2Bricklet, 240, (), '', 'B', args.execute, False, ['config'], [{0: 'status-led-config-off', 1: 'status-led-config-on', 2: 'status-led-config-show-heartbeat', 3: 'status-led-config-show-status'}])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, PiezoSpeakerV2Bricklet, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, PiezoSpeakerV2Bricklet, 243, (), '', '', None, args.expect_response, [], [])

	def write_uid(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-uid')

		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')

		args = parser.parse_args(argv)

		device_call(ctx, PiezoSpeakerV2Bricklet, 248, (args.uid,), 'I', '', None, args.expect_response, [], [])

	def read_uid(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-uid')

		args = parser.parse_args(argv)

		device_call(ctx, PiezoSpeakerV2Bricklet, 249, (), '', 'I', args.execute, False, ['uid'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, PiezoSpeakerV2Bricklet, argv)

	functions = {
	'set-beep': set_beep,
	'get-beep': get_beep,
	'set-alarm': set_alarm,
	'get-alarm': get_alarm,
	'update-volume': update_volume,
	'update-frequency': update_frequency,
	'get-spitfp-error-count': get_spitfp_error_count,
	'set-bootloader-mode': set_bootloader_mode,
	'get-bootloader-mode': get_bootloader_mode,
	'set-write-firmware-pointer': set_write_firmware_pointer,
	'write-firmware': write_firmware,
	'set-status-led-config': set_status_led_config,
	'get-status-led-config': get_status_led_config,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'write-uid': write_uid,
	'read-uid': read_uid,
	'get-identity': get_identity
	}

	call_generic(ctx, 'piezo-speaker-v2-bricklet', functions, argv)

def dispatch_piezo_speaker_v2_bricklet(ctx, argv):
	prog_prefix = 'dispatch piezo-speaker-v2-bricklet <uid>'

	def beep_finished(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' beep-finished')

		args = parser.parse_args(argv)

		device_dispatch(ctx, PiezoSpeakerV2Bricklet, 7, args.execute, [], [])

	def alarm_finished(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' alarm-finished')

		args = parser.parse_args(argv)

		device_dispatch(ctx, PiezoSpeakerV2Bricklet, 8, args.execute, [], [])

	callbacks = {
	'beep-finished': beep_finished,
	'alarm-finished': alarm_finished
	}

	dispatch_generic(ctx, 'piezo-speaker-v2-bricklet', callbacks, argv)

class PTCBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 1; re[3] = 2; re[4] = 1; re[5] = 2; re[6] = 1; re[7] = 2; re[8] = 1; re[9] = 2; re[10] = 1; re[11] = 2; re[12] = 1; re[17] = 3; re[18] = 1; re[19] = 1; re[20] = 3; re[21] = 1; re[22] = 2; re[23] = 1; re[255] = 1
		cf = self.callback_formats
		cf[13] = 'i'; cf[14] = 'i'; cf[15] = 'i'; cf[16] = 'i'; cf[24] = '!'


def call_ptc_bricklet(ctx, argv):
	prog_prefix = 'call ptc-bricklet <uid>'

	def get_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, PTCBricklet, 1, (), '', 'i', args.execute, False, ['temperature'], [None])

	def get_resistance(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-resistance')

		args = parser.parse_args(argv)

		device_call(ctx, PTCBricklet, 2, (), '', 'i', args.execute, False, ['resistance'], [None])

	def set_temperature_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-temperature-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, PTCBricklet, 3, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_temperature_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-temperature-callback-period')

		args = parser.parse_args(argv)

		device_call(ctx, PTCBricklet, 4, (), '', 'I', args.execute, False, ['period'], [None])

	def set_resistance_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-resistance-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, PTCBricklet, 5, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_resistance_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-resistance-callback-period')

		args = parser.parse_args(argv)

		device_call(ctx, PTCBricklet, 6, (), '', 'I', args.execute, False, ['period'], [None])

	def set_temperature_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-temperature-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, PTCBricklet, 7, (args.option, args.min, args.max), 'c i i', '', None, args.expect_response, [], [])

	def get_temperature_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-temperature-callback-threshold')

		args = parser.parse_args(argv)

		device_call(ctx, PTCBricklet, 8, (), '', 'c i i', args.execute, False, ['option', 'min', 'max'], [{'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def set_resistance_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-resistance-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, PTCBricklet, 9, (args.option, args.min, args.max), 'c i i', '', None, args.expect_response, [], [])

	def get_resistance_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-resistance-callback-threshold')

		args = parser.parse_args(argv)

		device_call(ctx, PTCBricklet, 10, (), '', 'c i i', args.execute, False, ['option', 'min', 'max'], [{'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def set_debounce_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-debounce-period')

		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_call(ctx, PTCBricklet, 11, (args.debounce,), 'I', '', None, args.expect_response, [], [])

	def get_debounce_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-debounce-period')

		args = parser.parse_args(argv)

		device_call(ctx, PTCBricklet, 12, (), '', 'I', args.execute, False, ['debounce'], [None])

	def set_noise_rejection_filter(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-noise-rejection-filter')

		parser.add_argument('filter', type=create_symbol_converter(ctx, convert_int, {'filter-option-50hz': 0, 'filter-option-60hz': 1}), help='int (filter-option-50hz: 0, filter-option-60hz: 1)', metavar='<filter>')

		args = parser.parse_args(argv)

		device_call(ctx, PTCBricklet, 17, (args.filter,), 'B', '', None, args.expect_response, [], [])

	def get_noise_rejection_filter(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-noise-rejection-filter')

		args = parser.parse_args(argv)

		device_call(ctx, PTCBricklet, 18, (), '', 'B', args.execute, False, ['filter'], [{0: 'filter-option-50hz', 1: 'filter-option-60hz'}])

	def is_sensor_connected(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' is-sensor-connected')

		args = parser.parse_args(argv)

		device_call(ctx, PTCBricklet, 19, (), '', '!', args.execute, False, ['connected'], [None])

	def set_wire_mode(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-wire-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'wire-mode-3': 3, 'wire-mode-2': 2, 'wire-mode-4': 4}), help='int (wire-mode-2: 2, wire-mode-3: 3, wire-mode-4: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, PTCBricklet, 20, (args.mode,), 'B', '', None, args.expect_response, [], [])

	def get_wire_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-wire-mode')

		args = parser.parse_args(argv)

		device_call(ctx, PTCBricklet, 21, (), '', 'B', args.execute, False, ['mode'], [{2: 'wire-mode-2', 3: 'wire-mode-3', 4: 'wire-mode-4'}])

	def set_sensor_connected_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-sensor-connected-callback-configuration')

		parser.add_argument('enabled', type=convert_bool, help='bool', metavar='<enabled>')

		args = parser.parse_args(argv)

		device_call(ctx, PTCBricklet, 22, (args.enabled,), '!', '', None, args.expect_response, [], [])

	def get_sensor_connected_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-sensor-connected-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, PTCBricklet, 23, (), '', '!', args.execute, False, ['enabled'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, PTCBricklet, argv)

	functions = {
	'get-temperature': get_temperature,
	'get-resistance': get_resistance,
	'set-temperature-callback-period': set_temperature_callback_period,
	'get-temperature-callback-period': get_temperature_callback_period,
	'set-resistance-callback-period': set_resistance_callback_period,
	'get-resistance-callback-period': get_resistance_callback_period,
	'set-temperature-callback-threshold': set_temperature_callback_threshold,
	'get-temperature-callback-threshold': get_temperature_callback_threshold,
	'set-resistance-callback-threshold': set_resistance_callback_threshold,
	'get-resistance-callback-threshold': get_resistance_callback_threshold,
	'set-debounce-period': set_debounce_period,
	'get-debounce-period': get_debounce_period,
	'set-noise-rejection-filter': set_noise_rejection_filter,
	'get-noise-rejection-filter': get_noise_rejection_filter,
	'is-sensor-connected': is_sensor_connected,
	'set-wire-mode': set_wire_mode,
	'get-wire-mode': get_wire_mode,
	'set-sensor-connected-callback-configuration': set_sensor_connected_callback_configuration,
	'get-sensor-connected-callback-configuration': get_sensor_connected_callback_configuration,
	'get-identity': get_identity
	}

	call_generic(ctx, 'ptc-bricklet', functions, argv)

def dispatch_ptc_bricklet(ctx, argv):
	prog_prefix = 'dispatch ptc-bricklet <uid>'

	def temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' temperature')

		args = parser.parse_args(argv)

		device_dispatch(ctx, PTCBricklet, 13, args.execute, ['temperature'], [None])

	def temperature_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' temperature-reached')

		args = parser.parse_args(argv)

		device_dispatch(ctx, PTCBricklet, 14, args.execute, ['temperature'], [None])

	def resistance(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' resistance')

		args = parser.parse_args(argv)

		device_dispatch(ctx, PTCBricklet, 15, args.execute, ['resistance'], [None])

	def resistance_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' resistance-reached')

		args = parser.parse_args(argv)

		device_dispatch(ctx, PTCBricklet, 16, args.execute, ['resistance'], [None])

	def sensor_connected(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' sensor-connected')

		args = parser.parse_args(argv)

		device_dispatch(ctx, PTCBricklet, 24, args.execute, ['connected'], [None])

	callbacks = {
	'temperature': temperature,
	'temperature-reached': temperature_reached,
	'resistance': resistance,
	'resistance-reached': resistance_reached,
	'sensor-connected': sensor_connected
	}

	dispatch_generic(ctx, 'ptc-bricklet', callbacks, argv)

class PTCV2Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 2; re[3] = 1; re[5] = 1; re[6] = 2; re[7] = 1; re[9] = 3; re[10] = 1; re[11] = 1; re[12] = 3; re[13] = 1; re[14] = 3; re[15] = 1; re[16] = 2; re[17] = 1; re[234] = 1; re[235] = 1; re[236] = 1; re[237] = 3; re[238] = 1; re[239] = 3; re[240] = 1; re[242] = 1; re[243] = 3; re[248] = 3; re[249] = 1; re[255] = 1
		cf = self.callback_formats
		cf[4] = 'i'; cf[8] = 'i'; cf[18] = '!'


def call_ptc_v2_bricklet(ctx, argv):
	prog_prefix = 'call ptc-v2-bricklet <uid>'

	def get_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, PTCV2Bricklet, 1, (), '', 'i', args.execute, False, ['temperature'], [None])

	def set_temperature_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-temperature-callback-configuration')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')
		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, PTCV2Bricklet, 2, (args.period, args.value_has_to_change, args.option, args.min, args.max), 'I ! c i i', '', None, args.expect_response, [], [])

	def get_temperature_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-temperature-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, PTCV2Bricklet, 3, (), '', 'I ! c i i', args.execute, False, ['period', 'value-has-to-change', 'option', 'min', 'max'], [None, None, {'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def get_resistance(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-resistance')

		args = parser.parse_args(argv)

		device_call(ctx, PTCV2Bricklet, 5, (), '', 'i', args.execute, False, ['resistance'], [None])

	def set_resistance_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-resistance-callback-configuration')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')
		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, PTCV2Bricklet, 6, (args.period, args.value_has_to_change, args.option, args.min, args.max), 'I ! c i i', '', None, args.expect_response, [], [])

	def get_resistance_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-resistance-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, PTCV2Bricklet, 7, (), '', 'I ! c i i', args.execute, False, ['period', 'value-has-to-change', 'option', 'min', 'max'], [None, None, {'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def set_noise_rejection_filter(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-noise-rejection-filter')

		parser.add_argument('filter', type=create_symbol_converter(ctx, convert_int, {'filter-option-50hz': 0, 'filter-option-60hz': 1}), help='int (filter-option-50hz: 0, filter-option-60hz: 1)', metavar='<filter>')

		args = parser.parse_args(argv)

		device_call(ctx, PTCV2Bricklet, 9, (args.filter,), 'B', '', None, args.expect_response, [], [])

	def get_noise_rejection_filter(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-noise-rejection-filter')

		args = parser.parse_args(argv)

		device_call(ctx, PTCV2Bricklet, 10, (), '', 'B', args.execute, False, ['filter'], [{0: 'filter-option-50hz', 1: 'filter-option-60hz'}])

	def is_sensor_connected(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' is-sensor-connected')

		args = parser.parse_args(argv)

		device_call(ctx, PTCV2Bricklet, 11, (), '', '!', args.execute, False, ['connected'], [None])

	def set_wire_mode(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-wire-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'wire-mode-3': 3, 'wire-mode-2': 2, 'wire-mode-4': 4}), help='int (wire-mode-2: 2, wire-mode-3: 3, wire-mode-4: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, PTCV2Bricklet, 12, (args.mode,), 'B', '', None, args.expect_response, [], [])

	def get_wire_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-wire-mode')

		args = parser.parse_args(argv)

		device_call(ctx, PTCV2Bricklet, 13, (), '', 'B', args.execute, False, ['mode'], [{2: 'wire-mode-2', 3: 'wire-mode-3', 4: 'wire-mode-4'}])

	def set_moving_average_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-moving-average-configuration')

		parser.add_argument('moving_average_length_resistance', type=convert_int, help='int', metavar='<moving-average-length-resistance>')
		parser.add_argument('moving_average_length_temperature', type=convert_int, help='int', metavar='<moving-average-length-temperature>')

		args = parser.parse_args(argv)

		device_call(ctx, PTCV2Bricklet, 14, (args.moving_average_length_resistance, args.moving_average_length_temperature), 'H H', '', None, args.expect_response, [], [])

	def get_moving_average_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-moving-average-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, PTCV2Bricklet, 15, (), '', 'H H', args.execute, False, ['moving-average-length-resistance', 'moving-average-length-temperature'], [None, None])

	def set_sensor_connected_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-sensor-connected-callback-configuration')

		parser.add_argument('enabled', type=convert_bool, help='bool', metavar='<enabled>')

		args = parser.parse_args(argv)

		device_call(ctx, PTCV2Bricklet, 16, (args.enabled,), '!', '', None, args.expect_response, [], [])

	def get_sensor_connected_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-sensor-connected-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, PTCV2Bricklet, 17, (), '', '!', args.execute, False, ['enabled'], [None])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, PTCV2Bricklet, 234, (), '', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def set_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-bootloader-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'bootloader-mode-firmware-wait-for-reboot': 3, 'bootloader-mode-firmware': 1, 'bootloader-mode-firmware-wait-for-erase-and-reboot': 4, 'bootloader-mode-bootloader-wait-for-reboot': 2, 'bootloader-mode-bootloader': 0}), help='int (bootloader-mode-bootloader: 0, bootloader-mode-firmware: 1, bootloader-mode-bootloader-wait-for-reboot: 2, bootloader-mode-firmware-wait-for-reboot: 3, bootloader-mode-firmware-wait-for-erase-and-reboot: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, PTCV2Bricklet, 235, (args.mode,), 'B', 'B', args.execute, False, ['status'], [{0: 'bootloader-status-ok', 1: 'bootloader-status-invalid-mode', 2: 'bootloader-status-no-change', 3: 'bootloader-status-entry-function-not-present', 4: 'bootloader-status-device-identifier-incorrect', 5: 'bootloader-status-crc-mismatch'}])

	def get_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-bootloader-mode')

		args = parser.parse_args(argv)

		device_call(ctx, PTCV2Bricklet, 236, (), '', 'B', args.execute, False, ['mode'], [{0: 'bootloader-mode-bootloader', 1: 'bootloader-mode-firmware', 2: 'bootloader-mode-bootloader-wait-for-reboot', 3: 'bootloader-mode-firmware-wait-for-reboot', 4: 'bootloader-mode-firmware-wait-for-erase-and-reboot'}])

	def set_write_firmware_pointer(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-write-firmware-pointer')

		parser.add_argument('pointer', type=convert_int, help='int', metavar='<pointer>')

		args = parser.parse_args(argv)

		device_call(ctx, PTCV2Bricklet, 237, (args.pointer,), 'I', '', None, args.expect_response, [], [])

	def write_firmware(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-firmware')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, PTCV2Bricklet, 238, (args.data,), '64B', 'B', args.execute, False, ['status'], [None])

	def set_status_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'status-led-config-on': 1, 'status-led-config-show-heartbeat': 2, 'status-led-config-off': 0, 'status-led-config-show-status': 3}), help='int (status-led-config-off: 0, status-led-config-on: 1, status-led-config-show-heartbeat: 2, status-led-config-show-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, PTCV2Bricklet, 239, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_status_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, PTCV2Bricklet, 240, (), '', 'B', args.execute, False, ['config'], [{0: 'status-led-config-off', 1: 'status-led-config-on', 2: 'status-led-config-show-heartbeat', 3: 'status-led-config-show-status'}])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, PTCV2Bricklet, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, PTCV2Bricklet, 243, (), '', '', None, args.expect_response, [], [])

	def write_uid(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-uid')

		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')

		args = parser.parse_args(argv)

		device_call(ctx, PTCV2Bricklet, 248, (args.uid,), 'I', '', None, args.expect_response, [], [])

	def read_uid(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-uid')

		args = parser.parse_args(argv)

		device_call(ctx, PTCV2Bricklet, 249, (), '', 'I', args.execute, False, ['uid'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, PTCV2Bricklet, argv)

	functions = {
	'get-temperature': get_temperature,
	'set-temperature-callback-configuration': set_temperature_callback_configuration,
	'get-temperature-callback-configuration': get_temperature_callback_configuration,
	'get-resistance': get_resistance,
	'set-resistance-callback-configuration': set_resistance_callback_configuration,
	'get-resistance-callback-configuration': get_resistance_callback_configuration,
	'set-noise-rejection-filter': set_noise_rejection_filter,
	'get-noise-rejection-filter': get_noise_rejection_filter,
	'is-sensor-connected': is_sensor_connected,
	'set-wire-mode': set_wire_mode,
	'get-wire-mode': get_wire_mode,
	'set-moving-average-configuration': set_moving_average_configuration,
	'get-moving-average-configuration': get_moving_average_configuration,
	'set-sensor-connected-callback-configuration': set_sensor_connected_callback_configuration,
	'get-sensor-connected-callback-configuration': get_sensor_connected_callback_configuration,
	'get-spitfp-error-count': get_spitfp_error_count,
	'set-bootloader-mode': set_bootloader_mode,
	'get-bootloader-mode': get_bootloader_mode,
	'set-write-firmware-pointer': set_write_firmware_pointer,
	'write-firmware': write_firmware,
	'set-status-led-config': set_status_led_config,
	'get-status-led-config': get_status_led_config,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'write-uid': write_uid,
	'read-uid': read_uid,
	'get-identity': get_identity
	}

	call_generic(ctx, 'ptc-v2-bricklet', functions, argv)

def dispatch_ptc_v2_bricklet(ctx, argv):
	prog_prefix = 'dispatch ptc-v2-bricklet <uid>'

	def temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' temperature')

		args = parser.parse_args(argv)

		device_dispatch(ctx, PTCV2Bricklet, 4, args.execute, ['temperature'], [None])

	def resistance(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' resistance')

		args = parser.parse_args(argv)

		device_dispatch(ctx, PTCV2Bricklet, 8, args.execute, ['resistance'], [None])

	def sensor_connected(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' sensor-connected')

		args = parser.parse_args(argv)

		device_dispatch(ctx, PTCV2Bricklet, 18, args.execute, ['connected'], [None])

	callbacks = {
	'temperature': temperature,
	'resistance': resistance,
	'sensor-connected': sensor_connected
	}

	dispatch_generic(ctx, 'ptc-v2-bricklet', callbacks, argv)

class RealTimeClockBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 3; re[2] = 1; re[3] = 1; re[4] = 3; re[5] = 1; re[6] = 2; re[7] = 1; re[8] = 2; re[9] = 1; re[255] = 1
		cf = self.callback_formats
		cf[10] = 'H B B B B B B B q'; cf[11] = 'H B B B B B B B q'


def call_real_time_clock_bricklet(ctx, argv):
	prog_prefix = 'call real-time-clock-bricklet <uid>'

	def set_date_time(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-date-time')

		parser.add_argument('year', type=convert_int, help='int', metavar='<year>')
		parser.add_argument('month', type=convert_int, help='int', metavar='<month>')
		parser.add_argument('day', type=convert_int, help='int', metavar='<day>')
		parser.add_argument('hour', type=convert_int, help='int', metavar='<hour>')
		parser.add_argument('minute', type=convert_int, help='int', metavar='<minute>')
		parser.add_argument('second', type=convert_int, help='int', metavar='<second>')
		parser.add_argument('centisecond', type=convert_int, help='int', metavar='<centisecond>')
		parser.add_argument('weekday', type=create_symbol_converter(ctx, convert_int, {'weekday-monday': 1, 'weekday-sunday': 7, 'weekday-tuesday': 2, 'weekday-friday': 5, 'weekday-thursday': 4, 'weekday-wednesday': 3, 'weekday-saturday': 6}), help='int (weekday-monday: 1, weekday-tuesday: 2, weekday-wednesday: 3, weekday-thursday: 4, weekday-friday: 5, weekday-saturday: 6, weekday-sunday: 7)', metavar='<weekday>')

		args = parser.parse_args(argv)

		device_call(ctx, RealTimeClockBricklet, 1, (args.year, args.month, args.day, args.hour, args.minute, args.second, args.centisecond, args.weekday), 'H B B B B B B B', '', None, args.expect_response, [], [])

	def get_date_time(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-date-time')

		args = parser.parse_args(argv)

		device_call(ctx, RealTimeClockBricklet, 2, (), '', 'H B B B B B B B', args.execute, False, ['year', 'month', 'day', 'hour', 'minute', 'second', 'centisecond', 'weekday'], [None, None, None, None, None, None, None, {1: 'weekday-monday', 2: 'weekday-tuesday', 3: 'weekday-wednesday', 4: 'weekday-thursday', 5: 'weekday-friday', 6: 'weekday-saturday', 7: 'weekday-sunday'}])

	def get_timestamp(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-timestamp')

		args = parser.parse_args(argv)

		device_call(ctx, RealTimeClockBricklet, 3, (), '', 'q', args.execute, False, ['timestamp'], [None])

	def set_offset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-offset')

		parser.add_argument('offset', type=convert_int, help='int', metavar='<offset>')

		args = parser.parse_args(argv)

		device_call(ctx, RealTimeClockBricklet, 4, (args.offset,), 'b', '', None, args.expect_response, [], [])

	def get_offset(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-offset')

		args = parser.parse_args(argv)

		device_call(ctx, RealTimeClockBricklet, 5, (), '', 'b', args.execute, False, ['offset'], [None])

	def set_date_time_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-date-time-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, RealTimeClockBricklet, 6, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_date_time_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-date-time-callback-period')

		args = parser.parse_args(argv)

		device_call(ctx, RealTimeClockBricklet, 7, (), '', 'I', args.execute, False, ['period'], [None])

	def set_alarm(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-alarm')

		parser.add_argument('month', type=create_symbol_converter(ctx, convert_int, {'alarm-match-disabled': -1}), help='int (alarm-match-disabled: -1)', metavar='<month>')
		parser.add_argument('day', type=create_symbol_converter(ctx, convert_int, {'alarm-match-disabled': -1}), help='int (alarm-match-disabled: -1)', metavar='<day>')
		parser.add_argument('hour', type=create_symbol_converter(ctx, convert_int, {'alarm-match-disabled': -1}), help='int (alarm-match-disabled: -1)', metavar='<hour>')
		parser.add_argument('minute', type=create_symbol_converter(ctx, convert_int, {'alarm-match-disabled': -1}), help='int (alarm-match-disabled: -1)', metavar='<minute>')
		parser.add_argument('second', type=create_symbol_converter(ctx, convert_int, {'alarm-match-disabled': -1}), help='int (alarm-match-disabled: -1)', metavar='<second>')
		parser.add_argument('weekday', type=create_symbol_converter(ctx, convert_int, {'alarm-match-disabled': -1}), help='int (alarm-match-disabled: -1)', metavar='<weekday>')
		parser.add_argument('interval', type=create_symbol_converter(ctx, convert_int, {'alarm-interval-disabled': -1}), help='int (alarm-interval-disabled: -1)', metavar='<interval>')

		args = parser.parse_args(argv)

		device_call(ctx, RealTimeClockBricklet, 8, (args.month, args.day, args.hour, args.minute, args.second, args.weekday, args.interval), 'b b b b b b i', '', None, args.expect_response, [], [])

	def get_alarm(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-alarm')

		args = parser.parse_args(argv)

		device_call(ctx, RealTimeClockBricklet, 9, (), '', 'b b b b b b i', args.execute, False, ['month', 'day', 'hour', 'minute', 'second', 'weekday', 'interval'], [{-1: 'alarm-match-disabled'}, {-1: 'alarm-match-disabled'}, {-1: 'alarm-match-disabled'}, {-1: 'alarm-match-disabled'}, {-1: 'alarm-match-disabled'}, {-1: 'alarm-match-disabled'}, {-1: 'alarm-interval-disabled'}])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, RealTimeClockBricklet, argv)

	functions = {
	'set-date-time': set_date_time,
	'get-date-time': get_date_time,
	'get-timestamp': get_timestamp,
	'set-offset': set_offset,
	'get-offset': get_offset,
	'set-date-time-callback-period': set_date_time_callback_period,
	'get-date-time-callback-period': get_date_time_callback_period,
	'set-alarm': set_alarm,
	'get-alarm': get_alarm,
	'get-identity': get_identity
	}

	call_generic(ctx, 'real-time-clock-bricklet', functions, argv)

def dispatch_real_time_clock_bricklet(ctx, argv):
	prog_prefix = 'dispatch real-time-clock-bricklet <uid>'

	def date_time(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' date-time')

		args = parser.parse_args(argv)

		device_dispatch(ctx, RealTimeClockBricklet, 10, args.execute, ['year', 'month', 'day', 'hour', 'minute', 'second', 'centisecond', 'weekday', 'timestamp'], [None, None, None, None, None, None, None, {1: 'weekday-monday', 2: 'weekday-tuesday', 3: 'weekday-wednesday', 4: 'weekday-thursday', 5: 'weekday-friday', 6: 'weekday-saturday', 7: 'weekday-sunday'}, None])

	def alarm(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' alarm')

		args = parser.parse_args(argv)

		device_dispatch(ctx, RealTimeClockBricklet, 11, args.execute, ['year', 'month', 'day', 'hour', 'minute', 'second', 'centisecond', 'weekday', 'timestamp'], [None, None, None, None, None, None, None, {1: 'weekday-monday', 2: 'weekday-tuesday', 3: 'weekday-wednesday', 4: 'weekday-thursday', 5: 'weekday-friday', 6: 'weekday-saturday', 7: 'weekday-sunday'}, None])

	callbacks = {
	'date-time': date_time,
	'alarm': alarm
	}

	dispatch_generic(ctx, 'real-time-clock-bricklet', callbacks, argv)

class RealTimeClockV2Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 3; re[2] = 1; re[3] = 1; re[4] = 3; re[5] = 1; re[6] = 2; re[7] = 1; re[8] = 2; re[9] = 1; re[234] = 1; re[235] = 1; re[236] = 1; re[237] = 3; re[238] = 1; re[239] = 3; re[240] = 1; re[242] = 1; re[243] = 3; re[248] = 3; re[249] = 1; re[255] = 1
		cf = self.callback_formats
		cf[10] = 'H B B B B B B B q'; cf[11] = 'H B B B B B B B q'


def call_real_time_clock_v2_bricklet(ctx, argv):
	prog_prefix = 'call real-time-clock-v2-bricklet <uid>'

	def set_date_time(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-date-time')

		parser.add_argument('year', type=convert_int, help='int', metavar='<year>')
		parser.add_argument('month', type=convert_int, help='int', metavar='<month>')
		parser.add_argument('day', type=convert_int, help='int', metavar='<day>')
		parser.add_argument('hour', type=convert_int, help='int', metavar='<hour>')
		parser.add_argument('minute', type=convert_int, help='int', metavar='<minute>')
		parser.add_argument('second', type=convert_int, help='int', metavar='<second>')
		parser.add_argument('centisecond', type=convert_int, help='int', metavar='<centisecond>')
		parser.add_argument('weekday', type=create_symbol_converter(ctx, convert_int, {'weekday-monday': 1, 'weekday-sunday': 7, 'weekday-tuesday': 2, 'weekday-friday': 5, 'weekday-thursday': 4, 'weekday-wednesday': 3, 'weekday-saturday': 6}), help='int (weekday-monday: 1, weekday-tuesday: 2, weekday-wednesday: 3, weekday-thursday: 4, weekday-friday: 5, weekday-saturday: 6, weekday-sunday: 7)', metavar='<weekday>')

		args = parser.parse_args(argv)

		device_call(ctx, RealTimeClockV2Bricklet, 1, (args.year, args.month, args.day, args.hour, args.minute, args.second, args.centisecond, args.weekday), 'H B B B B B B B', '', None, args.expect_response, [], [])

	def get_date_time(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-date-time')

		args = parser.parse_args(argv)

		device_call(ctx, RealTimeClockV2Bricklet, 2, (), '', 'H B B B B B B B q', args.execute, False, ['year', 'month', 'day', 'hour', 'minute', 'second', 'centisecond', 'weekday', 'timestamp'], [None, None, None, None, None, None, None, {1: 'weekday-monday', 2: 'weekday-tuesday', 3: 'weekday-wednesday', 4: 'weekday-thursday', 5: 'weekday-friday', 6: 'weekday-saturday', 7: 'weekday-sunday'}, None])

	def get_timestamp(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-timestamp')

		args = parser.parse_args(argv)

		device_call(ctx, RealTimeClockV2Bricklet, 3, (), '', 'q', args.execute, False, ['timestamp'], [None])

	def set_offset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-offset')

		parser.add_argument('offset', type=convert_int, help='int', metavar='<offset>')

		args = parser.parse_args(argv)

		device_call(ctx, RealTimeClockV2Bricklet, 4, (args.offset,), 'b', '', None, args.expect_response, [], [])

	def get_offset(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-offset')

		args = parser.parse_args(argv)

		device_call(ctx, RealTimeClockV2Bricklet, 5, (), '', 'b', args.execute, False, ['offset'], [None])

	def set_date_time_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-date-time-callback-configuration')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, RealTimeClockV2Bricklet, 6, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_date_time_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-date-time-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, RealTimeClockV2Bricklet, 7, (), '', 'I', args.execute, False, ['period'], [None])

	def set_alarm(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-alarm')

		parser.add_argument('month', type=create_symbol_converter(ctx, convert_int, {'alarm-match-disabled': -1}), help='int (alarm-match-disabled: -1)', metavar='<month>')
		parser.add_argument('day', type=create_symbol_converter(ctx, convert_int, {'alarm-match-disabled': -1}), help='int (alarm-match-disabled: -1)', metavar='<day>')
		parser.add_argument('hour', type=create_symbol_converter(ctx, convert_int, {'alarm-match-disabled': -1}), help='int (alarm-match-disabled: -1)', metavar='<hour>')
		parser.add_argument('minute', type=create_symbol_converter(ctx, convert_int, {'alarm-match-disabled': -1}), help='int (alarm-match-disabled: -1)', metavar='<minute>')
		parser.add_argument('second', type=create_symbol_converter(ctx, convert_int, {'alarm-match-disabled': -1}), help='int (alarm-match-disabled: -1)', metavar='<second>')
		parser.add_argument('weekday', type=create_symbol_converter(ctx, convert_int, {'alarm-match-disabled': -1}), help='int (alarm-match-disabled: -1)', metavar='<weekday>')
		parser.add_argument('interval', type=create_symbol_converter(ctx, convert_int, {'alarm-interval-disabled': -1}), help='int (alarm-interval-disabled: -1)', metavar='<interval>')

		args = parser.parse_args(argv)

		device_call(ctx, RealTimeClockV2Bricklet, 8, (args.month, args.day, args.hour, args.minute, args.second, args.weekday, args.interval), 'b b b b b b i', '', None, args.expect_response, [], [])

	def get_alarm(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-alarm')

		args = parser.parse_args(argv)

		device_call(ctx, RealTimeClockV2Bricklet, 9, (), '', 'b b b b b b i', args.execute, False, ['month', 'day', 'hour', 'minute', 'second', 'weekday', 'interval'], [{-1: 'alarm-match-disabled'}, {-1: 'alarm-match-disabled'}, {-1: 'alarm-match-disabled'}, {-1: 'alarm-match-disabled'}, {-1: 'alarm-match-disabled'}, {-1: 'alarm-match-disabled'}, {-1: 'alarm-interval-disabled'}])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, RealTimeClockV2Bricklet, 234, (), '', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def set_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-bootloader-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'bootloader-mode-firmware-wait-for-reboot': 3, 'bootloader-mode-firmware': 1, 'bootloader-mode-firmware-wait-for-erase-and-reboot': 4, 'bootloader-mode-bootloader-wait-for-reboot': 2, 'bootloader-mode-bootloader': 0}), help='int (bootloader-mode-bootloader: 0, bootloader-mode-firmware: 1, bootloader-mode-bootloader-wait-for-reboot: 2, bootloader-mode-firmware-wait-for-reboot: 3, bootloader-mode-firmware-wait-for-erase-and-reboot: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, RealTimeClockV2Bricklet, 235, (args.mode,), 'B', 'B', args.execute, False, ['status'], [{0: 'bootloader-status-ok', 1: 'bootloader-status-invalid-mode', 2: 'bootloader-status-no-change', 3: 'bootloader-status-entry-function-not-present', 4: 'bootloader-status-device-identifier-incorrect', 5: 'bootloader-status-crc-mismatch'}])

	def get_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-bootloader-mode')

		args = parser.parse_args(argv)

		device_call(ctx, RealTimeClockV2Bricklet, 236, (), '', 'B', args.execute, False, ['mode'], [{0: 'bootloader-mode-bootloader', 1: 'bootloader-mode-firmware', 2: 'bootloader-mode-bootloader-wait-for-reboot', 3: 'bootloader-mode-firmware-wait-for-reboot', 4: 'bootloader-mode-firmware-wait-for-erase-and-reboot'}])

	def set_write_firmware_pointer(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-write-firmware-pointer')

		parser.add_argument('pointer', type=convert_int, help='int', metavar='<pointer>')

		args = parser.parse_args(argv)

		device_call(ctx, RealTimeClockV2Bricklet, 237, (args.pointer,), 'I', '', None, args.expect_response, [], [])

	def write_firmware(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-firmware')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, RealTimeClockV2Bricklet, 238, (args.data,), '64B', 'B', args.execute, False, ['status'], [None])

	def set_status_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'status-led-config-on': 1, 'status-led-config-show-heartbeat': 2, 'status-led-config-off': 0, 'status-led-config-show-status': 3}), help='int (status-led-config-off: 0, status-led-config-on: 1, status-led-config-show-heartbeat: 2, status-led-config-show-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, RealTimeClockV2Bricklet, 239, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_status_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, RealTimeClockV2Bricklet, 240, (), '', 'B', args.execute, False, ['config'], [{0: 'status-led-config-off', 1: 'status-led-config-on', 2: 'status-led-config-show-heartbeat', 3: 'status-led-config-show-status'}])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, RealTimeClockV2Bricklet, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, RealTimeClockV2Bricklet, 243, (), '', '', None, args.expect_response, [], [])

	def write_uid(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-uid')

		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')

		args = parser.parse_args(argv)

		device_call(ctx, RealTimeClockV2Bricklet, 248, (args.uid,), 'I', '', None, args.expect_response, [], [])

	def read_uid(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-uid')

		args = parser.parse_args(argv)

		device_call(ctx, RealTimeClockV2Bricklet, 249, (), '', 'I', args.execute, False, ['uid'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, RealTimeClockV2Bricklet, argv)

	functions = {
	'set-date-time': set_date_time,
	'get-date-time': get_date_time,
	'get-timestamp': get_timestamp,
	'set-offset': set_offset,
	'get-offset': get_offset,
	'set-date-time-callback-configuration': set_date_time_callback_configuration,
	'get-date-time-callback-configuration': get_date_time_callback_configuration,
	'set-alarm': set_alarm,
	'get-alarm': get_alarm,
	'get-spitfp-error-count': get_spitfp_error_count,
	'set-bootloader-mode': set_bootloader_mode,
	'get-bootloader-mode': get_bootloader_mode,
	'set-write-firmware-pointer': set_write_firmware_pointer,
	'write-firmware': write_firmware,
	'set-status-led-config': set_status_led_config,
	'get-status-led-config': get_status_led_config,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'write-uid': write_uid,
	'read-uid': read_uid,
	'get-identity': get_identity
	}

	call_generic(ctx, 'real-time-clock-v2-bricklet', functions, argv)

def dispatch_real_time_clock_v2_bricklet(ctx, argv):
	prog_prefix = 'dispatch real-time-clock-v2-bricklet <uid>'

	def date_time(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' date-time')

		args = parser.parse_args(argv)

		device_dispatch(ctx, RealTimeClockV2Bricklet, 10, args.execute, ['year', 'month', 'day', 'hour', 'minute', 'second', 'centisecond', 'weekday', 'timestamp'], [None, None, None, None, None, None, None, {1: 'weekday-monday', 2: 'weekday-tuesday', 3: 'weekday-wednesday', 4: 'weekday-thursday', 5: 'weekday-friday', 6: 'weekday-saturday', 7: 'weekday-sunday'}, None])

	def alarm(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' alarm')

		args = parser.parse_args(argv)

		device_dispatch(ctx, RealTimeClockV2Bricklet, 11, args.execute, ['year', 'month', 'day', 'hour', 'minute', 'second', 'centisecond', 'weekday', 'timestamp'], [None, None, None, None, None, None, None, {1: 'weekday-monday', 2: 'weekday-tuesday', 3: 'weekday-wednesday', 4: 'weekday-thursday', 5: 'weekday-friday', 6: 'weekday-saturday', 7: 'weekday-sunday'}, None])

	callbacks = {
	'date-time': date_time,
	'alarm': alarm
	}

	dispatch_generic(ctx, 'real-time-clock-v2-bricklet', callbacks, argv)

class REDBrick(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 1; re[3] = 3; re[4] = 1; re[5] = 1; re[6] = 3; re[7] = 1; re[8] = 1; re[9] = 1; re[10] = 1; re[11] = 1; re[12] = 1; re[13] = 1; re[14] = 1; re[15] = 1; re[16] = 1; re[17] = 1; re[18] = 1; re[19] = 1; re[20] = 1; re[21] = 3; re[22] = 1; re[23] = 1; re[24] = 3; re[25] = 3; re[26] = 1; re[27] = 1; re[28] = 1; re[29] = 1; re[33] = 1; re[34] = 1; re[35] = 1; re[36] = 1; re[37] = 1; re[38] = 1; re[39] = 1; re[40] = 1; re[41] = 1; re[42] = 1; re[43] = 1; re[44] = 1; re[46] = 1; re[47] = 1; re[48] = 1; re[49] = 1; re[50] = 1; re[51] = 1; re[52] = 1; re[53] = 1; re[54] = 1; re[55] = 1; re[56] = 1; re[57] = 1; re[58] = 1; re[59] = 1; re[60] = 1; re[61] = 1; re[62] = 1; re[63] = 1; re[64] = 1; re[255] = 1
		cf = self.callback_formats
		cf[30] = 'H B 60B B'; cf[31] = 'H B B'; cf[32] = 'H H'; cf[45] = 'H B Q B'; cf[65] = 'H'; cf[66] = 'H'


def call_red_brick(ctx, argv):
	prog_prefix = 'call red-brick <uid>'

	def create_session(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' create-session')

		parser.add_argument('lifetime', type=convert_int, help='int', metavar='<lifetime>')

		args = parser.parse_args(argv)

		device_call(ctx, REDBrick, 1, (args.lifetime,), 'I', 'B H', args.execute, False, ['error-code', 'session-id'], [{0: 'error-code-success', 1: 'error-code-unknown-error', 2: 'error-code-invalid-operation', 3: 'error-code-operation-aborted', 4: 'error-code-internal-error', 5: 'error-code-unknown-session-id', 6: 'error-code-no-free-session-id', 7: 'error-code-unknown-object-id', 8: 'error-code-no-free-object-id', 9: 'error-code-object-is-locked', 10: 'error-code-no-more-data', 11: 'error-code-wrong-list-item-type', 12: 'error-code-program-is-purged', 130: 'error-code-no-free-space', 142: 'error-code-invalid-seek', 143: 'error-code-not-supported', 144: 'error-code-too-many-open-files', 132: 'error-code-already-exists', 133: 'error-code-does-not-exist', 134: 'error-code-interrupted', 129: 'error-code-no-free-memory', 135: 'error-code-is-directory', 136: 'error-code-not-a-directory', 128: 'error-code-invalid-parameter', 137: 'error-code-would-block', 138: 'error-code-overflow', 139: 'error-code-bad-file-descriptor', 140: 'error-code-out-of-range', 141: 'error-code-name-too-long', 121: 'error-code-access-denied'}, None])

	def expire_session(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' expire-session')

		parser.add_argument('session_id', type=convert_int, help='int', metavar='<session-id>')

		args = parser.parse_args(argv)

		device_call(ctx, REDBrick, 2, (args.session_id,), 'H', 'B', args.execute, False, ['error-code'], [{0: 'error-code-success', 1: 'error-code-unknown-error', 2: 'error-code-invalid-operation', 3: 'error-code-operation-aborted', 4: 'error-code-internal-error', 5: 'error-code-unknown-session-id', 6: 'error-code-no-free-session-id', 7: 'error-code-unknown-object-id', 8: 'error-code-no-free-object-id', 9: 'error-code-object-is-locked', 10: 'error-code-no-more-data', 11: 'error-code-wrong-list-item-type', 12: 'error-code-program-is-purged', 130: 'error-code-no-free-space', 142: 'error-code-invalid-seek', 143: 'error-code-not-supported', 144: 'error-code-too-many-open-files', 132: 'error-code-already-exists', 133: 'error-code-does-not-exist', 134: 'error-code-interrupted', 129: 'error-code-no-free-memory', 135: 'error-code-is-directory', 136: 'error-code-not-a-directory', 128: 'error-code-invalid-parameter', 137: 'error-code-would-block', 138: 'error-code-overflow', 139: 'error-code-bad-file-descriptor', 140: 'error-code-out-of-range', 141: 'error-code-name-too-long', 121: 'error-code-access-denied'}])

	def expire_session_unchecked(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' expire-session-unchecked')

		parser.add_argument('session_id', type=convert_int, help='int', metavar='<session-id>')

		args = parser.parse_args(argv)

		device_call(ctx, REDBrick, 3, (args.session_id,), 'H', '', None, args.expect_response, [], [])

	def keep_session_alive(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' keep-session-alive')

		parser.add_argument('session_id', type=convert_int, help='int', metavar='<session-id>')
		parser.add_argument('lifetime', type=convert_int, help='int', metavar='<lifetime>')

		args = parser.parse_args(argv)

		device_call(ctx, REDBrick, 4, (args.session_id, args.lifetime), 'H I', 'B', args.execute, False, ['error-code'], [{0: 'error-code-success', 1: 'error-code-unknown-error', 2: 'error-code-invalid-operation', 3: 'error-code-operation-aborted', 4: 'error-code-internal-error', 5: 'error-code-unknown-session-id', 6: 'error-code-no-free-session-id', 7: 'error-code-unknown-object-id', 8: 'error-code-no-free-object-id', 9: 'error-code-object-is-locked', 10: 'error-code-no-more-data', 11: 'error-code-wrong-list-item-type', 12: 'error-code-program-is-purged', 130: 'error-code-no-free-space', 142: 'error-code-invalid-seek', 143: 'error-code-not-supported', 144: 'error-code-too-many-open-files', 132: 'error-code-already-exists', 133: 'error-code-does-not-exist', 134: 'error-code-interrupted', 129: 'error-code-no-free-memory', 135: 'error-code-is-directory', 136: 'error-code-not-a-directory', 128: 'error-code-invalid-parameter', 137: 'error-code-would-block', 138: 'error-code-overflow', 139: 'error-code-bad-file-descriptor', 140: 'error-code-out-of-range', 141: 'error-code-name-too-long', 121: 'error-code-access-denied'}])

	def release_object(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' release-object')

		parser.add_argument('object_id', type=convert_int, help='int', metavar='<object-id>')
		parser.add_argument('session_id', type=convert_int, help='int', metavar='<session-id>')

		args = parser.parse_args(argv)

		device_call(ctx, REDBrick, 5, (args.object_id, args.session_id), 'H H', 'B', args.execute, False, ['error-code'], [{0: 'error-code-success', 1: 'error-code-unknown-error', 2: 'error-code-invalid-operation', 3: 'error-code-operation-aborted', 4: 'error-code-internal-error', 5: 'error-code-unknown-session-id', 6: 'error-code-no-free-session-id', 7: 'error-code-unknown-object-id', 8: 'error-code-no-free-object-id', 9: 'error-code-object-is-locked', 10: 'error-code-no-more-data', 11: 'error-code-wrong-list-item-type', 12: 'error-code-program-is-purged', 130: 'error-code-no-free-space', 142: 'error-code-invalid-seek', 143: 'error-code-not-supported', 144: 'error-code-too-many-open-files', 132: 'error-code-already-exists', 133: 'error-code-does-not-exist', 134: 'error-code-interrupted', 129: 'error-code-no-free-memory', 135: 'error-code-is-directory', 136: 'error-code-not-a-directory', 128: 'error-code-invalid-parameter', 137: 'error-code-would-block', 138: 'error-code-overflow', 139: 'error-code-bad-file-descriptor', 140: 'error-code-out-of-range', 141: 'error-code-name-too-long', 121: 'error-code-access-denied'}])

	def release_object_unchecked(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' release-object-unchecked')

		parser.add_argument('object_id', type=convert_int, help='int', metavar='<object-id>')
		parser.add_argument('session_id', type=convert_int, help='int', metavar='<session-id>')

		args = parser.parse_args(argv)

		device_call(ctx, REDBrick, 6, (args.object_id, args.session_id), 'H H', '', None, args.expect_response, [], [])

	def allocate_string(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' allocate-string')

		parser.add_argument('length_to_reserve', type=convert_int, help='int', metavar='<length-to-reserve>')
		parser.add_argument('buffer', type=create_string_converter(ctx, str, 58), help='string', metavar='<buffer>')
		parser.add_argument('session_id', type=convert_int, help='int', metavar='<session-id>')

		args = parser.parse_args(argv)

		device_call(ctx, REDBrick, 7, (args.length_to_reserve, args.buffer, args.session_id), 'I 58s H', 'B H', args.execute, False, ['error-code', 'string-id'], [{0: 'error-code-success', 1: 'error-code-unknown-error', 2: 'error-code-invalid-operation', 3: 'error-code-operation-aborted', 4: 'error-code-internal-error', 5: 'error-code-unknown-session-id', 6: 'error-code-no-free-session-id', 7: 'error-code-unknown-object-id', 8: 'error-code-no-free-object-id', 9: 'error-code-object-is-locked', 10: 'error-code-no-more-data', 11: 'error-code-wrong-list-item-type', 12: 'error-code-program-is-purged', 130: 'error-code-no-free-space', 142: 'error-code-invalid-seek', 143: 'error-code-not-supported', 144: 'error-code-too-many-open-files', 132: 'error-code-already-exists', 133: 'error-code-does-not-exist', 134: 'error-code-interrupted', 129: 'error-code-no-free-memory', 135: 'error-code-is-directory', 136: 'error-code-not-a-directory', 128: 'error-code-invalid-parameter', 137: 'error-code-would-block', 138: 'error-code-overflow', 139: 'error-code-bad-file-descriptor', 140: 'error-code-out-of-range', 141: 'error-code-name-too-long', 121: 'error-code-access-denied'}, None])

	def truncate_string(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' truncate-string')

		parser.add_argument('string_id', type=convert_int, help='int', metavar='<string-id>')
		parser.add_argument('length', type=convert_int, help='int', metavar='<length>')

		args = parser.parse_args(argv)

		device_call(ctx, REDBrick, 8, (args.string_id, args.length), 'H I', 'B', args.execute, False, ['error-code'], [{0: 'error-code-success', 1: 'error-code-unknown-error', 2: 'error-code-invalid-operation', 3: 'error-code-operation-aborted', 4: 'error-code-internal-error', 5: 'error-code-unknown-session-id', 6: 'error-code-no-free-session-id', 7: 'error-code-unknown-object-id', 8: 'error-code-no-free-object-id', 9: 'error-code-object-is-locked', 10: 'error-code-no-more-data', 11: 'error-code-wrong-list-item-type', 12: 'error-code-program-is-purged', 130: 'error-code-no-free-space', 142: 'error-code-invalid-seek', 143: 'error-code-not-supported', 144: 'error-code-too-many-open-files', 132: 'error-code-already-exists', 133: 'error-code-does-not-exist', 134: 'error-code-interrupted', 129: 'error-code-no-free-memory', 135: 'error-code-is-directory', 136: 'error-code-not-a-directory', 128: 'error-code-invalid-parameter', 137: 'error-code-would-block', 138: 'error-code-overflow', 139: 'error-code-bad-file-descriptor', 140: 'error-code-out-of-range', 141: 'error-code-name-too-long', 121: 'error-code-access-denied'}])

	def get_string_length(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-string-length')

		parser.add_argument('string_id', type=convert_int, help='int', metavar='<string-id>')

		args = parser.parse_args(argv)

		device_call(ctx, REDBrick, 9, (args.string_id,), 'H', 'B I', args.execute, False, ['error-code', 'length'], [{0: 'error-code-success', 1: 'error-code-unknown-error', 2: 'error-code-invalid-operation', 3: 'error-code-operation-aborted', 4: 'error-code-internal-error', 5: 'error-code-unknown-session-id', 6: 'error-code-no-free-session-id', 7: 'error-code-unknown-object-id', 8: 'error-code-no-free-object-id', 9: 'error-code-object-is-locked', 10: 'error-code-no-more-data', 11: 'error-code-wrong-list-item-type', 12: 'error-code-program-is-purged', 130: 'error-code-no-free-space', 142: 'error-code-invalid-seek', 143: 'error-code-not-supported', 144: 'error-code-too-many-open-files', 132: 'error-code-already-exists', 133: 'error-code-does-not-exist', 134: 'error-code-interrupted', 129: 'error-code-no-free-memory', 135: 'error-code-is-directory', 136: 'error-code-not-a-directory', 128: 'error-code-invalid-parameter', 137: 'error-code-would-block', 138: 'error-code-overflow', 139: 'error-code-bad-file-descriptor', 140: 'error-code-out-of-range', 141: 'error-code-name-too-long', 121: 'error-code-access-denied'}, None])

	def set_string_chunk(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-string-chunk')

		parser.add_argument('string_id', type=convert_int, help='int', metavar='<string-id>')
		parser.add_argument('offset', type=convert_int, help='int', metavar='<offset>')
		parser.add_argument('buffer', type=create_string_converter(ctx, str, 58), help='string', metavar='<buffer>')

		args = parser.parse_args(argv)

		device_call(ctx, REDBrick, 10, (args.string_id, args.offset, args.buffer), 'H I 58s', 'B', args.execute, False, ['error-code'], [{0: 'error-code-success', 1: 'error-code-unknown-error', 2: 'error-code-invalid-operation', 3: 'error-code-operation-aborted', 4: 'error-code-internal-error', 5: 'error-code-unknown-session-id', 6: 'error-code-no-free-session-id', 7: 'error-code-unknown-object-id', 8: 'error-code-no-free-object-id', 9: 'error-code-object-is-locked', 10: 'error-code-no-more-data', 11: 'error-code-wrong-list-item-type', 12: 'error-code-program-is-purged', 130: 'error-code-no-free-space', 142: 'error-code-invalid-seek', 143: 'error-code-not-supported', 144: 'error-code-too-many-open-files', 132: 'error-code-already-exists', 133: 'error-code-does-not-exist', 134: 'error-code-interrupted', 129: 'error-code-no-free-memory', 135: 'error-code-is-directory', 136: 'error-code-not-a-directory', 128: 'error-code-invalid-parameter', 137: 'error-code-would-block', 138: 'error-code-overflow', 139: 'error-code-bad-file-descriptor', 140: 'error-code-out-of-range', 141: 'error-code-name-too-long', 121: 'error-code-access-denied'}])

	def get_string_chunk(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-string-chunk')

		parser.add_argument('string_id', type=convert_int, help='int', metavar='<string-id>')
		parser.add_argument('offset', type=convert_int, help='int', metavar='<offset>')

		args = parser.parse_args(argv)

		device_call(ctx, REDBrick, 11, (args.string_id, args.offset), 'H I', 'B 63s', args.execute, False, ['error-code', 'buffer'], [{0: 'error-code-success', 1: 'error-code-unknown-error', 2: 'error-code-invalid-operation', 3: 'error-code-operation-aborted', 4: 'error-code-internal-error', 5: 'error-code-unknown-session-id', 6: 'error-code-no-free-session-id', 7: 'error-code-unknown-object-id', 8: 'error-code-no-free-object-id', 9: 'error-code-object-is-locked', 10: 'error-code-no-more-data', 11: 'error-code-wrong-list-item-type', 12: 'error-code-program-is-purged', 130: 'error-code-no-free-space', 142: 'error-code-invalid-seek', 143: 'error-code-not-supported', 144: 'error-code-too-many-open-files', 132: 'error-code-already-exists', 133: 'error-code-does-not-exist', 134: 'error-code-interrupted', 129: 'error-code-no-free-memory', 135: 'error-code-is-directory', 136: 'error-code-not-a-directory', 128: 'error-code-invalid-parameter', 137: 'error-code-would-block', 138: 'error-code-overflow', 139: 'error-code-bad-file-descriptor', 140: 'error-code-out-of-range', 141: 'error-code-name-too-long', 121: 'error-code-access-denied'}, None])

	def allocate_list(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' allocate-list')

		parser.add_argument('length_to_reserve', type=convert_int, help='int', metavar='<length-to-reserve>')
		parser.add_argument('session_id', type=convert_int, help='int', metavar='<session-id>')

		args = parser.parse_args(argv)

		device_call(ctx, REDBrick, 12, (args.length_to_reserve, args.session_id), 'H H', 'B H', args.execute, False, ['error-code', 'list-id'], [{0: 'error-code-success', 1: 'error-code-unknown-error', 2: 'error-code-invalid-operation', 3: 'error-code-operation-aborted', 4: 'error-code-internal-error', 5: 'error-code-unknown-session-id', 6: 'error-code-no-free-session-id', 7: 'error-code-unknown-object-id', 8: 'error-code-no-free-object-id', 9: 'error-code-object-is-locked', 10: 'error-code-no-more-data', 11: 'error-code-wrong-list-item-type', 12: 'error-code-program-is-purged', 130: 'error-code-no-free-space', 142: 'error-code-invalid-seek', 143: 'error-code-not-supported', 144: 'error-code-too-many-open-files', 132: 'error-code-already-exists', 133: 'error-code-does-not-exist', 134: 'error-code-interrupted', 129: 'error-code-no-free-memory', 135: 'error-code-is-directory', 136: 'error-code-not-a-directory', 128: 'error-code-invalid-parameter', 137: 'error-code-would-block', 138: 'error-code-overflow', 139: 'error-code-bad-file-descriptor', 140: 'error-code-out-of-range', 141: 'error-code-name-too-long', 121: 'error-code-access-denied'}, None])

	def get_list_length(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-list-length')

		parser.add_argument('list_id', type=convert_int, help='int', metavar='<list-id>')

		args = parser.parse_args(argv)

		device_call(ctx, REDBrick, 13, (args.list_id,), 'H', 'B H', args.execute, False, ['error-code', 'length'], [{0: 'error-code-success', 1: 'error-code-unknown-error', 2: 'error-code-invalid-operation', 3: 'error-code-operation-aborted', 4: 'error-code-internal-error', 5: 'error-code-unknown-session-id', 6: 'error-code-no-free-session-id', 7: 'error-code-unknown-object-id', 8: 'error-code-no-free-object-id', 9: 'error-code-object-is-locked', 10: 'error-code-no-more-data', 11: 'error-code-wrong-list-item-type', 12: 'error-code-program-is-purged', 130: 'error-code-no-free-space', 142: 'error-code-invalid-seek', 143: 'error-code-not-supported', 144: 'error-code-too-many-open-files', 132: 'error-code-already-exists', 133: 'error-code-does-not-exist', 134: 'error-code-interrupted', 129: 'error-code-no-free-memory', 135: 'error-code-is-directory', 136: 'error-code-not-a-directory', 128: 'error-code-invalid-parameter', 137: 'error-code-would-block', 138: 'error-code-overflow', 139: 'error-code-bad-file-descriptor', 140: 'error-code-out-of-range', 141: 'error-code-name-too-long', 121: 'error-code-access-denied'}, None])

	def get_list_item(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-list-item')

		parser.add_argument('list_id', type=convert_int, help='int', metavar='<list-id>')
		parser.add_argument('index', type=convert_int, help='int', metavar='<index>')
		parser.add_argument('session_id', type=convert_int, help='int', metavar='<session-id>')

		args = parser.parse_args(argv)

		device_call(ctx, REDBrick, 14, (args.list_id, args.index, args.session_id), 'H H H', 'B H B', args.execute, False, ['error-code', 'item-object-id', 'type'], [{0: 'error-code-success', 1: 'error-code-unknown-error', 2: 'error-code-invalid-operation', 3: 'error-code-operation-aborted', 4: 'error-code-internal-error', 5: 'error-code-unknown-session-id', 6: 'error-code-no-free-session-id', 7: 'error-code-unknown-object-id', 8: 'error-code-no-free-object-id', 9: 'error-code-object-is-locked', 10: 'error-code-no-more-data', 11: 'error-code-wrong-list-item-type', 12: 'error-code-program-is-purged', 130: 'error-code-no-free-space', 142: 'error-code-invalid-seek', 143: 'error-code-not-supported', 144: 'error-code-too-many-open-files', 132: 'error-code-already-exists', 133: 'error-code-does-not-exist', 134: 'error-code-interrupted', 129: 'error-code-no-free-memory', 135: 'error-code-is-directory', 136: 'error-code-not-a-directory', 128: 'error-code-invalid-parameter', 137: 'error-code-would-block', 138: 'error-code-overflow', 139: 'error-code-bad-file-descriptor', 140: 'error-code-out-of-range', 141: 'error-code-name-too-long', 121: 'error-code-access-denied'}, None, {0: 'object-type-string', 1: 'object-type-list', 2: 'object-type-file', 3: 'object-type-directory', 4: 'object-type-process', 5: 'object-type-program'}])

	def append_to_list(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' append-to-list')

		parser.add_argument('list_id', type=convert_int, help='int', metavar='<list-id>')
		parser.add_argument('item_object_id', type=convert_int, help='int', metavar='<item-object-id>')

		args = parser.parse_args(argv)

		device_call(ctx, REDBrick, 15, (args.list_id, args.item_object_id), 'H H', 'B', args.execute, False, ['error-code'], [{0: 'error-code-success', 1: 'error-code-unknown-error', 2: 'error-code-invalid-operation', 3: 'error-code-operation-aborted', 4: 'error-code-internal-error', 5: 'error-code-unknown-session-id', 6: 'error-code-no-free-session-id', 7: 'error-code-unknown-object-id', 8: 'error-code-no-free-object-id', 9: 'error-code-object-is-locked', 10: 'error-code-no-more-data', 11: 'error-code-wrong-list-item-type', 12: 'error-code-program-is-purged', 130: 'error-code-no-free-space', 142: 'error-code-invalid-seek', 143: 'error-code-not-supported', 144: 'error-code-too-many-open-files', 132: 'error-code-already-exists', 133: 'error-code-does-not-exist', 134: 'error-code-interrupted', 129: 'error-code-no-free-memory', 135: 'error-code-is-directory', 136: 'error-code-not-a-directory', 128: 'error-code-invalid-parameter', 137: 'error-code-would-block', 138: 'error-code-overflow', 139: 'error-code-bad-file-descriptor', 140: 'error-code-out-of-range', 141: 'error-code-name-too-long', 121: 'error-code-access-denied'}])

	def remove_from_list(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' remove-from-list')

		parser.add_argument('list_id', type=convert_int, help='int', metavar='<list-id>')
		parser.add_argument('index', type=convert_int, help='int', metavar='<index>')

		args = parser.parse_args(argv)

		device_call(ctx, REDBrick, 16, (args.list_id, args.index), 'H H', 'B', args.execute, False, ['error-code'], [{0: 'error-code-success', 1: 'error-code-unknown-error', 2: 'error-code-invalid-operation', 3: 'error-code-operation-aborted', 4: 'error-code-internal-error', 5: 'error-code-unknown-session-id', 6: 'error-code-no-free-session-id', 7: 'error-code-unknown-object-id', 8: 'error-code-no-free-object-id', 9: 'error-code-object-is-locked', 10: 'error-code-no-more-data', 11: 'error-code-wrong-list-item-type', 12: 'error-code-program-is-purged', 130: 'error-code-no-free-space', 142: 'error-code-invalid-seek', 143: 'error-code-not-supported', 144: 'error-code-too-many-open-files', 132: 'error-code-already-exists', 133: 'error-code-does-not-exist', 134: 'error-code-interrupted', 129: 'error-code-no-free-memory', 135: 'error-code-is-directory', 136: 'error-code-not-a-directory', 128: 'error-code-invalid-parameter', 137: 'error-code-would-block', 138: 'error-code-overflow', 139: 'error-code-bad-file-descriptor', 140: 'error-code-out-of-range', 141: 'error-code-name-too-long', 121: 'error-code-access-denied'}])

	def open_file(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' open-file')

		parser.add_argument('name_string_id', type=convert_int, help='int', metavar='<name-string-id>')
		parser.add_argument('flags', type=create_symbol_converter(ctx, convert_int, {'file-flag-read-write': 4, 'file-flag-temporary': 256, 'file-flag-append': 8, 'file-flag-non-blocking': 64, 'file-flag-exclusive': 32, 'file-flag-create': 16, 'file-flag-write-only': 2, 'file-flag-truncate': 128, 'file-flag-replace': 512, 'file-flag-read-only': 1}), help='int (file-flag-read-only: 1, file-flag-write-only: 2, file-flag-read-write: 4, file-flag-append: 8, file-flag-create: 16, file-flag-exclusive: 32, file-flag-non-blocking: 64, file-flag-truncate: 128, file-flag-temporary: 256, file-flag-replace: 512)', metavar='<flags>')
		parser.add_argument('permissions', type=create_symbol_converter(ctx, convert_int, {'file-permission-user-all': 448, 'file-permission-others-read': 4, 'file-permission-others-all': 7, 'file-permission-others-write': 2, 'file-permission-user-write': 128, 'file-permission-group-all': 56, 'file-permission-user-execute': 64, 'file-permission-group-execute': 8, 'file-permission-user-read': 256, 'file-permission-group-read': 32, 'file-permission-group-write': 16, 'file-permission-others-execute': 1}), help='int (file-permission-user-all: 448, file-permission-user-read: 256, file-permission-user-write: 128, file-permission-user-execute: 64, file-permission-group-all: 56, file-permission-group-read: 32, file-permission-group-write: 16, file-permission-group-execute: 8, file-permission-others-all: 7, file-permission-others-read: 4, file-permission-others-write: 2, file-permission-others-execute: 1)', metavar='<permissions>')
		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')
		parser.add_argument('gid', type=convert_int, help='int', metavar='<gid>')
		parser.add_argument('session_id', type=convert_int, help='int', metavar='<session-id>')

		args = parser.parse_args(argv)

		device_call(ctx, REDBrick, 17, (args.name_string_id, args.flags, args.permissions, args.uid, args.gid, args.session_id), 'H I H I I H', 'B H', args.execute, False, ['error-code', 'file-id'], [{0: 'error-code-success', 1: 'error-code-unknown-error', 2: 'error-code-invalid-operation', 3: 'error-code-operation-aborted', 4: 'error-code-internal-error', 5: 'error-code-unknown-session-id', 6: 'error-code-no-free-session-id', 7: 'error-code-unknown-object-id', 8: 'error-code-no-free-object-id', 9: 'error-code-object-is-locked', 10: 'error-code-no-more-data', 11: 'error-code-wrong-list-item-type', 12: 'error-code-program-is-purged', 130: 'error-code-no-free-space', 142: 'error-code-invalid-seek', 143: 'error-code-not-supported', 144: 'error-code-too-many-open-files', 132: 'error-code-already-exists', 133: 'error-code-does-not-exist', 134: 'error-code-interrupted', 129: 'error-code-no-free-memory', 135: 'error-code-is-directory', 136: 'error-code-not-a-directory', 128: 'error-code-invalid-parameter', 137: 'error-code-would-block', 138: 'error-code-overflow', 139: 'error-code-bad-file-descriptor', 140: 'error-code-out-of-range', 141: 'error-code-name-too-long', 121: 'error-code-access-denied'}, None])

	def create_pipe(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' create-pipe')

		parser.add_argument('flags', type=create_symbol_converter(ctx, convert_int, {'pipe-flag-non-blocking-read': 1, 'pipe-flag-non-blocking-write': 2}), help='int (pipe-flag-non-blocking-read: 1, pipe-flag-non-blocking-write: 2)', metavar='<flags>')
		parser.add_argument('length', type=convert_int, help='int', metavar='<length>')
		parser.add_argument('session_id', type=convert_int, help='int', metavar='<session-id>')

		args = parser.parse_args(argv)

		device_call(ctx, REDBrick, 18, (args.flags, args.length, args.session_id), 'I Q H', 'B H', args.execute, False, ['error-code', 'file-id'], [{0: 'error-code-success', 1: 'error-code-unknown-error', 2: 'error-code-invalid-operation', 3: 'error-code-operation-aborted', 4: 'error-code-internal-error', 5: 'error-code-unknown-session-id', 6: 'error-code-no-free-session-id', 7: 'error-code-unknown-object-id', 8: 'error-code-no-free-object-id', 9: 'error-code-object-is-locked', 10: 'error-code-no-more-data', 11: 'error-code-wrong-list-item-type', 12: 'error-code-program-is-purged', 130: 'error-code-no-free-space', 142: 'error-code-invalid-seek', 143: 'error-code-not-supported', 144: 'error-code-too-many-open-files', 132: 'error-code-already-exists', 133: 'error-code-does-not-exist', 134: 'error-code-interrupted', 129: 'error-code-no-free-memory', 135: 'error-code-is-directory', 136: 'error-code-not-a-directory', 128: 'error-code-invalid-parameter', 137: 'error-code-would-block', 138: 'error-code-overflow', 139: 'error-code-bad-file-descriptor', 140: 'error-code-out-of-range', 141: 'error-code-name-too-long', 121: 'error-code-access-denied'}, None])

	def get_file_info(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-file-info')

		parser.add_argument('file_id', type=convert_int, help='int', metavar='<file-id>')
		parser.add_argument('session_id', type=convert_int, help='int', metavar='<session-id>')

		args = parser.parse_args(argv)

		device_call(ctx, REDBrick, 19, (args.file_id, args.session_id), 'H H', 'B B H I H I I Q Q Q Q', args.execute, False, ['error-code', 'type', 'name-string-id', 'flags', 'permissions', 'uid', 'gid', 'length', 'access-timestamp', 'modification-timestamp', 'status-change-timestamp'], [{0: 'error-code-success', 1: 'error-code-unknown-error', 2: 'error-code-invalid-operation', 3: 'error-code-operation-aborted', 4: 'error-code-internal-error', 5: 'error-code-unknown-session-id', 6: 'error-code-no-free-session-id', 7: 'error-code-unknown-object-id', 8: 'error-code-no-free-object-id', 9: 'error-code-object-is-locked', 10: 'error-code-no-more-data', 11: 'error-code-wrong-list-item-type', 12: 'error-code-program-is-purged', 130: 'error-code-no-free-space', 142: 'error-code-invalid-seek', 143: 'error-code-not-supported', 144: 'error-code-too-many-open-files', 132: 'error-code-already-exists', 133: 'error-code-does-not-exist', 134: 'error-code-interrupted', 129: 'error-code-no-free-memory', 135: 'error-code-is-directory', 136: 'error-code-not-a-directory', 128: 'error-code-invalid-parameter', 137: 'error-code-would-block', 138: 'error-code-overflow', 139: 'error-code-bad-file-descriptor', 140: 'error-code-out-of-range', 141: 'error-code-name-too-long', 121: 'error-code-access-denied'}, {0: 'file-type-unknown', 1: 'file-type-regular', 2: 'file-type-directory', 3: 'file-type-character', 4: 'file-type-block', 5: 'file-type-fifo', 6: 'file-type-symlink', 7: 'file-type-socket', 8: 'file-type-pipe'}, None, None, {448: 'file-permission-user-all', 256: 'file-permission-user-read', 2: 'file-permission-others-write', 4: 'file-permission-others-read', 32: 'file-permission-group-read', 64: 'file-permission-user-execute', 128: 'file-permission-user-write', 7: 'file-permission-others-all', 16: 'file-permission-group-write', 8: 'file-permission-group-execute', 1: 'file-permission-others-execute', 56: 'file-permission-group-all'}, None, None, None, None, None, None])

	def read_file(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-file')

		parser.add_argument('file_id', type=convert_int, help='int', metavar='<file-id>')
		parser.add_argument('length_to_read', type=convert_int, help='int', metavar='<length-to-read>')

		args = parser.parse_args(argv)

		device_call(ctx, REDBrick, 20, (args.file_id, args.length_to_read), 'H B', 'B 62B B', args.execute, False, ['error-code', 'buffer', 'length-read'], [{0: 'error-code-success', 1: 'error-code-unknown-error', 2: 'error-code-invalid-operation', 3: 'error-code-operation-aborted', 4: 'error-code-internal-error', 5: 'error-code-unknown-session-id', 6: 'error-code-no-free-session-id', 7: 'error-code-unknown-object-id', 8: 'error-code-no-free-object-id', 9: 'error-code-object-is-locked', 10: 'error-code-no-more-data', 11: 'error-code-wrong-list-item-type', 12: 'error-code-program-is-purged', 130: 'error-code-no-free-space', 142: 'error-code-invalid-seek', 143: 'error-code-not-supported', 144: 'error-code-too-many-open-files', 132: 'error-code-already-exists', 133: 'error-code-does-not-exist', 134: 'error-code-interrupted', 129: 'error-code-no-free-memory', 135: 'error-code-is-directory', 136: 'error-code-not-a-directory', 128: 'error-code-invalid-parameter', 137: 'error-code-would-block', 138: 'error-code-overflow', 139: 'error-code-bad-file-descriptor', 140: 'error-code-out-of-range', 141: 'error-code-name-too-long', 121: 'error-code-access-denied'}, None, None])

	def read_file_async(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' read-file-async')

		parser.add_argument('file_id', type=convert_int, help='int', metavar='<file-id>')
		parser.add_argument('length_to_read', type=convert_int, help='int', metavar='<length-to-read>')

		args = parser.parse_args(argv)

		device_call(ctx, REDBrick, 21, (args.file_id, args.length_to_read), 'H Q', '', None, args.expect_response, [], [])

	def abort_async_file_read(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' abort-async-file-read')

		parser.add_argument('file_id', type=convert_int, help='int', metavar='<file-id>')

		args = parser.parse_args(argv)

		device_call(ctx, REDBrick, 22, (args.file_id,), 'H', 'B', args.execute, False, ['error-code'], [{0: 'error-code-success', 1: 'error-code-unknown-error', 2: 'error-code-invalid-operation', 3: 'error-code-operation-aborted', 4: 'error-code-internal-error', 5: 'error-code-unknown-session-id', 6: 'error-code-no-free-session-id', 7: 'error-code-unknown-object-id', 8: 'error-code-no-free-object-id', 9: 'error-code-object-is-locked', 10: 'error-code-no-more-data', 11: 'error-code-wrong-list-item-type', 12: 'error-code-program-is-purged', 130: 'error-code-no-free-space', 142: 'error-code-invalid-seek', 143: 'error-code-not-supported', 144: 'error-code-too-many-open-files', 132: 'error-code-already-exists', 133: 'error-code-does-not-exist', 134: 'error-code-interrupted', 129: 'error-code-no-free-memory', 135: 'error-code-is-directory', 136: 'error-code-not-a-directory', 128: 'error-code-invalid-parameter', 137: 'error-code-would-block', 138: 'error-code-overflow', 139: 'error-code-bad-file-descriptor', 140: 'error-code-out-of-range', 141: 'error-code-name-too-long', 121: 'error-code-access-denied'}])

	def write_file(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-file')

		parser.add_argument('file_id', type=convert_int, help='int', metavar='<file-id>')
		parser.add_argument('buffer', type=create_array_converter(ctx, convert_int, '0', 61), help=get_array_type_name(ctx, 'int', 61), metavar='<buffer>')
		parser.add_argument('length_to_write', type=convert_int, help='int', metavar='<length-to-write>')

		args = parser.parse_args(argv)

		device_call(ctx, REDBrick, 23, (args.file_id, args.buffer, args.length_to_write), 'H 61B B', 'B B', args.execute, False, ['error-code', 'length-written'], [{0: 'error-code-success', 1: 'error-code-unknown-error', 2: 'error-code-invalid-operation', 3: 'error-code-operation-aborted', 4: 'error-code-internal-error', 5: 'error-code-unknown-session-id', 6: 'error-code-no-free-session-id', 7: 'error-code-unknown-object-id', 8: 'error-code-no-free-object-id', 9: 'error-code-object-is-locked', 10: 'error-code-no-more-data', 11: 'error-code-wrong-list-item-type', 12: 'error-code-program-is-purged', 130: 'error-code-no-free-space', 142: 'error-code-invalid-seek', 143: 'error-code-not-supported', 144: 'error-code-too-many-open-files', 132: 'error-code-already-exists', 133: 'error-code-does-not-exist', 134: 'error-code-interrupted', 129: 'error-code-no-free-memory', 135: 'error-code-is-directory', 136: 'error-code-not-a-directory', 128: 'error-code-invalid-parameter', 137: 'error-code-would-block', 138: 'error-code-overflow', 139: 'error-code-bad-file-descriptor', 140: 'error-code-out-of-range', 141: 'error-code-name-too-long', 121: 'error-code-access-denied'}, None])

	def write_file_unchecked(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-file-unchecked')

		parser.add_argument('file_id', type=convert_int, help='int', metavar='<file-id>')
		parser.add_argument('buffer', type=create_array_converter(ctx, convert_int, '0', 61), help=get_array_type_name(ctx, 'int', 61), metavar='<buffer>')
		parser.add_argument('length_to_write', type=convert_int, help='int', metavar='<length-to-write>')

		args = parser.parse_args(argv)

		device_call(ctx, REDBrick, 24, (args.file_id, args.buffer, args.length_to_write), 'H 61B B', '', None, args.expect_response, [], [])

	def write_file_async(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-file-async')

		parser.add_argument('file_id', type=convert_int, help='int', metavar='<file-id>')
		parser.add_argument('buffer', type=create_array_converter(ctx, convert_int, '0', 61), help=get_array_type_name(ctx, 'int', 61), metavar='<buffer>')
		parser.add_argument('length_to_write', type=convert_int, help='int', metavar='<length-to-write>')

		args = parser.parse_args(argv)

		device_call(ctx, REDBrick, 25, (args.file_id, args.buffer, args.length_to_write), 'H 61B B', '', None, args.expect_response, [], [])

	def set_file_position(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-file-position')

		parser.add_argument('file_id', type=convert_int, help='int', metavar='<file-id>')
		parser.add_argument('offset', type=convert_int, help='int', metavar='<offset>')
		parser.add_argument('origin', type=create_symbol_converter(ctx, convert_int, {'file-origin-end': 2, 'file-origin-beginning': 0, 'file-origin-current': 1}), help='int (file-origin-beginning: 0, file-origin-current: 1, file-origin-end: 2)', metavar='<origin>')

		args = parser.parse_args(argv)

		device_call(ctx, REDBrick, 26, (args.file_id, args.offset, args.origin), 'H q B', 'B Q', args.execute, False, ['error-code', 'position'], [{0: 'error-code-success', 1: 'error-code-unknown-error', 2: 'error-code-invalid-operation', 3: 'error-code-operation-aborted', 4: 'error-code-internal-error', 5: 'error-code-unknown-session-id', 6: 'error-code-no-free-session-id', 7: 'error-code-unknown-object-id', 8: 'error-code-no-free-object-id', 9: 'error-code-object-is-locked', 10: 'error-code-no-more-data', 11: 'error-code-wrong-list-item-type', 12: 'error-code-program-is-purged', 130: 'error-code-no-free-space', 142: 'error-code-invalid-seek', 143: 'error-code-not-supported', 144: 'error-code-too-many-open-files', 132: 'error-code-already-exists', 133: 'error-code-does-not-exist', 134: 'error-code-interrupted', 129: 'error-code-no-free-memory', 135: 'error-code-is-directory', 136: 'error-code-not-a-directory', 128: 'error-code-invalid-parameter', 137: 'error-code-would-block', 138: 'error-code-overflow', 139: 'error-code-bad-file-descriptor', 140: 'error-code-out-of-range', 141: 'error-code-name-too-long', 121: 'error-code-access-denied'}, None])

	def get_file_position(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-file-position')

		parser.add_argument('file_id', type=convert_int, help='int', metavar='<file-id>')

		args = parser.parse_args(argv)

		device_call(ctx, REDBrick, 27, (args.file_id,), 'H', 'B Q', args.execute, False, ['error-code', 'position'], [{0: 'error-code-success', 1: 'error-code-unknown-error', 2: 'error-code-invalid-operation', 3: 'error-code-operation-aborted', 4: 'error-code-internal-error', 5: 'error-code-unknown-session-id', 6: 'error-code-no-free-session-id', 7: 'error-code-unknown-object-id', 8: 'error-code-no-free-object-id', 9: 'error-code-object-is-locked', 10: 'error-code-no-more-data', 11: 'error-code-wrong-list-item-type', 12: 'error-code-program-is-purged', 130: 'error-code-no-free-space', 142: 'error-code-invalid-seek', 143: 'error-code-not-supported', 144: 'error-code-too-many-open-files', 132: 'error-code-already-exists', 133: 'error-code-does-not-exist', 134: 'error-code-interrupted', 129: 'error-code-no-free-memory', 135: 'error-code-is-directory', 136: 'error-code-not-a-directory', 128: 'error-code-invalid-parameter', 137: 'error-code-would-block', 138: 'error-code-overflow', 139: 'error-code-bad-file-descriptor', 140: 'error-code-out-of-range', 141: 'error-code-name-too-long', 121: 'error-code-access-denied'}, None])

	def set_file_events(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-file-events')

		parser.add_argument('file_id', type=convert_int, help='int', metavar='<file-id>')
		parser.add_argument('events', type=create_symbol_converter(ctx, convert_int, {'file-event-readable': 1, 'file-event-writable': 2}), help='int (file-event-readable: 1, file-event-writable: 2)', metavar='<events>')

		args = parser.parse_args(argv)

		device_call(ctx, REDBrick, 28, (args.file_id, args.events), 'H H', 'B', args.execute, False, ['error-code'], [{0: 'error-code-success', 1: 'error-code-unknown-error', 2: 'error-code-invalid-operation', 3: 'error-code-operation-aborted', 4: 'error-code-internal-error', 5: 'error-code-unknown-session-id', 6: 'error-code-no-free-session-id', 7: 'error-code-unknown-object-id', 8: 'error-code-no-free-object-id', 9: 'error-code-object-is-locked', 10: 'error-code-no-more-data', 11: 'error-code-wrong-list-item-type', 12: 'error-code-program-is-purged', 130: 'error-code-no-free-space', 142: 'error-code-invalid-seek', 143: 'error-code-not-supported', 144: 'error-code-too-many-open-files', 132: 'error-code-already-exists', 133: 'error-code-does-not-exist', 134: 'error-code-interrupted', 129: 'error-code-no-free-memory', 135: 'error-code-is-directory', 136: 'error-code-not-a-directory', 128: 'error-code-invalid-parameter', 137: 'error-code-would-block', 138: 'error-code-overflow', 139: 'error-code-bad-file-descriptor', 140: 'error-code-out-of-range', 141: 'error-code-name-too-long', 121: 'error-code-access-denied'}])

	def get_file_events(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-file-events')

		parser.add_argument('file_id', type=convert_int, help='int', metavar='<file-id>')

		args = parser.parse_args(argv)

		device_call(ctx, REDBrick, 29, (args.file_id,), 'H', 'B H', args.execute, False, ['error-code', 'events'], [{0: 'error-code-success', 1: 'error-code-unknown-error', 2: 'error-code-invalid-operation', 3: 'error-code-operation-aborted', 4: 'error-code-internal-error', 5: 'error-code-unknown-session-id', 6: 'error-code-no-free-session-id', 7: 'error-code-unknown-object-id', 8: 'error-code-no-free-object-id', 9: 'error-code-object-is-locked', 10: 'error-code-no-more-data', 11: 'error-code-wrong-list-item-type', 12: 'error-code-program-is-purged', 130: 'error-code-no-free-space', 142: 'error-code-invalid-seek', 143: 'error-code-not-supported', 144: 'error-code-too-many-open-files', 132: 'error-code-already-exists', 133: 'error-code-does-not-exist', 134: 'error-code-interrupted', 129: 'error-code-no-free-memory', 135: 'error-code-is-directory', 136: 'error-code-not-a-directory', 128: 'error-code-invalid-parameter', 137: 'error-code-would-block', 138: 'error-code-overflow', 139: 'error-code-bad-file-descriptor', 140: 'error-code-out-of-range', 141: 'error-code-name-too-long', 121: 'error-code-access-denied'}, {1: 'file-event-readable', 2: 'file-event-writable'}])

	def open_directory(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' open-directory')

		parser.add_argument('name_string_id', type=convert_int, help='int', metavar='<name-string-id>')
		parser.add_argument('session_id', type=convert_int, help='int', metavar='<session-id>')

		args = parser.parse_args(argv)

		device_call(ctx, REDBrick, 33, (args.name_string_id, args.session_id), 'H H', 'B H', args.execute, False, ['error-code', 'directory-id'], [{0: 'error-code-success', 1: 'error-code-unknown-error', 2: 'error-code-invalid-operation', 3: 'error-code-operation-aborted', 4: 'error-code-internal-error', 5: 'error-code-unknown-session-id', 6: 'error-code-no-free-session-id', 7: 'error-code-unknown-object-id', 8: 'error-code-no-free-object-id', 9: 'error-code-object-is-locked', 10: 'error-code-no-more-data', 11: 'error-code-wrong-list-item-type', 12: 'error-code-program-is-purged', 130: 'error-code-no-free-space', 142: 'error-code-invalid-seek', 143: 'error-code-not-supported', 144: 'error-code-too-many-open-files', 132: 'error-code-already-exists', 133: 'error-code-does-not-exist', 134: 'error-code-interrupted', 129: 'error-code-no-free-memory', 135: 'error-code-is-directory', 136: 'error-code-not-a-directory', 128: 'error-code-invalid-parameter', 137: 'error-code-would-block', 138: 'error-code-overflow', 139: 'error-code-bad-file-descriptor', 140: 'error-code-out-of-range', 141: 'error-code-name-too-long', 121: 'error-code-access-denied'}, None])

	def get_directory_name(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-directory-name')

		parser.add_argument('directory_id', type=convert_int, help='int', metavar='<directory-id>')
		parser.add_argument('session_id', type=convert_int, help='int', metavar='<session-id>')

		args = parser.parse_args(argv)

		device_call(ctx, REDBrick, 34, (args.directory_id, args.session_id), 'H H', 'B H', args.execute, False, ['error-code', 'name-string-id'], [{0: 'error-code-success', 1: 'error-code-unknown-error', 2: 'error-code-invalid-operation', 3: 'error-code-operation-aborted', 4: 'error-code-internal-error', 5: 'error-code-unknown-session-id', 6: 'error-code-no-free-session-id', 7: 'error-code-unknown-object-id', 8: 'error-code-no-free-object-id', 9: 'error-code-object-is-locked', 10: 'error-code-no-more-data', 11: 'error-code-wrong-list-item-type', 12: 'error-code-program-is-purged', 130: 'error-code-no-free-space', 142: 'error-code-invalid-seek', 143: 'error-code-not-supported', 144: 'error-code-too-many-open-files', 132: 'error-code-already-exists', 133: 'error-code-does-not-exist', 134: 'error-code-interrupted', 129: 'error-code-no-free-memory', 135: 'error-code-is-directory', 136: 'error-code-not-a-directory', 128: 'error-code-invalid-parameter', 137: 'error-code-would-block', 138: 'error-code-overflow', 139: 'error-code-bad-file-descriptor', 140: 'error-code-out-of-range', 141: 'error-code-name-too-long', 121: 'error-code-access-denied'}, None])

	def get_next_directory_entry(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-next-directory-entry')

		parser.add_argument('directory_id', type=convert_int, help='int', metavar='<directory-id>')
		parser.add_argument('session_id', type=convert_int, help='int', metavar='<session-id>')

		args = parser.parse_args(argv)

		device_call(ctx, REDBrick, 35, (args.directory_id, args.session_id), 'H H', 'B H B', args.execute, False, ['error-code', 'name-string-id', 'type'], [{0: 'error-code-success', 1: 'error-code-unknown-error', 2: 'error-code-invalid-operation', 3: 'error-code-operation-aborted', 4: 'error-code-internal-error', 5: 'error-code-unknown-session-id', 6: 'error-code-no-free-session-id', 7: 'error-code-unknown-object-id', 8: 'error-code-no-free-object-id', 9: 'error-code-object-is-locked', 10: 'error-code-no-more-data', 11: 'error-code-wrong-list-item-type', 12: 'error-code-program-is-purged', 130: 'error-code-no-free-space', 142: 'error-code-invalid-seek', 143: 'error-code-not-supported', 144: 'error-code-too-many-open-files', 132: 'error-code-already-exists', 133: 'error-code-does-not-exist', 134: 'error-code-interrupted', 129: 'error-code-no-free-memory', 135: 'error-code-is-directory', 136: 'error-code-not-a-directory', 128: 'error-code-invalid-parameter', 137: 'error-code-would-block', 138: 'error-code-overflow', 139: 'error-code-bad-file-descriptor', 140: 'error-code-out-of-range', 141: 'error-code-name-too-long', 121: 'error-code-access-denied'}, None, {0: 'directory-entry-type-unknown', 1: 'directory-entry-type-regular', 2: 'directory-entry-type-directory', 3: 'directory-entry-type-character', 4: 'directory-entry-type-block', 5: 'directory-entry-type-fifo', 6: 'directory-entry-type-symlink', 7: 'directory-entry-type-socket'}])

	def rewind_directory(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' rewind-directory')

		parser.add_argument('directory_id', type=convert_int, help='int', metavar='<directory-id>')

		args = parser.parse_args(argv)

		device_call(ctx, REDBrick, 36, (args.directory_id,), 'H', 'B', args.execute, False, ['error-code'], [{0: 'error-code-success', 1: 'error-code-unknown-error', 2: 'error-code-invalid-operation', 3: 'error-code-operation-aborted', 4: 'error-code-internal-error', 5: 'error-code-unknown-session-id', 6: 'error-code-no-free-session-id', 7: 'error-code-unknown-object-id', 8: 'error-code-no-free-object-id', 9: 'error-code-object-is-locked', 10: 'error-code-no-more-data', 11: 'error-code-wrong-list-item-type', 12: 'error-code-program-is-purged', 130: 'error-code-no-free-space', 142: 'error-code-invalid-seek', 143: 'error-code-not-supported', 144: 'error-code-too-many-open-files', 132: 'error-code-already-exists', 133: 'error-code-does-not-exist', 134: 'error-code-interrupted', 129: 'error-code-no-free-memory', 135: 'error-code-is-directory', 136: 'error-code-not-a-directory', 128: 'error-code-invalid-parameter', 137: 'error-code-would-block', 138: 'error-code-overflow', 139: 'error-code-bad-file-descriptor', 140: 'error-code-out-of-range', 141: 'error-code-name-too-long', 121: 'error-code-access-denied'}])

	def create_directory(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' create-directory')

		parser.add_argument('name_string_id', type=convert_int, help='int', metavar='<name-string-id>')
		parser.add_argument('flags', type=create_symbol_converter(ctx, convert_int, {'directory-flag-exclusive': 2, 'directory-flag-recursive': 1}), help='int (directory-flag-recursive: 1, directory-flag-exclusive: 2)', metavar='<flags>')
		parser.add_argument('permissions', type=create_symbol_converter(ctx, convert_int, {'file-permission-user-all': 448, 'file-permission-others-read': 4, 'file-permission-others-all': 7, 'file-permission-others-write': 2, 'file-permission-user-write': 128, 'file-permission-group-all': 56, 'file-permission-user-execute': 64, 'file-permission-group-execute': 8, 'file-permission-user-read': 256, 'file-permission-group-read': 32, 'file-permission-group-write': 16, 'file-permission-others-execute': 1}), help='int (file-permission-user-all: 448, file-permission-user-read: 256, file-permission-user-write: 128, file-permission-user-execute: 64, file-permission-group-all: 56, file-permission-group-read: 32, file-permission-group-write: 16, file-permission-group-execute: 8, file-permission-others-all: 7, file-permission-others-read: 4, file-permission-others-write: 2, file-permission-others-execute: 1)', metavar='<permissions>')
		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')
		parser.add_argument('gid', type=convert_int, help='int', metavar='<gid>')

		args = parser.parse_args(argv)

		device_call(ctx, REDBrick, 37, (args.name_string_id, args.flags, args.permissions, args.uid, args.gid), 'H I H I I', 'B', args.execute, False, ['error-code'], [{0: 'error-code-success', 1: 'error-code-unknown-error', 2: 'error-code-invalid-operation', 3: 'error-code-operation-aborted', 4: 'error-code-internal-error', 5: 'error-code-unknown-session-id', 6: 'error-code-no-free-session-id', 7: 'error-code-unknown-object-id', 8: 'error-code-no-free-object-id', 9: 'error-code-object-is-locked', 10: 'error-code-no-more-data', 11: 'error-code-wrong-list-item-type', 12: 'error-code-program-is-purged', 130: 'error-code-no-free-space', 142: 'error-code-invalid-seek', 143: 'error-code-not-supported', 144: 'error-code-too-many-open-files', 132: 'error-code-already-exists', 133: 'error-code-does-not-exist', 134: 'error-code-interrupted', 129: 'error-code-no-free-memory', 135: 'error-code-is-directory', 136: 'error-code-not-a-directory', 128: 'error-code-invalid-parameter', 137: 'error-code-would-block', 138: 'error-code-overflow', 139: 'error-code-bad-file-descriptor', 140: 'error-code-out-of-range', 141: 'error-code-name-too-long', 121: 'error-code-access-denied'}])

	def get_processes(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-processes')

		parser.add_argument('session_id', type=convert_int, help='int', metavar='<session-id>')

		args = parser.parse_args(argv)

		device_call(ctx, REDBrick, 38, (args.session_id,), 'H', 'B H', args.execute, False, ['error-code', 'processes-list-id'], [{0: 'error-code-success', 1: 'error-code-unknown-error', 2: 'error-code-invalid-operation', 3: 'error-code-operation-aborted', 4: 'error-code-internal-error', 5: 'error-code-unknown-session-id', 6: 'error-code-no-free-session-id', 7: 'error-code-unknown-object-id', 8: 'error-code-no-free-object-id', 9: 'error-code-object-is-locked', 10: 'error-code-no-more-data', 11: 'error-code-wrong-list-item-type', 12: 'error-code-program-is-purged', 130: 'error-code-no-free-space', 142: 'error-code-invalid-seek', 143: 'error-code-not-supported', 144: 'error-code-too-many-open-files', 132: 'error-code-already-exists', 133: 'error-code-does-not-exist', 134: 'error-code-interrupted', 129: 'error-code-no-free-memory', 135: 'error-code-is-directory', 136: 'error-code-not-a-directory', 128: 'error-code-invalid-parameter', 137: 'error-code-would-block', 138: 'error-code-overflow', 139: 'error-code-bad-file-descriptor', 140: 'error-code-out-of-range', 141: 'error-code-name-too-long', 121: 'error-code-access-denied'}, None])

	def spawn_process(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' spawn-process')

		parser.add_argument('executable_string_id', type=convert_int, help='int', metavar='<executable-string-id>')
		parser.add_argument('arguments_list_id', type=convert_int, help='int', metavar='<arguments-list-id>')
		parser.add_argument('environment_list_id', type=convert_int, help='int', metavar='<environment-list-id>')
		parser.add_argument('working_directory_string_id', type=convert_int, help='int', metavar='<working-directory-string-id>')
		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')
		parser.add_argument('gid', type=convert_int, help='int', metavar='<gid>')
		parser.add_argument('stdin_file_id', type=convert_int, help='int', metavar='<stdin-file-id>')
		parser.add_argument('stdout_file_id', type=convert_int, help='int', metavar='<stdout-file-id>')
		parser.add_argument('stderr_file_id', type=convert_int, help='int', metavar='<stderr-file-id>')
		parser.add_argument('session_id', type=convert_int, help='int', metavar='<session-id>')

		args = parser.parse_args(argv)

		device_call(ctx, REDBrick, 39, (args.executable_string_id, args.arguments_list_id, args.environment_list_id, args.working_directory_string_id, args.uid, args.gid, args.stdin_file_id, args.stdout_file_id, args.stderr_file_id, args.session_id), 'H H H H I I H H H H', 'B H', args.execute, False, ['error-code', 'process-id'], [{0: 'error-code-success', 1: 'error-code-unknown-error', 2: 'error-code-invalid-operation', 3: 'error-code-operation-aborted', 4: 'error-code-internal-error', 5: 'error-code-unknown-session-id', 6: 'error-code-no-free-session-id', 7: 'error-code-unknown-object-id', 8: 'error-code-no-free-object-id', 9: 'error-code-object-is-locked', 10: 'error-code-no-more-data', 11: 'error-code-wrong-list-item-type', 12: 'error-code-program-is-purged', 130: 'error-code-no-free-space', 142: 'error-code-invalid-seek', 143: 'error-code-not-supported', 144: 'error-code-too-many-open-files', 132: 'error-code-already-exists', 133: 'error-code-does-not-exist', 134: 'error-code-interrupted', 129: 'error-code-no-free-memory', 135: 'error-code-is-directory', 136: 'error-code-not-a-directory', 128: 'error-code-invalid-parameter', 137: 'error-code-would-block', 138: 'error-code-overflow', 139: 'error-code-bad-file-descriptor', 140: 'error-code-out-of-range', 141: 'error-code-name-too-long', 121: 'error-code-access-denied'}, None])

	def kill_process(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' kill-process')

		parser.add_argument('process_id', type=convert_int, help='int', metavar='<process-id>')
		parser.add_argument('signal', type=create_symbol_converter(ctx, convert_int, {'process-signal-stop': 19, 'process-signal-interrupt': 2, 'process-signal-user1': 10, 'process-signal-user2': 12, 'process-signal-continue': 18, 'process-signal-terminate': 15, 'process-signal-abort': 6, 'process-signal-kill': 9, 'process-signal-quit': 3}), help='int (process-signal-interrupt: 2, process-signal-quit: 3, process-signal-abort: 6, process-signal-kill: 9, process-signal-user1: 10, process-signal-user2: 12, process-signal-terminate: 15, process-signal-continue: 18, process-signal-stop: 19)', metavar='<signal>')

		args = parser.parse_args(argv)

		device_call(ctx, REDBrick, 40, (args.process_id, args.signal), 'H B', 'B', args.execute, False, ['error-code'], [{0: 'error-code-success', 1: 'error-code-unknown-error', 2: 'error-code-invalid-operation', 3: 'error-code-operation-aborted', 4: 'error-code-internal-error', 5: 'error-code-unknown-session-id', 6: 'error-code-no-free-session-id', 7: 'error-code-unknown-object-id', 8: 'error-code-no-free-object-id', 9: 'error-code-object-is-locked', 10: 'error-code-no-more-data', 11: 'error-code-wrong-list-item-type', 12: 'error-code-program-is-purged', 130: 'error-code-no-free-space', 142: 'error-code-invalid-seek', 143: 'error-code-not-supported', 144: 'error-code-too-many-open-files', 132: 'error-code-already-exists', 133: 'error-code-does-not-exist', 134: 'error-code-interrupted', 129: 'error-code-no-free-memory', 135: 'error-code-is-directory', 136: 'error-code-not-a-directory', 128: 'error-code-invalid-parameter', 137: 'error-code-would-block', 138: 'error-code-overflow', 139: 'error-code-bad-file-descriptor', 140: 'error-code-out-of-range', 141: 'error-code-name-too-long', 121: 'error-code-access-denied'}])

	def get_process_command(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-process-command')

		parser.add_argument('process_id', type=convert_int, help='int', metavar='<process-id>')
		parser.add_argument('session_id', type=convert_int, help='int', metavar='<session-id>')

		args = parser.parse_args(argv)

		device_call(ctx, REDBrick, 41, (args.process_id, args.session_id), 'H H', 'B H H H H', args.execute, False, ['error-code', 'executable-string-id', 'arguments-list-id', 'environment-list-id', 'working-directory-string-id'], [{0: 'error-code-success', 1: 'error-code-unknown-error', 2: 'error-code-invalid-operation', 3: 'error-code-operation-aborted', 4: 'error-code-internal-error', 5: 'error-code-unknown-session-id', 6: 'error-code-no-free-session-id', 7: 'error-code-unknown-object-id', 8: 'error-code-no-free-object-id', 9: 'error-code-object-is-locked', 10: 'error-code-no-more-data', 11: 'error-code-wrong-list-item-type', 12: 'error-code-program-is-purged', 130: 'error-code-no-free-space', 142: 'error-code-invalid-seek', 143: 'error-code-not-supported', 144: 'error-code-too-many-open-files', 132: 'error-code-already-exists', 133: 'error-code-does-not-exist', 134: 'error-code-interrupted', 129: 'error-code-no-free-memory', 135: 'error-code-is-directory', 136: 'error-code-not-a-directory', 128: 'error-code-invalid-parameter', 137: 'error-code-would-block', 138: 'error-code-overflow', 139: 'error-code-bad-file-descriptor', 140: 'error-code-out-of-range', 141: 'error-code-name-too-long', 121: 'error-code-access-denied'}, None, None, None, None])

	def get_process_identity(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-process-identity')

		parser.add_argument('process_id', type=convert_int, help='int', metavar='<process-id>')

		args = parser.parse_args(argv)

		device_call(ctx, REDBrick, 42, (args.process_id,), 'H', 'B I I I', args.execute, False, ['error-code', 'pid', 'uid', 'gid'], [{0: 'error-code-success', 1: 'error-code-unknown-error', 2: 'error-code-invalid-operation', 3: 'error-code-operation-aborted', 4: 'error-code-internal-error', 5: 'error-code-unknown-session-id', 6: 'error-code-no-free-session-id', 7: 'error-code-unknown-object-id', 8: 'error-code-no-free-object-id', 9: 'error-code-object-is-locked', 10: 'error-code-no-more-data', 11: 'error-code-wrong-list-item-type', 12: 'error-code-program-is-purged', 130: 'error-code-no-free-space', 142: 'error-code-invalid-seek', 143: 'error-code-not-supported', 144: 'error-code-too-many-open-files', 132: 'error-code-already-exists', 133: 'error-code-does-not-exist', 134: 'error-code-interrupted', 129: 'error-code-no-free-memory', 135: 'error-code-is-directory', 136: 'error-code-not-a-directory', 128: 'error-code-invalid-parameter', 137: 'error-code-would-block', 138: 'error-code-overflow', 139: 'error-code-bad-file-descriptor', 140: 'error-code-out-of-range', 141: 'error-code-name-too-long', 121: 'error-code-access-denied'}, None, None, None])

	def get_process_stdio(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-process-stdio')

		parser.add_argument('process_id', type=convert_int, help='int', metavar='<process-id>')
		parser.add_argument('session_id', type=convert_int, help='int', metavar='<session-id>')

		args = parser.parse_args(argv)

		device_call(ctx, REDBrick, 43, (args.process_id, args.session_id), 'H H', 'B H H H', args.execute, False, ['error-code', 'stdin-file-id', 'stdout-file-id', 'stderr-file-id'], [{0: 'error-code-success', 1: 'error-code-unknown-error', 2: 'error-code-invalid-operation', 3: 'error-code-operation-aborted', 4: 'error-code-internal-error', 5: 'error-code-unknown-session-id', 6: 'error-code-no-free-session-id', 7: 'error-code-unknown-object-id', 8: 'error-code-no-free-object-id', 9: 'error-code-object-is-locked', 10: 'error-code-no-more-data', 11: 'error-code-wrong-list-item-type', 12: 'error-code-program-is-purged', 130: 'error-code-no-free-space', 142: 'error-code-invalid-seek', 143: 'error-code-not-supported', 144: 'error-code-too-many-open-files', 132: 'error-code-already-exists', 133: 'error-code-does-not-exist', 134: 'error-code-interrupted', 129: 'error-code-no-free-memory', 135: 'error-code-is-directory', 136: 'error-code-not-a-directory', 128: 'error-code-invalid-parameter', 137: 'error-code-would-block', 138: 'error-code-overflow', 139: 'error-code-bad-file-descriptor', 140: 'error-code-out-of-range', 141: 'error-code-name-too-long', 121: 'error-code-access-denied'}, None, None, None])

	def get_process_state(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-process-state')

		parser.add_argument('process_id', type=convert_int, help='int', metavar='<process-id>')

		args = parser.parse_args(argv)

		device_call(ctx, REDBrick, 44, (args.process_id,), 'H', 'B B Q B', args.execute, False, ['error-code', 'state', 'timestamp', 'exit-code'], [{0: 'error-code-success', 1: 'error-code-unknown-error', 2: 'error-code-invalid-operation', 3: 'error-code-operation-aborted', 4: 'error-code-internal-error', 5: 'error-code-unknown-session-id', 6: 'error-code-no-free-session-id', 7: 'error-code-unknown-object-id', 8: 'error-code-no-free-object-id', 9: 'error-code-object-is-locked', 10: 'error-code-no-more-data', 11: 'error-code-wrong-list-item-type', 12: 'error-code-program-is-purged', 130: 'error-code-no-free-space', 142: 'error-code-invalid-seek', 143: 'error-code-not-supported', 144: 'error-code-too-many-open-files', 132: 'error-code-already-exists', 133: 'error-code-does-not-exist', 134: 'error-code-interrupted', 129: 'error-code-no-free-memory', 135: 'error-code-is-directory', 136: 'error-code-not-a-directory', 128: 'error-code-invalid-parameter', 137: 'error-code-would-block', 138: 'error-code-overflow', 139: 'error-code-bad-file-descriptor', 140: 'error-code-out-of-range', 141: 'error-code-name-too-long', 121: 'error-code-access-denied'}, {0: 'process-state-unknown', 1: 'process-state-running', 2: 'process-state-error', 3: 'process-state-exited', 4: 'process-state-killed', 5: 'process-state-stopped'}, None, None])

	def get_programs(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-programs')

		parser.add_argument('session_id', type=convert_int, help='int', metavar='<session-id>')

		args = parser.parse_args(argv)

		device_call(ctx, REDBrick, 46, (args.session_id,), 'H', 'B H', args.execute, False, ['error-code', 'programs-list-id'], [{0: 'error-code-success', 1: 'error-code-unknown-error', 2: 'error-code-invalid-operation', 3: 'error-code-operation-aborted', 4: 'error-code-internal-error', 5: 'error-code-unknown-session-id', 6: 'error-code-no-free-session-id', 7: 'error-code-unknown-object-id', 8: 'error-code-no-free-object-id', 9: 'error-code-object-is-locked', 10: 'error-code-no-more-data', 11: 'error-code-wrong-list-item-type', 12: 'error-code-program-is-purged', 130: 'error-code-no-free-space', 142: 'error-code-invalid-seek', 143: 'error-code-not-supported', 144: 'error-code-too-many-open-files', 132: 'error-code-already-exists', 133: 'error-code-does-not-exist', 134: 'error-code-interrupted', 129: 'error-code-no-free-memory', 135: 'error-code-is-directory', 136: 'error-code-not-a-directory', 128: 'error-code-invalid-parameter', 137: 'error-code-would-block', 138: 'error-code-overflow', 139: 'error-code-bad-file-descriptor', 140: 'error-code-out-of-range', 141: 'error-code-name-too-long', 121: 'error-code-access-denied'}, None])

	def define_program(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' define-program')

		parser.add_argument('identifier_string_id', type=convert_int, help='int', metavar='<identifier-string-id>')
		parser.add_argument('session_id', type=convert_int, help='int', metavar='<session-id>')

		args = parser.parse_args(argv)

		device_call(ctx, REDBrick, 47, (args.identifier_string_id, args.session_id), 'H H', 'B H', args.execute, False, ['error-code', 'program-id'], [{0: 'error-code-success', 1: 'error-code-unknown-error', 2: 'error-code-invalid-operation', 3: 'error-code-operation-aborted', 4: 'error-code-internal-error', 5: 'error-code-unknown-session-id', 6: 'error-code-no-free-session-id', 7: 'error-code-unknown-object-id', 8: 'error-code-no-free-object-id', 9: 'error-code-object-is-locked', 10: 'error-code-no-more-data', 11: 'error-code-wrong-list-item-type', 12: 'error-code-program-is-purged', 130: 'error-code-no-free-space', 142: 'error-code-invalid-seek', 143: 'error-code-not-supported', 144: 'error-code-too-many-open-files', 132: 'error-code-already-exists', 133: 'error-code-does-not-exist', 134: 'error-code-interrupted', 129: 'error-code-no-free-memory', 135: 'error-code-is-directory', 136: 'error-code-not-a-directory', 128: 'error-code-invalid-parameter', 137: 'error-code-would-block', 138: 'error-code-overflow', 139: 'error-code-bad-file-descriptor', 140: 'error-code-out-of-range', 141: 'error-code-name-too-long', 121: 'error-code-access-denied'}, None])

	def purge_program(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' purge-program')

		parser.add_argument('program_id', type=convert_int, help='int', metavar='<program-id>')
		parser.add_argument('cookie', type=convert_int, help='int', metavar='<cookie>')

		args = parser.parse_args(argv)

		device_call(ctx, REDBrick, 48, (args.program_id, args.cookie), 'H I', 'B', args.execute, False, ['error-code'], [{0: 'error-code-success', 1: 'error-code-unknown-error', 2: 'error-code-invalid-operation', 3: 'error-code-operation-aborted', 4: 'error-code-internal-error', 5: 'error-code-unknown-session-id', 6: 'error-code-no-free-session-id', 7: 'error-code-unknown-object-id', 8: 'error-code-no-free-object-id', 9: 'error-code-object-is-locked', 10: 'error-code-no-more-data', 11: 'error-code-wrong-list-item-type', 12: 'error-code-program-is-purged', 130: 'error-code-no-free-space', 142: 'error-code-invalid-seek', 143: 'error-code-not-supported', 144: 'error-code-too-many-open-files', 132: 'error-code-already-exists', 133: 'error-code-does-not-exist', 134: 'error-code-interrupted', 129: 'error-code-no-free-memory', 135: 'error-code-is-directory', 136: 'error-code-not-a-directory', 128: 'error-code-invalid-parameter', 137: 'error-code-would-block', 138: 'error-code-overflow', 139: 'error-code-bad-file-descriptor', 140: 'error-code-out-of-range', 141: 'error-code-name-too-long', 121: 'error-code-access-denied'}])

	def get_program_identifier(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-program-identifier')

		parser.add_argument('program_id', type=convert_int, help='int', metavar='<program-id>')
		parser.add_argument('session_id', type=convert_int, help='int', metavar='<session-id>')

		args = parser.parse_args(argv)

		device_call(ctx, REDBrick, 49, (args.program_id, args.session_id), 'H H', 'B H', args.execute, False, ['error-code', 'identifier-string-id'], [{0: 'error-code-success', 1: 'error-code-unknown-error', 2: 'error-code-invalid-operation', 3: 'error-code-operation-aborted', 4: 'error-code-internal-error', 5: 'error-code-unknown-session-id', 6: 'error-code-no-free-session-id', 7: 'error-code-unknown-object-id', 8: 'error-code-no-free-object-id', 9: 'error-code-object-is-locked', 10: 'error-code-no-more-data', 11: 'error-code-wrong-list-item-type', 12: 'error-code-program-is-purged', 130: 'error-code-no-free-space', 142: 'error-code-invalid-seek', 143: 'error-code-not-supported', 144: 'error-code-too-many-open-files', 132: 'error-code-already-exists', 133: 'error-code-does-not-exist', 134: 'error-code-interrupted', 129: 'error-code-no-free-memory', 135: 'error-code-is-directory', 136: 'error-code-not-a-directory', 128: 'error-code-invalid-parameter', 137: 'error-code-would-block', 138: 'error-code-overflow', 139: 'error-code-bad-file-descriptor', 140: 'error-code-out-of-range', 141: 'error-code-name-too-long', 121: 'error-code-access-denied'}, None])

	def get_program_root_directory(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-program-root-directory')

		parser.add_argument('program_id', type=convert_int, help='int', metavar='<program-id>')
		parser.add_argument('session_id', type=convert_int, help='int', metavar='<session-id>')

		args = parser.parse_args(argv)

		device_call(ctx, REDBrick, 50, (args.program_id, args.session_id), 'H H', 'B H', args.execute, False, ['error-code', 'root-directory-string-id'], [{0: 'error-code-success', 1: 'error-code-unknown-error', 2: 'error-code-invalid-operation', 3: 'error-code-operation-aborted', 4: 'error-code-internal-error', 5: 'error-code-unknown-session-id', 6: 'error-code-no-free-session-id', 7: 'error-code-unknown-object-id', 8: 'error-code-no-free-object-id', 9: 'error-code-object-is-locked', 10: 'error-code-no-more-data', 11: 'error-code-wrong-list-item-type', 12: 'error-code-program-is-purged', 130: 'error-code-no-free-space', 142: 'error-code-invalid-seek', 143: 'error-code-not-supported', 144: 'error-code-too-many-open-files', 132: 'error-code-already-exists', 133: 'error-code-does-not-exist', 134: 'error-code-interrupted', 129: 'error-code-no-free-memory', 135: 'error-code-is-directory', 136: 'error-code-not-a-directory', 128: 'error-code-invalid-parameter', 137: 'error-code-would-block', 138: 'error-code-overflow', 139: 'error-code-bad-file-descriptor', 140: 'error-code-out-of-range', 141: 'error-code-name-too-long', 121: 'error-code-access-denied'}, None])

	def set_program_command(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-program-command')

		parser.add_argument('program_id', type=convert_int, help='int', metavar='<program-id>')
		parser.add_argument('executable_string_id', type=convert_int, help='int', metavar='<executable-string-id>')
		parser.add_argument('arguments_list_id', type=convert_int, help='int', metavar='<arguments-list-id>')
		parser.add_argument('environment_list_id', type=convert_int, help='int', metavar='<environment-list-id>')
		parser.add_argument('working_directory_string_id', type=convert_int, help='int', metavar='<working-directory-string-id>')

		args = parser.parse_args(argv)

		device_call(ctx, REDBrick, 51, (args.program_id, args.executable_string_id, args.arguments_list_id, args.environment_list_id, args.working_directory_string_id), 'H H H H H', 'B', args.execute, False, ['error-code'], [{0: 'error-code-success', 1: 'error-code-unknown-error', 2: 'error-code-invalid-operation', 3: 'error-code-operation-aborted', 4: 'error-code-internal-error', 5: 'error-code-unknown-session-id', 6: 'error-code-no-free-session-id', 7: 'error-code-unknown-object-id', 8: 'error-code-no-free-object-id', 9: 'error-code-object-is-locked', 10: 'error-code-no-more-data', 11: 'error-code-wrong-list-item-type', 12: 'error-code-program-is-purged', 130: 'error-code-no-free-space', 142: 'error-code-invalid-seek', 143: 'error-code-not-supported', 144: 'error-code-too-many-open-files', 132: 'error-code-already-exists', 133: 'error-code-does-not-exist', 134: 'error-code-interrupted', 129: 'error-code-no-free-memory', 135: 'error-code-is-directory', 136: 'error-code-not-a-directory', 128: 'error-code-invalid-parameter', 137: 'error-code-would-block', 138: 'error-code-overflow', 139: 'error-code-bad-file-descriptor', 140: 'error-code-out-of-range', 141: 'error-code-name-too-long', 121: 'error-code-access-denied'}])

	def get_program_command(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-program-command')

		parser.add_argument('program_id', type=convert_int, help='int', metavar='<program-id>')
		parser.add_argument('session_id', type=convert_int, help='int', metavar='<session-id>')

		args = parser.parse_args(argv)

		device_call(ctx, REDBrick, 52, (args.program_id, args.session_id), 'H H', 'B H H H H', args.execute, False, ['error-code', 'executable-string-id', 'arguments-list-id', 'environment-list-id', 'working-directory-string-id'], [{0: 'error-code-success', 1: 'error-code-unknown-error', 2: 'error-code-invalid-operation', 3: 'error-code-operation-aborted', 4: 'error-code-internal-error', 5: 'error-code-unknown-session-id', 6: 'error-code-no-free-session-id', 7: 'error-code-unknown-object-id', 8: 'error-code-no-free-object-id', 9: 'error-code-object-is-locked', 10: 'error-code-no-more-data', 11: 'error-code-wrong-list-item-type', 12: 'error-code-program-is-purged', 130: 'error-code-no-free-space', 142: 'error-code-invalid-seek', 143: 'error-code-not-supported', 144: 'error-code-too-many-open-files', 132: 'error-code-already-exists', 133: 'error-code-does-not-exist', 134: 'error-code-interrupted', 129: 'error-code-no-free-memory', 135: 'error-code-is-directory', 136: 'error-code-not-a-directory', 128: 'error-code-invalid-parameter', 137: 'error-code-would-block', 138: 'error-code-overflow', 139: 'error-code-bad-file-descriptor', 140: 'error-code-out-of-range', 141: 'error-code-name-too-long', 121: 'error-code-access-denied'}, None, None, None, None])

	def set_program_stdio_redirection(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-program-stdio-redirection')

		parser.add_argument('program_id', type=convert_int, help='int', metavar='<program-id>')
		parser.add_argument('stdin_redirection', type=create_symbol_converter(ctx, convert_int, {'program-stdio-redirection-file': 2, 'program-stdio-redirection-individual-log': 3, 'program-stdio-redirection-pipe': 1, 'program-stdio-redirection-continuous-log': 4, 'program-stdio-redirection-stdout': 5, 'program-stdio-redirection-dev-null': 0}), help='int (program-stdio-redirection-dev-null: 0, program-stdio-redirection-pipe: 1, program-stdio-redirection-file: 2, program-stdio-redirection-individual-log: 3, program-stdio-redirection-continuous-log: 4, program-stdio-redirection-stdout: 5)', metavar='<stdin-redirection>')
		parser.add_argument('stdin_file_name_string_id', type=convert_int, help='int', metavar='<stdin-file-name-string-id>')
		parser.add_argument('stdout_redirection', type=create_symbol_converter(ctx, convert_int, {'program-stdio-redirection-file': 2, 'program-stdio-redirection-individual-log': 3, 'program-stdio-redirection-pipe': 1, 'program-stdio-redirection-continuous-log': 4, 'program-stdio-redirection-stdout': 5, 'program-stdio-redirection-dev-null': 0}), help='int (program-stdio-redirection-dev-null: 0, program-stdio-redirection-pipe: 1, program-stdio-redirection-file: 2, program-stdio-redirection-individual-log: 3, program-stdio-redirection-continuous-log: 4, program-stdio-redirection-stdout: 5)', metavar='<stdout-redirection>')
		parser.add_argument('stdout_file_name_string_id', type=convert_int, help='int', metavar='<stdout-file-name-string-id>')
		parser.add_argument('stderr_redirection', type=create_symbol_converter(ctx, convert_int, {'program-stdio-redirection-file': 2, 'program-stdio-redirection-individual-log': 3, 'program-stdio-redirection-pipe': 1, 'program-stdio-redirection-continuous-log': 4, 'program-stdio-redirection-stdout': 5, 'program-stdio-redirection-dev-null': 0}), help='int (program-stdio-redirection-dev-null: 0, program-stdio-redirection-pipe: 1, program-stdio-redirection-file: 2, program-stdio-redirection-individual-log: 3, program-stdio-redirection-continuous-log: 4, program-stdio-redirection-stdout: 5)', metavar='<stderr-redirection>')
		parser.add_argument('stderr_file_name_string_id', type=convert_int, help='int', metavar='<stderr-file-name-string-id>')

		args = parser.parse_args(argv)

		device_call(ctx, REDBrick, 53, (args.program_id, args.stdin_redirection, args.stdin_file_name_string_id, args.stdout_redirection, args.stdout_file_name_string_id, args.stderr_redirection, args.stderr_file_name_string_id), 'H B H B H B H', 'B', args.execute, False, ['error-code'], [{0: 'error-code-success', 1: 'error-code-unknown-error', 2: 'error-code-invalid-operation', 3: 'error-code-operation-aborted', 4: 'error-code-internal-error', 5: 'error-code-unknown-session-id', 6: 'error-code-no-free-session-id', 7: 'error-code-unknown-object-id', 8: 'error-code-no-free-object-id', 9: 'error-code-object-is-locked', 10: 'error-code-no-more-data', 11: 'error-code-wrong-list-item-type', 12: 'error-code-program-is-purged', 130: 'error-code-no-free-space', 142: 'error-code-invalid-seek', 143: 'error-code-not-supported', 144: 'error-code-too-many-open-files', 132: 'error-code-already-exists', 133: 'error-code-does-not-exist', 134: 'error-code-interrupted', 129: 'error-code-no-free-memory', 135: 'error-code-is-directory', 136: 'error-code-not-a-directory', 128: 'error-code-invalid-parameter', 137: 'error-code-would-block', 138: 'error-code-overflow', 139: 'error-code-bad-file-descriptor', 140: 'error-code-out-of-range', 141: 'error-code-name-too-long', 121: 'error-code-access-denied'}])

	def get_program_stdio_redirection(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-program-stdio-redirection')

		parser.add_argument('program_id', type=convert_int, help='int', metavar='<program-id>')
		parser.add_argument('session_id', type=convert_int, help='int', metavar='<session-id>')

		args = parser.parse_args(argv)

		device_call(ctx, REDBrick, 54, (args.program_id, args.session_id), 'H H', 'B B H B H B H', args.execute, False, ['error-code', 'stdin-redirection', 'stdin-file-name-string-id', 'stdout-redirection', 'stdout-file-name-string-id', 'stderr-redirection', 'stderr-file-name-string-id'], [{0: 'error-code-success', 1: 'error-code-unknown-error', 2: 'error-code-invalid-operation', 3: 'error-code-operation-aborted', 4: 'error-code-internal-error', 5: 'error-code-unknown-session-id', 6: 'error-code-no-free-session-id', 7: 'error-code-unknown-object-id', 8: 'error-code-no-free-object-id', 9: 'error-code-object-is-locked', 10: 'error-code-no-more-data', 11: 'error-code-wrong-list-item-type', 12: 'error-code-program-is-purged', 130: 'error-code-no-free-space', 142: 'error-code-invalid-seek', 143: 'error-code-not-supported', 144: 'error-code-too-many-open-files', 132: 'error-code-already-exists', 133: 'error-code-does-not-exist', 134: 'error-code-interrupted', 129: 'error-code-no-free-memory', 135: 'error-code-is-directory', 136: 'error-code-not-a-directory', 128: 'error-code-invalid-parameter', 137: 'error-code-would-block', 138: 'error-code-overflow', 139: 'error-code-bad-file-descriptor', 140: 'error-code-out-of-range', 141: 'error-code-name-too-long', 121: 'error-code-access-denied'}, {0: 'program-stdio-redirection-dev-null', 1: 'program-stdio-redirection-pipe', 2: 'program-stdio-redirection-file', 3: 'program-stdio-redirection-individual-log', 4: 'program-stdio-redirection-continuous-log', 5: 'program-stdio-redirection-stdout'}, None, {0: 'program-stdio-redirection-dev-null', 1: 'program-stdio-redirection-pipe', 2: 'program-stdio-redirection-file', 3: 'program-stdio-redirection-individual-log', 4: 'program-stdio-redirection-continuous-log', 5: 'program-stdio-redirection-stdout'}, None, {0: 'program-stdio-redirection-dev-null', 1: 'program-stdio-redirection-pipe', 2: 'program-stdio-redirection-file', 3: 'program-stdio-redirection-individual-log', 4: 'program-stdio-redirection-continuous-log', 5: 'program-stdio-redirection-stdout'}, None])

	def set_program_schedule(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-program-schedule')

		parser.add_argument('program_id', type=convert_int, help='int', metavar='<program-id>')
		parser.add_argument('start_mode', type=create_symbol_converter(ctx, convert_int, {'program-start-mode-never': 0, 'program-start-mode-always': 1, 'program-start-mode-interval': 2, 'program-start-mode-cron': 3}), help='int (program-start-mode-never: 0, program-start-mode-always: 1, program-start-mode-interval: 2, program-start-mode-cron: 3)', metavar='<start-mode>')
		parser.add_argument('continue_after_error', type=convert_bool, help='bool', metavar='<continue-after-error>')
		parser.add_argument('start_interval', type=convert_int, help='int', metavar='<start-interval>')
		parser.add_argument('start_fields_string_id', type=convert_int, help='int', metavar='<start-fields-string-id>')

		args = parser.parse_args(argv)

		device_call(ctx, REDBrick, 55, (args.program_id, args.start_mode, args.continue_after_error, args.start_interval, args.start_fields_string_id), 'H B ! I H', 'B', args.execute, False, ['error-code'], [{0: 'error-code-success', 1: 'error-code-unknown-error', 2: 'error-code-invalid-operation', 3: 'error-code-operation-aborted', 4: 'error-code-internal-error', 5: 'error-code-unknown-session-id', 6: 'error-code-no-free-session-id', 7: 'error-code-unknown-object-id', 8: 'error-code-no-free-object-id', 9: 'error-code-object-is-locked', 10: 'error-code-no-more-data', 11: 'error-code-wrong-list-item-type', 12: 'error-code-program-is-purged', 130: 'error-code-no-free-space', 142: 'error-code-invalid-seek', 143: 'error-code-not-supported', 144: 'error-code-too-many-open-files', 132: 'error-code-already-exists', 133: 'error-code-does-not-exist', 134: 'error-code-interrupted', 129: 'error-code-no-free-memory', 135: 'error-code-is-directory', 136: 'error-code-not-a-directory', 128: 'error-code-invalid-parameter', 137: 'error-code-would-block', 138: 'error-code-overflow', 139: 'error-code-bad-file-descriptor', 140: 'error-code-out-of-range', 141: 'error-code-name-too-long', 121: 'error-code-access-denied'}])

	def get_program_schedule(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-program-schedule')

		parser.add_argument('program_id', type=convert_int, help='int', metavar='<program-id>')
		parser.add_argument('session_id', type=convert_int, help='int', metavar='<session-id>')

		args = parser.parse_args(argv)

		device_call(ctx, REDBrick, 56, (args.program_id, args.session_id), 'H H', 'B B ! I H', args.execute, False, ['error-code', 'start-mode', 'continue-after-error', 'start-interval', 'start-fields-string-id'], [{0: 'error-code-success', 1: 'error-code-unknown-error', 2: 'error-code-invalid-operation', 3: 'error-code-operation-aborted', 4: 'error-code-internal-error', 5: 'error-code-unknown-session-id', 6: 'error-code-no-free-session-id', 7: 'error-code-unknown-object-id', 8: 'error-code-no-free-object-id', 9: 'error-code-object-is-locked', 10: 'error-code-no-more-data', 11: 'error-code-wrong-list-item-type', 12: 'error-code-program-is-purged', 130: 'error-code-no-free-space', 142: 'error-code-invalid-seek', 143: 'error-code-not-supported', 144: 'error-code-too-many-open-files', 132: 'error-code-already-exists', 133: 'error-code-does-not-exist', 134: 'error-code-interrupted', 129: 'error-code-no-free-memory', 135: 'error-code-is-directory', 136: 'error-code-not-a-directory', 128: 'error-code-invalid-parameter', 137: 'error-code-would-block', 138: 'error-code-overflow', 139: 'error-code-bad-file-descriptor', 140: 'error-code-out-of-range', 141: 'error-code-name-too-long', 121: 'error-code-access-denied'}, {0: 'program-start-mode-never', 1: 'program-start-mode-always', 2: 'program-start-mode-interval', 3: 'program-start-mode-cron'}, None, None, None])

	def get_program_scheduler_state(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-program-scheduler-state')

		parser.add_argument('program_id', type=convert_int, help='int', metavar='<program-id>')
		parser.add_argument('session_id', type=convert_int, help='int', metavar='<session-id>')

		args = parser.parse_args(argv)

		device_call(ctx, REDBrick, 57, (args.program_id, args.session_id), 'H H', 'B B Q H', args.execute, False, ['error-code', 'state', 'timestamp', 'message-string-id'], [{0: 'error-code-success', 1: 'error-code-unknown-error', 2: 'error-code-invalid-operation', 3: 'error-code-operation-aborted', 4: 'error-code-internal-error', 5: 'error-code-unknown-session-id', 6: 'error-code-no-free-session-id', 7: 'error-code-unknown-object-id', 8: 'error-code-no-free-object-id', 9: 'error-code-object-is-locked', 10: 'error-code-no-more-data', 11: 'error-code-wrong-list-item-type', 12: 'error-code-program-is-purged', 130: 'error-code-no-free-space', 142: 'error-code-invalid-seek', 143: 'error-code-not-supported', 144: 'error-code-too-many-open-files', 132: 'error-code-already-exists', 133: 'error-code-does-not-exist', 134: 'error-code-interrupted', 129: 'error-code-no-free-memory', 135: 'error-code-is-directory', 136: 'error-code-not-a-directory', 128: 'error-code-invalid-parameter', 137: 'error-code-would-block', 138: 'error-code-overflow', 139: 'error-code-bad-file-descriptor', 140: 'error-code-out-of-range', 141: 'error-code-name-too-long', 121: 'error-code-access-denied'}, {0: 'program-scheduler-state-stopped', 1: 'program-scheduler-state-running'}, None, None])

	def continue_program_schedule(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' continue-program-schedule')

		parser.add_argument('program_id', type=convert_int, help='int', metavar='<program-id>')

		args = parser.parse_args(argv)

		device_call(ctx, REDBrick, 58, (args.program_id,), 'H', 'B', args.execute, False, ['error-code'], [{0: 'error-code-success', 1: 'error-code-unknown-error', 2: 'error-code-invalid-operation', 3: 'error-code-operation-aborted', 4: 'error-code-internal-error', 5: 'error-code-unknown-session-id', 6: 'error-code-no-free-session-id', 7: 'error-code-unknown-object-id', 8: 'error-code-no-free-object-id', 9: 'error-code-object-is-locked', 10: 'error-code-no-more-data', 11: 'error-code-wrong-list-item-type', 12: 'error-code-program-is-purged', 130: 'error-code-no-free-space', 142: 'error-code-invalid-seek', 143: 'error-code-not-supported', 144: 'error-code-too-many-open-files', 132: 'error-code-already-exists', 133: 'error-code-does-not-exist', 134: 'error-code-interrupted', 129: 'error-code-no-free-memory', 135: 'error-code-is-directory', 136: 'error-code-not-a-directory', 128: 'error-code-invalid-parameter', 137: 'error-code-would-block', 138: 'error-code-overflow', 139: 'error-code-bad-file-descriptor', 140: 'error-code-out-of-range', 141: 'error-code-name-too-long', 121: 'error-code-access-denied'}])

	def start_program(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' start-program')

		parser.add_argument('program_id', type=convert_int, help='int', metavar='<program-id>')

		args = parser.parse_args(argv)

		device_call(ctx, REDBrick, 59, (args.program_id,), 'H', 'B', args.execute, False, ['error-code'], [{0: 'error-code-success', 1: 'error-code-unknown-error', 2: 'error-code-invalid-operation', 3: 'error-code-operation-aborted', 4: 'error-code-internal-error', 5: 'error-code-unknown-session-id', 6: 'error-code-no-free-session-id', 7: 'error-code-unknown-object-id', 8: 'error-code-no-free-object-id', 9: 'error-code-object-is-locked', 10: 'error-code-no-more-data', 11: 'error-code-wrong-list-item-type', 12: 'error-code-program-is-purged', 130: 'error-code-no-free-space', 142: 'error-code-invalid-seek', 143: 'error-code-not-supported', 144: 'error-code-too-many-open-files', 132: 'error-code-already-exists', 133: 'error-code-does-not-exist', 134: 'error-code-interrupted', 129: 'error-code-no-free-memory', 135: 'error-code-is-directory', 136: 'error-code-not-a-directory', 128: 'error-code-invalid-parameter', 137: 'error-code-would-block', 138: 'error-code-overflow', 139: 'error-code-bad-file-descriptor', 140: 'error-code-out-of-range', 141: 'error-code-name-too-long', 121: 'error-code-access-denied'}])

	def get_last_spawned_program_process(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-last-spawned-program-process')

		parser.add_argument('program_id', type=convert_int, help='int', metavar='<program-id>')
		parser.add_argument('session_id', type=convert_int, help='int', metavar='<session-id>')

		args = parser.parse_args(argv)

		device_call(ctx, REDBrick, 60, (args.program_id, args.session_id), 'H H', 'B H Q', args.execute, False, ['error-code', 'process-id', 'timestamp'], [{0: 'error-code-success', 1: 'error-code-unknown-error', 2: 'error-code-invalid-operation', 3: 'error-code-operation-aborted', 4: 'error-code-internal-error', 5: 'error-code-unknown-session-id', 6: 'error-code-no-free-session-id', 7: 'error-code-unknown-object-id', 8: 'error-code-no-free-object-id', 9: 'error-code-object-is-locked', 10: 'error-code-no-more-data', 11: 'error-code-wrong-list-item-type', 12: 'error-code-program-is-purged', 130: 'error-code-no-free-space', 142: 'error-code-invalid-seek', 143: 'error-code-not-supported', 144: 'error-code-too-many-open-files', 132: 'error-code-already-exists', 133: 'error-code-does-not-exist', 134: 'error-code-interrupted', 129: 'error-code-no-free-memory', 135: 'error-code-is-directory', 136: 'error-code-not-a-directory', 128: 'error-code-invalid-parameter', 137: 'error-code-would-block', 138: 'error-code-overflow', 139: 'error-code-bad-file-descriptor', 140: 'error-code-out-of-range', 141: 'error-code-name-too-long', 121: 'error-code-access-denied'}, None, None])

	def get_custom_program_option_names(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-custom-program-option-names')

		parser.add_argument('program_id', type=convert_int, help='int', metavar='<program-id>')
		parser.add_argument('session_id', type=convert_int, help='int', metavar='<session-id>')

		args = parser.parse_args(argv)

		device_call(ctx, REDBrick, 61, (args.program_id, args.session_id), 'H H', 'B H', args.execute, False, ['error-code', 'names-list-id'], [{0: 'error-code-success', 1: 'error-code-unknown-error', 2: 'error-code-invalid-operation', 3: 'error-code-operation-aborted', 4: 'error-code-internal-error', 5: 'error-code-unknown-session-id', 6: 'error-code-no-free-session-id', 7: 'error-code-unknown-object-id', 8: 'error-code-no-free-object-id', 9: 'error-code-object-is-locked', 10: 'error-code-no-more-data', 11: 'error-code-wrong-list-item-type', 12: 'error-code-program-is-purged', 130: 'error-code-no-free-space', 142: 'error-code-invalid-seek', 143: 'error-code-not-supported', 144: 'error-code-too-many-open-files', 132: 'error-code-already-exists', 133: 'error-code-does-not-exist', 134: 'error-code-interrupted', 129: 'error-code-no-free-memory', 135: 'error-code-is-directory', 136: 'error-code-not-a-directory', 128: 'error-code-invalid-parameter', 137: 'error-code-would-block', 138: 'error-code-overflow', 139: 'error-code-bad-file-descriptor', 140: 'error-code-out-of-range', 141: 'error-code-name-too-long', 121: 'error-code-access-denied'}, None])

	def set_custom_program_option_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-custom-program-option-value')

		parser.add_argument('program_id', type=convert_int, help='int', metavar='<program-id>')
		parser.add_argument('name_string_id', type=convert_int, help='int', metavar='<name-string-id>')
		parser.add_argument('value_string_id', type=convert_int, help='int', metavar='<value-string-id>')

		args = parser.parse_args(argv)

		device_call(ctx, REDBrick, 62, (args.program_id, args.name_string_id, args.value_string_id), 'H H H', 'B', args.execute, False, ['error-code'], [{0: 'error-code-success', 1: 'error-code-unknown-error', 2: 'error-code-invalid-operation', 3: 'error-code-operation-aborted', 4: 'error-code-internal-error', 5: 'error-code-unknown-session-id', 6: 'error-code-no-free-session-id', 7: 'error-code-unknown-object-id', 8: 'error-code-no-free-object-id', 9: 'error-code-object-is-locked', 10: 'error-code-no-more-data', 11: 'error-code-wrong-list-item-type', 12: 'error-code-program-is-purged', 130: 'error-code-no-free-space', 142: 'error-code-invalid-seek', 143: 'error-code-not-supported', 144: 'error-code-too-many-open-files', 132: 'error-code-already-exists', 133: 'error-code-does-not-exist', 134: 'error-code-interrupted', 129: 'error-code-no-free-memory', 135: 'error-code-is-directory', 136: 'error-code-not-a-directory', 128: 'error-code-invalid-parameter', 137: 'error-code-would-block', 138: 'error-code-overflow', 139: 'error-code-bad-file-descriptor', 140: 'error-code-out-of-range', 141: 'error-code-name-too-long', 121: 'error-code-access-denied'}])

	def get_custom_program_option_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-custom-program-option-value')

		parser.add_argument('program_id', type=convert_int, help='int', metavar='<program-id>')
		parser.add_argument('name_string_id', type=convert_int, help='int', metavar='<name-string-id>')
		parser.add_argument('session_id', type=convert_int, help='int', metavar='<session-id>')

		args = parser.parse_args(argv)

		device_call(ctx, REDBrick, 63, (args.program_id, args.name_string_id, args.session_id), 'H H H', 'B H', args.execute, False, ['error-code', 'value-string-id'], [{0: 'error-code-success', 1: 'error-code-unknown-error', 2: 'error-code-invalid-operation', 3: 'error-code-operation-aborted', 4: 'error-code-internal-error', 5: 'error-code-unknown-session-id', 6: 'error-code-no-free-session-id', 7: 'error-code-unknown-object-id', 8: 'error-code-no-free-object-id', 9: 'error-code-object-is-locked', 10: 'error-code-no-more-data', 11: 'error-code-wrong-list-item-type', 12: 'error-code-program-is-purged', 130: 'error-code-no-free-space', 142: 'error-code-invalid-seek', 143: 'error-code-not-supported', 144: 'error-code-too-many-open-files', 132: 'error-code-already-exists', 133: 'error-code-does-not-exist', 134: 'error-code-interrupted', 129: 'error-code-no-free-memory', 135: 'error-code-is-directory', 136: 'error-code-not-a-directory', 128: 'error-code-invalid-parameter', 137: 'error-code-would-block', 138: 'error-code-overflow', 139: 'error-code-bad-file-descriptor', 140: 'error-code-out-of-range', 141: 'error-code-name-too-long', 121: 'error-code-access-denied'}, None])

	def remove_custom_program_option(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' remove-custom-program-option')

		parser.add_argument('program_id', type=convert_int, help='int', metavar='<program-id>')
		parser.add_argument('name_string_id', type=convert_int, help='int', metavar='<name-string-id>')

		args = parser.parse_args(argv)

		device_call(ctx, REDBrick, 64, (args.program_id, args.name_string_id), 'H H', 'B', args.execute, False, ['error-code'], [{0: 'error-code-success', 1: 'error-code-unknown-error', 2: 'error-code-invalid-operation', 3: 'error-code-operation-aborted', 4: 'error-code-internal-error', 5: 'error-code-unknown-session-id', 6: 'error-code-no-free-session-id', 7: 'error-code-unknown-object-id', 8: 'error-code-no-free-object-id', 9: 'error-code-object-is-locked', 10: 'error-code-no-more-data', 11: 'error-code-wrong-list-item-type', 12: 'error-code-program-is-purged', 130: 'error-code-no-free-space', 142: 'error-code-invalid-seek', 143: 'error-code-not-supported', 144: 'error-code-too-many-open-files', 132: 'error-code-already-exists', 133: 'error-code-does-not-exist', 134: 'error-code-interrupted', 129: 'error-code-no-free-memory', 135: 'error-code-is-directory', 136: 'error-code-not-a-directory', 128: 'error-code-invalid-parameter', 137: 'error-code-would-block', 138: 'error-code-overflow', 139: 'error-code-bad-file-descriptor', 140: 'error-code-out-of-range', 141: 'error-code-name-too-long', 121: 'error-code-access-denied'}])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, REDBrick, argv)

	functions = {
	'create-session': create_session,
	'expire-session': expire_session,
	'expire-session-unchecked': expire_session_unchecked,
	'keep-session-alive': keep_session_alive,
	'release-object': release_object,
	'release-object-unchecked': release_object_unchecked,
	'allocate-string': allocate_string,
	'truncate-string': truncate_string,
	'get-string-length': get_string_length,
	'set-string-chunk': set_string_chunk,
	'get-string-chunk': get_string_chunk,
	'allocate-list': allocate_list,
	'get-list-length': get_list_length,
	'get-list-item': get_list_item,
	'append-to-list': append_to_list,
	'remove-from-list': remove_from_list,
	'open-file': open_file,
	'create-pipe': create_pipe,
	'get-file-info': get_file_info,
	'read-file': read_file,
	'read-file-async': read_file_async,
	'abort-async-file-read': abort_async_file_read,
	'write-file': write_file,
	'write-file-unchecked': write_file_unchecked,
	'write-file-async': write_file_async,
	'set-file-position': set_file_position,
	'get-file-position': get_file_position,
	'set-file-events': set_file_events,
	'get-file-events': get_file_events,
	'open-directory': open_directory,
	'get-directory-name': get_directory_name,
	'get-next-directory-entry': get_next_directory_entry,
	'rewind-directory': rewind_directory,
	'create-directory': create_directory,
	'get-processes': get_processes,
	'spawn-process': spawn_process,
	'kill-process': kill_process,
	'get-process-command': get_process_command,
	'get-process-identity': get_process_identity,
	'get-process-stdio': get_process_stdio,
	'get-process-state': get_process_state,
	'get-programs': get_programs,
	'define-program': define_program,
	'purge-program': purge_program,
	'get-program-identifier': get_program_identifier,
	'get-program-root-directory': get_program_root_directory,
	'set-program-command': set_program_command,
	'get-program-command': get_program_command,
	'set-program-stdio-redirection': set_program_stdio_redirection,
	'get-program-stdio-redirection': get_program_stdio_redirection,
	'set-program-schedule': set_program_schedule,
	'get-program-schedule': get_program_schedule,
	'get-program-scheduler-state': get_program_scheduler_state,
	'continue-program-schedule': continue_program_schedule,
	'start-program': start_program,
	'get-last-spawned-program-process': get_last_spawned_program_process,
	'get-custom-program-option-names': get_custom_program_option_names,
	'set-custom-program-option-value': set_custom_program_option_value,
	'get-custom-program-option-value': get_custom_program_option_value,
	'remove-custom-program-option': remove_custom_program_option,
	'get-identity': get_identity
	}

	call_generic(ctx, 'red-brick', functions, argv)

def dispatch_red_brick(ctx, argv):
	prog_prefix = 'dispatch red-brick <uid>'

	def async_file_read(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' async-file-read')

		args = parser.parse_args(argv)

		device_dispatch(ctx, REDBrick, 30, args.execute, ['file-id', 'error-code', 'buffer', 'length-read'], [None, {0: 'error-code-success', 1: 'error-code-unknown-error', 2: 'error-code-invalid-operation', 3: 'error-code-operation-aborted', 4: 'error-code-internal-error', 5: 'error-code-unknown-session-id', 6: 'error-code-no-free-session-id', 7: 'error-code-unknown-object-id', 8: 'error-code-no-free-object-id', 9: 'error-code-object-is-locked', 10: 'error-code-no-more-data', 11: 'error-code-wrong-list-item-type', 12: 'error-code-program-is-purged', 130: 'error-code-no-free-space', 142: 'error-code-invalid-seek', 143: 'error-code-not-supported', 144: 'error-code-too-many-open-files', 132: 'error-code-already-exists', 133: 'error-code-does-not-exist', 134: 'error-code-interrupted', 129: 'error-code-no-free-memory', 135: 'error-code-is-directory', 136: 'error-code-not-a-directory', 128: 'error-code-invalid-parameter', 137: 'error-code-would-block', 138: 'error-code-overflow', 139: 'error-code-bad-file-descriptor', 140: 'error-code-out-of-range', 141: 'error-code-name-too-long', 121: 'error-code-access-denied'}, None, None])

	def async_file_write(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' async-file-write')

		args = parser.parse_args(argv)

		device_dispatch(ctx, REDBrick, 31, args.execute, ['file-id', 'error-code', 'length-written'], [None, {0: 'error-code-success', 1: 'error-code-unknown-error', 2: 'error-code-invalid-operation', 3: 'error-code-operation-aborted', 4: 'error-code-internal-error', 5: 'error-code-unknown-session-id', 6: 'error-code-no-free-session-id', 7: 'error-code-unknown-object-id', 8: 'error-code-no-free-object-id', 9: 'error-code-object-is-locked', 10: 'error-code-no-more-data', 11: 'error-code-wrong-list-item-type', 12: 'error-code-program-is-purged', 130: 'error-code-no-free-space', 142: 'error-code-invalid-seek', 143: 'error-code-not-supported', 144: 'error-code-too-many-open-files', 132: 'error-code-already-exists', 133: 'error-code-does-not-exist', 134: 'error-code-interrupted', 129: 'error-code-no-free-memory', 135: 'error-code-is-directory', 136: 'error-code-not-a-directory', 128: 'error-code-invalid-parameter', 137: 'error-code-would-block', 138: 'error-code-overflow', 139: 'error-code-bad-file-descriptor', 140: 'error-code-out-of-range', 141: 'error-code-name-too-long', 121: 'error-code-access-denied'}, None])

	def file_events_occurred(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' file-events-occurred')

		args = parser.parse_args(argv)

		device_dispatch(ctx, REDBrick, 32, args.execute, ['file-id', 'events'], [None, {1: 'file-event-readable', 2: 'file-event-writable'}])

	def process_state_changed(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' process-state-changed')

		args = parser.parse_args(argv)

		device_dispatch(ctx, REDBrick, 45, args.execute, ['process-id', 'state', 'timestamp', 'exit-code'], [None, {0: 'process-state-unknown', 1: 'process-state-running', 2: 'process-state-error', 3: 'process-state-exited', 4: 'process-state-killed', 5: 'process-state-stopped'}, None, None])

	def program_scheduler_state_changed(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' program-scheduler-state-changed')

		args = parser.parse_args(argv)

		device_dispatch(ctx, REDBrick, 65, args.execute, ['program-id'], [None])

	def program_process_spawned(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' program-process-spawned')

		args = parser.parse_args(argv)

		device_dispatch(ctx, REDBrick, 66, args.execute, ['program-id'], [None])

	callbacks = {
	'async-file-read': async_file_read,
	'async-file-write': async_file_write,
	'file-events-occurred': file_events_occurred,
	'process-state-changed': process_state_changed,
	'program-scheduler-state-changed': program_scheduler_state_changed,
	'program-process-spawned': program_process_spawned
	}

	dispatch_generic(ctx, 'red-brick', callbacks, argv)

class RemoteSwitchBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 3; re[2] = 1; re[4] = 3; re[5] = 1; re[6] = 3; re[7] = 3; re[8] = 3; re[9] = 3; re[255] = 1
		cf = self.callback_formats
		cf[3] = ''


def call_remote_switch_bricklet(ctx, argv):
	prog_prefix = 'call remote-switch-bricklet <uid>'

	def switch_socket(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' switch-socket')

		parser.add_argument('house_code', type=convert_int, help='int', metavar='<house-code>')
		parser.add_argument('receiver_code', type=convert_int, help='int', metavar='<receiver-code>')
		parser.add_argument('switch_to', type=create_symbol_converter(ctx, convert_int, {'switch-to-on': 1, 'switch-to-off': 0}), help='int (switch-to-off: 0, switch-to-on: 1)', metavar='<switch-to>')

		args = parser.parse_args(argv)

		device_call(ctx, RemoteSwitchBricklet, 1, (args.house_code, args.receiver_code, args.switch_to), 'B B B', '', None, args.expect_response, [], [])

	def get_switching_state(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-switching-state')

		args = parser.parse_args(argv)

		device_call(ctx, RemoteSwitchBricklet, 2, (), '', 'B', args.execute, False, ['state'], [{0: 'switching-state-ready', 1: 'switching-state-busy'}])

	def set_repeats(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-repeats')

		parser.add_argument('repeats', type=convert_int, help='int', metavar='<repeats>')

		args = parser.parse_args(argv)

		device_call(ctx, RemoteSwitchBricklet, 4, (args.repeats,), 'B', '', None, args.expect_response, [], [])

	def get_repeats(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-repeats')

		args = parser.parse_args(argv)

		device_call(ctx, RemoteSwitchBricklet, 5, (), '', 'B', args.execute, False, ['repeats'], [None])

	def switch_socket_a(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' switch-socket-a')

		parser.add_argument('house_code', type=convert_int, help='int', metavar='<house-code>')
		parser.add_argument('receiver_code', type=convert_int, help='int', metavar='<receiver-code>')
		parser.add_argument('switch_to', type=create_symbol_converter(ctx, convert_int, {'switch-to-on': 1, 'switch-to-off': 0}), help='int (switch-to-off: 0, switch-to-on: 1)', metavar='<switch-to>')

		args = parser.parse_args(argv)

		device_call(ctx, RemoteSwitchBricklet, 6, (args.house_code, args.receiver_code, args.switch_to), 'B B B', '', None, args.expect_response, [], [])

	def switch_socket_b(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' switch-socket-b')

		parser.add_argument('address', type=convert_int, help='int', metavar='<address>')
		parser.add_argument('unit', type=convert_int, help='int', metavar='<unit>')
		parser.add_argument('switch_to', type=create_symbol_converter(ctx, convert_int, {'switch-to-on': 1, 'switch-to-off': 0}), help='int (switch-to-off: 0, switch-to-on: 1)', metavar='<switch-to>')

		args = parser.parse_args(argv)

		device_call(ctx, RemoteSwitchBricklet, 7, (args.address, args.unit, args.switch_to), 'I B B', '', None, args.expect_response, [], [])

	def dim_socket_b(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' dim-socket-b')

		parser.add_argument('address', type=convert_int, help='int', metavar='<address>')
		parser.add_argument('unit', type=convert_int, help='int', metavar='<unit>')
		parser.add_argument('dim_value', type=convert_int, help='int', metavar='<dim-value>')

		args = parser.parse_args(argv)

		device_call(ctx, RemoteSwitchBricklet, 8, (args.address, args.unit, args.dim_value), 'I B B', '', None, args.expect_response, [], [])

	def switch_socket_c(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' switch-socket-c')

		parser.add_argument('system_code', type=create_char_converter(ctx), help='char', metavar='<system-code>')
		parser.add_argument('device_code', type=convert_int, help='int', metavar='<device-code>')
		parser.add_argument('switch_to', type=create_symbol_converter(ctx, convert_int, {'switch-to-on': 1, 'switch-to-off': 0}), help='int (switch-to-off: 0, switch-to-on: 1)', metavar='<switch-to>')

		args = parser.parse_args(argv)

		device_call(ctx, RemoteSwitchBricklet, 9, (args.system_code, args.device_code, args.switch_to), 'c B B', '', None, args.expect_response, [], [])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, RemoteSwitchBricklet, argv)

	functions = {
	'switch-socket': switch_socket,
	'get-switching-state': get_switching_state,
	'set-repeats': set_repeats,
	'get-repeats': get_repeats,
	'switch-socket-a': switch_socket_a,
	'switch-socket-b': switch_socket_b,
	'dim-socket-b': dim_socket_b,
	'switch-socket-c': switch_socket_c,
	'get-identity': get_identity
	}

	call_generic(ctx, 'remote-switch-bricklet', functions, argv)

def dispatch_remote_switch_bricklet(ctx, argv):
	prog_prefix = 'dispatch remote-switch-bricklet <uid>'

	def switching_done(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' switching-done')

		args = parser.parse_args(argv)

		device_dispatch(ctx, RemoteSwitchBricklet, 3, args.execute, [], [])

	callbacks = {
	'switching-done': switching_done
	}

	dispatch_generic(ctx, 'remote-switch-bricklet', callbacks, argv)

class RemoteSwitchV2Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[3] = 3; re[4] = 1; re[5] = 3; re[6] = 3; re[7] = 3; re[8] = 3; re[9] = 3; re[10] = 1; re[11] = 1; re[12] = 1; re[13] = 1; re[234] = 1; re[235] = 1; re[236] = 1; re[237] = 3; re[238] = 1; re[239] = 3; re[240] = 1; re[242] = 1; re[243] = 3; re[248] = 3; re[249] = 1; re[255] = 1
		cf = self.callback_formats
		cf[2] = ''; cf[14] = 'B B B H'; cf[15] = 'I B B B H'; cf[16] = 'c B B H'


def call_remote_switch_v2_bricklet(ctx, argv):
	prog_prefix = 'call remote-switch-v2-bricklet <uid>'

	def get_switching_state(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-switching-state')

		args = parser.parse_args(argv)

		device_call(ctx, RemoteSwitchV2Bricklet, 1, (), '', 'B', args.execute, False, ['state'], [{0: 'switching-state-ready', 1: 'switching-state-busy'}])

	def set_repeats(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-repeats')

		parser.add_argument('repeats', type=convert_int, help='int', metavar='<repeats>')

		args = parser.parse_args(argv)

		device_call(ctx, RemoteSwitchV2Bricklet, 3, (args.repeats,), 'B', '', None, args.expect_response, [], [])

	def get_repeats(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-repeats')

		args = parser.parse_args(argv)

		device_call(ctx, RemoteSwitchV2Bricklet, 4, (), '', 'B', args.execute, False, ['repeats'], [None])

	def switch_socket_a(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' switch-socket-a')

		parser.add_argument('house_code', type=convert_int, help='int', metavar='<house-code>')
		parser.add_argument('receiver_code', type=convert_int, help='int', metavar='<receiver-code>')
		parser.add_argument('switch_to', type=create_symbol_converter(ctx, convert_int, {'switch-to-on': 1, 'switch-to-off': 0}), help='int (switch-to-off: 0, switch-to-on: 1)', metavar='<switch-to>')

		args = parser.parse_args(argv)

		device_call(ctx, RemoteSwitchV2Bricklet, 5, (args.house_code, args.receiver_code, args.switch_to), 'B B B', '', None, args.expect_response, [], [])

	def switch_socket_b(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' switch-socket-b')

		parser.add_argument('address', type=convert_int, help='int', metavar='<address>')
		parser.add_argument('unit', type=convert_int, help='int', metavar='<unit>')
		parser.add_argument('switch_to', type=create_symbol_converter(ctx, convert_int, {'switch-to-on': 1, 'switch-to-off': 0}), help='int (switch-to-off: 0, switch-to-on: 1)', metavar='<switch-to>')

		args = parser.parse_args(argv)

		device_call(ctx, RemoteSwitchV2Bricklet, 6, (args.address, args.unit, args.switch_to), 'I B B', '', None, args.expect_response, [], [])

	def dim_socket_b(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' dim-socket-b')

		parser.add_argument('address', type=convert_int, help='int', metavar='<address>')
		parser.add_argument('unit', type=convert_int, help='int', metavar='<unit>')
		parser.add_argument('dim_value', type=convert_int, help='int', metavar='<dim-value>')

		args = parser.parse_args(argv)

		device_call(ctx, RemoteSwitchV2Bricklet, 7, (args.address, args.unit, args.dim_value), 'I B B', '', None, args.expect_response, [], [])

	def switch_socket_c(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' switch-socket-c')

		parser.add_argument('system_code', type=create_char_converter(ctx), help='char', metavar='<system-code>')
		parser.add_argument('device_code', type=convert_int, help='int', metavar='<device-code>')
		parser.add_argument('switch_to', type=create_symbol_converter(ctx, convert_int, {'switch-to-on': 1, 'switch-to-off': 0}), help='int (switch-to-off: 0, switch-to-on: 1)', metavar='<switch-to>')

		args = parser.parse_args(argv)

		device_call(ctx, RemoteSwitchV2Bricklet, 8, (args.system_code, args.device_code, args.switch_to), 'c B B', '', None, args.expect_response, [], [])

	def set_remote_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-remote-configuration')

		parser.add_argument('remote_type', type=create_symbol_converter(ctx, convert_int, {'remote-type-a': 0, 'remote-type-c': 2, 'remote-type-b': 1}), help='int (remote-type-a: 0, remote-type-b: 1, remote-type-c: 2)', metavar='<remote-type>')
		parser.add_argument('minimum_repeats', type=convert_int, help='int', metavar='<minimum-repeats>')
		parser.add_argument('callback_enabled', type=convert_bool, help='bool', metavar='<callback-enabled>')

		args = parser.parse_args(argv)

		device_call(ctx, RemoteSwitchV2Bricklet, 9, (args.remote_type, args.minimum_repeats, args.callback_enabled), 'B H !', '', None, args.expect_response, [], [])

	def get_remote_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-remote-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, RemoteSwitchV2Bricklet, 10, (), '', 'B H !', args.execute, False, ['remote-type', 'minimum-repeats', 'callback-enabled'], [{0: 'remote-type-a', 1: 'remote-type-b', 2: 'remote-type-c'}, None, None])

	def get_remote_status_a(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-remote-status-a')

		args = parser.parse_args(argv)

		device_call(ctx, RemoteSwitchV2Bricklet, 11, (), '', 'B B B H', args.execute, False, ['house-code', 'receiver-code', 'switch-to', 'repeats'], [None, None, {0: 'switch-to-off', 1: 'switch-to-on'}, None])

	def get_remote_status_b(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-remote-status-b')

		args = parser.parse_args(argv)

		device_call(ctx, RemoteSwitchV2Bricklet, 12, (), '', 'I B B B H', args.execute, False, ['address', 'unit', 'switch-to', 'dim-value', 'repeats'], [None, None, {0: 'switch-to-off', 1: 'switch-to-on'}, None, None])

	def get_remote_status_c(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-remote-status-c')

		args = parser.parse_args(argv)

		device_call(ctx, RemoteSwitchV2Bricklet, 13, (), '', 'c B B H', args.execute, False, ['system-code', 'device-code', 'switch-to', 'repeats'], [None, None, {0: 'switch-to-off', 1: 'switch-to-on'}, None])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, RemoteSwitchV2Bricklet, 234, (), '', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def set_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-bootloader-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'bootloader-mode-firmware-wait-for-reboot': 3, 'bootloader-mode-firmware': 1, 'bootloader-mode-firmware-wait-for-erase-and-reboot': 4, 'bootloader-mode-bootloader-wait-for-reboot': 2, 'bootloader-mode-bootloader': 0}), help='int (bootloader-mode-bootloader: 0, bootloader-mode-firmware: 1, bootloader-mode-bootloader-wait-for-reboot: 2, bootloader-mode-firmware-wait-for-reboot: 3, bootloader-mode-firmware-wait-for-erase-and-reboot: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, RemoteSwitchV2Bricklet, 235, (args.mode,), 'B', 'B', args.execute, False, ['status'], [{0: 'bootloader-status-ok', 1: 'bootloader-status-invalid-mode', 2: 'bootloader-status-no-change', 3: 'bootloader-status-entry-function-not-present', 4: 'bootloader-status-device-identifier-incorrect', 5: 'bootloader-status-crc-mismatch'}])

	def get_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-bootloader-mode')

		args = parser.parse_args(argv)

		device_call(ctx, RemoteSwitchV2Bricklet, 236, (), '', 'B', args.execute, False, ['mode'], [{0: 'bootloader-mode-bootloader', 1: 'bootloader-mode-firmware', 2: 'bootloader-mode-bootloader-wait-for-reboot', 3: 'bootloader-mode-firmware-wait-for-reboot', 4: 'bootloader-mode-firmware-wait-for-erase-and-reboot'}])

	def set_write_firmware_pointer(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-write-firmware-pointer')

		parser.add_argument('pointer', type=convert_int, help='int', metavar='<pointer>')

		args = parser.parse_args(argv)

		device_call(ctx, RemoteSwitchV2Bricklet, 237, (args.pointer,), 'I', '', None, args.expect_response, [], [])

	def write_firmware(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-firmware')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, RemoteSwitchV2Bricklet, 238, (args.data,), '64B', 'B', args.execute, False, ['status'], [None])

	def set_status_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'status-led-config-on': 1, 'status-led-config-show-heartbeat': 2, 'status-led-config-off': 0, 'status-led-config-show-status': 3}), help='int (status-led-config-off: 0, status-led-config-on: 1, status-led-config-show-heartbeat: 2, status-led-config-show-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, RemoteSwitchV2Bricklet, 239, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_status_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, RemoteSwitchV2Bricklet, 240, (), '', 'B', args.execute, False, ['config'], [{0: 'status-led-config-off', 1: 'status-led-config-on', 2: 'status-led-config-show-heartbeat', 3: 'status-led-config-show-status'}])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, RemoteSwitchV2Bricklet, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, RemoteSwitchV2Bricklet, 243, (), '', '', None, args.expect_response, [], [])

	def write_uid(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-uid')

		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')

		args = parser.parse_args(argv)

		device_call(ctx, RemoteSwitchV2Bricklet, 248, (args.uid,), 'I', '', None, args.expect_response, [], [])

	def read_uid(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-uid')

		args = parser.parse_args(argv)

		device_call(ctx, RemoteSwitchV2Bricklet, 249, (), '', 'I', args.execute, False, ['uid'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, RemoteSwitchV2Bricklet, argv)

	functions = {
	'get-switching-state': get_switching_state,
	'set-repeats': set_repeats,
	'get-repeats': get_repeats,
	'switch-socket-a': switch_socket_a,
	'switch-socket-b': switch_socket_b,
	'dim-socket-b': dim_socket_b,
	'switch-socket-c': switch_socket_c,
	'set-remote-configuration': set_remote_configuration,
	'get-remote-configuration': get_remote_configuration,
	'get-remote-status-a': get_remote_status_a,
	'get-remote-status-b': get_remote_status_b,
	'get-remote-status-c': get_remote_status_c,
	'get-spitfp-error-count': get_spitfp_error_count,
	'set-bootloader-mode': set_bootloader_mode,
	'get-bootloader-mode': get_bootloader_mode,
	'set-write-firmware-pointer': set_write_firmware_pointer,
	'write-firmware': write_firmware,
	'set-status-led-config': set_status_led_config,
	'get-status-led-config': get_status_led_config,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'write-uid': write_uid,
	'read-uid': read_uid,
	'get-identity': get_identity
	}

	call_generic(ctx, 'remote-switch-v2-bricklet', functions, argv)

def dispatch_remote_switch_v2_bricklet(ctx, argv):
	prog_prefix = 'dispatch remote-switch-v2-bricklet <uid>'

	def switching_done(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' switching-done')

		args = parser.parse_args(argv)

		device_dispatch(ctx, RemoteSwitchV2Bricklet, 2, args.execute, [], [])

	def remote_status_a(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' remote-status-a')

		args = parser.parse_args(argv)

		device_dispatch(ctx, RemoteSwitchV2Bricklet, 14, args.execute, ['house-code', 'receiver-code', 'switch-to', 'repeats'], [None, None, {0: 'switch-to-off', 1: 'switch-to-on'}, None])

	def remote_status_b(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' remote-status-b')

		args = parser.parse_args(argv)

		device_dispatch(ctx, RemoteSwitchV2Bricklet, 15, args.execute, ['address', 'unit', 'switch-to', 'dim-value', 'repeats'], [None, None, {0: 'switch-to-off', 1: 'switch-to-on'}, None, None])

	def remote_status_c(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' remote-status-c')

		args = parser.parse_args(argv)

		device_dispatch(ctx, RemoteSwitchV2Bricklet, 16, args.execute, ['system-code', 'device-code', 'switch-to', 'repeats'], [None, None, {0: 'switch-to-off', 1: 'switch-to-on'}, None])

	callbacks = {
	'switching-done': switching_done,
	'remote-status-a': remote_status_a,
	'remote-status-b': remote_status_b,
	'remote-status-c': remote_status_c
	}

	dispatch_generic(ctx, 'remote-switch-v2-bricklet', callbacks, argv)

class RGBLEDBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 3; re[2] = 1; re[255] = 1



def call_rgb_led_bricklet(ctx, argv):
	prog_prefix = 'call rgb-led-bricklet <uid>'

	def set_rgb_value(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-rgb-value')

		parser.add_argument('r', type=convert_int, help='int', metavar='<r>')
		parser.add_argument('g', type=convert_int, help='int', metavar='<g>')
		parser.add_argument('b', type=convert_int, help='int', metavar='<b>')

		args = parser.parse_args(argv)

		device_call(ctx, RGBLEDBricklet, 1, (args.r, args.g, args.b), 'B B B', '', None, args.expect_response, [], [])

	def get_rgb_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-rgb-value')

		args = parser.parse_args(argv)

		device_call(ctx, RGBLEDBricklet, 2, (), '', 'B B B', args.execute, False, ['r', 'g', 'b'], [None, None, None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, RGBLEDBricklet, argv)

	functions = {
	'set-rgb-value': set_rgb_value,
	'get-rgb-value': get_rgb_value,
	'get-identity': get_identity
	}

	call_generic(ctx, 'rgb-led-bricklet', functions, argv)

def dispatch_rgb_led_bricklet(ctx, argv):
	prog_prefix = 'dispatch rgb-led-bricklet <uid>'


	callbacks = {

	}

	dispatch_generic(ctx, 'rgb-led-bricklet', callbacks, argv)

class RGBLEDButtonBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 3; re[2] = 1; re[3] = 1; re[5] = 3; re[6] = 1; re[234] = 1; re[235] = 1; re[236] = 1; re[237] = 3; re[238] = 1; re[239] = 3; re[240] = 1; re[242] = 1; re[243] = 3; re[248] = 3; re[249] = 1; re[255] = 1
		cf = self.callback_formats
		cf[4] = 'B'


def call_rgb_led_button_bricklet(ctx, argv):
	prog_prefix = 'call rgb-led-button-bricklet <uid>'

	def set_color(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-color')

		parser.add_argument('red', type=convert_int, help='int', metavar='<red>')
		parser.add_argument('green', type=convert_int, help='int', metavar='<green>')
		parser.add_argument('blue', type=convert_int, help='int', metavar='<blue>')

		args = parser.parse_args(argv)

		device_call(ctx, RGBLEDButtonBricklet, 1, (args.red, args.green, args.blue), 'B B B', '', None, args.expect_response, [], [])

	def get_color(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-color')

		args = parser.parse_args(argv)

		device_call(ctx, RGBLEDButtonBricklet, 2, (), '', 'B B B', args.execute, False, ['red', 'green', 'blue'], [None, None, None])

	def get_button_state(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-button-state')

		args = parser.parse_args(argv)

		device_call(ctx, RGBLEDButtonBricklet, 3, (), '', 'B', args.execute, False, ['state'], [{0: 'button-state-pressed', 1: 'button-state-released'}])

	def set_color_calibration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-color-calibration')

		parser.add_argument('red', type=convert_int, help='int', metavar='<red>')
		parser.add_argument('green', type=convert_int, help='int', metavar='<green>')
		parser.add_argument('blue', type=convert_int, help='int', metavar='<blue>')

		args = parser.parse_args(argv)

		device_call(ctx, RGBLEDButtonBricklet, 5, (args.red, args.green, args.blue), 'B B B', '', None, args.expect_response, [], [])

	def get_color_calibration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-color-calibration')

		args = parser.parse_args(argv)

		device_call(ctx, RGBLEDButtonBricklet, 6, (), '', 'B B B', args.execute, False, ['red', 'green', 'blue'], [None, None, None])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, RGBLEDButtonBricklet, 234, (), '', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def set_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-bootloader-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'bootloader-mode-firmware-wait-for-reboot': 3, 'bootloader-mode-firmware': 1, 'bootloader-mode-firmware-wait-for-erase-and-reboot': 4, 'bootloader-mode-bootloader-wait-for-reboot': 2, 'bootloader-mode-bootloader': 0}), help='int (bootloader-mode-bootloader: 0, bootloader-mode-firmware: 1, bootloader-mode-bootloader-wait-for-reboot: 2, bootloader-mode-firmware-wait-for-reboot: 3, bootloader-mode-firmware-wait-for-erase-and-reboot: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, RGBLEDButtonBricklet, 235, (args.mode,), 'B', 'B', args.execute, False, ['status'], [{0: 'bootloader-status-ok', 1: 'bootloader-status-invalid-mode', 2: 'bootloader-status-no-change', 3: 'bootloader-status-entry-function-not-present', 4: 'bootloader-status-device-identifier-incorrect', 5: 'bootloader-status-crc-mismatch'}])

	def get_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-bootloader-mode')

		args = parser.parse_args(argv)

		device_call(ctx, RGBLEDButtonBricklet, 236, (), '', 'B', args.execute, False, ['mode'], [{0: 'bootloader-mode-bootloader', 1: 'bootloader-mode-firmware', 2: 'bootloader-mode-bootloader-wait-for-reboot', 3: 'bootloader-mode-firmware-wait-for-reboot', 4: 'bootloader-mode-firmware-wait-for-erase-and-reboot'}])

	def set_write_firmware_pointer(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-write-firmware-pointer')

		parser.add_argument('pointer', type=convert_int, help='int', metavar='<pointer>')

		args = parser.parse_args(argv)

		device_call(ctx, RGBLEDButtonBricklet, 237, (args.pointer,), 'I', '', None, args.expect_response, [], [])

	def write_firmware(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-firmware')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, RGBLEDButtonBricklet, 238, (args.data,), '64B', 'B', args.execute, False, ['status'], [None])

	def set_status_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'status-led-config-on': 1, 'status-led-config-show-heartbeat': 2, 'status-led-config-off': 0, 'status-led-config-show-status': 3}), help='int (status-led-config-off: 0, status-led-config-on: 1, status-led-config-show-heartbeat: 2, status-led-config-show-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, RGBLEDButtonBricklet, 239, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_status_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, RGBLEDButtonBricklet, 240, (), '', 'B', args.execute, False, ['config'], [{0: 'status-led-config-off', 1: 'status-led-config-on', 2: 'status-led-config-show-heartbeat', 3: 'status-led-config-show-status'}])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, RGBLEDButtonBricklet, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, RGBLEDButtonBricklet, 243, (), '', '', None, args.expect_response, [], [])

	def write_uid(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-uid')

		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')

		args = parser.parse_args(argv)

		device_call(ctx, RGBLEDButtonBricklet, 248, (args.uid,), 'I', '', None, args.expect_response, [], [])

	def read_uid(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-uid')

		args = parser.parse_args(argv)

		device_call(ctx, RGBLEDButtonBricklet, 249, (), '', 'I', args.execute, False, ['uid'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, RGBLEDButtonBricklet, argv)

	functions = {
	'set-color': set_color,
	'get-color': get_color,
	'get-button-state': get_button_state,
	'set-color-calibration': set_color_calibration,
	'get-color-calibration': get_color_calibration,
	'get-spitfp-error-count': get_spitfp_error_count,
	'set-bootloader-mode': set_bootloader_mode,
	'get-bootloader-mode': get_bootloader_mode,
	'set-write-firmware-pointer': set_write_firmware_pointer,
	'write-firmware': write_firmware,
	'set-status-led-config': set_status_led_config,
	'get-status-led-config': get_status_led_config,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'write-uid': write_uid,
	'read-uid': read_uid,
	'get-identity': get_identity
	}

	call_generic(ctx, 'rgb-led-button-bricklet', functions, argv)

def dispatch_rgb_led_button_bricklet(ctx, argv):
	prog_prefix = 'dispatch rgb-led-button-bricklet <uid>'

	def button_state_changed(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' button-state-changed')

		args = parser.parse_args(argv)

		device_dispatch(ctx, RGBLEDButtonBricklet, 4, args.execute, ['state'], [{0: 'button-state-pressed', 1: 'button-state-released'}])

	callbacks = {
	'button-state-changed': button_state_changed
	}

	dispatch_generic(ctx, 'rgb-led-button-bricklet', callbacks, argv)

class RGBLEDMatrixBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 3; re[2] = 1; re[3] = 3; re[4] = 1; re[5] = 3; re[6] = 1; re[7] = 3; re[8] = 1; re[9] = 3; re[10] = 1; re[234] = 1; re[235] = 1; re[236] = 1; re[237] = 3; re[238] = 1; re[239] = 3; re[240] = 1; re[242] = 1; re[243] = 3; re[248] = 3; re[249] = 1; re[255] = 1
		cf = self.callback_formats
		cf[11] = 'I'


def call_rgb_led_matrix_bricklet(ctx, argv):
	prog_prefix = 'call rgb-led-matrix-bricklet <uid>'

	def set_red(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-red')

		parser.add_argument('red', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<red>')

		args = parser.parse_args(argv)

		device_call(ctx, RGBLEDMatrixBricklet, 1, (args.red,), '64B', '', None, args.expect_response, [], [])

	def get_red(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-red')

		args = parser.parse_args(argv)

		device_call(ctx, RGBLEDMatrixBricklet, 2, (), '', '64B', args.execute, False, ['red'], [None])

	def set_green(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-green')

		parser.add_argument('green', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<green>')

		args = parser.parse_args(argv)

		device_call(ctx, RGBLEDMatrixBricklet, 3, (args.green,), '64B', '', None, args.expect_response, [], [])

	def get_green(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-green')

		args = parser.parse_args(argv)

		device_call(ctx, RGBLEDMatrixBricklet, 4, (), '', '64B', args.execute, False, ['green'], [None])

	def set_blue(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-blue')

		parser.add_argument('blue', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<blue>')

		args = parser.parse_args(argv)

		device_call(ctx, RGBLEDMatrixBricklet, 5, (args.blue,), '64B', '', None, args.expect_response, [], [])

	def get_blue(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-blue')

		args = parser.parse_args(argv)

		device_call(ctx, RGBLEDMatrixBricklet, 6, (), '', '64B', args.execute, False, ['blue'], [None])

	def set_frame_duration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-frame-duration')

		parser.add_argument('frame_duration', type=convert_int, help='int', metavar='<frame-duration>')

		args = parser.parse_args(argv)

		device_call(ctx, RGBLEDMatrixBricklet, 7, (args.frame_duration,), 'H', '', None, args.expect_response, [], [])

	def get_frame_duration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-frame-duration')

		args = parser.parse_args(argv)

		device_call(ctx, RGBLEDMatrixBricklet, 8, (), '', 'H', args.execute, False, ['frame-duration'], [None])

	def draw_frame(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' draw-frame')

		args = parser.parse_args(argv)

		device_call(ctx, RGBLEDMatrixBricklet, 9, (), '', '', None, args.expect_response, [], [])

	def get_supply_voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-supply-voltage')

		args = parser.parse_args(argv)

		device_call(ctx, RGBLEDMatrixBricklet, 10, (), '', 'H', args.execute, False, ['voltage'], [None])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, RGBLEDMatrixBricklet, 234, (), '', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def set_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-bootloader-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'bootloader-mode-firmware-wait-for-reboot': 3, 'bootloader-mode-firmware': 1, 'bootloader-mode-firmware-wait-for-erase-and-reboot': 4, 'bootloader-mode-bootloader-wait-for-reboot': 2, 'bootloader-mode-bootloader': 0}), help='int (bootloader-mode-bootloader: 0, bootloader-mode-firmware: 1, bootloader-mode-bootloader-wait-for-reboot: 2, bootloader-mode-firmware-wait-for-reboot: 3, bootloader-mode-firmware-wait-for-erase-and-reboot: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, RGBLEDMatrixBricklet, 235, (args.mode,), 'B', 'B', args.execute, False, ['status'], [{0: 'bootloader-status-ok', 1: 'bootloader-status-invalid-mode', 2: 'bootloader-status-no-change', 3: 'bootloader-status-entry-function-not-present', 4: 'bootloader-status-device-identifier-incorrect', 5: 'bootloader-status-crc-mismatch'}])

	def get_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-bootloader-mode')

		args = parser.parse_args(argv)

		device_call(ctx, RGBLEDMatrixBricklet, 236, (), '', 'B', args.execute, False, ['mode'], [{0: 'bootloader-mode-bootloader', 1: 'bootloader-mode-firmware', 2: 'bootloader-mode-bootloader-wait-for-reboot', 3: 'bootloader-mode-firmware-wait-for-reboot', 4: 'bootloader-mode-firmware-wait-for-erase-and-reboot'}])

	def set_write_firmware_pointer(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-write-firmware-pointer')

		parser.add_argument('pointer', type=convert_int, help='int', metavar='<pointer>')

		args = parser.parse_args(argv)

		device_call(ctx, RGBLEDMatrixBricklet, 237, (args.pointer,), 'I', '', None, args.expect_response, [], [])

	def write_firmware(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-firmware')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, RGBLEDMatrixBricklet, 238, (args.data,), '64B', 'B', args.execute, False, ['status'], [None])

	def set_status_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'status-led-config-on': 1, 'status-led-config-show-heartbeat': 2, 'status-led-config-off': 0, 'status-led-config-show-status': 3}), help='int (status-led-config-off: 0, status-led-config-on: 1, status-led-config-show-heartbeat: 2, status-led-config-show-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, RGBLEDMatrixBricklet, 239, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_status_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, RGBLEDMatrixBricklet, 240, (), '', 'B', args.execute, False, ['config'], [{0: 'status-led-config-off', 1: 'status-led-config-on', 2: 'status-led-config-show-heartbeat', 3: 'status-led-config-show-status'}])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, RGBLEDMatrixBricklet, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, RGBLEDMatrixBricklet, 243, (), '', '', None, args.expect_response, [], [])

	def write_uid(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-uid')

		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')

		args = parser.parse_args(argv)

		device_call(ctx, RGBLEDMatrixBricklet, 248, (args.uid,), 'I', '', None, args.expect_response, [], [])

	def read_uid(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-uid')

		args = parser.parse_args(argv)

		device_call(ctx, RGBLEDMatrixBricklet, 249, (), '', 'I', args.execute, False, ['uid'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, RGBLEDMatrixBricklet, argv)

	functions = {
	'set-red': set_red,
	'get-red': get_red,
	'set-green': set_green,
	'get-green': get_green,
	'set-blue': set_blue,
	'get-blue': get_blue,
	'set-frame-duration': set_frame_duration,
	'get-frame-duration': get_frame_duration,
	'draw-frame': draw_frame,
	'get-supply-voltage': get_supply_voltage,
	'get-spitfp-error-count': get_spitfp_error_count,
	'set-bootloader-mode': set_bootloader_mode,
	'get-bootloader-mode': get_bootloader_mode,
	'set-write-firmware-pointer': set_write_firmware_pointer,
	'write-firmware': write_firmware,
	'set-status-led-config': set_status_led_config,
	'get-status-led-config': get_status_led_config,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'write-uid': write_uid,
	'read-uid': read_uid,
	'get-identity': get_identity
	}

	call_generic(ctx, 'rgb-led-matrix-bricklet', functions, argv)

def dispatch_rgb_led_matrix_bricklet(ctx, argv):
	prog_prefix = 'dispatch rgb-led-matrix-bricklet <uid>'

	def frame_started(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' frame-started')

		args = parser.parse_args(argv)

		device_dispatch(ctx, RGBLEDMatrixBricklet, 11, args.execute, ['frame-number'], [None])

	callbacks = {
	'frame-started': frame_started
	}

	dispatch_generic(ctx, 'rgb-led-matrix-bricklet', callbacks, argv)

class RGBLEDV2Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 3; re[2] = 1; re[234] = 1; re[235] = 1; re[236] = 1; re[237] = 3; re[238] = 1; re[239] = 3; re[240] = 1; re[242] = 1; re[243] = 3; re[248] = 3; re[249] = 1; re[255] = 1



def call_rgb_led_v2_bricklet(ctx, argv):
	prog_prefix = 'call rgb-led-v2-bricklet <uid>'

	def set_rgb_value(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-rgb-value')

		parser.add_argument('r', type=convert_int, help='int', metavar='<r>')
		parser.add_argument('g', type=convert_int, help='int', metavar='<g>')
		parser.add_argument('b', type=convert_int, help='int', metavar='<b>')

		args = parser.parse_args(argv)

		device_call(ctx, RGBLEDV2Bricklet, 1, (args.r, args.g, args.b), 'B B B', '', None, args.expect_response, [], [])

	def get_rgb_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-rgb-value')

		args = parser.parse_args(argv)

		device_call(ctx, RGBLEDV2Bricklet, 2, (), '', 'B B B', args.execute, False, ['r', 'g', 'b'], [None, None, None])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, RGBLEDV2Bricklet, 234, (), '', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def set_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-bootloader-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'bootloader-mode-firmware-wait-for-reboot': 3, 'bootloader-mode-firmware': 1, 'bootloader-mode-firmware-wait-for-erase-and-reboot': 4, 'bootloader-mode-bootloader-wait-for-reboot': 2, 'bootloader-mode-bootloader': 0}), help='int (bootloader-mode-bootloader: 0, bootloader-mode-firmware: 1, bootloader-mode-bootloader-wait-for-reboot: 2, bootloader-mode-firmware-wait-for-reboot: 3, bootloader-mode-firmware-wait-for-erase-and-reboot: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, RGBLEDV2Bricklet, 235, (args.mode,), 'B', 'B', args.execute, False, ['status'], [{0: 'bootloader-status-ok', 1: 'bootloader-status-invalid-mode', 2: 'bootloader-status-no-change', 3: 'bootloader-status-entry-function-not-present', 4: 'bootloader-status-device-identifier-incorrect', 5: 'bootloader-status-crc-mismatch'}])

	def get_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-bootloader-mode')

		args = parser.parse_args(argv)

		device_call(ctx, RGBLEDV2Bricklet, 236, (), '', 'B', args.execute, False, ['mode'], [{0: 'bootloader-mode-bootloader', 1: 'bootloader-mode-firmware', 2: 'bootloader-mode-bootloader-wait-for-reboot', 3: 'bootloader-mode-firmware-wait-for-reboot', 4: 'bootloader-mode-firmware-wait-for-erase-and-reboot'}])

	def set_write_firmware_pointer(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-write-firmware-pointer')

		parser.add_argument('pointer', type=convert_int, help='int', metavar='<pointer>')

		args = parser.parse_args(argv)

		device_call(ctx, RGBLEDV2Bricklet, 237, (args.pointer,), 'I', '', None, args.expect_response, [], [])

	def write_firmware(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-firmware')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, RGBLEDV2Bricklet, 238, (args.data,), '64B', 'B', args.execute, False, ['status'], [None])

	def set_status_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'status-led-config-on': 1, 'status-led-config-show-heartbeat': 2, 'status-led-config-off': 0, 'status-led-config-show-status': 3}), help='int (status-led-config-off: 0, status-led-config-on: 1, status-led-config-show-heartbeat: 2, status-led-config-show-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, RGBLEDV2Bricklet, 239, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_status_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, RGBLEDV2Bricklet, 240, (), '', 'B', args.execute, False, ['config'], [{0: 'status-led-config-off', 1: 'status-led-config-on', 2: 'status-led-config-show-heartbeat', 3: 'status-led-config-show-status'}])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, RGBLEDV2Bricklet, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, RGBLEDV2Bricklet, 243, (), '', '', None, args.expect_response, [], [])

	def write_uid(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-uid')

		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')

		args = parser.parse_args(argv)

		device_call(ctx, RGBLEDV2Bricklet, 248, (args.uid,), 'I', '', None, args.expect_response, [], [])

	def read_uid(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-uid')

		args = parser.parse_args(argv)

		device_call(ctx, RGBLEDV2Bricklet, 249, (), '', 'I', args.execute, False, ['uid'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, RGBLEDV2Bricklet, argv)

	functions = {
	'set-rgb-value': set_rgb_value,
	'get-rgb-value': get_rgb_value,
	'get-spitfp-error-count': get_spitfp_error_count,
	'set-bootloader-mode': set_bootloader_mode,
	'get-bootloader-mode': get_bootloader_mode,
	'set-write-firmware-pointer': set_write_firmware_pointer,
	'write-firmware': write_firmware,
	'set-status-led-config': set_status_led_config,
	'get-status-led-config': get_status_led_config,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'write-uid': write_uid,
	'read-uid': read_uid,
	'get-identity': get_identity
	}

	call_generic(ctx, 'rgb-led-v2-bricklet', functions, argv)

def dispatch_rgb_led_v2_bricklet(ctx, argv):
	prog_prefix = 'dispatch rgb-led-v2-bricklet <uid>'


	callbacks = {

	}

	dispatch_generic(ctx, 'rgb-led-v2-bricklet', callbacks, argv)

class RotaryEncoderBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 2; re[3] = 1; re[4] = 2; re[5] = 1; re[6] = 2; re[7] = 1; re[10] = 1; re[255] = 1
		cf = self.callback_formats
		cf[8] = 'i'; cf[9] = 'i'; cf[11] = ''; cf[12] = ''


def call_rotary_encoder_bricklet(ctx, argv):
	prog_prefix = 'call rotary-encoder-bricklet <uid>'

	def get_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-count')

		parser.add_argument('reset', type=convert_bool, help='bool', metavar='<reset>')

		args = parser.parse_args(argv)

		device_call(ctx, RotaryEncoderBricklet, 1, (args.reset,), '!', 'i', args.execute, False, ['count'], [None])

	def set_count_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-count-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, RotaryEncoderBricklet, 2, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_count_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-count-callback-period')

		args = parser.parse_args(argv)

		device_call(ctx, RotaryEncoderBricklet, 3, (), '', 'I', args.execute, False, ['period'], [None])

	def set_count_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-count-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, RotaryEncoderBricklet, 4, (args.option, args.min, args.max), 'c i i', '', None, args.expect_response, [], [])

	def get_count_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-count-callback-threshold')

		args = parser.parse_args(argv)

		device_call(ctx, RotaryEncoderBricklet, 5, (), '', 'c i i', args.execute, False, ['option', 'min', 'max'], [{'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def set_debounce_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-debounce-period')

		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_call(ctx, RotaryEncoderBricklet, 6, (args.debounce,), 'I', '', None, args.expect_response, [], [])

	def get_debounce_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-debounce-period')

		args = parser.parse_args(argv)

		device_call(ctx, RotaryEncoderBricklet, 7, (), '', 'I', args.execute, False, ['debounce'], [None])

	def is_pressed(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' is-pressed')

		args = parser.parse_args(argv)

		device_call(ctx, RotaryEncoderBricklet, 10, (), '', '!', args.execute, False, ['pressed'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, RotaryEncoderBricklet, argv)

	functions = {
	'get-count': get_count,
	'set-count-callback-period': set_count_callback_period,
	'get-count-callback-period': get_count_callback_period,
	'set-count-callback-threshold': set_count_callback_threshold,
	'get-count-callback-threshold': get_count_callback_threshold,
	'set-debounce-period': set_debounce_period,
	'get-debounce-period': get_debounce_period,
	'is-pressed': is_pressed,
	'get-identity': get_identity
	}

	call_generic(ctx, 'rotary-encoder-bricklet', functions, argv)

def dispatch_rotary_encoder_bricklet(ctx, argv):
	prog_prefix = 'dispatch rotary-encoder-bricklet <uid>'

	def count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' count')

		args = parser.parse_args(argv)

		device_dispatch(ctx, RotaryEncoderBricklet, 8, args.execute, ['count'], [None])

	def count_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' count-reached')

		args = parser.parse_args(argv)

		device_dispatch(ctx, RotaryEncoderBricklet, 9, args.execute, ['count'], [None])

	def pressed(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' pressed')

		args = parser.parse_args(argv)

		device_dispatch(ctx, RotaryEncoderBricklet, 11, args.execute, [], [])

	def released(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' released')

		args = parser.parse_args(argv)

		device_dispatch(ctx, RotaryEncoderBricklet, 12, args.execute, [], [])

	callbacks = {
	'count': count,
	'count-reached': count_reached,
	'pressed': pressed,
	'released': released
	}

	dispatch_generic(ctx, 'rotary-encoder-bricklet', callbacks, argv)

class RotaryEncoderV2Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 2; re[3] = 1; re[5] = 1; re[234] = 1; re[235] = 1; re[236] = 1; re[237] = 3; re[238] = 1; re[239] = 3; re[240] = 1; re[242] = 1; re[243] = 3; re[248] = 3; re[249] = 1; re[255] = 1
		cf = self.callback_formats
		cf[4] = 'i'; cf[6] = ''; cf[7] = ''


def call_rotary_encoder_v2_bricklet(ctx, argv):
	prog_prefix = 'call rotary-encoder-v2-bricklet <uid>'

	def get_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-count')

		parser.add_argument('reset', type=convert_bool, help='bool', metavar='<reset>')

		args = parser.parse_args(argv)

		device_call(ctx, RotaryEncoderV2Bricklet, 1, (args.reset,), '!', 'i', args.execute, False, ['count'], [None])

	def set_count_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-count-callback-configuration')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')
		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, RotaryEncoderV2Bricklet, 2, (args.period, args.value_has_to_change, args.option, args.min, args.max), 'I ! c i i', '', None, args.expect_response, [], [])

	def get_count_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-count-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, RotaryEncoderV2Bricklet, 3, (), '', 'I ! c i i', args.execute, False, ['period', 'value-has-to-change', 'option', 'min', 'max'], [None, None, {'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def is_pressed(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' is-pressed')

		args = parser.parse_args(argv)

		device_call(ctx, RotaryEncoderV2Bricklet, 5, (), '', '!', args.execute, False, ['pressed'], [None])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, RotaryEncoderV2Bricklet, 234, (), '', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def set_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-bootloader-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'bootloader-mode-firmware-wait-for-reboot': 3, 'bootloader-mode-firmware': 1, 'bootloader-mode-firmware-wait-for-erase-and-reboot': 4, 'bootloader-mode-bootloader-wait-for-reboot': 2, 'bootloader-mode-bootloader': 0}), help='int (bootloader-mode-bootloader: 0, bootloader-mode-firmware: 1, bootloader-mode-bootloader-wait-for-reboot: 2, bootloader-mode-firmware-wait-for-reboot: 3, bootloader-mode-firmware-wait-for-erase-and-reboot: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, RotaryEncoderV2Bricklet, 235, (args.mode,), 'B', 'B', args.execute, False, ['status'], [{0: 'bootloader-status-ok', 1: 'bootloader-status-invalid-mode', 2: 'bootloader-status-no-change', 3: 'bootloader-status-entry-function-not-present', 4: 'bootloader-status-device-identifier-incorrect', 5: 'bootloader-status-crc-mismatch'}])

	def get_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-bootloader-mode')

		args = parser.parse_args(argv)

		device_call(ctx, RotaryEncoderV2Bricklet, 236, (), '', 'B', args.execute, False, ['mode'], [{0: 'bootloader-mode-bootloader', 1: 'bootloader-mode-firmware', 2: 'bootloader-mode-bootloader-wait-for-reboot', 3: 'bootloader-mode-firmware-wait-for-reboot', 4: 'bootloader-mode-firmware-wait-for-erase-and-reboot'}])

	def set_write_firmware_pointer(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-write-firmware-pointer')

		parser.add_argument('pointer', type=convert_int, help='int', metavar='<pointer>')

		args = parser.parse_args(argv)

		device_call(ctx, RotaryEncoderV2Bricklet, 237, (args.pointer,), 'I', '', None, args.expect_response, [], [])

	def write_firmware(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-firmware')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, RotaryEncoderV2Bricklet, 238, (args.data,), '64B', 'B', args.execute, False, ['status'], [None])

	def set_status_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'status-led-config-on': 1, 'status-led-config-show-heartbeat': 2, 'status-led-config-off': 0, 'status-led-config-show-status': 3}), help='int (status-led-config-off: 0, status-led-config-on: 1, status-led-config-show-heartbeat: 2, status-led-config-show-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, RotaryEncoderV2Bricklet, 239, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_status_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, RotaryEncoderV2Bricklet, 240, (), '', 'B', args.execute, False, ['config'], [{0: 'status-led-config-off', 1: 'status-led-config-on', 2: 'status-led-config-show-heartbeat', 3: 'status-led-config-show-status'}])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, RotaryEncoderV2Bricklet, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, RotaryEncoderV2Bricklet, 243, (), '', '', None, args.expect_response, [], [])

	def write_uid(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-uid')

		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')

		args = parser.parse_args(argv)

		device_call(ctx, RotaryEncoderV2Bricklet, 248, (args.uid,), 'I', '', None, args.expect_response, [], [])

	def read_uid(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-uid')

		args = parser.parse_args(argv)

		device_call(ctx, RotaryEncoderV2Bricklet, 249, (), '', 'I', args.execute, False, ['uid'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, RotaryEncoderV2Bricklet, argv)

	functions = {
	'get-count': get_count,
	'set-count-callback-configuration': set_count_callback_configuration,
	'get-count-callback-configuration': get_count_callback_configuration,
	'is-pressed': is_pressed,
	'get-spitfp-error-count': get_spitfp_error_count,
	'set-bootloader-mode': set_bootloader_mode,
	'get-bootloader-mode': get_bootloader_mode,
	'set-write-firmware-pointer': set_write_firmware_pointer,
	'write-firmware': write_firmware,
	'set-status-led-config': set_status_led_config,
	'get-status-led-config': get_status_led_config,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'write-uid': write_uid,
	'read-uid': read_uid,
	'get-identity': get_identity
	}

	call_generic(ctx, 'rotary-encoder-v2-bricklet', functions, argv)

def dispatch_rotary_encoder_v2_bricklet(ctx, argv):
	prog_prefix = 'dispatch rotary-encoder-v2-bricklet <uid>'

	def count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' count')

		args = parser.parse_args(argv)

		device_dispatch(ctx, RotaryEncoderV2Bricklet, 4, args.execute, ['count'], [None])

	def pressed(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' pressed')

		args = parser.parse_args(argv)

		device_dispatch(ctx, RotaryEncoderV2Bricklet, 6, args.execute, [], [])

	def released(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' released')

		args = parser.parse_args(argv)

		device_dispatch(ctx, RotaryEncoderV2Bricklet, 7, args.execute, [], [])

	callbacks = {
	'count': count,
	'pressed': pressed,
	'released': released
	}

	dispatch_generic(ctx, 'rotary-encoder-v2-bricklet', callbacks, argv)

class RotaryPotiBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 1; re[3] = 2; re[4] = 1; re[5] = 2; re[6] = 1; re[7] = 2; re[8] = 1; re[9] = 2; re[10] = 1; re[11] = 2; re[12] = 1; re[255] = 1
		cf = self.callback_formats
		cf[13] = 'h'; cf[14] = 'H'; cf[15] = 'h'; cf[16] = 'H'


def call_rotary_poti_bricklet(ctx, argv):
	prog_prefix = 'call rotary-poti-bricklet <uid>'

	def get_position(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-position')

		args = parser.parse_args(argv)

		device_call(ctx, RotaryPotiBricklet, 1, (), '', 'h', args.execute, False, ['position'], [None])

	def get_analog_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-analog-value')

		args = parser.parse_args(argv)

		device_call(ctx, RotaryPotiBricklet, 2, (), '', 'H', args.execute, False, ['value'], [None])

	def set_position_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-position-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, RotaryPotiBricklet, 3, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_position_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-position-callback-period')

		args = parser.parse_args(argv)

		device_call(ctx, RotaryPotiBricklet, 4, (), '', 'I', args.execute, False, ['period'], [None])

	def set_analog_value_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-analog-value-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, RotaryPotiBricklet, 5, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_analog_value_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-analog-value-callback-period')

		args = parser.parse_args(argv)

		device_call(ctx, RotaryPotiBricklet, 6, (), '', 'I', args.execute, False, ['period'], [None])

	def set_position_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-position-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, RotaryPotiBricklet, 7, (args.option, args.min, args.max), 'c h h', '', None, args.expect_response, [], [])

	def get_position_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-position-callback-threshold')

		args = parser.parse_args(argv)

		device_call(ctx, RotaryPotiBricklet, 8, (), '', 'c h h', args.execute, False, ['option', 'min', 'max'], [{'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def set_analog_value_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-analog-value-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, RotaryPotiBricklet, 9, (args.option, args.min, args.max), 'c H H', '', None, args.expect_response, [], [])

	def get_analog_value_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-analog-value-callback-threshold')

		args = parser.parse_args(argv)

		device_call(ctx, RotaryPotiBricklet, 10, (), '', 'c H H', args.execute, False, ['option', 'min', 'max'], [{'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def set_debounce_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-debounce-period')

		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_call(ctx, RotaryPotiBricklet, 11, (args.debounce,), 'I', '', None, args.expect_response, [], [])

	def get_debounce_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-debounce-period')

		args = parser.parse_args(argv)

		device_call(ctx, RotaryPotiBricklet, 12, (), '', 'I', args.execute, False, ['debounce'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, RotaryPotiBricklet, argv)

	functions = {
	'get-position': get_position,
	'get-analog-value': get_analog_value,
	'set-position-callback-period': set_position_callback_period,
	'get-position-callback-period': get_position_callback_period,
	'set-analog-value-callback-period': set_analog_value_callback_period,
	'get-analog-value-callback-period': get_analog_value_callback_period,
	'set-position-callback-threshold': set_position_callback_threshold,
	'get-position-callback-threshold': get_position_callback_threshold,
	'set-analog-value-callback-threshold': set_analog_value_callback_threshold,
	'get-analog-value-callback-threshold': get_analog_value_callback_threshold,
	'set-debounce-period': set_debounce_period,
	'get-debounce-period': get_debounce_period,
	'get-identity': get_identity
	}

	call_generic(ctx, 'rotary-poti-bricklet', functions, argv)

def dispatch_rotary_poti_bricklet(ctx, argv):
	prog_prefix = 'dispatch rotary-poti-bricklet <uid>'

	def position(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' position')

		args = parser.parse_args(argv)

		device_dispatch(ctx, RotaryPotiBricklet, 13, args.execute, ['position'], [None])

	def analog_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' analog-value')

		args = parser.parse_args(argv)

		device_dispatch(ctx, RotaryPotiBricklet, 14, args.execute, ['value'], [None])

	def position_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' position-reached')

		args = parser.parse_args(argv)

		device_dispatch(ctx, RotaryPotiBricklet, 15, args.execute, ['position'], [None])

	def analog_value_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' analog-value-reached')

		args = parser.parse_args(argv)

		device_dispatch(ctx, RotaryPotiBricklet, 16, args.execute, ['value'], [None])

	callbacks = {
	'position': position,
	'analog-value': analog_value,
	'position-reached': position_reached,
	'analog-value-reached': analog_value_reached
	}

	dispatch_generic(ctx, 'rotary-poti-bricklet', callbacks, argv)

class RotaryPotiV2Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 2; re[3] = 1; re[234] = 1; re[235] = 1; re[236] = 1; re[237] = 3; re[238] = 1; re[239] = 3; re[240] = 1; re[242] = 1; re[243] = 3; re[248] = 3; re[249] = 1; re[255] = 1
		cf = self.callback_formats
		cf[4] = 'h'


def call_rotary_poti_v2_bricklet(ctx, argv):
	prog_prefix = 'call rotary-poti-v2-bricklet <uid>'

	def get_position(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-position')

		args = parser.parse_args(argv)

		device_call(ctx, RotaryPotiV2Bricklet, 1, (), '', 'h', args.execute, False, ['position'], [None])

	def set_position_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-position-callback-configuration')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')
		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, RotaryPotiV2Bricklet, 2, (args.period, args.value_has_to_change, args.option, args.min, args.max), 'I ! c h h', '', None, args.expect_response, [], [])

	def get_position_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-position-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, RotaryPotiV2Bricklet, 3, (), '', 'I ! c h h', args.execute, False, ['period', 'value-has-to-change', 'option', 'min', 'max'], [None, None, {'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, RotaryPotiV2Bricklet, 234, (), '', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def set_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-bootloader-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'bootloader-mode-firmware-wait-for-reboot': 3, 'bootloader-mode-firmware': 1, 'bootloader-mode-firmware-wait-for-erase-and-reboot': 4, 'bootloader-mode-bootloader-wait-for-reboot': 2, 'bootloader-mode-bootloader': 0}), help='int (bootloader-mode-bootloader: 0, bootloader-mode-firmware: 1, bootloader-mode-bootloader-wait-for-reboot: 2, bootloader-mode-firmware-wait-for-reboot: 3, bootloader-mode-firmware-wait-for-erase-and-reboot: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, RotaryPotiV2Bricklet, 235, (args.mode,), 'B', 'B', args.execute, False, ['status'], [{0: 'bootloader-status-ok', 1: 'bootloader-status-invalid-mode', 2: 'bootloader-status-no-change', 3: 'bootloader-status-entry-function-not-present', 4: 'bootloader-status-device-identifier-incorrect', 5: 'bootloader-status-crc-mismatch'}])

	def get_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-bootloader-mode')

		args = parser.parse_args(argv)

		device_call(ctx, RotaryPotiV2Bricklet, 236, (), '', 'B', args.execute, False, ['mode'], [{0: 'bootloader-mode-bootloader', 1: 'bootloader-mode-firmware', 2: 'bootloader-mode-bootloader-wait-for-reboot', 3: 'bootloader-mode-firmware-wait-for-reboot', 4: 'bootloader-mode-firmware-wait-for-erase-and-reboot'}])

	def set_write_firmware_pointer(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-write-firmware-pointer')

		parser.add_argument('pointer', type=convert_int, help='int', metavar='<pointer>')

		args = parser.parse_args(argv)

		device_call(ctx, RotaryPotiV2Bricklet, 237, (args.pointer,), 'I', '', None, args.expect_response, [], [])

	def write_firmware(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-firmware')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, RotaryPotiV2Bricklet, 238, (args.data,), '64B', 'B', args.execute, False, ['status'], [None])

	def set_status_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'status-led-config-on': 1, 'status-led-config-show-heartbeat': 2, 'status-led-config-off': 0, 'status-led-config-show-status': 3}), help='int (status-led-config-off: 0, status-led-config-on: 1, status-led-config-show-heartbeat: 2, status-led-config-show-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, RotaryPotiV2Bricklet, 239, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_status_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, RotaryPotiV2Bricklet, 240, (), '', 'B', args.execute, False, ['config'], [{0: 'status-led-config-off', 1: 'status-led-config-on', 2: 'status-led-config-show-heartbeat', 3: 'status-led-config-show-status'}])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, RotaryPotiV2Bricklet, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, RotaryPotiV2Bricklet, 243, (), '', '', None, args.expect_response, [], [])

	def write_uid(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-uid')

		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')

		args = parser.parse_args(argv)

		device_call(ctx, RotaryPotiV2Bricklet, 248, (args.uid,), 'I', '', None, args.expect_response, [], [])

	def read_uid(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-uid')

		args = parser.parse_args(argv)

		device_call(ctx, RotaryPotiV2Bricklet, 249, (), '', 'I', args.execute, False, ['uid'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, RotaryPotiV2Bricklet, argv)

	functions = {
	'get-position': get_position,
	'set-position-callback-configuration': set_position_callback_configuration,
	'get-position-callback-configuration': get_position_callback_configuration,
	'get-spitfp-error-count': get_spitfp_error_count,
	'set-bootloader-mode': set_bootloader_mode,
	'get-bootloader-mode': get_bootloader_mode,
	'set-write-firmware-pointer': set_write_firmware_pointer,
	'write-firmware': write_firmware,
	'set-status-led-config': set_status_led_config,
	'get-status-led-config': get_status_led_config,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'write-uid': write_uid,
	'read-uid': read_uid,
	'get-identity': get_identity
	}

	call_generic(ctx, 'rotary-poti-v2-bricklet', functions, argv)

def dispatch_rotary_poti_v2_bricklet(ctx, argv):
	prog_prefix = 'dispatch rotary-poti-v2-bricklet <uid>'

	def position(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' position')

		args = parser.parse_args(argv)

		device_dispatch(ctx, RotaryPotiV2Bricklet, 4, args.execute, ['position'], [None])

	callbacks = {
	'position': position
	}

	dispatch_generic(ctx, 'rotary-poti-v2-bricklet', callbacks, argv)

class RS232Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 1; re[3] = 2; re[4] = 2; re[5] = 1; re[6] = 3; re[7] = 1; re[10] = 3; re[255] = 1
		cf = self.callback_formats
		cf[8] = '60c B'; cf[9] = 'B'


def call_rs232_bricklet(ctx, argv):
	prog_prefix = 'call rs232-bricklet <uid>'

	def write(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write')

		parser.add_argument('message', type=create_array_converter(ctx, create_char_converter(ctx), '\0', 60), help=get_array_type_name(ctx, 'char', 60), metavar='<message>')
		parser.add_argument('length', type=convert_int, help='int', metavar='<length>')

		args = parser.parse_args(argv)

		device_call(ctx, RS232Bricklet, 1, (args.message, args.length), '60c B', 'B', args.execute, False, ['written'], [None])

	def read(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read')

		args = parser.parse_args(argv)

		device_call(ctx, RS232Bricklet, 2, (), '', '60c B', args.execute, False, ['message', 'length'], [None, None])

	def enable_read_callback(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' enable-read-callback')

		args = parser.parse_args(argv)

		device_call(ctx, RS232Bricklet, 3, (), '', '', None, args.expect_response, [], [])

	def disable_read_callback(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' disable-read-callback')

		args = parser.parse_args(argv)

		device_call(ctx, RS232Bricklet, 4, (), '', '', None, args.expect_response, [], [])

	def is_read_callback_enabled(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' is-read-callback-enabled')

		args = parser.parse_args(argv)

		device_call(ctx, RS232Bricklet, 5, (), '', '!', args.execute, False, ['enabled'], [None])

	def set_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-configuration')

		parser.add_argument('baudrate', type=create_symbol_converter(ctx, convert_int, {'baudrate-600': 1, 'baudrate-28800': 8, 'baudrate-57600': 10, 'baudrate-9600': 5, 'baudrate-19200': 7, 'baudrate-2400': 3, 'baudrate-115200': 11, 'baudrate-300': 0, 'baudrate-1200': 2, 'baudrate-38400': 9, 'baudrate-230400': 12, 'baudrate-4800': 4, 'baudrate-14400': 6}), help='int (baudrate-300: 0, baudrate-600: 1, baudrate-1200: 2, baudrate-2400: 3, baudrate-4800: 4, baudrate-9600: 5, baudrate-14400: 6, baudrate-19200: 7, baudrate-28800: 8, baudrate-38400: 9, baudrate-57600: 10, baudrate-115200: 11, baudrate-230400: 12)', metavar='<baudrate>')
		parser.add_argument('parity', type=create_symbol_converter(ctx, convert_int, {'parity-forced-parity-1': 3, 'parity-even': 2, 'parity-none': 0, 'parity-forced-parity-0': 4, 'parity-odd': 1}), help='int (parity-none: 0, parity-odd: 1, parity-even: 2, parity-forced-parity-1: 3, parity-forced-parity-0: 4)', metavar='<parity>')
		parser.add_argument('stopbits', type=create_symbol_converter(ctx, convert_int, {'stopbits-1': 1, 'stopbits-2': 2}), help='int (stopbits-1: 1, stopbits-2: 2)', metavar='<stopbits>')
		parser.add_argument('wordlength', type=create_symbol_converter(ctx, convert_int, {'wordlength-7': 7, 'wordlength-6': 6, 'wordlength-5': 5, 'wordlength-8': 8}), help='int (wordlength-5: 5, wordlength-6: 6, wordlength-7: 7, wordlength-8: 8)', metavar='<wordlength>')
		parser.add_argument('hardware_flowcontrol', type=create_symbol_converter(ctx, convert_int, {'hardware-flowcontrol-off': 0, 'hardware-flowcontrol-on': 1}), help='int (hardware-flowcontrol-off: 0, hardware-flowcontrol-on: 1)', metavar='<hardware-flowcontrol>')
		parser.add_argument('software_flowcontrol', type=create_symbol_converter(ctx, convert_int, {'software-flowcontrol-on': 1, 'software-flowcontrol-off': 0}), help='int (software-flowcontrol-off: 0, software-flowcontrol-on: 1)', metavar='<software-flowcontrol>')

		args = parser.parse_args(argv)

		device_call(ctx, RS232Bricklet, 6, (args.baudrate, args.parity, args.stopbits, args.wordlength, args.hardware_flowcontrol, args.software_flowcontrol), 'B B B B B B', '', None, args.expect_response, [], [])

	def get_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, RS232Bricklet, 7, (), '', 'B B B B B B', args.execute, False, ['baudrate', 'parity', 'stopbits', 'wordlength', 'hardware-flowcontrol', 'software-flowcontrol'], [{0: 'baudrate-300', 1: 'baudrate-600', 2: 'baudrate-1200', 3: 'baudrate-2400', 4: 'baudrate-4800', 5: 'baudrate-9600', 6: 'baudrate-14400', 7: 'baudrate-19200', 8: 'baudrate-28800', 9: 'baudrate-38400', 10: 'baudrate-57600', 11: 'baudrate-115200', 12: 'baudrate-230400'}, {0: 'parity-none', 1: 'parity-odd', 2: 'parity-even', 3: 'parity-forced-parity-1', 4: 'parity-forced-parity-0'}, {1: 'stopbits-1', 2: 'stopbits-2'}, {8: 'wordlength-8', 5: 'wordlength-5', 6: 'wordlength-6', 7: 'wordlength-7'}, {0: 'hardware-flowcontrol-off', 1: 'hardware-flowcontrol-on'}, {0: 'software-flowcontrol-off', 1: 'software-flowcontrol-on'}])

	def set_break_condition(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-break-condition')

		parser.add_argument('break_time', type=convert_int, help='int', metavar='<break-time>')

		args = parser.parse_args(argv)

		device_call(ctx, RS232Bricklet, 10, (args.break_time,), 'H', '', None, args.expect_response, [], [])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, RS232Bricklet, argv)

	functions = {
	'write': write,
	'read': read,
	'enable-read-callback': enable_read_callback,
	'disable-read-callback': disable_read_callback,
	'is-read-callback-enabled': is_read_callback_enabled,
	'set-configuration': set_configuration,
	'get-configuration': get_configuration,
	'set-break-condition': set_break_condition,
	'get-identity': get_identity
	}

	call_generic(ctx, 'rs232-bricklet', functions, argv)

def dispatch_rs232_bricklet(ctx, argv):
	prog_prefix = 'dispatch rs232-bricklet <uid>'

	def read(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read')

		args = parser.parse_args(argv)

		device_dispatch(ctx, RS232Bricklet, 8, args.execute, ['message', 'length'], [None, None])

	def error(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' error')

		args = parser.parse_args(argv)

		device_dispatch(ctx, RS232Bricklet, 9, args.execute, ['error'], [{1: 'error-overrun', 2: 'error-parity', 4: 'error-framing'}])

	callbacks = {
	'read': read,
	'error': error,
	'read-callback': read,
	'error-callback': error
	}

	dispatch_generic(ctx, 'rs232-bricklet', callbacks, argv)

class RS232V2Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 1; re[3] = 2; re[4] = 2; re[5] = 1; re[6] = 3; re[7] = 1; re[8] = 3; re[9] = 1; re[10] = 1; re[11] = 1; re[234] = 1; re[235] = 1; re[236] = 1; re[237] = 3; re[238] = 1; re[239] = 3; re[240] = 1; re[242] = 1; re[243] = 3; re[248] = 3; re[249] = 1; re[255] = 1
		cf = self.callback_formats
		cf[12] = 'H H 60c'; cf[13] = 'I I'
		hlc = self.high_level_callbacks
		hlc[-12] = [('stream_length', 'stream_chunk_offset', 'stream_chunk_data'), {'fixed_length': None, 'single_chunk': False}, None]

def call_rs232_v2_bricklet(ctx, argv):
	prog_prefix = 'call rs232-v2-bricklet <uid>'

	def write_low_level(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-low-level')

		parser.add_argument('message_length', type=convert_int, help='int', metavar='<message-length>')
		parser.add_argument('message_chunk_offset', type=convert_int, help='int', metavar='<message-chunk-offset>')
		parser.add_argument('message_chunk_data', type=create_array_converter(ctx, create_char_converter(ctx), '\0', 60), help=get_array_type_name(ctx, 'char', 60), metavar='<message-chunk-data>')

		args = parser.parse_args(argv)

		device_call(ctx, RS232V2Bricklet, 1, (args.message_length, args.message_chunk_offset, args.message_chunk_data), 'H H 60c', 'B', args.execute, False, ['message-chunk-written'], [None])

	def write(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write')

		parser.add_argument('message', type=create_array_converter(ctx, create_char_converter(ctx), None, -65535), help=get_array_type_name(ctx, 'char', -65535), metavar='<message>')

		args = parser.parse_args(argv)

		device_stream_call(ctx, RS232V2Bricklet, 1, 'in', (args.message,), ('stream_data',), ('stream_written',), ('stream_length', 'stream_chunk_offset', 'stream_chunk_data'), ('stream_chunk_written',), 'H H 60c', 'B', args.execute, False, ['message-written'], [None], '\0', 60, None, True, False, None)

	def read_low_level(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-low-level')

		parser.add_argument('length', type=convert_int, help='int', metavar='<length>')

		args = parser.parse_args(argv)

		device_call(ctx, RS232V2Bricklet, 2, (args.length,), 'H', 'H H 60c', args.execute, False, ['message-length', 'message-chunk-offset', 'message-chunk-data'], [None, None, None])

	def read(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read')

		parser.add_argument('length', type=convert_int, help='int', metavar='<length>')

		args = parser.parse_args(argv)

		device_stream_call(ctx, RS232V2Bricklet, 2, 'out', (args.length,), (None,), ('stream_data',), (None,), ('stream_length', 'stream_chunk_offset', 'stream_chunk_data'), 'H', 'H H 60c', args.execute, False, ['message'], [None], None, 60, None, False, False, None)

	def enable_read_callback(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' enable-read-callback')

		args = parser.parse_args(argv)

		device_call(ctx, RS232V2Bricklet, 3, (), '', '', None, args.expect_response, [], [])

	def disable_read_callback(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' disable-read-callback')

		args = parser.parse_args(argv)

		device_call(ctx, RS232V2Bricklet, 4, (), '', '', None, args.expect_response, [], [])

	def is_read_callback_enabled(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' is-read-callback-enabled')

		args = parser.parse_args(argv)

		device_call(ctx, RS232V2Bricklet, 5, (), '', '!', args.execute, False, ['enabled'], [None])

	def set_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-configuration')

		parser.add_argument('baudrate', type=convert_int, help='int', metavar='<baudrate>')
		parser.add_argument('parity', type=create_symbol_converter(ctx, convert_int, {'parity-even': 2, 'parity-none': 0, 'parity-odd': 1}), help='int (parity-none: 0, parity-odd: 1, parity-even: 2)', metavar='<parity>')
		parser.add_argument('stopbits', type=create_symbol_converter(ctx, convert_int, {'stopbits-1': 1, 'stopbits-2': 2}), help='int (stopbits-1: 1, stopbits-2: 2)', metavar='<stopbits>')
		parser.add_argument('wordlength', type=create_symbol_converter(ctx, convert_int, {'wordlength-7': 7, 'wordlength-6': 6, 'wordlength-5': 5, 'wordlength-8': 8}), help='int (wordlength-5: 5, wordlength-6: 6, wordlength-7: 7, wordlength-8: 8)', metavar='<wordlength>')
		parser.add_argument('flowcontrol', type=create_symbol_converter(ctx, convert_int, {'flowcontrol-off': 0, 'flowcontrol-software': 1, 'flowcontrol-hardware': 2}), help='int (flowcontrol-off: 0, flowcontrol-software: 1, flowcontrol-hardware: 2)', metavar='<flowcontrol>')

		args = parser.parse_args(argv)

		device_call(ctx, RS232V2Bricklet, 6, (args.baudrate, args.parity, args.stopbits, args.wordlength, args.flowcontrol), 'I B B B B', '', None, args.expect_response, [], [])

	def get_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, RS232V2Bricklet, 7, (), '', 'I B B B B', args.execute, False, ['baudrate', 'parity', 'stopbits', 'wordlength', 'flowcontrol'], [None, {0: 'parity-none', 1: 'parity-odd', 2: 'parity-even'}, {1: 'stopbits-1', 2: 'stopbits-2'}, {8: 'wordlength-8', 5: 'wordlength-5', 6: 'wordlength-6', 7: 'wordlength-7'}, {0: 'flowcontrol-off', 1: 'flowcontrol-software', 2: 'flowcontrol-hardware'}])

	def set_buffer_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-buffer-config')

		parser.add_argument('send_buffer_size', type=convert_int, help='int', metavar='<send-buffer-size>')
		parser.add_argument('receive_buffer_size', type=convert_int, help='int', metavar='<receive-buffer-size>')

		args = parser.parse_args(argv)

		device_call(ctx, RS232V2Bricklet, 8, (args.send_buffer_size, args.receive_buffer_size), 'H H', '', None, args.expect_response, [], [])

	def get_buffer_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-buffer-config')

		args = parser.parse_args(argv)

		device_call(ctx, RS232V2Bricklet, 9, (), '', 'H H', args.execute, False, ['send-buffer-size', 'receive-buffer-size'], [None, None])

	def get_buffer_status(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-buffer-status')

		args = parser.parse_args(argv)

		device_call(ctx, RS232V2Bricklet, 10, (), '', 'H H', args.execute, False, ['send-buffer-used', 'receive-buffer-used'], [None, None])

	def get_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, RS232V2Bricklet, 11, (), '', 'I I', args.execute, False, ['error-count-overrun', 'error-count-parity'], [None, None])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, RS232V2Bricklet, 234, (), '', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def set_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-bootloader-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'bootloader-mode-firmware-wait-for-reboot': 3, 'bootloader-mode-firmware': 1, 'bootloader-mode-firmware-wait-for-erase-and-reboot': 4, 'bootloader-mode-bootloader-wait-for-reboot': 2, 'bootloader-mode-bootloader': 0}), help='int (bootloader-mode-bootloader: 0, bootloader-mode-firmware: 1, bootloader-mode-bootloader-wait-for-reboot: 2, bootloader-mode-firmware-wait-for-reboot: 3, bootloader-mode-firmware-wait-for-erase-and-reboot: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, RS232V2Bricklet, 235, (args.mode,), 'B', 'B', args.execute, False, ['status'], [{0: 'bootloader-status-ok', 1: 'bootloader-status-invalid-mode', 2: 'bootloader-status-no-change', 3: 'bootloader-status-entry-function-not-present', 4: 'bootloader-status-device-identifier-incorrect', 5: 'bootloader-status-crc-mismatch'}])

	def get_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-bootloader-mode')

		args = parser.parse_args(argv)

		device_call(ctx, RS232V2Bricklet, 236, (), '', 'B', args.execute, False, ['mode'], [{0: 'bootloader-mode-bootloader', 1: 'bootloader-mode-firmware', 2: 'bootloader-mode-bootloader-wait-for-reboot', 3: 'bootloader-mode-firmware-wait-for-reboot', 4: 'bootloader-mode-firmware-wait-for-erase-and-reboot'}])

	def set_write_firmware_pointer(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-write-firmware-pointer')

		parser.add_argument('pointer', type=convert_int, help='int', metavar='<pointer>')

		args = parser.parse_args(argv)

		device_call(ctx, RS232V2Bricklet, 237, (args.pointer,), 'I', '', None, args.expect_response, [], [])

	def write_firmware(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-firmware')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, RS232V2Bricklet, 238, (args.data,), '64B', 'B', args.execute, False, ['status'], [None])

	def set_status_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'status-led-config-on': 1, 'status-led-config-show-heartbeat': 2, 'status-led-config-off': 0, 'status-led-config-show-status': 3}), help='int (status-led-config-off: 0, status-led-config-on: 1, status-led-config-show-heartbeat: 2, status-led-config-show-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, RS232V2Bricklet, 239, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_status_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, RS232V2Bricklet, 240, (), '', 'B', args.execute, False, ['config'], [{0: 'status-led-config-off', 1: 'status-led-config-on', 2: 'status-led-config-show-heartbeat', 3: 'status-led-config-show-status'}])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, RS232V2Bricklet, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, RS232V2Bricklet, 243, (), '', '', None, args.expect_response, [], [])

	def write_uid(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-uid')

		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')

		args = parser.parse_args(argv)

		device_call(ctx, RS232V2Bricklet, 248, (args.uid,), 'I', '', None, args.expect_response, [], [])

	def read_uid(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-uid')

		args = parser.parse_args(argv)

		device_call(ctx, RS232V2Bricklet, 249, (), '', 'I', args.execute, False, ['uid'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, RS232V2Bricklet, argv)

	functions = {
	'write-low-level': write_low_level,
	'write': write,
	'read-low-level': read_low_level,
	'read': read,
	'enable-read-callback': enable_read_callback,
	'disable-read-callback': disable_read_callback,
	'is-read-callback-enabled': is_read_callback_enabled,
	'set-configuration': set_configuration,
	'get-configuration': get_configuration,
	'set-buffer-config': set_buffer_config,
	'get-buffer-config': get_buffer_config,
	'get-buffer-status': get_buffer_status,
	'get-error-count': get_error_count,
	'get-spitfp-error-count': get_spitfp_error_count,
	'set-bootloader-mode': set_bootloader_mode,
	'get-bootloader-mode': get_bootloader_mode,
	'set-write-firmware-pointer': set_write_firmware_pointer,
	'write-firmware': write_firmware,
	'set-status-led-config': set_status_led_config,
	'get-status-led-config': get_status_led_config,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'write-uid': write_uid,
	'read-uid': read_uid,
	'get-identity': get_identity
	}

	call_generic(ctx, 'rs232-v2-bricklet', functions, argv)

def dispatch_rs232_v2_bricklet(ctx, argv):
	prog_prefix = 'dispatch rs232-v2-bricklet <uid>'

	def read_low_level(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-low-level')

		args = parser.parse_args(argv)

		device_dispatch(ctx, RS232V2Bricklet, 12, args.execute, ['message-length', 'message-chunk-offset', 'message-chunk-data'], [None, None, None])

	def read(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read')

		args = parser.parse_args(argv)

		device_dispatch(ctx, RS232V2Bricklet, -12, args.execute, ['message'], [None])

	def error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' error-count')

		args = parser.parse_args(argv)

		device_dispatch(ctx, RS232V2Bricklet, 13, args.execute, ['error-count-overrun', 'error-count-parity'], [None, None])

	callbacks = {
	'read-low-level': read_low_level,
	'read': read,
	'error-count': error_count
	}

	dispatch_generic(ctx, 'rs232-v2-bricklet', callbacks, argv)

class RS485Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 1; re[3] = 2; re[4] = 2; re[5] = 1; re[6] = 3; re[7] = 1; re[8] = 3; re[9] = 1; re[10] = 3; re[11] = 1; re[12] = 3; re[13] = 1; re[14] = 3; re[15] = 1; re[16] = 3; re[17] = 1; re[18] = 1; re[19] = 2; re[20] = 2; re[21] = 1; re[22] = 1; re[23] = 1; re[24] = 3; re[25] = 2; re[26] = 1; re[27] = 2; re[28] = 1; re[29] = 3; re[30] = 1; re[31] = 3; re[32] = 1; re[33] = 3; re[34] = 1; re[35] = 3; re[36] = 1; re[37] = 2; re[38] = 1; re[39] = 2; re[40] = 1; re[234] = 1; re[235] = 1; re[236] = 1; re[237] = 3; re[238] = 1; re[239] = 3; re[240] = 1; re[242] = 1; re[243] = 3; re[248] = 3; re[249] = 1; re[255] = 1
		cf = self.callback_formats
		cf[41] = 'H H 60c'; cf[42] = 'I I'; cf[43] = 'B I H'; cf[44] = 'B b H H 464!'; cf[45] = 'B I H'; cf[46] = 'B b H H 29H'; cf[47] = 'B I !'; cf[48] = 'B b'; cf[49] = 'B I H'; cf[50] = 'B b'; cf[51] = 'B I H H 440!'; cf[52] = 'B b'; cf[53] = 'B I H H 27H'; cf[54] = 'B b'; cf[55] = 'B I H'; cf[56] = 'B b H H 464!'; cf[57] = 'B I H'; cf[58] = 'B b H H 29H'
		hlc = self.high_level_callbacks
		hlc[-41] = [('stream_length', 'stream_chunk_offset', 'stream_chunk_data'), {'fixed_length': None, 'single_chunk': False}, None]; hlc[-44] = [(None, None, 'stream_length', 'stream_chunk_offset', 'stream_chunk_data'), {'fixed_length': None, 'single_chunk': False}, None]; hlc[-46] = [(None, None, 'stream_length', 'stream_chunk_offset', 'stream_chunk_data'), {'fixed_length': None, 'single_chunk': False}, None]; hlc[-51] = [(None, None, 'stream_length', 'stream_chunk_offset', 'stream_chunk_data'), {'fixed_length': None, 'single_chunk': False}, None]; hlc[-53] = [(None, None, 'stream_length', 'stream_chunk_offset', 'stream_chunk_data'), {'fixed_length': None, 'single_chunk': False}, None]; hlc[-56] = [(None, None, 'stream_length', 'stream_chunk_offset', 'stream_chunk_data'), {'fixed_length': None, 'single_chunk': False}, None]; hlc[-58] = [(None, None, 'stream_length', 'stream_chunk_offset', 'stream_chunk_data'), {'fixed_length': None, 'single_chunk': False}, None]

def call_rs485_bricklet(ctx, argv):
	prog_prefix = 'call rs485-bricklet <uid>'

	def write_low_level(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-low-level')

		parser.add_argument('message_length', type=convert_int, help='int', metavar='<message-length>')
		parser.add_argument('message_chunk_offset', type=convert_int, help='int', metavar='<message-chunk-offset>')
		parser.add_argument('message_chunk_data', type=create_array_converter(ctx, create_char_converter(ctx), '\0', 60), help=get_array_type_name(ctx, 'char', 60), metavar='<message-chunk-data>')

		args = parser.parse_args(argv)

		device_call(ctx, RS485Bricklet, 1, (args.message_length, args.message_chunk_offset, args.message_chunk_data), 'H H 60c', 'B', args.execute, False, ['message-chunk-written'], [None])

	def write(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write')

		parser.add_argument('message', type=create_array_converter(ctx, create_char_converter(ctx), None, -65535), help=get_array_type_name(ctx, 'char', -65535), metavar='<message>')

		args = parser.parse_args(argv)

		device_stream_call(ctx, RS485Bricklet, 1, 'in', (args.message,), ('stream_data',), ('stream_written',), ('stream_length', 'stream_chunk_offset', 'stream_chunk_data'), ('stream_chunk_written',), 'H H 60c', 'B', args.execute, False, ['message-written'], [None], '\0', 60, None, True, False, None)

	def read_low_level(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-low-level')

		parser.add_argument('length', type=convert_int, help='int', metavar='<length>')

		args = parser.parse_args(argv)

		device_call(ctx, RS485Bricklet, 2, (args.length,), 'H', 'H H 60c', args.execute, False, ['message-length', 'message-chunk-offset', 'message-chunk-data'], [None, None, None])

	def read(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read')

		parser.add_argument('length', type=convert_int, help='int', metavar='<length>')

		args = parser.parse_args(argv)

		device_stream_call(ctx, RS485Bricklet, 2, 'out', (args.length,), (None,), ('stream_data',), (None,), ('stream_length', 'stream_chunk_offset', 'stream_chunk_data'), 'H', 'H H 60c', args.execute, False, ['message'], [None], None, 60, None, False, False, None)

	def enable_read_callback(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' enable-read-callback')

		args = parser.parse_args(argv)

		device_call(ctx, RS485Bricklet, 3, (), '', '', None, args.expect_response, [], [])

	def disable_read_callback(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' disable-read-callback')

		args = parser.parse_args(argv)

		device_call(ctx, RS485Bricklet, 4, (), '', '', None, args.expect_response, [], [])

	def is_read_callback_enabled(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' is-read-callback-enabled')

		args = parser.parse_args(argv)

		device_call(ctx, RS485Bricklet, 5, (), '', '!', args.execute, False, ['enabled'], [None])

	def set_rs485_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-rs485-configuration')

		parser.add_argument('baudrate', type=convert_int, help='int', metavar='<baudrate>')
		parser.add_argument('parity', type=create_symbol_converter(ctx, convert_int, {'parity-even': 2, 'parity-none': 0, 'parity-odd': 1}), help='int (parity-none: 0, parity-odd: 1, parity-even: 2)', metavar='<parity>')
		parser.add_argument('stopbits', type=create_symbol_converter(ctx, convert_int, {'stopbits-1': 1, 'stopbits-2': 2}), help='int (stopbits-1: 1, stopbits-2: 2)', metavar='<stopbits>')
		parser.add_argument('wordlength', type=create_symbol_converter(ctx, convert_int, {'wordlength-7': 7, 'wordlength-6': 6, 'wordlength-5': 5, 'wordlength-8': 8}), help='int (wordlength-5: 5, wordlength-6: 6, wordlength-7: 7, wordlength-8: 8)', metavar='<wordlength>')
		parser.add_argument('duplex', type=create_symbol_converter(ctx, convert_int, {'duplex-full': 1, 'duplex-half': 0}), help='int (duplex-half: 0, duplex-full: 1)', metavar='<duplex>')

		args = parser.parse_args(argv)

		device_call(ctx, RS485Bricklet, 6, (args.baudrate, args.parity, args.stopbits, args.wordlength, args.duplex), 'I B B B B', '', None, args.expect_response, [], [])

	def get_rs485_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-rs485-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, RS485Bricklet, 7, (), '', 'I B B B B', args.execute, False, ['baudrate', 'parity', 'stopbits', 'wordlength', 'duplex'], [None, {0: 'parity-none', 1: 'parity-odd', 2: 'parity-even'}, {1: 'stopbits-1', 2: 'stopbits-2'}, {8: 'wordlength-8', 5: 'wordlength-5', 6: 'wordlength-6', 7: 'wordlength-7'}, {0: 'duplex-half', 1: 'duplex-full'}])

	def set_modbus_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-modbus-configuration')

		parser.add_argument('slave_address', type=convert_int, help='int', metavar='<slave-address>')
		parser.add_argument('master_request_timeout', type=convert_int, help='int', metavar='<master-request-timeout>')

		args = parser.parse_args(argv)

		device_call(ctx, RS485Bricklet, 8, (args.slave_address, args.master_request_timeout), 'B I', '', None, args.expect_response, [], [])

	def get_modbus_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-modbus-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, RS485Bricklet, 9, (), '', 'B I', args.execute, False, ['slave-address', 'master-request-timeout'], [None, None])

	def set_mode(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'mode-rs485': 0, 'mode-modbus-master-rtu': 1, 'mode-modbus-slave-rtu': 2}), help='int (mode-rs485: 0, mode-modbus-master-rtu: 1, mode-modbus-slave-rtu: 2)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, RS485Bricklet, 10, (args.mode,), 'B', '', None, args.expect_response, [], [])

	def get_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-mode')

		args = parser.parse_args(argv)

		device_call(ctx, RS485Bricklet, 11, (), '', 'B', args.execute, False, ['mode'], [{0: 'mode-rs485', 1: 'mode-modbus-master-rtu', 2: 'mode-modbus-slave-rtu'}])

	def set_communication_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-communication-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'communication-led-config-show-communication': 3, 'communication-led-config-show-heartbeat': 2, 'communication-led-config-on': 1, 'communication-led-config-off': 0}), help='int (communication-led-config-off: 0, communication-led-config-on: 1, communication-led-config-show-heartbeat: 2, communication-led-config-show-communication: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, RS485Bricklet, 12, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_communication_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-communication-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, RS485Bricklet, 13, (), '', 'B', args.execute, False, ['config'], [{0: 'communication-led-config-off', 1: 'communication-led-config-on', 2: 'communication-led-config-show-heartbeat', 3: 'communication-led-config-show-communication'}])

	def set_error_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-error-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'error-led-config-off': 0, 'error-led-config-on': 1, 'error-led-config-show-error': 3, 'error-led-config-show-heartbeat': 2}), help='int (error-led-config-off: 0, error-led-config-on: 1, error-led-config-show-heartbeat: 2, error-led-config-show-error: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, RS485Bricklet, 14, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_error_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-error-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, RS485Bricklet, 15, (), '', 'B', args.execute, False, ['config'], [{0: 'error-led-config-off', 1: 'error-led-config-on', 2: 'error-led-config-show-heartbeat', 3: 'error-led-config-show-error'}])

	def set_buffer_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-buffer-config')

		parser.add_argument('send_buffer_size', type=convert_int, help='int', metavar='<send-buffer-size>')
		parser.add_argument('receive_buffer_size', type=convert_int, help='int', metavar='<receive-buffer-size>')

		args = parser.parse_args(argv)

		device_call(ctx, RS485Bricklet, 16, (args.send_buffer_size, args.receive_buffer_size), 'H H', '', None, args.expect_response, [], [])

	def get_buffer_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-buffer-config')

		args = parser.parse_args(argv)

		device_call(ctx, RS485Bricklet, 17, (), '', 'H H', args.execute, False, ['send-buffer-size', 'receive-buffer-size'], [None, None])

	def get_buffer_status(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-buffer-status')

		args = parser.parse_args(argv)

		device_call(ctx, RS485Bricklet, 18, (), '', 'H H', args.execute, False, ['send-buffer-used', 'receive-buffer-used'], [None, None])

	def enable_error_count_callback(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' enable-error-count-callback')

		args = parser.parse_args(argv)

		device_call(ctx, RS485Bricklet, 19, (), '', '', None, args.expect_response, [], [])

	def disable_error_count_callback(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' disable-error-count-callback')

		args = parser.parse_args(argv)

		device_call(ctx, RS485Bricklet, 20, (), '', '', None, args.expect_response, [], [])

	def is_error_count_callback_enabled(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' is-error-count-callback-enabled')

		args = parser.parse_args(argv)

		device_call(ctx, RS485Bricklet, 21, (), '', '!', args.execute, False, ['enabled'], [None])

	def get_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, RS485Bricklet, 22, (), '', 'I I', args.execute, False, ['overrun-error-count', 'parity-error-count'], [None, None])

	def get_modbus_common_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-modbus-common-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, RS485Bricklet, 23, (), '', 'I I I I I I I', args.execute, False, ['timeout-error-count', 'checksum-error-count', 'frame-too-big-error-count', 'illegal-function-error-count', 'illegal-data-address-error-count', 'illegal-data-value-error-count', 'slave-device-failure-error-count'], [None, None, None, None, None, None, None])

	def modbus_slave_report_exception(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' modbus-slave-report-exception')

		parser.add_argument('request_id', type=convert_int, help='int', metavar='<request-id>')
		parser.add_argument('exception_code', type=create_symbol_converter(ctx, convert_int, {'exception-code-illegal-function': 1, 'exception-code-success': 0, 'exception-code-illegal-data-value': 3, 'exception-code-slave-device-busy': 6, 'exception-code-memory-parity-error': 8, 'exception-code-timeout': -1, 'exception-code-slave-device-failure': 4, 'exception-code-illegal-data-address': 2, 'exception-code-gateway-path-unavailable': 10, 'exception-code-acknowledge': 5, 'exception-code-gateway-target-device-failed-to-respond': 11}), help='int (exception-code-timeout: -1, exception-code-success: 0, exception-code-illegal-function: 1, exception-code-illegal-data-address: 2, exception-code-illegal-data-value: 3, exception-code-slave-device-failure: 4, exception-code-acknowledge: 5, exception-code-slave-device-busy: 6, exception-code-memory-parity-error: 8, exception-code-gateway-path-unavailable: 10, exception-code-gateway-target-device-failed-to-respond: 11)', metavar='<exception-code>')

		args = parser.parse_args(argv)

		device_call(ctx, RS485Bricklet, 24, (args.request_id, args.exception_code), 'B b', '', None, args.expect_response, [], [])

	def modbus_slave_answer_read_coils_request_low_level(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' modbus-slave-answer-read-coils-request-low-level')

		parser.add_argument('request_id', type=convert_int, help='int', metavar='<request-id>')
		parser.add_argument('coils_length', type=convert_int, help='int', metavar='<coils-length>')
		parser.add_argument('coils_chunk_offset', type=convert_int, help='int', metavar='<coils-chunk-offset>')
		parser.add_argument('coils_chunk_data', type=create_array_converter(ctx, convert_bool, 'false', 472), help=get_array_type_name(ctx, 'bool', 472), metavar='<coils-chunk-data>')

		args = parser.parse_args(argv)

		device_call(ctx, RS485Bricklet, 25, (args.request_id, args.coils_length, args.coils_chunk_offset, args.coils_chunk_data), 'B H H 472!', '', None, args.expect_response, [], [])

	def modbus_slave_answer_read_coils_request(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' modbus-slave-answer-read-coils-request')

		parser.add_argument('request_id', type=convert_int, help='int', metavar='<request-id>')
		parser.add_argument('coils', type=create_array_converter(ctx, convert_bool, None, -65535), help=get_array_type_name(ctx, 'bool', -65535), metavar='<coils>')

		args = parser.parse_args(argv)

		device_stream_call(ctx, RS485Bricklet, 25, 'in', (args.request_id, args.coils), (None, 'stream_data'), (), (None, 'stream_length', 'stream_chunk_offset', 'stream_chunk_data'), (), 'B H H 472!', '', None, args.expect_response, [], [], 'false', 472, None, False, False, None)

	def modbus_master_read_coils(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' modbus-master-read-coils')

		parser.add_argument('slave_address', type=convert_int, help='int', metavar='<slave-address>')
		parser.add_argument('starting_address', type=convert_int, help='int', metavar='<starting-address>')
		parser.add_argument('count', type=convert_int, help='int', metavar='<count>')

		args = parser.parse_args(argv)

		device_call(ctx, RS485Bricklet, 26, (args.slave_address, args.starting_address, args.count), 'B I H', 'B', args.execute, False, ['request-id'], [None])

	def modbus_slave_answer_read_holding_registers_request_low_level(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' modbus-slave-answer-read-holding-registers-request-low-level')

		parser.add_argument('request_id', type=convert_int, help='int', metavar='<request-id>')
		parser.add_argument('holding_registers_length', type=convert_int, help='int', metavar='<holding-registers-length>')
		parser.add_argument('holding_registers_chunk_offset', type=convert_int, help='int', metavar='<holding-registers-chunk-offset>')
		parser.add_argument('holding_registers_chunk_data', type=create_array_converter(ctx, convert_int, '0', 29), help=get_array_type_name(ctx, 'int', 29), metavar='<holding-registers-chunk-data>')

		args = parser.parse_args(argv)

		device_call(ctx, RS485Bricklet, 27, (args.request_id, args.holding_registers_length, args.holding_registers_chunk_offset, args.holding_registers_chunk_data), 'B H H 29H', '', None, args.expect_response, [], [])

	def modbus_slave_answer_read_holding_registers_request(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' modbus-slave-answer-read-holding-registers-request')

		parser.add_argument('request_id', type=convert_int, help='int', metavar='<request-id>')
		parser.add_argument('holding_registers', type=create_array_converter(ctx, convert_int, None, -65535), help=get_array_type_name(ctx, 'int', -65535), metavar='<holding-registers>')

		args = parser.parse_args(argv)

		device_stream_call(ctx, RS485Bricklet, 27, 'in', (args.request_id, args.holding_registers), (None, 'stream_data'), (), (None, 'stream_length', 'stream_chunk_offset', 'stream_chunk_data'), (), 'B H H 29H', '', None, args.expect_response, [], [], '0', 29, None, False, False, None)

	def modbus_master_read_holding_registers(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' modbus-master-read-holding-registers')

		parser.add_argument('slave_address', type=convert_int, help='int', metavar='<slave-address>')
		parser.add_argument('starting_address', type=convert_int, help='int', metavar='<starting-address>')
		parser.add_argument('count', type=convert_int, help='int', metavar='<count>')

		args = parser.parse_args(argv)

		device_call(ctx, RS485Bricklet, 28, (args.slave_address, args.starting_address, args.count), 'B I H', 'B', args.execute, False, ['request-id'], [None])

	def modbus_slave_answer_write_single_coil_request(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' modbus-slave-answer-write-single-coil-request')

		parser.add_argument('request_id', type=convert_int, help='int', metavar='<request-id>')

		args = parser.parse_args(argv)

		device_call(ctx, RS485Bricklet, 29, (args.request_id,), 'B', '', None, args.expect_response, [], [])

	def modbus_master_write_single_coil(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' modbus-master-write-single-coil')

		parser.add_argument('slave_address', type=convert_int, help='int', metavar='<slave-address>')
		parser.add_argument('coil_address', type=convert_int, help='int', metavar='<coil-address>')
		parser.add_argument('coil_value', type=convert_bool, help='bool', metavar='<coil-value>')

		args = parser.parse_args(argv)

		device_call(ctx, RS485Bricklet, 30, (args.slave_address, args.coil_address, args.coil_value), 'B I !', 'B', args.execute, False, ['request-id'], [None])

	def modbus_slave_answer_write_single_register_request(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' modbus-slave-answer-write-single-register-request')

		parser.add_argument('request_id', type=convert_int, help='int', metavar='<request-id>')

		args = parser.parse_args(argv)

		device_call(ctx, RS485Bricklet, 31, (args.request_id,), 'B', '', None, args.expect_response, [], [])

	def modbus_master_write_single_register(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' modbus-master-write-single-register')

		parser.add_argument('slave_address', type=convert_int, help='int', metavar='<slave-address>')
		parser.add_argument('register_address', type=convert_int, help='int', metavar='<register-address>')
		parser.add_argument('register_value', type=convert_int, help='int', metavar='<register-value>')

		args = parser.parse_args(argv)

		device_call(ctx, RS485Bricklet, 32, (args.slave_address, args.register_address, args.register_value), 'B I H', 'B', args.execute, False, ['request-id'], [None])

	def modbus_slave_answer_write_multiple_coils_request(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' modbus-slave-answer-write-multiple-coils-request')

		parser.add_argument('request_id', type=convert_int, help='int', metavar='<request-id>')

		args = parser.parse_args(argv)

		device_call(ctx, RS485Bricklet, 33, (args.request_id,), 'B', '', None, args.expect_response, [], [])

	def modbus_master_write_multiple_coils_low_level(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' modbus-master-write-multiple-coils-low-level')

		parser.add_argument('slave_address', type=convert_int, help='int', metavar='<slave-address>')
		parser.add_argument('starting_address', type=convert_int, help='int', metavar='<starting-address>')
		parser.add_argument('coils_length', type=convert_int, help='int', metavar='<coils-length>')
		parser.add_argument('coils_chunk_offset', type=convert_int, help='int', metavar='<coils-chunk-offset>')
		parser.add_argument('coils_chunk_data', type=create_array_converter(ctx, convert_bool, 'false', 440), help=get_array_type_name(ctx, 'bool', 440), metavar='<coils-chunk-data>')

		args = parser.parse_args(argv)

		device_call(ctx, RS485Bricklet, 34, (args.slave_address, args.starting_address, args.coils_length, args.coils_chunk_offset, args.coils_chunk_data), 'B I H H 440!', 'B', args.execute, False, ['request-id'], [None])

	def modbus_master_write_multiple_coils(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' modbus-master-write-multiple-coils')

		parser.add_argument('slave_address', type=convert_int, help='int', metavar='<slave-address>')
		parser.add_argument('starting_address', type=convert_int, help='int', metavar='<starting-address>')
		parser.add_argument('coils', type=create_array_converter(ctx, convert_bool, None, -65535), help=get_array_type_name(ctx, 'bool', -65535), metavar='<coils>')

		args = parser.parse_args(argv)

		device_stream_call(ctx, RS485Bricklet, 34, 'in', (args.slave_address, args.starting_address, args.coils), (None, None, 'stream_data'), (None,), (None, None, 'stream_length', 'stream_chunk_offset', 'stream_chunk_data'), (None,), 'B I H H 440!', 'B', args.execute, False, ['request-id'], [None], 'false', 440, None, False, False, None)

	def modbus_slave_answer_write_multiple_registers_request(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' modbus-slave-answer-write-multiple-registers-request')

		parser.add_argument('request_id', type=convert_int, help='int', metavar='<request-id>')

		args = parser.parse_args(argv)

		device_call(ctx, RS485Bricklet, 35, (args.request_id,), 'B', '', None, args.expect_response, [], [])

	def modbus_master_write_multiple_registers_low_level(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' modbus-master-write-multiple-registers-low-level')

		parser.add_argument('slave_address', type=convert_int, help='int', metavar='<slave-address>')
		parser.add_argument('starting_address', type=convert_int, help='int', metavar='<starting-address>')
		parser.add_argument('registers_length', type=convert_int, help='int', metavar='<registers-length>')
		parser.add_argument('registers_chunk_offset', type=convert_int, help='int', metavar='<registers-chunk-offset>')
		parser.add_argument('registers_chunk_data', type=create_array_converter(ctx, convert_int, '0', 27), help=get_array_type_name(ctx, 'int', 27), metavar='<registers-chunk-data>')

		args = parser.parse_args(argv)

		device_call(ctx, RS485Bricklet, 36, (args.slave_address, args.starting_address, args.registers_length, args.registers_chunk_offset, args.registers_chunk_data), 'B I H H 27H', 'B', args.execute, False, ['request-id'], [None])

	def modbus_master_write_multiple_registers(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' modbus-master-write-multiple-registers')

		parser.add_argument('slave_address', type=convert_int, help='int', metavar='<slave-address>')
		parser.add_argument('starting_address', type=convert_int, help='int', metavar='<starting-address>')
		parser.add_argument('registers', type=create_array_converter(ctx, convert_int, None, -65535), help=get_array_type_name(ctx, 'int', -65535), metavar='<registers>')

		args = parser.parse_args(argv)

		device_stream_call(ctx, RS485Bricklet, 36, 'in', (args.slave_address, args.starting_address, args.registers), (None, None, 'stream_data'), (None,), (None, None, 'stream_length', 'stream_chunk_offset', 'stream_chunk_data'), (None,), 'B I H H 27H', 'B', args.execute, False, ['request-id'], [None], '0', 27, None, False, False, None)

	def modbus_slave_answer_read_discrete_inputs_request_low_level(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' modbus-slave-answer-read-discrete-inputs-request-low-level')

		parser.add_argument('request_id', type=convert_int, help='int', metavar='<request-id>')
		parser.add_argument('discrete_inputs_length', type=convert_int, help='int', metavar='<discrete-inputs-length>')
		parser.add_argument('discrete_inputs_chunk_offset', type=convert_int, help='int', metavar='<discrete-inputs-chunk-offset>')
		parser.add_argument('discrete_inputs_chunk_data', type=create_array_converter(ctx, convert_bool, 'false', 472), help=get_array_type_name(ctx, 'bool', 472), metavar='<discrete-inputs-chunk-data>')

		args = parser.parse_args(argv)

		device_call(ctx, RS485Bricklet, 37, (args.request_id, args.discrete_inputs_length, args.discrete_inputs_chunk_offset, args.discrete_inputs_chunk_data), 'B H H 472!', '', None, args.expect_response, [], [])

	def modbus_slave_answer_read_discrete_inputs_request(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' modbus-slave-answer-read-discrete-inputs-request')

		parser.add_argument('request_id', type=convert_int, help='int', metavar='<request-id>')
		parser.add_argument('discrete_inputs', type=create_array_converter(ctx, convert_bool, None, -65535), help=get_array_type_name(ctx, 'bool', -65535), metavar='<discrete-inputs>')

		args = parser.parse_args(argv)

		device_stream_call(ctx, RS485Bricklet, 37, 'in', (args.request_id, args.discrete_inputs), (None, 'stream_data'), (), (None, 'stream_length', 'stream_chunk_offset', 'stream_chunk_data'), (), 'B H H 472!', '', None, args.expect_response, [], [], 'false', 472, None, False, False, None)

	def modbus_master_read_discrete_inputs(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' modbus-master-read-discrete-inputs')

		parser.add_argument('slave_address', type=convert_int, help='int', metavar='<slave-address>')
		parser.add_argument('starting_address', type=convert_int, help='int', metavar='<starting-address>')
		parser.add_argument('count', type=convert_int, help='int', metavar='<count>')

		args = parser.parse_args(argv)

		device_call(ctx, RS485Bricklet, 38, (args.slave_address, args.starting_address, args.count), 'B I H', 'B', args.execute, False, ['request-id'], [None])

	def modbus_slave_answer_read_input_registers_request_low_level(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' modbus-slave-answer-read-input-registers-request-low-level')

		parser.add_argument('request_id', type=convert_int, help='int', metavar='<request-id>')
		parser.add_argument('input_registers_length', type=convert_int, help='int', metavar='<input-registers-length>')
		parser.add_argument('input_registers_chunk_offset', type=convert_int, help='int', metavar='<input-registers-chunk-offset>')
		parser.add_argument('input_registers_chunk_data', type=create_array_converter(ctx, convert_int, '0', 29), help=get_array_type_name(ctx, 'int', 29), metavar='<input-registers-chunk-data>')

		args = parser.parse_args(argv)

		device_call(ctx, RS485Bricklet, 39, (args.request_id, args.input_registers_length, args.input_registers_chunk_offset, args.input_registers_chunk_data), 'B H H 29H', '', None, args.expect_response, [], [])

	def modbus_slave_answer_read_input_registers_request(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' modbus-slave-answer-read-input-registers-request')

		parser.add_argument('request_id', type=convert_int, help='int', metavar='<request-id>')
		parser.add_argument('input_registers', type=create_array_converter(ctx, convert_int, None, -65535), help=get_array_type_name(ctx, 'int', -65535), metavar='<input-registers>')

		args = parser.parse_args(argv)

		device_stream_call(ctx, RS485Bricklet, 39, 'in', (args.request_id, args.input_registers), (None, 'stream_data'), (), (None, 'stream_length', 'stream_chunk_offset', 'stream_chunk_data'), (), 'B H H 29H', '', None, args.expect_response, [], [], '0', 29, None, False, False, None)

	def modbus_master_read_input_registers(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' modbus-master-read-input-registers')

		parser.add_argument('slave_address', type=convert_int, help='int', metavar='<slave-address>')
		parser.add_argument('starting_address', type=convert_int, help='int', metavar='<starting-address>')
		parser.add_argument('count', type=convert_int, help='int', metavar='<count>')

		args = parser.parse_args(argv)

		device_call(ctx, RS485Bricklet, 40, (args.slave_address, args.starting_address, args.count), 'B I H', 'B', args.execute, False, ['request-id'], [None])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, RS485Bricklet, 234, (), '', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def set_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-bootloader-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'bootloader-mode-firmware-wait-for-reboot': 3, 'bootloader-mode-firmware': 1, 'bootloader-mode-firmware-wait-for-erase-and-reboot': 4, 'bootloader-mode-bootloader-wait-for-reboot': 2, 'bootloader-mode-bootloader': 0}), help='int (bootloader-mode-bootloader: 0, bootloader-mode-firmware: 1, bootloader-mode-bootloader-wait-for-reboot: 2, bootloader-mode-firmware-wait-for-reboot: 3, bootloader-mode-firmware-wait-for-erase-and-reboot: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, RS485Bricklet, 235, (args.mode,), 'B', 'B', args.execute, False, ['status'], [{0: 'bootloader-status-ok', 1: 'bootloader-status-invalid-mode', 2: 'bootloader-status-no-change', 3: 'bootloader-status-entry-function-not-present', 4: 'bootloader-status-device-identifier-incorrect', 5: 'bootloader-status-crc-mismatch'}])

	def get_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-bootloader-mode')

		args = parser.parse_args(argv)

		device_call(ctx, RS485Bricklet, 236, (), '', 'B', args.execute, False, ['mode'], [{0: 'bootloader-mode-bootloader', 1: 'bootloader-mode-firmware', 2: 'bootloader-mode-bootloader-wait-for-reboot', 3: 'bootloader-mode-firmware-wait-for-reboot', 4: 'bootloader-mode-firmware-wait-for-erase-and-reboot'}])

	def set_write_firmware_pointer(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-write-firmware-pointer')

		parser.add_argument('pointer', type=convert_int, help='int', metavar='<pointer>')

		args = parser.parse_args(argv)

		device_call(ctx, RS485Bricklet, 237, (args.pointer,), 'I', '', None, args.expect_response, [], [])

	def write_firmware(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-firmware')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, RS485Bricklet, 238, (args.data,), '64B', 'B', args.execute, False, ['status'], [None])

	def set_status_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'status-led-config-on': 1, 'status-led-config-show-heartbeat': 2, 'status-led-config-off': 0, 'status-led-config-show-status': 3}), help='int (status-led-config-off: 0, status-led-config-on: 1, status-led-config-show-heartbeat: 2, status-led-config-show-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, RS485Bricklet, 239, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_status_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, RS485Bricklet, 240, (), '', 'B', args.execute, False, ['config'], [{0: 'status-led-config-off', 1: 'status-led-config-on', 2: 'status-led-config-show-heartbeat', 3: 'status-led-config-show-status'}])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, RS485Bricklet, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, RS485Bricklet, 243, (), '', '', None, args.expect_response, [], [])

	def write_uid(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-uid')

		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')

		args = parser.parse_args(argv)

		device_call(ctx, RS485Bricklet, 248, (args.uid,), 'I', '', None, args.expect_response, [], [])

	def read_uid(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-uid')

		args = parser.parse_args(argv)

		device_call(ctx, RS485Bricklet, 249, (), '', 'I', args.execute, False, ['uid'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, RS485Bricklet, argv)

	functions = {
	'write-low-level': write_low_level,
	'write': write,
	'read-low-level': read_low_level,
	'read': read,
	'enable-read-callback': enable_read_callback,
	'disable-read-callback': disable_read_callback,
	'is-read-callback-enabled': is_read_callback_enabled,
	'set-rs485-configuration': set_rs485_configuration,
	'get-rs485-configuration': get_rs485_configuration,
	'set-modbus-configuration': set_modbus_configuration,
	'get-modbus-configuration': get_modbus_configuration,
	'set-mode': set_mode,
	'get-mode': get_mode,
	'set-communication-led-config': set_communication_led_config,
	'get-communication-led-config': get_communication_led_config,
	'set-error-led-config': set_error_led_config,
	'get-error-led-config': get_error_led_config,
	'set-buffer-config': set_buffer_config,
	'get-buffer-config': get_buffer_config,
	'get-buffer-status': get_buffer_status,
	'enable-error-count-callback': enable_error_count_callback,
	'disable-error-count-callback': disable_error_count_callback,
	'is-error-count-callback-enabled': is_error_count_callback_enabled,
	'get-error-count': get_error_count,
	'get-modbus-common-error-count': get_modbus_common_error_count,
	'modbus-slave-report-exception': modbus_slave_report_exception,
	'modbus-slave-answer-read-coils-request-low-level': modbus_slave_answer_read_coils_request_low_level,
	'modbus-slave-answer-read-coils-request': modbus_slave_answer_read_coils_request,
	'modbus-master-read-coils': modbus_master_read_coils,
	'modbus-slave-answer-read-holding-registers-request-low-level': modbus_slave_answer_read_holding_registers_request_low_level,
	'modbus-slave-answer-read-holding-registers-request': modbus_slave_answer_read_holding_registers_request,
	'modbus-master-read-holding-registers': modbus_master_read_holding_registers,
	'modbus-slave-answer-write-single-coil-request': modbus_slave_answer_write_single_coil_request,
	'modbus-master-write-single-coil': modbus_master_write_single_coil,
	'modbus-slave-answer-write-single-register-request': modbus_slave_answer_write_single_register_request,
	'modbus-master-write-single-register': modbus_master_write_single_register,
	'modbus-slave-answer-write-multiple-coils-request': modbus_slave_answer_write_multiple_coils_request,
	'modbus-master-write-multiple-coils-low-level': modbus_master_write_multiple_coils_low_level,
	'modbus-master-write-multiple-coils': modbus_master_write_multiple_coils,
	'modbus-slave-answer-write-multiple-registers-request': modbus_slave_answer_write_multiple_registers_request,
	'modbus-master-write-multiple-registers-low-level': modbus_master_write_multiple_registers_low_level,
	'modbus-master-write-multiple-registers': modbus_master_write_multiple_registers,
	'modbus-slave-answer-read-discrete-inputs-request-low-level': modbus_slave_answer_read_discrete_inputs_request_low_level,
	'modbus-slave-answer-read-discrete-inputs-request': modbus_slave_answer_read_discrete_inputs_request,
	'modbus-master-read-discrete-inputs': modbus_master_read_discrete_inputs,
	'modbus-slave-answer-read-input-registers-request-low-level': modbus_slave_answer_read_input_registers_request_low_level,
	'modbus-slave-answer-read-input-registers-request': modbus_slave_answer_read_input_registers_request,
	'modbus-master-read-input-registers': modbus_master_read_input_registers,
	'get-spitfp-error-count': get_spitfp_error_count,
	'set-bootloader-mode': set_bootloader_mode,
	'get-bootloader-mode': get_bootloader_mode,
	'set-write-firmware-pointer': set_write_firmware_pointer,
	'write-firmware': write_firmware,
	'set-status-led-config': set_status_led_config,
	'get-status-led-config': get_status_led_config,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'write-uid': write_uid,
	'read-uid': read_uid,
	'get-identity': get_identity
	}

	call_generic(ctx, 'rs485-bricklet', functions, argv)

def dispatch_rs485_bricklet(ctx, argv):
	prog_prefix = 'dispatch rs485-bricklet <uid>'

	def read_low_level(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-low-level')

		args = parser.parse_args(argv)

		device_dispatch(ctx, RS485Bricklet, 41, args.execute, ['message-length', 'message-chunk-offset', 'message-chunk-data'], [None, None, None])

	def read(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read')

		args = parser.parse_args(argv)

		device_dispatch(ctx, RS485Bricklet, -41, args.execute, ['message'], [None])

	def error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' error-count')

		args = parser.parse_args(argv)

		device_dispatch(ctx, RS485Bricklet, 42, args.execute, ['overrun-error-count', 'parity-error-count'], [None, None])

	def modbus_slave_read_coils_request(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' modbus-slave-read-coils-request')

		args = parser.parse_args(argv)

		device_dispatch(ctx, RS485Bricklet, 43, args.execute, ['request-id', 'starting-address', 'count'], [None, None, None])

	def modbus_master_read_coils_response_low_level(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' modbus-master-read-coils-response-low-level')

		args = parser.parse_args(argv)

		device_dispatch(ctx, RS485Bricklet, 44, args.execute, ['request-id', 'exception-code', 'coils-length', 'coils-chunk-offset', 'coils-chunk-data'], [None, {0: 'exception-code-success', 1: 'exception-code-illegal-function', 2: 'exception-code-illegal-data-address', 3: 'exception-code-illegal-data-value', 4: 'exception-code-slave-device-failure', 5: 'exception-code-acknowledge', 6: 'exception-code-slave-device-busy', 8: 'exception-code-memory-parity-error', 10: 'exception-code-gateway-path-unavailable', 11: 'exception-code-gateway-target-device-failed-to-respond', -1: 'exception-code-timeout'}, None, None, None])

	def modbus_master_read_coils_response(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' modbus-master-read-coils-response')

		args = parser.parse_args(argv)

		device_dispatch(ctx, RS485Bricklet, -44, args.execute, ['request-id', 'exception-code', 'coils'], [None, {0: 'exception-code-success', 1: 'exception-code-illegal-function', 2: 'exception-code-illegal-data-address', 3: 'exception-code-illegal-data-value', 4: 'exception-code-slave-device-failure', 5: 'exception-code-acknowledge', 6: 'exception-code-slave-device-busy', 8: 'exception-code-memory-parity-error', 10: 'exception-code-gateway-path-unavailable', 11: 'exception-code-gateway-target-device-failed-to-respond', -1: 'exception-code-timeout'}, None])

	def modbus_slave_read_holding_registers_request(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' modbus-slave-read-holding-registers-request')

		args = parser.parse_args(argv)

		device_dispatch(ctx, RS485Bricklet, 45, args.execute, ['request-id', 'starting-address', 'count'], [None, None, None])

	def modbus_master_read_holding_registers_response_low_level(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' modbus-master-read-holding-registers-response-low-level')

		args = parser.parse_args(argv)

		device_dispatch(ctx, RS485Bricklet, 46, args.execute, ['request-id', 'exception-code', 'holding-registers-length', 'holding-registers-chunk-offset', 'holding-registers-chunk-data'], [None, {0: 'exception-code-success', 1: 'exception-code-illegal-function', 2: 'exception-code-illegal-data-address', 3: 'exception-code-illegal-data-value', 4: 'exception-code-slave-device-failure', 5: 'exception-code-acknowledge', 6: 'exception-code-slave-device-busy', 8: 'exception-code-memory-parity-error', 10: 'exception-code-gateway-path-unavailable', 11: 'exception-code-gateway-target-device-failed-to-respond', -1: 'exception-code-timeout'}, None, None, None])

	def modbus_master_read_holding_registers_response(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' modbus-master-read-holding-registers-response')

		args = parser.parse_args(argv)

		device_dispatch(ctx, RS485Bricklet, -46, args.execute, ['request-id', 'exception-code', 'holding-registers'], [None, {0: 'exception-code-success', 1: 'exception-code-illegal-function', 2: 'exception-code-illegal-data-address', 3: 'exception-code-illegal-data-value', 4: 'exception-code-slave-device-failure', 5: 'exception-code-acknowledge', 6: 'exception-code-slave-device-busy', 8: 'exception-code-memory-parity-error', 10: 'exception-code-gateway-path-unavailable', 11: 'exception-code-gateway-target-device-failed-to-respond', -1: 'exception-code-timeout'}, None])

	def modbus_slave_write_single_coil_request(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' modbus-slave-write-single-coil-request')

		args = parser.parse_args(argv)

		device_dispatch(ctx, RS485Bricklet, 47, args.execute, ['request-id', 'coil-address', 'coil-value'], [None, None, None])

	def modbus_master_write_single_coil_response(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' modbus-master-write-single-coil-response')

		args = parser.parse_args(argv)

		device_dispatch(ctx, RS485Bricklet, 48, args.execute, ['request-id', 'exception-code'], [None, {0: 'exception-code-success', 1: 'exception-code-illegal-function', 2: 'exception-code-illegal-data-address', 3: 'exception-code-illegal-data-value', 4: 'exception-code-slave-device-failure', 5: 'exception-code-acknowledge', 6: 'exception-code-slave-device-busy', 8: 'exception-code-memory-parity-error', 10: 'exception-code-gateway-path-unavailable', 11: 'exception-code-gateway-target-device-failed-to-respond', -1: 'exception-code-timeout'}])

	def modbus_slave_write_single_register_request(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' modbus-slave-write-single-register-request')

		args = parser.parse_args(argv)

		device_dispatch(ctx, RS485Bricklet, 49, args.execute, ['request-id', 'register-address', 'register-value'], [None, None, None])

	def modbus_master_write_single_register_response(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' modbus-master-write-single-register-response')

		args = parser.parse_args(argv)

		device_dispatch(ctx, RS485Bricklet, 50, args.execute, ['request-id', 'exception-code'], [None, {0: 'exception-code-success', 1: 'exception-code-illegal-function', 2: 'exception-code-illegal-data-address', 3: 'exception-code-illegal-data-value', 4: 'exception-code-slave-device-failure', 5: 'exception-code-acknowledge', 6: 'exception-code-slave-device-busy', 8: 'exception-code-memory-parity-error', 10: 'exception-code-gateway-path-unavailable', 11: 'exception-code-gateway-target-device-failed-to-respond', -1: 'exception-code-timeout'}])

	def modbus_slave_write_multiple_coils_request_low_level(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' modbus-slave-write-multiple-coils-request-low-level')

		args = parser.parse_args(argv)

		device_dispatch(ctx, RS485Bricklet, 51, args.execute, ['request-id', 'starting-address', 'coils-length', 'coils-chunk-offset', 'coils-chunk-data'], [None, None, None, None, None])

	def modbus_slave_write_multiple_coils_request(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' modbus-slave-write-multiple-coils-request')

		args = parser.parse_args(argv)

		device_dispatch(ctx, RS485Bricklet, -51, args.execute, ['request-id', 'starting-address', 'coils'], [None, None, None])

	def modbus_master_write_multiple_coils_response(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' modbus-master-write-multiple-coils-response')

		args = parser.parse_args(argv)

		device_dispatch(ctx, RS485Bricklet, 52, args.execute, ['request-id', 'exception-code'], [None, {0: 'exception-code-success', 1: 'exception-code-illegal-function', 2: 'exception-code-illegal-data-address', 3: 'exception-code-illegal-data-value', 4: 'exception-code-slave-device-failure', 5: 'exception-code-acknowledge', 6: 'exception-code-slave-device-busy', 8: 'exception-code-memory-parity-error', 10: 'exception-code-gateway-path-unavailable', 11: 'exception-code-gateway-target-device-failed-to-respond', -1: 'exception-code-timeout'}])

	def modbus_slave_write_multiple_registers_request_low_level(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' modbus-slave-write-multiple-registers-request-low-level')

		args = parser.parse_args(argv)

		device_dispatch(ctx, RS485Bricklet, 53, args.execute, ['request-id', 'starting-address', 'registers-length', 'registers-chunk-offset', 'registers-chunk-data'], [None, None, None, None, None])

	def modbus_slave_write_multiple_registers_request(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' modbus-slave-write-multiple-registers-request')

		args = parser.parse_args(argv)

		device_dispatch(ctx, RS485Bricklet, -53, args.execute, ['request-id', 'starting-address', 'registers'], [None, None, None])

	def modbus_master_write_multiple_registers_response(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' modbus-master-write-multiple-registers-response')

		args = parser.parse_args(argv)

		device_dispatch(ctx, RS485Bricklet, 54, args.execute, ['request-id', 'exception-code'], [None, {0: 'exception-code-success', 1: 'exception-code-illegal-function', 2: 'exception-code-illegal-data-address', 3: 'exception-code-illegal-data-value', 4: 'exception-code-slave-device-failure', 5: 'exception-code-acknowledge', 6: 'exception-code-slave-device-busy', 8: 'exception-code-memory-parity-error', 10: 'exception-code-gateway-path-unavailable', 11: 'exception-code-gateway-target-device-failed-to-respond', -1: 'exception-code-timeout'}])

	def modbus_slave_read_discrete_inputs_request(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' modbus-slave-read-discrete-inputs-request')

		args = parser.parse_args(argv)

		device_dispatch(ctx, RS485Bricklet, 55, args.execute, ['request-id', 'starting-address', 'count'], [None, None, None])

	def modbus_master_read_discrete_inputs_response_low_level(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' modbus-master-read-discrete-inputs-response-low-level')

		args = parser.parse_args(argv)

		device_dispatch(ctx, RS485Bricklet, 56, args.execute, ['request-id', 'exception-code', 'discrete-inputs-length', 'discrete-inputs-chunk-offset', 'discrete-inputs-chunk-data'], [None, {0: 'exception-code-success', 1: 'exception-code-illegal-function', 2: 'exception-code-illegal-data-address', 3: 'exception-code-illegal-data-value', 4: 'exception-code-slave-device-failure', 5: 'exception-code-acknowledge', 6: 'exception-code-slave-device-busy', 8: 'exception-code-memory-parity-error', 10: 'exception-code-gateway-path-unavailable', 11: 'exception-code-gateway-target-device-failed-to-respond', -1: 'exception-code-timeout'}, None, None, None])

	def modbus_master_read_discrete_inputs_response(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' modbus-master-read-discrete-inputs-response')

		args = parser.parse_args(argv)

		device_dispatch(ctx, RS485Bricklet, -56, args.execute, ['request-id', 'exception-code', 'discrete-inputs'], [None, {0: 'exception-code-success', 1: 'exception-code-illegal-function', 2: 'exception-code-illegal-data-address', 3: 'exception-code-illegal-data-value', 4: 'exception-code-slave-device-failure', 5: 'exception-code-acknowledge', 6: 'exception-code-slave-device-busy', 8: 'exception-code-memory-parity-error', 10: 'exception-code-gateway-path-unavailable', 11: 'exception-code-gateway-target-device-failed-to-respond', -1: 'exception-code-timeout'}, None])

	def modbus_slave_read_input_registers_request(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' modbus-slave-read-input-registers-request')

		args = parser.parse_args(argv)

		device_dispatch(ctx, RS485Bricklet, 57, args.execute, ['request-id', 'starting-address', 'count'], [None, None, None])

	def modbus_master_read_input_registers_response_low_level(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' modbus-master-read-input-registers-response-low-level')

		args = parser.parse_args(argv)

		device_dispatch(ctx, RS485Bricklet, 58, args.execute, ['request-id', 'exception-code', 'input-registers-length', 'input-registers-chunk-offset', 'input-registers-chunk-data'], [None, {0: 'exception-code-success', 1: 'exception-code-illegal-function', 2: 'exception-code-illegal-data-address', 3: 'exception-code-illegal-data-value', 4: 'exception-code-slave-device-failure', 5: 'exception-code-acknowledge', 6: 'exception-code-slave-device-busy', 8: 'exception-code-memory-parity-error', 10: 'exception-code-gateway-path-unavailable', 11: 'exception-code-gateway-target-device-failed-to-respond', -1: 'exception-code-timeout'}, None, None, None])

	def modbus_master_read_input_registers_response(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' modbus-master-read-input-registers-response')

		args = parser.parse_args(argv)

		device_dispatch(ctx, RS485Bricklet, -58, args.execute, ['request-id', 'exception-code', 'input-registers'], [None, {0: 'exception-code-success', 1: 'exception-code-illegal-function', 2: 'exception-code-illegal-data-address', 3: 'exception-code-illegal-data-value', 4: 'exception-code-slave-device-failure', 5: 'exception-code-acknowledge', 6: 'exception-code-slave-device-busy', 8: 'exception-code-memory-parity-error', 10: 'exception-code-gateway-path-unavailable', 11: 'exception-code-gateway-target-device-failed-to-respond', -1: 'exception-code-timeout'}, None])

	callbacks = {
	'read-low-level': read_low_level,
	'read': read,
	'error-count': error_count,
	'modbus-slave-read-coils-request': modbus_slave_read_coils_request,
	'modbus-master-read-coils-response-low-level': modbus_master_read_coils_response_low_level,
	'modbus-master-read-coils-response': modbus_master_read_coils_response,
	'modbus-slave-read-holding-registers-request': modbus_slave_read_holding_registers_request,
	'modbus-master-read-holding-registers-response-low-level': modbus_master_read_holding_registers_response_low_level,
	'modbus-master-read-holding-registers-response': modbus_master_read_holding_registers_response,
	'modbus-slave-write-single-coil-request': modbus_slave_write_single_coil_request,
	'modbus-master-write-single-coil-response': modbus_master_write_single_coil_response,
	'modbus-slave-write-single-register-request': modbus_slave_write_single_register_request,
	'modbus-master-write-single-register-response': modbus_master_write_single_register_response,
	'modbus-slave-write-multiple-coils-request-low-level': modbus_slave_write_multiple_coils_request_low_level,
	'modbus-slave-write-multiple-coils-request': modbus_slave_write_multiple_coils_request,
	'modbus-master-write-multiple-coils-response': modbus_master_write_multiple_coils_response,
	'modbus-slave-write-multiple-registers-request-low-level': modbus_slave_write_multiple_registers_request_low_level,
	'modbus-slave-write-multiple-registers-request': modbus_slave_write_multiple_registers_request,
	'modbus-master-write-multiple-registers-response': modbus_master_write_multiple_registers_response,
	'modbus-slave-read-discrete-inputs-request': modbus_slave_read_discrete_inputs_request,
	'modbus-master-read-discrete-inputs-response-low-level': modbus_master_read_discrete_inputs_response_low_level,
	'modbus-master-read-discrete-inputs-response': modbus_master_read_discrete_inputs_response,
	'modbus-slave-read-input-registers-request': modbus_slave_read_input_registers_request,
	'modbus-master-read-input-registers-response-low-level': modbus_master_read_input_registers_response_low_level,
	'modbus-master-read-input-registers-response': modbus_master_read_input_registers_response
	}

	dispatch_generic(ctx, 'rs485-bricklet', callbacks, argv)

class SegmentDisplay4x7Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 3; re[2] = 1; re[3] = 3; re[4] = 1; re[255] = 1
		cf = self.callback_formats
		cf[5] = ''


def call_segment_display_4x7_bricklet(ctx, argv):
	prog_prefix = 'call segment-display-4x7-bricklet <uid>'

	def set_segments(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-segments')

		parser.add_argument('segments', type=create_array_converter(ctx, convert_int, '0', 4), help=get_array_type_name(ctx, 'int', 4), metavar='<segments>')
		parser.add_argument('brightness', type=convert_int, help='int', metavar='<brightness>')
		parser.add_argument('colon', type=convert_bool, help='bool', metavar='<colon>')

		args = parser.parse_args(argv)

		device_call(ctx, SegmentDisplay4x7Bricklet, 1, (args.segments, args.brightness, args.colon), '4B B !', '', None, args.expect_response, [], [])

	def get_segments(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-segments')

		args = parser.parse_args(argv)

		device_call(ctx, SegmentDisplay4x7Bricklet, 2, (), '', '4B B !', args.execute, False, ['segments', 'brightness', 'colon'], [None, None, None])

	def start_counter(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' start-counter')

		parser.add_argument('value_from', type=convert_int, help='int', metavar='<value-from>')
		parser.add_argument('value_to', type=convert_int, help='int', metavar='<value-to>')
		parser.add_argument('increment', type=convert_int, help='int', metavar='<increment>')
		parser.add_argument('length', type=convert_int, help='int', metavar='<length>')

		args = parser.parse_args(argv)

		device_call(ctx, SegmentDisplay4x7Bricklet, 3, (args.value_from, args.value_to, args.increment, args.length), 'h h h I', '', None, args.expect_response, [], [])

	def get_counter_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-counter-value')

		args = parser.parse_args(argv)

		device_call(ctx, SegmentDisplay4x7Bricklet, 4, (), '', 'H', args.execute, False, ['value'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, SegmentDisplay4x7Bricklet, argv)

	functions = {
	'set-segments': set_segments,
	'get-segments': get_segments,
	'start-counter': start_counter,
	'get-counter-value': get_counter_value,
	'get-identity': get_identity
	}

	call_generic(ctx, 'segment-display-4x7-bricklet', functions, argv)

def dispatch_segment_display_4x7_bricklet(ctx, argv):
	prog_prefix = 'dispatch segment-display-4x7-bricklet <uid>'

	def counter_finished(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' counter-finished')

		args = parser.parse_args(argv)

		device_dispatch(ctx, SegmentDisplay4x7Bricklet, 5, args.execute, [], [])

	callbacks = {
	'counter-finished': counter_finished
	}

	dispatch_generic(ctx, 'segment-display-4x7-bricklet', callbacks, argv)

class SegmentDisplay4x7V2Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 3; re[2] = 1; re[3] = 3; re[4] = 1; re[5] = 3; re[6] = 3; re[7] = 1; re[8] = 3; re[9] = 1; re[234] = 1; re[235] = 1; re[236] = 1; re[237] = 3; re[238] = 1; re[239] = 3; re[240] = 1; re[242] = 1; re[243] = 3; re[248] = 3; re[249] = 1; re[255] = 1
		cf = self.callback_formats
		cf[10] = ''


def call_segment_display_4x7_v2_bricklet(ctx, argv):
	prog_prefix = 'call segment-display-4x7-v2-bricklet <uid>'

	def set_segments(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-segments')

		parser.add_argument('digit0', type=create_array_converter(ctx, convert_bool, 'false', 8), help=get_array_type_name(ctx, 'bool', 8), metavar='<digit0>')
		parser.add_argument('digit1', type=create_array_converter(ctx, convert_bool, 'false', 8), help=get_array_type_name(ctx, 'bool', 8), metavar='<digit1>')
		parser.add_argument('digit2', type=create_array_converter(ctx, convert_bool, 'false', 8), help=get_array_type_name(ctx, 'bool', 8), metavar='<digit2>')
		parser.add_argument('digit3', type=create_array_converter(ctx, convert_bool, 'false', 8), help=get_array_type_name(ctx, 'bool', 8), metavar='<digit3>')
		parser.add_argument('colon', type=create_array_converter(ctx, convert_bool, 'false', 2), help=get_array_type_name(ctx, 'bool', 2), metavar='<colon>')
		parser.add_argument('tick', type=convert_bool, help='bool', metavar='<tick>')

		args = parser.parse_args(argv)

		device_call(ctx, SegmentDisplay4x7V2Bricklet, 1, (args.digit0, args.digit1, args.digit2, args.digit3, args.colon, args.tick), '8! 8! 8! 8! 2! !', '', None, args.expect_response, [], [])

	def get_segments(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-segments')

		args = parser.parse_args(argv)

		device_call(ctx, SegmentDisplay4x7V2Bricklet, 2, (), '', '8! 8! 8! 8! 2! !', args.execute, False, ['digit0', 'digit1', 'digit2', 'digit3', 'colon', 'tick'], [None, None, None, None, None, None])

	def set_brightness(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-brightness')

		parser.add_argument('brightness', type=convert_int, help='int', metavar='<brightness>')

		args = parser.parse_args(argv)

		device_call(ctx, SegmentDisplay4x7V2Bricklet, 3, (args.brightness,), 'B', '', None, args.expect_response, [], [])

	def get_brightness(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-brightness')

		args = parser.parse_args(argv)

		device_call(ctx, SegmentDisplay4x7V2Bricklet, 4, (), '', 'B', args.execute, False, ['brightness'], [None])

	def set_numeric_value(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-numeric-value')

		parser.add_argument('value', type=create_array_converter(ctx, convert_int, '0', 4), help=get_array_type_name(ctx, 'int', 4), metavar='<value>')

		args = parser.parse_args(argv)

		device_call(ctx, SegmentDisplay4x7V2Bricklet, 5, (args.value,), '4b', '', None, args.expect_response, [], [])

	def set_selected_segment(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-selected-segment')

		parser.add_argument('segment', type=convert_int, help='int', metavar='<segment>')
		parser.add_argument('value', type=convert_bool, help='bool', metavar='<value>')

		args = parser.parse_args(argv)

		device_call(ctx, SegmentDisplay4x7V2Bricklet, 6, (args.segment, args.value), 'B !', '', None, args.expect_response, [], [])

	def get_selected_segment(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-selected-segment')

		parser.add_argument('segment', type=convert_int, help='int', metavar='<segment>')

		args = parser.parse_args(argv)

		device_call(ctx, SegmentDisplay4x7V2Bricklet, 7, (args.segment,), 'B', '!', args.execute, False, ['value'], [None])

	def start_counter(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' start-counter')

		parser.add_argument('value_from', type=convert_int, help='int', metavar='<value-from>')
		parser.add_argument('value_to', type=convert_int, help='int', metavar='<value-to>')
		parser.add_argument('increment', type=convert_int, help='int', metavar='<increment>')
		parser.add_argument('length', type=convert_int, help='int', metavar='<length>')

		args = parser.parse_args(argv)

		device_call(ctx, SegmentDisplay4x7V2Bricklet, 8, (args.value_from, args.value_to, args.increment, args.length), 'h h h I', '', None, args.expect_response, [], [])

	def get_counter_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-counter-value')

		args = parser.parse_args(argv)

		device_call(ctx, SegmentDisplay4x7V2Bricklet, 9, (), '', 'H', args.execute, False, ['value'], [None])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, SegmentDisplay4x7V2Bricklet, 234, (), '', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def set_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-bootloader-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'bootloader-mode-firmware-wait-for-reboot': 3, 'bootloader-mode-firmware': 1, 'bootloader-mode-firmware-wait-for-erase-and-reboot': 4, 'bootloader-mode-bootloader-wait-for-reboot': 2, 'bootloader-mode-bootloader': 0}), help='int (bootloader-mode-bootloader: 0, bootloader-mode-firmware: 1, bootloader-mode-bootloader-wait-for-reboot: 2, bootloader-mode-firmware-wait-for-reboot: 3, bootloader-mode-firmware-wait-for-erase-and-reboot: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, SegmentDisplay4x7V2Bricklet, 235, (args.mode,), 'B', 'B', args.execute, False, ['status'], [{0: 'bootloader-status-ok', 1: 'bootloader-status-invalid-mode', 2: 'bootloader-status-no-change', 3: 'bootloader-status-entry-function-not-present', 4: 'bootloader-status-device-identifier-incorrect', 5: 'bootloader-status-crc-mismatch'}])

	def get_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-bootloader-mode')

		args = parser.parse_args(argv)

		device_call(ctx, SegmentDisplay4x7V2Bricklet, 236, (), '', 'B', args.execute, False, ['mode'], [{0: 'bootloader-mode-bootloader', 1: 'bootloader-mode-firmware', 2: 'bootloader-mode-bootloader-wait-for-reboot', 3: 'bootloader-mode-firmware-wait-for-reboot', 4: 'bootloader-mode-firmware-wait-for-erase-and-reboot'}])

	def set_write_firmware_pointer(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-write-firmware-pointer')

		parser.add_argument('pointer', type=convert_int, help='int', metavar='<pointer>')

		args = parser.parse_args(argv)

		device_call(ctx, SegmentDisplay4x7V2Bricklet, 237, (args.pointer,), 'I', '', None, args.expect_response, [], [])

	def write_firmware(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-firmware')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, SegmentDisplay4x7V2Bricklet, 238, (args.data,), '64B', 'B', args.execute, False, ['status'], [None])

	def set_status_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'status-led-config-on': 1, 'status-led-config-show-heartbeat': 2, 'status-led-config-off': 0, 'status-led-config-show-status': 3}), help='int (status-led-config-off: 0, status-led-config-on: 1, status-led-config-show-heartbeat: 2, status-led-config-show-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, SegmentDisplay4x7V2Bricklet, 239, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_status_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, SegmentDisplay4x7V2Bricklet, 240, (), '', 'B', args.execute, False, ['config'], [{0: 'status-led-config-off', 1: 'status-led-config-on', 2: 'status-led-config-show-heartbeat', 3: 'status-led-config-show-status'}])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, SegmentDisplay4x7V2Bricklet, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, SegmentDisplay4x7V2Bricklet, 243, (), '', '', None, args.expect_response, [], [])

	def write_uid(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-uid')

		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')

		args = parser.parse_args(argv)

		device_call(ctx, SegmentDisplay4x7V2Bricklet, 248, (args.uid,), 'I', '', None, args.expect_response, [], [])

	def read_uid(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-uid')

		args = parser.parse_args(argv)

		device_call(ctx, SegmentDisplay4x7V2Bricklet, 249, (), '', 'I', args.execute, False, ['uid'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, SegmentDisplay4x7V2Bricklet, argv)

	functions = {
	'set-segments': set_segments,
	'get-segments': get_segments,
	'set-brightness': set_brightness,
	'get-brightness': get_brightness,
	'set-numeric-value': set_numeric_value,
	'set-selected-segment': set_selected_segment,
	'get-selected-segment': get_selected_segment,
	'start-counter': start_counter,
	'get-counter-value': get_counter_value,
	'get-spitfp-error-count': get_spitfp_error_count,
	'set-bootloader-mode': set_bootloader_mode,
	'get-bootloader-mode': get_bootloader_mode,
	'set-write-firmware-pointer': set_write_firmware_pointer,
	'write-firmware': write_firmware,
	'set-status-led-config': set_status_led_config,
	'get-status-led-config': get_status_led_config,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'write-uid': write_uid,
	'read-uid': read_uid,
	'get-identity': get_identity
	}

	call_generic(ctx, 'segment-display-4x7-v2-bricklet', functions, argv)

def dispatch_segment_display_4x7_v2_bricklet(ctx, argv):
	prog_prefix = 'dispatch segment-display-4x7-v2-bricklet <uid>'

	def counter_finished(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' counter-finished')

		args = parser.parse_args(argv)

		device_dispatch(ctx, SegmentDisplay4x7V2Bricklet, 10, args.execute, [], [])

	callbacks = {
	'counter-finished': counter_finished
	}

	dispatch_generic(ctx, 'segment-display-4x7-v2-bricklet', callbacks, argv)

class ServoBrick(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 3; re[2] = 3; re[3] = 1; re[4] = 3; re[5] = 1; re[6] = 1; re[7] = 3; re[8] = 1; re[9] = 1; re[10] = 3; re[11] = 1; re[12] = 3; re[13] = 1; re[14] = 3; re[15] = 1; re[16] = 3; re[17] = 1; re[18] = 3; re[19] = 1; re[20] = 1; re[21] = 1; re[22] = 1; re[23] = 1; re[24] = 2; re[25] = 1; re[29] = 2; re[30] = 2; re[31] = 1; re[32] = 2; re[33] = 2; re[34] = 1; re[231] = 3; re[232] = 1; re[233] = 1; re[234] = 3; re[235] = 1; re[237] = 1; re[238] = 3; re[239] = 3; re[240] = 1; re[241] = 1; re[242] = 1; re[243] = 3; re[255] = 1
		cf = self.callback_formats
		cf[26] = 'H'; cf[27] = 'B h'; cf[28] = 'B h'


def call_servo_brick(ctx, argv):
	prog_prefix = 'call servo-brick <uid>'

	def enable(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' enable')

		parser.add_argument('servo_num', type=convert_int, help='int', metavar='<servo-num>')

		args = parser.parse_args(argv)

		device_call(ctx, ServoBrick, 1, (args.servo_num,), 'B', '', None, args.expect_response, [], [])

	def disable(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' disable')

		parser.add_argument('servo_num', type=convert_int, help='int', metavar='<servo-num>')

		args = parser.parse_args(argv)

		device_call(ctx, ServoBrick, 2, (args.servo_num,), 'B', '', None, args.expect_response, [], [])

	def is_enabled(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' is-enabled')

		parser.add_argument('servo_num', type=convert_int, help='int', metavar='<servo-num>')

		args = parser.parse_args(argv)

		device_call(ctx, ServoBrick, 3, (args.servo_num,), 'B', '!', args.execute, False, ['enabled'], [None])

	def set_position(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-position')

		parser.add_argument('servo_num', type=convert_int, help='int', metavar='<servo-num>')
		parser.add_argument('position', type=convert_int, help='int', metavar='<position>')

		args = parser.parse_args(argv)

		device_call(ctx, ServoBrick, 4, (args.servo_num, args.position), 'B h', '', None, args.expect_response, [], [])

	def get_position(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-position')

		parser.add_argument('servo_num', type=convert_int, help='int', metavar='<servo-num>')

		args = parser.parse_args(argv)

		device_call(ctx, ServoBrick, 5, (args.servo_num,), 'B', 'h', args.execute, False, ['position'], [None])

	def get_current_position(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-current-position')

		parser.add_argument('servo_num', type=convert_int, help='int', metavar='<servo-num>')

		args = parser.parse_args(argv)

		device_call(ctx, ServoBrick, 6, (args.servo_num,), 'B', 'h', args.execute, False, ['position'], [None])

	def set_velocity(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-velocity')

		parser.add_argument('servo_num', type=convert_int, help='int', metavar='<servo-num>')
		parser.add_argument('velocity', type=convert_int, help='int', metavar='<velocity>')

		args = parser.parse_args(argv)

		device_call(ctx, ServoBrick, 7, (args.servo_num, args.velocity), 'B H', '', None, args.expect_response, [], [])

	def get_velocity(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-velocity')

		parser.add_argument('servo_num', type=convert_int, help='int', metavar='<servo-num>')

		args = parser.parse_args(argv)

		device_call(ctx, ServoBrick, 8, (args.servo_num,), 'B', 'H', args.execute, False, ['velocity'], [None])

	def get_current_velocity(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-current-velocity')

		parser.add_argument('servo_num', type=convert_int, help='int', metavar='<servo-num>')

		args = parser.parse_args(argv)

		device_call(ctx, ServoBrick, 9, (args.servo_num,), 'B', 'H', args.execute, False, ['velocity'], [None])

	def set_acceleration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-acceleration')

		parser.add_argument('servo_num', type=convert_int, help='int', metavar='<servo-num>')
		parser.add_argument('acceleration', type=convert_int, help='int', metavar='<acceleration>')

		args = parser.parse_args(argv)

		device_call(ctx, ServoBrick, 10, (args.servo_num, args.acceleration), 'B H', '', None, args.expect_response, [], [])

	def get_acceleration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-acceleration')

		parser.add_argument('servo_num', type=convert_int, help='int', metavar='<servo-num>')

		args = parser.parse_args(argv)

		device_call(ctx, ServoBrick, 11, (args.servo_num,), 'B', 'H', args.execute, False, ['acceleration'], [None])

	def set_output_voltage(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-output-voltage')

		parser.add_argument('voltage', type=convert_int, help='int', metavar='<voltage>')

		args = parser.parse_args(argv)

		device_call(ctx, ServoBrick, 12, (args.voltage,), 'H', '', None, args.expect_response, [], [])

	def get_output_voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-output-voltage')

		args = parser.parse_args(argv)

		device_call(ctx, ServoBrick, 13, (), '', 'H', args.execute, False, ['voltage'], [None])

	def set_pulse_width(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-pulse-width')

		parser.add_argument('servo_num', type=convert_int, help='int', metavar='<servo-num>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, ServoBrick, 14, (args.servo_num, args.min, args.max), 'B H H', '', None, args.expect_response, [], [])

	def get_pulse_width(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-pulse-width')

		parser.add_argument('servo_num', type=convert_int, help='int', metavar='<servo-num>')

		args = parser.parse_args(argv)

		device_call(ctx, ServoBrick, 15, (args.servo_num,), 'B', 'H H', args.execute, False, ['min', 'max'], [None, None])

	def set_degree(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-degree')

		parser.add_argument('servo_num', type=convert_int, help='int', metavar='<servo-num>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, ServoBrick, 16, (args.servo_num, args.min, args.max), 'B h h', '', None, args.expect_response, [], [])

	def get_degree(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-degree')

		parser.add_argument('servo_num', type=convert_int, help='int', metavar='<servo-num>')

		args = parser.parse_args(argv)

		device_call(ctx, ServoBrick, 17, (args.servo_num,), 'B', 'h h', args.execute, False, ['min', 'max'], [None, None])

	def set_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-period')

		parser.add_argument('servo_num', type=convert_int, help='int', metavar='<servo-num>')
		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, ServoBrick, 18, (args.servo_num, args.period), 'B H', '', None, args.expect_response, [], [])

	def get_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-period')

		parser.add_argument('servo_num', type=convert_int, help='int', metavar='<servo-num>')

		args = parser.parse_args(argv)

		device_call(ctx, ServoBrick, 19, (args.servo_num,), 'B', 'H', args.execute, False, ['period'], [None])

	def get_servo_current(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-servo-current')

		parser.add_argument('servo_num', type=convert_int, help='int', metavar='<servo-num>')

		args = parser.parse_args(argv)

		device_call(ctx, ServoBrick, 20, (args.servo_num,), 'B', 'H', args.execute, False, ['current'], [None])

	def get_overall_current(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-overall-current')

		args = parser.parse_args(argv)

		device_call(ctx, ServoBrick, 21, (), '', 'H', args.execute, False, ['current'], [None])

	def get_stack_input_voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-stack-input-voltage')

		args = parser.parse_args(argv)

		device_call(ctx, ServoBrick, 22, (), '', 'H', args.execute, False, ['voltage'], [None])

	def get_external_input_voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-external-input-voltage')

		args = parser.parse_args(argv)

		device_call(ctx, ServoBrick, 23, (), '', 'H', args.execute, False, ['voltage'], [None])

	def set_minimum_voltage(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-minimum-voltage')

		parser.add_argument('voltage', type=convert_int, help='int', metavar='<voltage>')

		args = parser.parse_args(argv)

		device_call(ctx, ServoBrick, 24, (args.voltage,), 'H', '', None, args.expect_response, [], [])

	def get_minimum_voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-minimum-voltage')

		args = parser.parse_args(argv)

		device_call(ctx, ServoBrick, 25, (), '', 'H', args.execute, False, ['voltage'], [None])

	def enable_position_reached_callback(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' enable-position-reached-callback')

		args = parser.parse_args(argv)

		device_call(ctx, ServoBrick, 29, (), '', '', None, args.expect_response, [], [])

	def disable_position_reached_callback(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' disable-position-reached-callback')

		args = parser.parse_args(argv)

		device_call(ctx, ServoBrick, 30, (), '', '', None, args.expect_response, [], [])

	def is_position_reached_callback_enabled(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' is-position-reached-callback-enabled')

		args = parser.parse_args(argv)

		device_call(ctx, ServoBrick, 31, (), '', '!', args.execute, False, ['enabled'], [None])

	def enable_velocity_reached_callback(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' enable-velocity-reached-callback')

		args = parser.parse_args(argv)

		device_call(ctx, ServoBrick, 32, (), '', '', None, args.expect_response, [], [])

	def disable_velocity_reached_callback(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' disable-velocity-reached-callback')

		args = parser.parse_args(argv)

		device_call(ctx, ServoBrick, 33, (), '', '', None, args.expect_response, [], [])

	def is_velocity_reached_callback_enabled(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' is-velocity-reached-callback-enabled')

		args = parser.parse_args(argv)

		device_call(ctx, ServoBrick, 34, (), '', '!', args.execute, False, ['enabled'], [None])

	def set_spitfp_baudrate_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-spitfp-baudrate-config')

		parser.add_argument('enable_dynamic_baudrate', type=convert_bool, help='bool', metavar='<enable-dynamic-baudrate>')
		parser.add_argument('minimum_dynamic_baudrate', type=convert_int, help='int', metavar='<minimum-dynamic-baudrate>')

		args = parser.parse_args(argv)

		device_call(ctx, ServoBrick, 231, (args.enable_dynamic_baudrate, args.minimum_dynamic_baudrate), '! I', '', None, args.expect_response, [], [])

	def get_spitfp_baudrate_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-baudrate-config')

		args = parser.parse_args(argv)

		device_call(ctx, ServoBrick, 232, (), '', '! I', args.execute, False, ['enable-dynamic-baudrate', 'minimum-dynamic-baudrate'], [None, None])

	def get_send_timeout_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-send-timeout-count')

		parser.add_argument('communication_method', type=create_symbol_converter(ctx, convert_int, {'communication-method-none': 0, 'communication-method-rs485': 4, 'communication-method-usb': 1, 'communication-method-wifi-v2': 7, 'communication-method-spi-stack': 2, 'communication-method-wifi': 5, 'communication-method-chibi': 3, 'communication-method-ethernet': 6}), help='int (communication-method-none: 0, communication-method-usb: 1, communication-method-spi-stack: 2, communication-method-chibi: 3, communication-method-rs485: 4, communication-method-wifi: 5, communication-method-ethernet: 6, communication-method-wifi-v2: 7)', metavar='<communication-method>')

		args = parser.parse_args(argv)

		device_call(ctx, ServoBrick, 233, (args.communication_method,), 'B', 'I', args.execute, False, ['timeout-count'], [None])

	def set_spitfp_baudrate(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-spitfp-baudrate')

		parser.add_argument('bricklet_port', type=create_char_converter(ctx), help='char', metavar='<bricklet-port>')
		parser.add_argument('baudrate', type=convert_int, help='int', metavar='<baudrate>')

		args = parser.parse_args(argv)

		device_call(ctx, ServoBrick, 234, (args.bricklet_port, args.baudrate), 'c I', '', None, args.expect_response, [], [])

	def get_spitfp_baudrate(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-baudrate')

		parser.add_argument('bricklet_port', type=create_char_converter(ctx), help='char', metavar='<bricklet-port>')

		args = parser.parse_args(argv)

		device_call(ctx, ServoBrick, 235, (args.bricklet_port,), 'c', 'I', args.execute, False, ['baudrate'], [None])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		parser.add_argument('bricklet_port', type=create_char_converter(ctx), help='char', metavar='<bricklet-port>')

		args = parser.parse_args(argv)

		device_call(ctx, ServoBrick, 237, (args.bricklet_port,), 'c', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def enable_status_led(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' enable-status-led')

		args = parser.parse_args(argv)

		device_call(ctx, ServoBrick, 238, (), '', '', None, args.expect_response, [], [])

	def disable_status_led(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' disable-status-led')

		args = parser.parse_args(argv)

		device_call(ctx, ServoBrick, 239, (), '', '', None, args.expect_response, [], [])

	def is_status_led_enabled(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' is-status-led-enabled')

		args = parser.parse_args(argv)

		device_call(ctx, ServoBrick, 240, (), '', '!', args.execute, False, ['enabled'], [None])

	def get_protocol1_bricklet_name(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-protocol1-bricklet-name')

		parser.add_argument('port', type=create_char_converter(ctx), help='char', metavar='<port>')

		args = parser.parse_args(argv)

		device_call(ctx, ServoBrick, 241, (args.port,), 'c', 'B 3B 40s', args.execute, False, ['protocol-version', 'firmware-version', 'name'], [None, None, None])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, ServoBrick, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, ServoBrick, 243, (), '', '', None, args.expect_response, [], [])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, ServoBrick, argv)

	functions = {
	'enable': enable,
	'disable': disable,
	'is-enabled': is_enabled,
	'set-position': set_position,
	'get-position': get_position,
	'get-current-position': get_current_position,
	'set-velocity': set_velocity,
	'get-velocity': get_velocity,
	'get-current-velocity': get_current_velocity,
	'set-acceleration': set_acceleration,
	'get-acceleration': get_acceleration,
	'set-output-voltage': set_output_voltage,
	'get-output-voltage': get_output_voltage,
	'set-pulse-width': set_pulse_width,
	'get-pulse-width': get_pulse_width,
	'set-degree': set_degree,
	'get-degree': get_degree,
	'set-period': set_period,
	'get-period': get_period,
	'get-servo-current': get_servo_current,
	'get-overall-current': get_overall_current,
	'get-stack-input-voltage': get_stack_input_voltage,
	'get-external-input-voltage': get_external_input_voltage,
	'set-minimum-voltage': set_minimum_voltage,
	'get-minimum-voltage': get_minimum_voltage,
	'enable-position-reached-callback': enable_position_reached_callback,
	'disable-position-reached-callback': disable_position_reached_callback,
	'is-position-reached-callback-enabled': is_position_reached_callback_enabled,
	'enable-velocity-reached-callback': enable_velocity_reached_callback,
	'disable-velocity-reached-callback': disable_velocity_reached_callback,
	'is-velocity-reached-callback-enabled': is_velocity_reached_callback_enabled,
	'set-spitfp-baudrate-config': set_spitfp_baudrate_config,
	'get-spitfp-baudrate-config': get_spitfp_baudrate_config,
	'get-send-timeout-count': get_send_timeout_count,
	'set-spitfp-baudrate': set_spitfp_baudrate,
	'get-spitfp-baudrate': get_spitfp_baudrate,
	'get-spitfp-error-count': get_spitfp_error_count,
	'enable-status-led': enable_status_led,
	'disable-status-led': disable_status_led,
	'is-status-led-enabled': is_status_led_enabled,
	'get-protocol1-bricklet-name': get_protocol1_bricklet_name,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'get-identity': get_identity
	}

	call_generic(ctx, 'servo-brick', functions, argv)

def dispatch_servo_brick(ctx, argv):
	prog_prefix = 'dispatch servo-brick <uid>'

	def under_voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' under-voltage')

		args = parser.parse_args(argv)

		device_dispatch(ctx, ServoBrick, 26, args.execute, ['voltage'], [None])

	def position_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' position-reached')

		args = parser.parse_args(argv)

		device_dispatch(ctx, ServoBrick, 27, args.execute, ['servo-num', 'position'], [None, None])

	def velocity_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' velocity-reached')

		args = parser.parse_args(argv)

		device_dispatch(ctx, ServoBrick, 28, args.execute, ['servo-num', 'velocity'], [None, None])

	callbacks = {
	'under-voltage': under_voltage,
	'position-reached': position_reached,
	'velocity-reached': velocity_reached
	}

	dispatch_generic(ctx, 'servo-brick', callbacks, argv)

class SilentStepperBrick(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 3; re[2] = 1; re[3] = 1; re[4] = 3; re[5] = 1; re[6] = 3; re[7] = 3; re[8] = 1; re[9] = 3; re[10] = 1; re[11] = 3; re[12] = 1; re[13] = 1; re[14] = 3; re[15] = 1; re[16] = 3; re[17] = 3; re[18] = 3; re[19] = 1; re[20] = 1; re[22] = 3; re[23] = 1; re[24] = 3; re[25] = 3; re[26] = 1; re[27] = 3; re[28] = 1; re[29] = 3; re[30] = 1; re[31] = 3; re[32] = 1; re[33] = 3; re[34] = 1; re[35] = 3; re[36] = 1; re[37] = 1; re[38] = 2; re[39] = 1; re[42] = 3; re[43] = 1; re[44] = 1; re[45] = 2; re[46] = 1; re[231] = 3; re[232] = 1; re[233] = 1; re[234] = 3; re[235] = 1; re[237] = 1; re[238] = 3; re[239] = 3; re[240] = 1; re[241] = 1; re[242] = 1; re[243] = 3; re[255] = 1
		cf = self.callback_formats
		cf[40] = 'H'; cf[41] = 'i'; cf[47] = 'H i i H H H'; cf[48] = 'B B'


def call_silent_stepper_brick(ctx, argv):
	prog_prefix = 'call silent-stepper-brick <uid>'

	def set_max_velocity(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-max-velocity')

		parser.add_argument('velocity', type=convert_int, help='int', metavar='<velocity>')

		args = parser.parse_args(argv)

		device_call(ctx, SilentStepperBrick, 1, (args.velocity,), 'H', '', None, args.expect_response, [], [])

	def get_max_velocity(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-max-velocity')

		args = parser.parse_args(argv)

		device_call(ctx, SilentStepperBrick, 2, (), '', 'H', args.execute, False, ['velocity'], [None])

	def get_current_velocity(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-current-velocity')

		args = parser.parse_args(argv)

		device_call(ctx, SilentStepperBrick, 3, (), '', 'H', args.execute, False, ['velocity'], [None])

	def set_speed_ramping(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-speed-ramping')

		parser.add_argument('acceleration', type=convert_int, help='int', metavar='<acceleration>')
		parser.add_argument('deacceleration', type=convert_int, help='int', metavar='<deacceleration>')

		args = parser.parse_args(argv)

		device_call(ctx, SilentStepperBrick, 4, (args.acceleration, args.deacceleration), 'H H', '', None, args.expect_response, [], [])

	def get_speed_ramping(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-speed-ramping')

		args = parser.parse_args(argv)

		device_call(ctx, SilentStepperBrick, 5, (), '', 'H H', args.execute, False, ['acceleration', 'deacceleration'], [None, None])

	def full_brake(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' full-brake')

		args = parser.parse_args(argv)

		device_call(ctx, SilentStepperBrick, 6, (), '', '', None, args.expect_response, [], [])

	def set_current_position(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-current-position')

		parser.add_argument('position', type=convert_int, help='int', metavar='<position>')

		args = parser.parse_args(argv)

		device_call(ctx, SilentStepperBrick, 7, (args.position,), 'i', '', None, args.expect_response, [], [])

	def get_current_position(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-current-position')

		args = parser.parse_args(argv)

		device_call(ctx, SilentStepperBrick, 8, (), '', 'i', args.execute, False, ['position'], [None])

	def set_target_position(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-target-position')

		parser.add_argument('position', type=convert_int, help='int', metavar='<position>')

		args = parser.parse_args(argv)

		device_call(ctx, SilentStepperBrick, 9, (args.position,), 'i', '', None, args.expect_response, [], [])

	def get_target_position(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-target-position')

		args = parser.parse_args(argv)

		device_call(ctx, SilentStepperBrick, 10, (), '', 'i', args.execute, False, ['position'], [None])

	def set_steps(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-steps')

		parser.add_argument('steps', type=convert_int, help='int', metavar='<steps>')

		args = parser.parse_args(argv)

		device_call(ctx, SilentStepperBrick, 11, (args.steps,), 'i', '', None, args.expect_response, [], [])

	def get_steps(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-steps')

		args = parser.parse_args(argv)

		device_call(ctx, SilentStepperBrick, 12, (), '', 'i', args.execute, False, ['steps'], [None])

	def get_remaining_steps(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-remaining-steps')

		args = parser.parse_args(argv)

		device_call(ctx, SilentStepperBrick, 13, (), '', 'i', args.execute, False, ['steps'], [None])

	def set_step_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-step-configuration')

		parser.add_argument('step_resolution', type=create_symbol_converter(ctx, convert_int, {'step-resolution-256': 0, 'step-resolution-32': 3, 'step-resolution-16': 4, 'step-resolution-64': 2, 'step-resolution-128': 1, 'step-resolution-8': 5, 'step-resolution-4': 6, 'step-resolution-2': 7, 'step-resolution-1': 8}), help='int (step-resolution-1: 8, step-resolution-2: 7, step-resolution-4: 6, step-resolution-8: 5, step-resolution-16: 4, step-resolution-32: 3, step-resolution-64: 2, step-resolution-128: 1, step-resolution-256: 0)', metavar='<step-resolution>')
		parser.add_argument('interpolation', type=convert_bool, help='bool', metavar='<interpolation>')

		args = parser.parse_args(argv)

		device_call(ctx, SilentStepperBrick, 14, (args.step_resolution, args.interpolation), 'B !', '', None, args.expect_response, [], [])

	def get_step_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-step-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, SilentStepperBrick, 15, (), '', 'B !', args.execute, False, ['step-resolution', 'interpolation'], [{0: 'step-resolution-256', 1: 'step-resolution-128', 2: 'step-resolution-64', 3: 'step-resolution-32', 4: 'step-resolution-16', 5: 'step-resolution-8', 6: 'step-resolution-4', 7: 'step-resolution-2', 8: 'step-resolution-1'}, None])

	def drive_forward(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' drive-forward')

		args = parser.parse_args(argv)

		device_call(ctx, SilentStepperBrick, 16, (), '', '', None, args.expect_response, [], [])

	def drive_backward(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' drive-backward')

		args = parser.parse_args(argv)

		device_call(ctx, SilentStepperBrick, 17, (), '', '', None, args.expect_response, [], [])

	def stop(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' stop')

		args = parser.parse_args(argv)

		device_call(ctx, SilentStepperBrick, 18, (), '', '', None, args.expect_response, [], [])

	def get_stack_input_voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-stack-input-voltage')

		args = parser.parse_args(argv)

		device_call(ctx, SilentStepperBrick, 19, (), '', 'H', args.execute, False, ['voltage'], [None])

	def get_external_input_voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-external-input-voltage')

		args = parser.parse_args(argv)

		device_call(ctx, SilentStepperBrick, 20, (), '', 'H', args.execute, False, ['voltage'], [None])

	def set_motor_current(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-motor-current')

		parser.add_argument('current', type=convert_int, help='int', metavar='<current>')

		args = parser.parse_args(argv)

		device_call(ctx, SilentStepperBrick, 22, (args.current,), 'H', '', None, args.expect_response, [], [])

	def get_motor_current(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-motor-current')

		args = parser.parse_args(argv)

		device_call(ctx, SilentStepperBrick, 23, (), '', 'H', args.execute, False, ['current'], [None])

	def enable(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' enable')

		args = parser.parse_args(argv)

		device_call(ctx, SilentStepperBrick, 24, (), '', '', None, args.expect_response, [], [])

	def disable(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' disable')

		args = parser.parse_args(argv)

		device_call(ctx, SilentStepperBrick, 25, (), '', '', None, args.expect_response, [], [])

	def is_enabled(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' is-enabled')

		args = parser.parse_args(argv)

		device_call(ctx, SilentStepperBrick, 26, (), '', '!', args.execute, False, ['enabled'], [None])

	def set_basic_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-basic-configuration')

		parser.add_argument('standstill_current', type=convert_int, help='int', metavar='<standstill-current>')
		parser.add_argument('motor_run_current', type=convert_int, help='int', metavar='<motor-run-current>')
		parser.add_argument('standstill_delay_time', type=convert_int, help='int', metavar='<standstill-delay-time>')
		parser.add_argument('power_down_time', type=convert_int, help='int', metavar='<power-down-time>')
		parser.add_argument('stealth_threshold', type=convert_int, help='int', metavar='<stealth-threshold>')
		parser.add_argument('coolstep_threshold', type=convert_int, help='int', metavar='<coolstep-threshold>')
		parser.add_argument('classic_threshold', type=convert_int, help='int', metavar='<classic-threshold>')
		parser.add_argument('high_velocity_chopper_mode', type=convert_bool, help='bool', metavar='<high-velocity-chopper-mode>')

		args = parser.parse_args(argv)

		device_call(ctx, SilentStepperBrick, 27, (args.standstill_current, args.motor_run_current, args.standstill_delay_time, args.power_down_time, args.stealth_threshold, args.coolstep_threshold, args.classic_threshold, args.high_velocity_chopper_mode), 'H H H H H H H !', '', None, args.expect_response, [], [])

	def get_basic_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-basic-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, SilentStepperBrick, 28, (), '', 'H H H H H H H !', args.execute, False, ['standstill-current', 'motor-run-current', 'standstill-delay-time', 'power-down-time', 'stealth-threshold', 'coolstep-threshold', 'classic-threshold', 'high-velocity-chopper-mode'], [None, None, None, None, None, None, None, None])

	def set_spreadcycle_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-spreadcycle-configuration')

		parser.add_argument('slow_decay_duration', type=convert_int, help='int', metavar='<slow-decay-duration>')
		parser.add_argument('enable_random_slow_decay', type=convert_bool, help='bool', metavar='<enable-random-slow-decay>')
		parser.add_argument('fast_decay_duration', type=convert_int, help='int', metavar='<fast-decay-duration>')
		parser.add_argument('hysteresis_start_value', type=convert_int, help='int', metavar='<hysteresis-start-value>')
		parser.add_argument('hysteresis_end_value', type=convert_int, help='int', metavar='<hysteresis-end-value>')
		parser.add_argument('sine_wave_offset', type=convert_int, help='int', metavar='<sine-wave-offset>')
		parser.add_argument('chopper_mode', type=create_symbol_converter(ctx, convert_int, {'chopper-mode-fast-decay': 1, 'chopper-mode-spread-cycle': 0}), help='int (chopper-mode-spread-cycle: 0, chopper-mode-fast-decay: 1)', metavar='<chopper-mode>')
		parser.add_argument('comparator_blank_time', type=convert_int, help='int', metavar='<comparator-blank-time>')
		parser.add_argument('fast_decay_without_comparator', type=convert_bool, help='bool', metavar='<fast-decay-without-comparator>')

		args = parser.parse_args(argv)

		device_call(ctx, SilentStepperBrick, 29, (args.slow_decay_duration, args.enable_random_slow_decay, args.fast_decay_duration, args.hysteresis_start_value, args.hysteresis_end_value, args.sine_wave_offset, args.chopper_mode, args.comparator_blank_time, args.fast_decay_without_comparator), 'B ! B B b b B B !', '', None, args.expect_response, [], [])

	def get_spreadcycle_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spreadcycle-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, SilentStepperBrick, 30, (), '', 'B ! B B b b B B !', args.execute, False, ['slow-decay-duration', 'enable-random-slow-decay', 'fast-decay-duration', 'hysteresis-start-value', 'hysteresis-end-value', 'sine-wave-offset', 'chopper-mode', 'comparator-blank-time', 'fast-decay-without-comparator'], [None, None, None, None, None, None, {0: 'chopper-mode-spread-cycle', 1: 'chopper-mode-fast-decay'}, None, None])

	def set_stealth_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-stealth-configuration')

		parser.add_argument('enable_stealth', type=convert_bool, help='bool', metavar='<enable-stealth>')
		parser.add_argument('amplitude', type=convert_int, help='int', metavar='<amplitude>')
		parser.add_argument('gradient', type=convert_int, help='int', metavar='<gradient>')
		parser.add_argument('enable_autoscale', type=convert_bool, help='bool', metavar='<enable-autoscale>')
		parser.add_argument('force_symmetric', type=convert_bool, help='bool', metavar='<force-symmetric>')
		parser.add_argument('freewheel_mode', type=create_symbol_converter(ctx, convert_int, {'freewheel-mode-freewheeling': 1, 'freewheel-mode-coil-short-ls': 2, 'freewheel-mode-coil-short-hs': 3, 'freewheel-mode-normal': 0}), help='int (freewheel-mode-normal: 0, freewheel-mode-freewheeling: 1, freewheel-mode-coil-short-ls: 2, freewheel-mode-coil-short-hs: 3)', metavar='<freewheel-mode>')

		args = parser.parse_args(argv)

		device_call(ctx, SilentStepperBrick, 31, (args.enable_stealth, args.amplitude, args.gradient, args.enable_autoscale, args.force_symmetric, args.freewheel_mode), '! B B ! ! B', '', None, args.expect_response, [], [])

	def get_stealth_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-stealth-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, SilentStepperBrick, 32, (), '', '! B B ! ! B', args.execute, False, ['enable-stealth', 'amplitude', 'gradient', 'enable-autoscale', 'force-symmetric', 'freewheel-mode'], [None, None, None, None, None, {0: 'freewheel-mode-normal', 1: 'freewheel-mode-freewheeling', 2: 'freewheel-mode-coil-short-ls', 3: 'freewheel-mode-coil-short-hs'}])

	def set_coolstep_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-coolstep-configuration')

		parser.add_argument('minimum_stallguard_value', type=convert_int, help='int', metavar='<minimum-stallguard-value>')
		parser.add_argument('maximum_stallguard_value', type=convert_int, help='int', metavar='<maximum-stallguard-value>')
		parser.add_argument('current_up_step_width', type=create_symbol_converter(ctx, convert_int, {'current-up-step-increment-2': 1, 'current-up-step-increment-8': 3, 'current-up-step-increment-1': 0, 'current-up-step-increment-4': 2}), help='int (current-up-step-increment-1: 0, current-up-step-increment-2: 1, current-up-step-increment-4: 2, current-up-step-increment-8: 3)', metavar='<current-up-step-width>')
		parser.add_argument('current_down_step_width', type=create_symbol_converter(ctx, convert_int, {'current-down-step-decrement-32': 3, 'current-down-step-decrement-1': 0, 'current-down-step-decrement-8': 2, 'current-down-step-decrement-2': 1}), help='int (current-down-step-decrement-1: 0, current-down-step-decrement-2: 1, current-down-step-decrement-8: 2, current-down-step-decrement-32: 3)', metavar='<current-down-step-width>')
		parser.add_argument('minimum_current', type=create_symbol_converter(ctx, convert_int, {'minimum-current-quarter': 1, 'minimum-current-half': 0}), help='int (minimum-current-half: 0, minimum-current-quarter: 1)', metavar='<minimum-current>')
		parser.add_argument('stallguard_threshold_value', type=convert_int, help='int', metavar='<stallguard-threshold-value>')
		parser.add_argument('stallguard_mode', type=create_symbol_converter(ctx, convert_int, {'stallguard-mode-standard': 0, 'stallguard-mode-filtered': 1}), help='int (stallguard-mode-standard: 0, stallguard-mode-filtered: 1)', metavar='<stallguard-mode>')

		args = parser.parse_args(argv)

		device_call(ctx, SilentStepperBrick, 33, (args.minimum_stallguard_value, args.maximum_stallguard_value, args.current_up_step_width, args.current_down_step_width, args.minimum_current, args.stallguard_threshold_value, args.stallguard_mode), 'B B B B B b B', '', None, args.expect_response, [], [])

	def get_coolstep_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-coolstep-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, SilentStepperBrick, 34, (), '', 'B B B B B b B', args.execute, False, ['minimum-stallguard-value', 'maximum-stallguard-value', 'current-up-step-width', 'current-down-step-width', 'minimum-current', 'stallguard-threshold-value', 'stallguard-mode'], [None, None, {0: 'current-up-step-increment-1', 1: 'current-up-step-increment-2', 2: 'current-up-step-increment-4', 3: 'current-up-step-increment-8'}, {0: 'current-down-step-decrement-1', 1: 'current-down-step-decrement-2', 2: 'current-down-step-decrement-8', 3: 'current-down-step-decrement-32'}, {0: 'minimum-current-half', 1: 'minimum-current-quarter'}, None, {0: 'stallguard-mode-standard', 1: 'stallguard-mode-filtered'}])

	def set_misc_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-misc-configuration')

		parser.add_argument('disable_short_to_ground_protection', type=convert_bool, help='bool', metavar='<disable-short-to-ground-protection>')
		parser.add_argument('synchronize_phase_frequency', type=convert_int, help='int', metavar='<synchronize-phase-frequency>')

		args = parser.parse_args(argv)

		device_call(ctx, SilentStepperBrick, 35, (args.disable_short_to_ground_protection, args.synchronize_phase_frequency), '! B', '', None, args.expect_response, [], [])

	def get_misc_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-misc-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, SilentStepperBrick, 36, (), '', '! B', args.execute, False, ['disable-short-to-ground-protection', 'synchronize-phase-frequency'], [None, None])

	def get_driver_status(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-driver-status')

		args = parser.parse_args(argv)

		device_call(ctx, SilentStepperBrick, 37, (), '', 'B B B ! B ! B B', args.execute, False, ['open-load', 'short-to-ground', 'over-temperature', 'motor-stalled', 'actual-motor-current', 'full-step-active', 'stallguard-result', 'stealth-voltage-amplitude'], [{0: 'open-load-none', 1: 'open-load-phase-a', 2: 'open-load-phase-b', 3: 'open-load-phase-ab'}, {0: 'short-to-ground-none', 1: 'short-to-ground-phase-a', 2: 'short-to-ground-phase-b', 3: 'short-to-ground-phase-ab'}, {0: 'over-temperature-none', 1: 'over-temperature-warning', 2: 'over-temperature-limit'}, None, None, None, None, None])

	def set_minimum_voltage(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-minimum-voltage')

		parser.add_argument('voltage', type=convert_int, help='int', metavar='<voltage>')

		args = parser.parse_args(argv)

		device_call(ctx, SilentStepperBrick, 38, (args.voltage,), 'H', '', None, args.expect_response, [], [])

	def get_minimum_voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-minimum-voltage')

		args = parser.parse_args(argv)

		device_call(ctx, SilentStepperBrick, 39, (), '', 'H', args.execute, False, ['voltage'], [None])

	def set_time_base(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-time-base')

		parser.add_argument('time_base', type=convert_int, help='int', metavar='<time-base>')

		args = parser.parse_args(argv)

		device_call(ctx, SilentStepperBrick, 42, (args.time_base,), 'I', '', None, args.expect_response, [], [])

	def get_time_base(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-time-base')

		args = parser.parse_args(argv)

		device_call(ctx, SilentStepperBrick, 43, (), '', 'I', args.execute, False, ['time-base'], [None])

	def get_all_data(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-all-data')

		args = parser.parse_args(argv)

		device_call(ctx, SilentStepperBrick, 44, (), '', 'H i i H H H', args.execute, False, ['current-velocity', 'current-position', 'remaining-steps', 'stack-voltage', 'external-voltage', 'current-consumption'], [None, None, None, None, None, None])

	def set_all_data_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-all-data-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, SilentStepperBrick, 45, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_all_data_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-all-data-period')

		args = parser.parse_args(argv)

		device_call(ctx, SilentStepperBrick, 46, (), '', 'I', args.execute, False, ['period'], [None])

	def set_spitfp_baudrate_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-spitfp-baudrate-config')

		parser.add_argument('enable_dynamic_baudrate', type=convert_bool, help='bool', metavar='<enable-dynamic-baudrate>')
		parser.add_argument('minimum_dynamic_baudrate', type=convert_int, help='int', metavar='<minimum-dynamic-baudrate>')

		args = parser.parse_args(argv)

		device_call(ctx, SilentStepperBrick, 231, (args.enable_dynamic_baudrate, args.minimum_dynamic_baudrate), '! I', '', None, args.expect_response, [], [])

	def get_spitfp_baudrate_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-baudrate-config')

		args = parser.parse_args(argv)

		device_call(ctx, SilentStepperBrick, 232, (), '', '! I', args.execute, False, ['enable-dynamic-baudrate', 'minimum-dynamic-baudrate'], [None, None])

	def get_send_timeout_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-send-timeout-count')

		parser.add_argument('communication_method', type=create_symbol_converter(ctx, convert_int, {'communication-method-none': 0, 'communication-method-rs485': 4, 'communication-method-usb': 1, 'communication-method-wifi-v2': 7, 'communication-method-spi-stack': 2, 'communication-method-wifi': 5, 'communication-method-chibi': 3, 'communication-method-ethernet': 6}), help='int (communication-method-none: 0, communication-method-usb: 1, communication-method-spi-stack: 2, communication-method-chibi: 3, communication-method-rs485: 4, communication-method-wifi: 5, communication-method-ethernet: 6, communication-method-wifi-v2: 7)', metavar='<communication-method>')

		args = parser.parse_args(argv)

		device_call(ctx, SilentStepperBrick, 233, (args.communication_method,), 'B', 'I', args.execute, False, ['timeout-count'], [None])

	def set_spitfp_baudrate(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-spitfp-baudrate')

		parser.add_argument('bricklet_port', type=create_char_converter(ctx), help='char', metavar='<bricklet-port>')
		parser.add_argument('baudrate', type=convert_int, help='int', metavar='<baudrate>')

		args = parser.parse_args(argv)

		device_call(ctx, SilentStepperBrick, 234, (args.bricklet_port, args.baudrate), 'c I', '', None, args.expect_response, [], [])

	def get_spitfp_baudrate(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-baudrate')

		parser.add_argument('bricklet_port', type=create_char_converter(ctx), help='char', metavar='<bricklet-port>')

		args = parser.parse_args(argv)

		device_call(ctx, SilentStepperBrick, 235, (args.bricklet_port,), 'c', 'I', args.execute, False, ['baudrate'], [None])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		parser.add_argument('bricklet_port', type=create_char_converter(ctx), help='char', metavar='<bricklet-port>')

		args = parser.parse_args(argv)

		device_call(ctx, SilentStepperBrick, 237, (args.bricklet_port,), 'c', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def enable_status_led(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' enable-status-led')

		args = parser.parse_args(argv)

		device_call(ctx, SilentStepperBrick, 238, (), '', '', None, args.expect_response, [], [])

	def disable_status_led(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' disable-status-led')

		args = parser.parse_args(argv)

		device_call(ctx, SilentStepperBrick, 239, (), '', '', None, args.expect_response, [], [])

	def is_status_led_enabled(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' is-status-led-enabled')

		args = parser.parse_args(argv)

		device_call(ctx, SilentStepperBrick, 240, (), '', '!', args.execute, False, ['enabled'], [None])

	def get_protocol1_bricklet_name(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-protocol1-bricklet-name')

		parser.add_argument('port', type=create_char_converter(ctx), help='char', metavar='<port>')

		args = parser.parse_args(argv)

		device_call(ctx, SilentStepperBrick, 241, (args.port,), 'c', 'B 3B 40s', args.execute, False, ['protocol-version', 'firmware-version', 'name'], [None, None, None])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, SilentStepperBrick, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, SilentStepperBrick, 243, (), '', '', None, args.expect_response, [], [])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, SilentStepperBrick, argv)

	functions = {
	'set-max-velocity': set_max_velocity,
	'get-max-velocity': get_max_velocity,
	'get-current-velocity': get_current_velocity,
	'set-speed-ramping': set_speed_ramping,
	'get-speed-ramping': get_speed_ramping,
	'full-brake': full_brake,
	'set-current-position': set_current_position,
	'get-current-position': get_current_position,
	'set-target-position': set_target_position,
	'get-target-position': get_target_position,
	'set-steps': set_steps,
	'get-steps': get_steps,
	'get-remaining-steps': get_remaining_steps,
	'set-step-configuration': set_step_configuration,
	'get-step-configuration': get_step_configuration,
	'drive-forward': drive_forward,
	'drive-backward': drive_backward,
	'stop': stop,
	'get-stack-input-voltage': get_stack_input_voltage,
	'get-external-input-voltage': get_external_input_voltage,
	'set-motor-current': set_motor_current,
	'get-motor-current': get_motor_current,
	'enable': enable,
	'disable': disable,
	'is-enabled': is_enabled,
	'set-basic-configuration': set_basic_configuration,
	'get-basic-configuration': get_basic_configuration,
	'set-spreadcycle-configuration': set_spreadcycle_configuration,
	'get-spreadcycle-configuration': get_spreadcycle_configuration,
	'set-stealth-configuration': set_stealth_configuration,
	'get-stealth-configuration': get_stealth_configuration,
	'set-coolstep-configuration': set_coolstep_configuration,
	'get-coolstep-configuration': get_coolstep_configuration,
	'set-misc-configuration': set_misc_configuration,
	'get-misc-configuration': get_misc_configuration,
	'get-driver-status': get_driver_status,
	'set-minimum-voltage': set_minimum_voltage,
	'get-minimum-voltage': get_minimum_voltage,
	'set-time-base': set_time_base,
	'get-time-base': get_time_base,
	'get-all-data': get_all_data,
	'set-all-data-period': set_all_data_period,
	'get-all-data-period': get_all_data_period,
	'set-spitfp-baudrate-config': set_spitfp_baudrate_config,
	'get-spitfp-baudrate-config': get_spitfp_baudrate_config,
	'get-send-timeout-count': get_send_timeout_count,
	'set-spitfp-baudrate': set_spitfp_baudrate,
	'get-spitfp-baudrate': get_spitfp_baudrate,
	'get-spitfp-error-count': get_spitfp_error_count,
	'enable-status-led': enable_status_led,
	'disable-status-led': disable_status_led,
	'is-status-led-enabled': is_status_led_enabled,
	'get-protocol1-bricklet-name': get_protocol1_bricklet_name,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'get-identity': get_identity
	}

	call_generic(ctx, 'silent-stepper-brick', functions, argv)

def dispatch_silent_stepper_brick(ctx, argv):
	prog_prefix = 'dispatch silent-stepper-brick <uid>'

	def under_voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' under-voltage')

		args = parser.parse_args(argv)

		device_dispatch(ctx, SilentStepperBrick, 40, args.execute, ['voltage'], [None])

	def position_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' position-reached')

		args = parser.parse_args(argv)

		device_dispatch(ctx, SilentStepperBrick, 41, args.execute, ['position'], [None])

	def all_data(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' all-data')

		args = parser.parse_args(argv)

		device_dispatch(ctx, SilentStepperBrick, 47, args.execute, ['current-velocity', 'current-position', 'remaining-steps', 'stack-voltage', 'external-voltage', 'current-consumption'], [None, None, None, None, None, None])

	def new_state(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' new-state')

		args = parser.parse_args(argv)

		device_dispatch(ctx, SilentStepperBrick, 48, args.execute, ['state-new', 'state-previous'], [{1: 'state-stop', 2: 'state-acceleration', 3: 'state-run', 4: 'state-deacceleration', 5: 'state-direction-change-to-forward', 6: 'state-direction-change-to-backward'}, {1: 'state-stop', 2: 'state-acceleration', 3: 'state-run', 4: 'state-deacceleration', 5: 'state-direction-change-to-forward', 6: 'state-direction-change-to-backward'}])

	callbacks = {
	'under-voltage': under_voltage,
	'position-reached': position_reached,
	'all-data': all_data,
	'new-state': new_state
	}

	dispatch_generic(ctx, 'silent-stepper-brick', callbacks, argv)

class SolidStateRelayBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 3; re[2] = 1; re[3] = 3; re[4] = 1; re[255] = 1
		cf = self.callback_formats
		cf[5] = '!'


def call_solid_state_relay_bricklet(ctx, argv):
	prog_prefix = 'call solid-state-relay-bricklet <uid>'

	def set_state(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-state')

		parser.add_argument('state', type=convert_bool, help='bool', metavar='<state>')

		args = parser.parse_args(argv)

		device_call(ctx, SolidStateRelayBricklet, 1, (args.state,), '!', '', None, args.expect_response, [], [])

	def get_state(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-state')

		args = parser.parse_args(argv)

		device_call(ctx, SolidStateRelayBricklet, 2, (), '', '!', args.execute, False, ['state'], [None])

	def set_monoflop(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-monoflop')

		parser.add_argument('state', type=convert_bool, help='bool', metavar='<state>')
		parser.add_argument('time', type=convert_int, help='int', metavar='<time>')

		args = parser.parse_args(argv)

		device_call(ctx, SolidStateRelayBricklet, 3, (args.state, args.time), '! I', '', None, args.expect_response, [], [])

	def get_monoflop(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-monoflop')

		args = parser.parse_args(argv)

		device_call(ctx, SolidStateRelayBricklet, 4, (), '', '! I I', args.execute, False, ['state', 'time', 'time-remaining'], [None, None, None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, SolidStateRelayBricklet, argv)

	functions = {
	'set-state': set_state,
	'get-state': get_state,
	'set-monoflop': set_monoflop,
	'get-monoflop': get_monoflop,
	'get-identity': get_identity
	}

	call_generic(ctx, 'solid-state-relay-bricklet', functions, argv)

def dispatch_solid_state_relay_bricklet(ctx, argv):
	prog_prefix = 'dispatch solid-state-relay-bricklet <uid>'

	def monoflop_done(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' monoflop-done')

		args = parser.parse_args(argv)

		device_dispatch(ctx, SolidStateRelayBricklet, 5, args.execute, ['state'], [None])

	callbacks = {
	'monoflop-done': monoflop_done
	}

	dispatch_generic(ctx, 'solid-state-relay-bricklet', callbacks, argv)

class SolidStateRelayV2Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 3; re[2] = 1; re[3] = 3; re[4] = 1; re[234] = 1; re[235] = 1; re[236] = 1; re[237] = 3; re[238] = 1; re[239] = 3; re[240] = 1; re[242] = 1; re[243] = 3; re[248] = 3; re[249] = 1; re[255] = 1
		cf = self.callback_formats
		cf[5] = '!'


def call_solid_state_relay_v2_bricklet(ctx, argv):
	prog_prefix = 'call solid-state-relay-v2-bricklet <uid>'

	def set_state(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-state')

		parser.add_argument('state', type=convert_bool, help='bool', metavar='<state>')

		args = parser.parse_args(argv)

		device_call(ctx, SolidStateRelayV2Bricklet, 1, (args.state,), '!', '', None, args.expect_response, [], [])

	def get_state(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-state')

		args = parser.parse_args(argv)

		device_call(ctx, SolidStateRelayV2Bricklet, 2, (), '', '!', args.execute, False, ['state'], [None])

	def set_monoflop(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-monoflop')

		parser.add_argument('state', type=convert_bool, help='bool', metavar='<state>')
		parser.add_argument('time', type=convert_int, help='int', metavar='<time>')

		args = parser.parse_args(argv)

		device_call(ctx, SolidStateRelayV2Bricklet, 3, (args.state, args.time), '! I', '', None, args.expect_response, [], [])

	def get_monoflop(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-monoflop')

		args = parser.parse_args(argv)

		device_call(ctx, SolidStateRelayV2Bricklet, 4, (), '', '! I I', args.execute, False, ['state', 'time', 'time-remaining'], [None, None, None])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, SolidStateRelayV2Bricklet, 234, (), '', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def set_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-bootloader-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'bootloader-mode-firmware-wait-for-reboot': 3, 'bootloader-mode-firmware': 1, 'bootloader-mode-firmware-wait-for-erase-and-reboot': 4, 'bootloader-mode-bootloader-wait-for-reboot': 2, 'bootloader-mode-bootloader': 0}), help='int (bootloader-mode-bootloader: 0, bootloader-mode-firmware: 1, bootloader-mode-bootloader-wait-for-reboot: 2, bootloader-mode-firmware-wait-for-reboot: 3, bootloader-mode-firmware-wait-for-erase-and-reboot: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, SolidStateRelayV2Bricklet, 235, (args.mode,), 'B', 'B', args.execute, False, ['status'], [{0: 'bootloader-status-ok', 1: 'bootloader-status-invalid-mode', 2: 'bootloader-status-no-change', 3: 'bootloader-status-entry-function-not-present', 4: 'bootloader-status-device-identifier-incorrect', 5: 'bootloader-status-crc-mismatch'}])

	def get_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-bootloader-mode')

		args = parser.parse_args(argv)

		device_call(ctx, SolidStateRelayV2Bricklet, 236, (), '', 'B', args.execute, False, ['mode'], [{0: 'bootloader-mode-bootloader', 1: 'bootloader-mode-firmware', 2: 'bootloader-mode-bootloader-wait-for-reboot', 3: 'bootloader-mode-firmware-wait-for-reboot', 4: 'bootloader-mode-firmware-wait-for-erase-and-reboot'}])

	def set_write_firmware_pointer(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-write-firmware-pointer')

		parser.add_argument('pointer', type=convert_int, help='int', metavar='<pointer>')

		args = parser.parse_args(argv)

		device_call(ctx, SolidStateRelayV2Bricklet, 237, (args.pointer,), 'I', '', None, args.expect_response, [], [])

	def write_firmware(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-firmware')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, SolidStateRelayV2Bricklet, 238, (args.data,), '64B', 'B', args.execute, False, ['status'], [None])

	def set_status_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'status-led-config-on': 1, 'status-led-config-show-heartbeat': 2, 'status-led-config-off': 0, 'status-led-config-show-status': 3}), help='int (status-led-config-off: 0, status-led-config-on: 1, status-led-config-show-heartbeat: 2, status-led-config-show-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, SolidStateRelayV2Bricklet, 239, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_status_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, SolidStateRelayV2Bricklet, 240, (), '', 'B', args.execute, False, ['config'], [{0: 'status-led-config-off', 1: 'status-led-config-on', 2: 'status-led-config-show-heartbeat', 3: 'status-led-config-show-status'}])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, SolidStateRelayV2Bricklet, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, SolidStateRelayV2Bricklet, 243, (), '', '', None, args.expect_response, [], [])

	def write_uid(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-uid')

		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')

		args = parser.parse_args(argv)

		device_call(ctx, SolidStateRelayV2Bricklet, 248, (args.uid,), 'I', '', None, args.expect_response, [], [])

	def read_uid(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-uid')

		args = parser.parse_args(argv)

		device_call(ctx, SolidStateRelayV2Bricklet, 249, (), '', 'I', args.execute, False, ['uid'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, SolidStateRelayV2Bricklet, argv)

	functions = {
	'set-state': set_state,
	'get-state': get_state,
	'set-monoflop': set_monoflop,
	'get-monoflop': get_monoflop,
	'get-spitfp-error-count': get_spitfp_error_count,
	'set-bootloader-mode': set_bootloader_mode,
	'get-bootloader-mode': get_bootloader_mode,
	'set-write-firmware-pointer': set_write_firmware_pointer,
	'write-firmware': write_firmware,
	'set-status-led-config': set_status_led_config,
	'get-status-led-config': get_status_led_config,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'write-uid': write_uid,
	'read-uid': read_uid,
	'get-identity': get_identity
	}

	call_generic(ctx, 'solid-state-relay-v2-bricklet', functions, argv)

def dispatch_solid_state_relay_v2_bricklet(ctx, argv):
	prog_prefix = 'dispatch solid-state-relay-v2-bricklet <uid>'

	def monoflop_done(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' monoflop-done')

		args = parser.parse_args(argv)

		device_dispatch(ctx, SolidStateRelayV2Bricklet, 5, args.execute, ['state'], [None])

	callbacks = {
	'monoflop-done': monoflop_done
	}

	dispatch_generic(ctx, 'solid-state-relay-v2-bricklet', callbacks, argv)

class SoundIntensityBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 2; re[3] = 1; re[4] = 2; re[5] = 1; re[6] = 2; re[7] = 1; re[255] = 1
		cf = self.callback_formats
		cf[8] = 'H'; cf[9] = 'H'


def call_sound_intensity_bricklet(ctx, argv):
	prog_prefix = 'call sound-intensity-bricklet <uid>'

	def get_intensity(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-intensity')

		args = parser.parse_args(argv)

		device_call(ctx, SoundIntensityBricklet, 1, (), '', 'H', args.execute, False, ['intensity'], [None])

	def set_intensity_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-intensity-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, SoundIntensityBricklet, 2, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_intensity_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-intensity-callback-period')

		args = parser.parse_args(argv)

		device_call(ctx, SoundIntensityBricklet, 3, (), '', 'I', args.execute, False, ['period'], [None])

	def set_intensity_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-intensity-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, SoundIntensityBricklet, 4, (args.option, args.min, args.max), 'c H H', '', None, args.expect_response, [], [])

	def get_intensity_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-intensity-callback-threshold')

		args = parser.parse_args(argv)

		device_call(ctx, SoundIntensityBricklet, 5, (), '', 'c H H', args.execute, False, ['option', 'min', 'max'], [{'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def set_debounce_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-debounce-period')

		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_call(ctx, SoundIntensityBricklet, 6, (args.debounce,), 'I', '', None, args.expect_response, [], [])

	def get_debounce_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-debounce-period')

		args = parser.parse_args(argv)

		device_call(ctx, SoundIntensityBricklet, 7, (), '', 'I', args.execute, False, ['debounce'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, SoundIntensityBricklet, argv)

	functions = {
	'get-intensity': get_intensity,
	'set-intensity-callback-period': set_intensity_callback_period,
	'get-intensity-callback-period': get_intensity_callback_period,
	'set-intensity-callback-threshold': set_intensity_callback_threshold,
	'get-intensity-callback-threshold': get_intensity_callback_threshold,
	'set-debounce-period': set_debounce_period,
	'get-debounce-period': get_debounce_period,
	'get-identity': get_identity
	}

	call_generic(ctx, 'sound-intensity-bricklet', functions, argv)

def dispatch_sound_intensity_bricklet(ctx, argv):
	prog_prefix = 'dispatch sound-intensity-bricklet <uid>'

	def intensity(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' intensity')

		args = parser.parse_args(argv)

		device_dispatch(ctx, SoundIntensityBricklet, 8, args.execute, ['intensity'], [None])

	def intensity_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' intensity-reached')

		args = parser.parse_args(argv)

		device_dispatch(ctx, SoundIntensityBricklet, 9, args.execute, ['intensity'], [None])

	callbacks = {
	'intensity': intensity,
	'intensity-reached': intensity_reached
	}

	dispatch_generic(ctx, 'sound-intensity-bricklet', callbacks, argv)

class SoundPressureLevelBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 2; re[3] = 1; re[5] = 1; re[6] = 2; re[7] = 1; re[9] = 3; re[10] = 1; re[234] = 1; re[235] = 1; re[236] = 1; re[237] = 3; re[238] = 1; re[239] = 3; re[240] = 1; re[242] = 1; re[243] = 3; re[248] = 3; re[249] = 1; re[255] = 1
		cf = self.callback_formats
		cf[4] = 'H'; cf[8] = 'H H 30H'
		hlc = self.high_level_callbacks
		hlc[-8] = [('stream_length', 'stream_chunk_offset', 'stream_chunk_data'), {'fixed_length': None, 'single_chunk': False}, None]

def call_sound_pressure_level_bricklet(ctx, argv):
	prog_prefix = 'call sound-pressure-level-bricklet <uid>'

	def get_decibel(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-decibel')

		args = parser.parse_args(argv)

		device_call(ctx, SoundPressureLevelBricklet, 1, (), '', 'H', args.execute, False, ['decibel'], [None])

	def set_decibel_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-decibel-callback-configuration')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')
		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, SoundPressureLevelBricklet, 2, (args.period, args.value_has_to_change, args.option, args.min, args.max), 'I ! c H H', '', None, args.expect_response, [], [])

	def get_decibel_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-decibel-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, SoundPressureLevelBricklet, 3, (), '', 'I ! c H H', args.execute, False, ['period', 'value-has-to-change', 'option', 'min', 'max'], [None, None, {'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def get_spectrum_low_level(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spectrum-low-level')

		args = parser.parse_args(argv)

		device_call(ctx, SoundPressureLevelBricklet, 5, (), '', 'H H 30H', args.execute, False, ['spectrum-length', 'spectrum-chunk-offset', 'spectrum-chunk-data'], [None, None, None])

	def get_spectrum(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spectrum')

		args = parser.parse_args(argv)

		device_stream_call(ctx, SoundPressureLevelBricklet, 5, 'out', (), (), ('stream_data',), (), ('stream_length', 'stream_chunk_offset', 'stream_chunk_data'), '', 'H H 30H', args.execute, False, ['spectrum'], [None], None, 30, None, False, False, None)

	def set_spectrum_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-spectrum-callback-configuration')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, SoundPressureLevelBricklet, 6, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_spectrum_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spectrum-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, SoundPressureLevelBricklet, 7, (), '', 'I', args.execute, False, ['period'], [None])

	def set_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-configuration')

		parser.add_argument('fft_size', type=create_symbol_converter(ctx, convert_int, {'fft-size-512': 2, 'fft-size-128': 0, 'fft-size-256': 1, 'fft-size-1024': 3}), help='int (fft-size-128: 0, fft-size-256: 1, fft-size-512: 2, fft-size-1024: 3)', metavar='<fft-size>')
		parser.add_argument('weighting', type=create_symbol_converter(ctx, convert_int, {'weighting-d': 3, 'weighting-a': 0, 'weighting-b': 1, 'weighting-c': 2, 'weighting-itu-r-468': 5, 'weighting-z': 4}), help='int (weighting-a: 0, weighting-b: 1, weighting-c: 2, weighting-d: 3, weighting-z: 4, weighting-itu-r-468: 5)', metavar='<weighting>')

		args = parser.parse_args(argv)

		device_call(ctx, SoundPressureLevelBricklet, 9, (args.fft_size, args.weighting), 'B B', '', None, args.expect_response, [], [])

	def get_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, SoundPressureLevelBricklet, 10, (), '', 'B B', args.execute, False, ['fft-size', 'weighting'], [{0: 'fft-size-128', 1: 'fft-size-256', 2: 'fft-size-512', 3: 'fft-size-1024'}, {0: 'weighting-a', 1: 'weighting-b', 2: 'weighting-c', 3: 'weighting-d', 4: 'weighting-z', 5: 'weighting-itu-r-468'}])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, SoundPressureLevelBricklet, 234, (), '', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def set_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-bootloader-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'bootloader-mode-firmware-wait-for-reboot': 3, 'bootloader-mode-firmware': 1, 'bootloader-mode-firmware-wait-for-erase-and-reboot': 4, 'bootloader-mode-bootloader-wait-for-reboot': 2, 'bootloader-mode-bootloader': 0}), help='int (bootloader-mode-bootloader: 0, bootloader-mode-firmware: 1, bootloader-mode-bootloader-wait-for-reboot: 2, bootloader-mode-firmware-wait-for-reboot: 3, bootloader-mode-firmware-wait-for-erase-and-reboot: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, SoundPressureLevelBricklet, 235, (args.mode,), 'B', 'B', args.execute, False, ['status'], [{0: 'bootloader-status-ok', 1: 'bootloader-status-invalid-mode', 2: 'bootloader-status-no-change', 3: 'bootloader-status-entry-function-not-present', 4: 'bootloader-status-device-identifier-incorrect', 5: 'bootloader-status-crc-mismatch'}])

	def get_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-bootloader-mode')

		args = parser.parse_args(argv)

		device_call(ctx, SoundPressureLevelBricklet, 236, (), '', 'B', args.execute, False, ['mode'], [{0: 'bootloader-mode-bootloader', 1: 'bootloader-mode-firmware', 2: 'bootloader-mode-bootloader-wait-for-reboot', 3: 'bootloader-mode-firmware-wait-for-reboot', 4: 'bootloader-mode-firmware-wait-for-erase-and-reboot'}])

	def set_write_firmware_pointer(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-write-firmware-pointer')

		parser.add_argument('pointer', type=convert_int, help='int', metavar='<pointer>')

		args = parser.parse_args(argv)

		device_call(ctx, SoundPressureLevelBricklet, 237, (args.pointer,), 'I', '', None, args.expect_response, [], [])

	def write_firmware(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-firmware')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, SoundPressureLevelBricklet, 238, (args.data,), '64B', 'B', args.execute, False, ['status'], [None])

	def set_status_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'status-led-config-on': 1, 'status-led-config-show-heartbeat': 2, 'status-led-config-off': 0, 'status-led-config-show-status': 3}), help='int (status-led-config-off: 0, status-led-config-on: 1, status-led-config-show-heartbeat: 2, status-led-config-show-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, SoundPressureLevelBricklet, 239, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_status_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, SoundPressureLevelBricklet, 240, (), '', 'B', args.execute, False, ['config'], [{0: 'status-led-config-off', 1: 'status-led-config-on', 2: 'status-led-config-show-heartbeat', 3: 'status-led-config-show-status'}])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, SoundPressureLevelBricklet, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, SoundPressureLevelBricklet, 243, (), '', '', None, args.expect_response, [], [])

	def write_uid(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-uid')

		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')

		args = parser.parse_args(argv)

		device_call(ctx, SoundPressureLevelBricklet, 248, (args.uid,), 'I', '', None, args.expect_response, [], [])

	def read_uid(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-uid')

		args = parser.parse_args(argv)

		device_call(ctx, SoundPressureLevelBricklet, 249, (), '', 'I', args.execute, False, ['uid'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, SoundPressureLevelBricklet, argv)

	functions = {
	'get-decibel': get_decibel,
	'set-decibel-callback-configuration': set_decibel_callback_configuration,
	'get-decibel-callback-configuration': get_decibel_callback_configuration,
	'get-spectrum-low-level': get_spectrum_low_level,
	'get-spectrum': get_spectrum,
	'set-spectrum-callback-configuration': set_spectrum_callback_configuration,
	'get-spectrum-callback-configuration': get_spectrum_callback_configuration,
	'set-configuration': set_configuration,
	'get-configuration': get_configuration,
	'get-spitfp-error-count': get_spitfp_error_count,
	'set-bootloader-mode': set_bootloader_mode,
	'get-bootloader-mode': get_bootloader_mode,
	'set-write-firmware-pointer': set_write_firmware_pointer,
	'write-firmware': write_firmware,
	'set-status-led-config': set_status_led_config,
	'get-status-led-config': get_status_led_config,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'write-uid': write_uid,
	'read-uid': read_uid,
	'get-identity': get_identity
	}

	call_generic(ctx, 'sound-pressure-level-bricklet', functions, argv)

def dispatch_sound_pressure_level_bricklet(ctx, argv):
	prog_prefix = 'dispatch sound-pressure-level-bricklet <uid>'

	def decibel(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' decibel')

		args = parser.parse_args(argv)

		device_dispatch(ctx, SoundPressureLevelBricklet, 4, args.execute, ['decibel'], [None])

	def spectrum_low_level(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' spectrum-low-level')

		args = parser.parse_args(argv)

		device_dispatch(ctx, SoundPressureLevelBricklet, 8, args.execute, ['spectrum-length', 'spectrum-chunk-offset', 'spectrum-chunk-data'], [None, None, None])

	def spectrum(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' spectrum')

		args = parser.parse_args(argv)

		device_dispatch(ctx, SoundPressureLevelBricklet, -8, args.execute, ['spectrum'], [None])

	callbacks = {
	'decibel': decibel,
	'spectrum-low-level': spectrum_low_level,
	'spectrum': spectrum
	}

	dispatch_generic(ctx, 'sound-pressure-level-bricklet', callbacks, argv)

class StepperBrick(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 3; re[2] = 1; re[3] = 1; re[4] = 3; re[5] = 1; re[6] = 3; re[7] = 3; re[8] = 1; re[9] = 3; re[10] = 1; re[11] = 3; re[12] = 1; re[13] = 1; re[14] = 3; re[15] = 1; re[16] = 3; re[17] = 3; re[18] = 3; re[19] = 1; re[20] = 1; re[21] = 1; re[22] = 3; re[23] = 1; re[24] = 3; re[25] = 3; re[26] = 1; re[27] = 3; re[28] = 1; re[29] = 2; re[30] = 1; re[33] = 3; re[34] = 1; re[35] = 3; re[36] = 1; re[37] = 1; re[38] = 2; re[39] = 1; re[231] = 3; re[232] = 1; re[233] = 1; re[234] = 3; re[235] = 1; re[237] = 1; re[238] = 3; re[239] = 3; re[240] = 1; re[241] = 1; re[242] = 1; re[243] = 3; re[255] = 1
		cf = self.callback_formats
		cf[31] = 'H'; cf[32] = 'i'; cf[40] = 'H i i H H H'; cf[41] = 'B B'


def call_stepper_brick(ctx, argv):
	prog_prefix = 'call stepper-brick <uid>'

	def set_max_velocity(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-max-velocity')

		parser.add_argument('velocity', type=convert_int, help='int', metavar='<velocity>')

		args = parser.parse_args(argv)

		device_call(ctx, StepperBrick, 1, (args.velocity,), 'H', '', None, args.expect_response, [], [])

	def get_max_velocity(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-max-velocity')

		args = parser.parse_args(argv)

		device_call(ctx, StepperBrick, 2, (), '', 'H', args.execute, False, ['velocity'], [None])

	def get_current_velocity(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-current-velocity')

		args = parser.parse_args(argv)

		device_call(ctx, StepperBrick, 3, (), '', 'H', args.execute, False, ['velocity'], [None])

	def set_speed_ramping(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-speed-ramping')

		parser.add_argument('acceleration', type=convert_int, help='int', metavar='<acceleration>')
		parser.add_argument('deacceleration', type=convert_int, help='int', metavar='<deacceleration>')

		args = parser.parse_args(argv)

		device_call(ctx, StepperBrick, 4, (args.acceleration, args.deacceleration), 'H H', '', None, args.expect_response, [], [])

	def get_speed_ramping(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-speed-ramping')

		args = parser.parse_args(argv)

		device_call(ctx, StepperBrick, 5, (), '', 'H H', args.execute, False, ['acceleration', 'deacceleration'], [None, None])

	def full_brake(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' full-brake')

		args = parser.parse_args(argv)

		device_call(ctx, StepperBrick, 6, (), '', '', None, args.expect_response, [], [])

	def set_current_position(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-current-position')

		parser.add_argument('position', type=convert_int, help='int', metavar='<position>')

		args = parser.parse_args(argv)

		device_call(ctx, StepperBrick, 7, (args.position,), 'i', '', None, args.expect_response, [], [])

	def get_current_position(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-current-position')

		args = parser.parse_args(argv)

		device_call(ctx, StepperBrick, 8, (), '', 'i', args.execute, False, ['position'], [None])

	def set_target_position(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-target-position')

		parser.add_argument('position', type=convert_int, help='int', metavar='<position>')

		args = parser.parse_args(argv)

		device_call(ctx, StepperBrick, 9, (args.position,), 'i', '', None, args.expect_response, [], [])

	def get_target_position(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-target-position')

		args = parser.parse_args(argv)

		device_call(ctx, StepperBrick, 10, (), '', 'i', args.execute, False, ['position'], [None])

	def set_steps(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-steps')

		parser.add_argument('steps', type=convert_int, help='int', metavar='<steps>')

		args = parser.parse_args(argv)

		device_call(ctx, StepperBrick, 11, (args.steps,), 'i', '', None, args.expect_response, [], [])

	def get_steps(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-steps')

		args = parser.parse_args(argv)

		device_call(ctx, StepperBrick, 12, (), '', 'i', args.execute, False, ['steps'], [None])

	def get_remaining_steps(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-remaining-steps')

		args = parser.parse_args(argv)

		device_call(ctx, StepperBrick, 13, (), '', 'i', args.execute, False, ['steps'], [None])

	def set_step_mode(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-step-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'step-mode-full-step': 1, 'step-mode-half-step': 2, 'step-mode-quarter-step': 4, 'step-mode-eighth-step': 8}), help='int (step-mode-full-step: 1, step-mode-half-step: 2, step-mode-quarter-step: 4, step-mode-eighth-step: 8)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, StepperBrick, 14, (args.mode,), 'B', '', None, args.expect_response, [], [])

	def get_step_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-step-mode')

		args = parser.parse_args(argv)

		device_call(ctx, StepperBrick, 15, (), '', 'B', args.execute, False, ['mode'], [{8: 'step-mode-eighth-step', 1: 'step-mode-full-step', 2: 'step-mode-half-step', 4: 'step-mode-quarter-step'}])

	def drive_forward(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' drive-forward')

		args = parser.parse_args(argv)

		device_call(ctx, StepperBrick, 16, (), '', '', None, args.expect_response, [], [])

	def drive_backward(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' drive-backward')

		args = parser.parse_args(argv)

		device_call(ctx, StepperBrick, 17, (), '', '', None, args.expect_response, [], [])

	def stop(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' stop')

		args = parser.parse_args(argv)

		device_call(ctx, StepperBrick, 18, (), '', '', None, args.expect_response, [], [])

	def get_stack_input_voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-stack-input-voltage')

		args = parser.parse_args(argv)

		device_call(ctx, StepperBrick, 19, (), '', 'H', args.execute, False, ['voltage'], [None])

	def get_external_input_voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-external-input-voltage')

		args = parser.parse_args(argv)

		device_call(ctx, StepperBrick, 20, (), '', 'H', args.execute, False, ['voltage'], [None])

	def get_current_consumption(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-current-consumption')

		args = parser.parse_args(argv)

		device_call(ctx, StepperBrick, 21, (), '', 'H', args.execute, False, ['current'], [None])

	def set_motor_current(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-motor-current')

		parser.add_argument('current', type=convert_int, help='int', metavar='<current>')

		args = parser.parse_args(argv)

		device_call(ctx, StepperBrick, 22, (args.current,), 'H', '', None, args.expect_response, [], [])

	def get_motor_current(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-motor-current')

		args = parser.parse_args(argv)

		device_call(ctx, StepperBrick, 23, (), '', 'H', args.execute, False, ['current'], [None])

	def enable(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' enable')

		args = parser.parse_args(argv)

		device_call(ctx, StepperBrick, 24, (), '', '', None, args.expect_response, [], [])

	def disable(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' disable')

		args = parser.parse_args(argv)

		device_call(ctx, StepperBrick, 25, (), '', '', None, args.expect_response, [], [])

	def is_enabled(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' is-enabled')

		args = parser.parse_args(argv)

		device_call(ctx, StepperBrick, 26, (), '', '!', args.execute, False, ['enabled'], [None])

	def set_decay(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-decay')

		parser.add_argument('decay', type=convert_int, help='int', metavar='<decay>')

		args = parser.parse_args(argv)

		device_call(ctx, StepperBrick, 27, (args.decay,), 'H', '', None, args.expect_response, [], [])

	def get_decay(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-decay')

		args = parser.parse_args(argv)

		device_call(ctx, StepperBrick, 28, (), '', 'H', args.execute, False, ['decay'], [None])

	def set_minimum_voltage(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-minimum-voltage')

		parser.add_argument('voltage', type=convert_int, help='int', metavar='<voltage>')

		args = parser.parse_args(argv)

		device_call(ctx, StepperBrick, 29, (args.voltage,), 'H', '', None, args.expect_response, [], [])

	def get_minimum_voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-minimum-voltage')

		args = parser.parse_args(argv)

		device_call(ctx, StepperBrick, 30, (), '', 'H', args.execute, False, ['voltage'], [None])

	def set_sync_rect(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-sync-rect')

		parser.add_argument('sync_rect', type=convert_bool, help='bool', metavar='<sync-rect>')

		args = parser.parse_args(argv)

		device_call(ctx, StepperBrick, 33, (args.sync_rect,), '!', '', None, args.expect_response, [], [])

	def is_sync_rect(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' is-sync-rect')

		args = parser.parse_args(argv)

		device_call(ctx, StepperBrick, 34, (), '', '!', args.execute, False, ['sync-rect'], [None])

	def set_time_base(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-time-base')

		parser.add_argument('time_base', type=convert_int, help='int', metavar='<time-base>')

		args = parser.parse_args(argv)

		device_call(ctx, StepperBrick, 35, (args.time_base,), 'I', '', None, args.expect_response, [], [])

	def get_time_base(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-time-base')

		args = parser.parse_args(argv)

		device_call(ctx, StepperBrick, 36, (), '', 'I', args.execute, False, ['time-base'], [None])

	def get_all_data(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-all-data')

		args = parser.parse_args(argv)

		device_call(ctx, StepperBrick, 37, (), '', 'H i i H H H', args.execute, False, ['current-velocity', 'current-position', 'remaining-steps', 'stack-voltage', 'external-voltage', 'current-consumption'], [None, None, None, None, None, None])

	def set_all_data_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-all-data-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, StepperBrick, 38, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_all_data_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-all-data-period')

		args = parser.parse_args(argv)

		device_call(ctx, StepperBrick, 39, (), '', 'I', args.execute, False, ['period'], [None])

	def set_spitfp_baudrate_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-spitfp-baudrate-config')

		parser.add_argument('enable_dynamic_baudrate', type=convert_bool, help='bool', metavar='<enable-dynamic-baudrate>')
		parser.add_argument('minimum_dynamic_baudrate', type=convert_int, help='int', metavar='<minimum-dynamic-baudrate>')

		args = parser.parse_args(argv)

		device_call(ctx, StepperBrick, 231, (args.enable_dynamic_baudrate, args.minimum_dynamic_baudrate), '! I', '', None, args.expect_response, [], [])

	def get_spitfp_baudrate_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-baudrate-config')

		args = parser.parse_args(argv)

		device_call(ctx, StepperBrick, 232, (), '', '! I', args.execute, False, ['enable-dynamic-baudrate', 'minimum-dynamic-baudrate'], [None, None])

	def get_send_timeout_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-send-timeout-count')

		parser.add_argument('communication_method', type=create_symbol_converter(ctx, convert_int, {'communication-method-none': 0, 'communication-method-rs485': 4, 'communication-method-usb': 1, 'communication-method-wifi-v2': 7, 'communication-method-spi-stack': 2, 'communication-method-wifi': 5, 'communication-method-chibi': 3, 'communication-method-ethernet': 6}), help='int (communication-method-none: 0, communication-method-usb: 1, communication-method-spi-stack: 2, communication-method-chibi: 3, communication-method-rs485: 4, communication-method-wifi: 5, communication-method-ethernet: 6, communication-method-wifi-v2: 7)', metavar='<communication-method>')

		args = parser.parse_args(argv)

		device_call(ctx, StepperBrick, 233, (args.communication_method,), 'B', 'I', args.execute, False, ['timeout-count'], [None])

	def set_spitfp_baudrate(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-spitfp-baudrate')

		parser.add_argument('bricklet_port', type=create_char_converter(ctx), help='char', metavar='<bricklet-port>')
		parser.add_argument('baudrate', type=convert_int, help='int', metavar='<baudrate>')

		args = parser.parse_args(argv)

		device_call(ctx, StepperBrick, 234, (args.bricklet_port, args.baudrate), 'c I', '', None, args.expect_response, [], [])

	def get_spitfp_baudrate(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-baudrate')

		parser.add_argument('bricklet_port', type=create_char_converter(ctx), help='char', metavar='<bricklet-port>')

		args = parser.parse_args(argv)

		device_call(ctx, StepperBrick, 235, (args.bricklet_port,), 'c', 'I', args.execute, False, ['baudrate'], [None])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		parser.add_argument('bricklet_port', type=create_char_converter(ctx), help='char', metavar='<bricklet-port>')

		args = parser.parse_args(argv)

		device_call(ctx, StepperBrick, 237, (args.bricklet_port,), 'c', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def enable_status_led(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' enable-status-led')

		args = parser.parse_args(argv)

		device_call(ctx, StepperBrick, 238, (), '', '', None, args.expect_response, [], [])

	def disable_status_led(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' disable-status-led')

		args = parser.parse_args(argv)

		device_call(ctx, StepperBrick, 239, (), '', '', None, args.expect_response, [], [])

	def is_status_led_enabled(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' is-status-led-enabled')

		args = parser.parse_args(argv)

		device_call(ctx, StepperBrick, 240, (), '', '!', args.execute, False, ['enabled'], [None])

	def get_protocol1_bricklet_name(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-protocol1-bricklet-name')

		parser.add_argument('port', type=create_char_converter(ctx), help='char', metavar='<port>')

		args = parser.parse_args(argv)

		device_call(ctx, StepperBrick, 241, (args.port,), 'c', 'B 3B 40s', args.execute, False, ['protocol-version', 'firmware-version', 'name'], [None, None, None])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, StepperBrick, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, StepperBrick, 243, (), '', '', None, args.expect_response, [], [])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, StepperBrick, argv)

	functions = {
	'set-max-velocity': set_max_velocity,
	'get-max-velocity': get_max_velocity,
	'get-current-velocity': get_current_velocity,
	'set-speed-ramping': set_speed_ramping,
	'get-speed-ramping': get_speed_ramping,
	'full-brake': full_brake,
	'set-current-position': set_current_position,
	'get-current-position': get_current_position,
	'set-target-position': set_target_position,
	'get-target-position': get_target_position,
	'set-steps': set_steps,
	'get-steps': get_steps,
	'get-remaining-steps': get_remaining_steps,
	'set-step-mode': set_step_mode,
	'get-step-mode': get_step_mode,
	'drive-forward': drive_forward,
	'drive-backward': drive_backward,
	'stop': stop,
	'get-stack-input-voltage': get_stack_input_voltage,
	'get-external-input-voltage': get_external_input_voltage,
	'get-current-consumption': get_current_consumption,
	'set-motor-current': set_motor_current,
	'get-motor-current': get_motor_current,
	'enable': enable,
	'disable': disable,
	'is-enabled': is_enabled,
	'set-decay': set_decay,
	'get-decay': get_decay,
	'set-minimum-voltage': set_minimum_voltage,
	'get-minimum-voltage': get_minimum_voltage,
	'set-sync-rect': set_sync_rect,
	'is-sync-rect': is_sync_rect,
	'set-time-base': set_time_base,
	'get-time-base': get_time_base,
	'get-all-data': get_all_data,
	'set-all-data-period': set_all_data_period,
	'get-all-data-period': get_all_data_period,
	'set-spitfp-baudrate-config': set_spitfp_baudrate_config,
	'get-spitfp-baudrate-config': get_spitfp_baudrate_config,
	'get-send-timeout-count': get_send_timeout_count,
	'set-spitfp-baudrate': set_spitfp_baudrate,
	'get-spitfp-baudrate': get_spitfp_baudrate,
	'get-spitfp-error-count': get_spitfp_error_count,
	'enable-status-led': enable_status_led,
	'disable-status-led': disable_status_led,
	'is-status-led-enabled': is_status_led_enabled,
	'get-protocol1-bricklet-name': get_protocol1_bricklet_name,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'get-identity': get_identity
	}

	call_generic(ctx, 'stepper-brick', functions, argv)

def dispatch_stepper_brick(ctx, argv):
	prog_prefix = 'dispatch stepper-brick <uid>'

	def under_voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' under-voltage')

		args = parser.parse_args(argv)

		device_dispatch(ctx, StepperBrick, 31, args.execute, ['voltage'], [None])

	def position_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' position-reached')

		args = parser.parse_args(argv)

		device_dispatch(ctx, StepperBrick, 32, args.execute, ['position'], [None])

	def all_data(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' all-data')

		args = parser.parse_args(argv)

		device_dispatch(ctx, StepperBrick, 40, args.execute, ['current-velocity', 'current-position', 'remaining-steps', 'stack-voltage', 'external-voltage', 'current-consumption'], [None, None, None, None, None, None])

	def new_state(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' new-state')

		args = parser.parse_args(argv)

		device_dispatch(ctx, StepperBrick, 41, args.execute, ['state-new', 'state-previous'], [{1: 'state-stop', 2: 'state-acceleration', 3: 'state-run', 4: 'state-deacceleration', 5: 'state-direction-change-to-forward', 6: 'state-direction-change-to-backward'}, {1: 'state-stop', 2: 'state-acceleration', 3: 'state-run', 4: 'state-deacceleration', 5: 'state-direction-change-to-forward', 6: 'state-direction-change-to-backward'}])

	callbacks = {
	'under-voltage': under_voltage,
	'position-reached': position_reached,
	'all-data': all_data,
	'new-state': new_state
	}

	dispatch_generic(ctx, 'stepper-brick', callbacks, argv)

class TemperatureBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 2; re[3] = 1; re[4] = 2; re[5] = 1; re[6] = 2; re[7] = 1; re[10] = 3; re[11] = 1; re[255] = 1
		cf = self.callback_formats
		cf[8] = 'h'; cf[9] = 'h'


def call_temperature_bricklet(ctx, argv):
	prog_prefix = 'call temperature-bricklet <uid>'

	def get_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, TemperatureBricklet, 1, (), '', 'h', args.execute, False, ['temperature'], [None])

	def set_temperature_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-temperature-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, TemperatureBricklet, 2, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_temperature_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-temperature-callback-period')

		args = parser.parse_args(argv)

		device_call(ctx, TemperatureBricklet, 3, (), '', 'I', args.execute, False, ['period'], [None])

	def set_temperature_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-temperature-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, TemperatureBricklet, 4, (args.option, args.min, args.max), 'c h h', '', None, args.expect_response, [], [])

	def get_temperature_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-temperature-callback-threshold')

		args = parser.parse_args(argv)

		device_call(ctx, TemperatureBricklet, 5, (), '', 'c h h', args.execute, False, ['option', 'min', 'max'], [{'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def set_debounce_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-debounce-period')

		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_call(ctx, TemperatureBricklet, 6, (args.debounce,), 'I', '', None, args.expect_response, [], [])

	def get_debounce_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-debounce-period')

		args = parser.parse_args(argv)

		device_call(ctx, TemperatureBricklet, 7, (), '', 'I', args.execute, False, ['debounce'], [None])

	def set_i2c_mode(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-i2c-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'i2c-mode-fast': 0, 'i2c-mode-slow': 1}), help='int (i2c-mode-fast: 0, i2c-mode-slow: 1)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, TemperatureBricklet, 10, (args.mode,), 'B', '', None, args.expect_response, [], [])

	def get_i2c_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-i2c-mode')

		args = parser.parse_args(argv)

		device_call(ctx, TemperatureBricklet, 11, (), '', 'B', args.execute, False, ['mode'], [{0: 'i2c-mode-fast', 1: 'i2c-mode-slow'}])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, TemperatureBricklet, argv)

	functions = {
	'get-temperature': get_temperature,
	'set-temperature-callback-period': set_temperature_callback_period,
	'get-temperature-callback-period': get_temperature_callback_period,
	'set-temperature-callback-threshold': set_temperature_callback_threshold,
	'get-temperature-callback-threshold': get_temperature_callback_threshold,
	'set-debounce-period': set_debounce_period,
	'get-debounce-period': get_debounce_period,
	'set-i2c-mode': set_i2c_mode,
	'get-i2c-mode': get_i2c_mode,
	'get-identity': get_identity
	}

	call_generic(ctx, 'temperature-bricklet', functions, argv)

def dispatch_temperature_bricklet(ctx, argv):
	prog_prefix = 'dispatch temperature-bricklet <uid>'

	def temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' temperature')

		args = parser.parse_args(argv)

		device_dispatch(ctx, TemperatureBricklet, 8, args.execute, ['temperature'], [None])

	def temperature_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' temperature-reached')

		args = parser.parse_args(argv)

		device_dispatch(ctx, TemperatureBricklet, 9, args.execute, ['temperature'], [None])

	callbacks = {
	'temperature': temperature,
	'temperature-reached': temperature_reached
	}

	dispatch_generic(ctx, 'temperature-bricklet', callbacks, argv)

class TemperatureIRBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 1; re[3] = 3; re[4] = 1; re[5] = 2; re[6] = 1; re[7] = 2; re[8] = 1; re[9] = 2; re[10] = 1; re[11] = 2; re[12] = 1; re[13] = 2; re[14] = 1; re[255] = 1
		cf = self.callback_formats
		cf[15] = 'h'; cf[16] = 'h'; cf[17] = 'h'; cf[18] = 'h'


def call_temperature_ir_bricklet(ctx, argv):
	prog_prefix = 'call temperature-ir-bricklet <uid>'

	def get_ambient_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-ambient-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, TemperatureIRBricklet, 1, (), '', 'h', args.execute, False, ['temperature'], [None])

	def get_object_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-object-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, TemperatureIRBricklet, 2, (), '', 'h', args.execute, False, ['temperature'], [None])

	def set_emissivity(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-emissivity')

		parser.add_argument('emissivity', type=convert_int, help='int', metavar='<emissivity>')

		args = parser.parse_args(argv)

		device_call(ctx, TemperatureIRBricklet, 3, (args.emissivity,), 'H', '', None, args.expect_response, [], [])

	def get_emissivity(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-emissivity')

		args = parser.parse_args(argv)

		device_call(ctx, TemperatureIRBricklet, 4, (), '', 'H', args.execute, False, ['emissivity'], [None])

	def set_ambient_temperature_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-ambient-temperature-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, TemperatureIRBricklet, 5, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_ambient_temperature_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-ambient-temperature-callback-period')

		args = parser.parse_args(argv)

		device_call(ctx, TemperatureIRBricklet, 6, (), '', 'I', args.execute, False, ['period'], [None])

	def set_object_temperature_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-object-temperature-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, TemperatureIRBricklet, 7, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_object_temperature_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-object-temperature-callback-period')

		args = parser.parse_args(argv)

		device_call(ctx, TemperatureIRBricklet, 8, (), '', 'I', args.execute, False, ['period'], [None])

	def set_ambient_temperature_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-ambient-temperature-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, TemperatureIRBricklet, 9, (args.option, args.min, args.max), 'c h h', '', None, args.expect_response, [], [])

	def get_ambient_temperature_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-ambient-temperature-callback-threshold')

		args = parser.parse_args(argv)

		device_call(ctx, TemperatureIRBricklet, 10, (), '', 'c h h', args.execute, False, ['option', 'min', 'max'], [{'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def set_object_temperature_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-object-temperature-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, TemperatureIRBricklet, 11, (args.option, args.min, args.max), 'c h h', '', None, args.expect_response, [], [])

	def get_object_temperature_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-object-temperature-callback-threshold')

		args = parser.parse_args(argv)

		device_call(ctx, TemperatureIRBricklet, 12, (), '', 'c h h', args.execute, False, ['option', 'min', 'max'], [{'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def set_debounce_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-debounce-period')

		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_call(ctx, TemperatureIRBricklet, 13, (args.debounce,), 'I', '', None, args.expect_response, [], [])

	def get_debounce_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-debounce-period')

		args = parser.parse_args(argv)

		device_call(ctx, TemperatureIRBricklet, 14, (), '', 'I', args.execute, False, ['debounce'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, TemperatureIRBricklet, argv)

	functions = {
	'get-ambient-temperature': get_ambient_temperature,
	'get-object-temperature': get_object_temperature,
	'set-emissivity': set_emissivity,
	'get-emissivity': get_emissivity,
	'set-ambient-temperature-callback-period': set_ambient_temperature_callback_period,
	'get-ambient-temperature-callback-period': get_ambient_temperature_callback_period,
	'set-object-temperature-callback-period': set_object_temperature_callback_period,
	'get-object-temperature-callback-period': get_object_temperature_callback_period,
	'set-ambient-temperature-callback-threshold': set_ambient_temperature_callback_threshold,
	'get-ambient-temperature-callback-threshold': get_ambient_temperature_callback_threshold,
	'set-object-temperature-callback-threshold': set_object_temperature_callback_threshold,
	'get-object-temperature-callback-threshold': get_object_temperature_callback_threshold,
	'set-debounce-period': set_debounce_period,
	'get-debounce-period': get_debounce_period,
	'get-identity': get_identity
	}

	call_generic(ctx, 'temperature-ir-bricklet', functions, argv)

def dispatch_temperature_ir_bricklet(ctx, argv):
	prog_prefix = 'dispatch temperature-ir-bricklet <uid>'

	def ambient_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' ambient-temperature')

		args = parser.parse_args(argv)

		device_dispatch(ctx, TemperatureIRBricklet, 15, args.execute, ['temperature'], [None])

	def object_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' object-temperature')

		args = parser.parse_args(argv)

		device_dispatch(ctx, TemperatureIRBricklet, 16, args.execute, ['temperature'], [None])

	def ambient_temperature_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' ambient-temperature-reached')

		args = parser.parse_args(argv)

		device_dispatch(ctx, TemperatureIRBricklet, 17, args.execute, ['temperature'], [None])

	def object_temperature_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' object-temperature-reached')

		args = parser.parse_args(argv)

		device_dispatch(ctx, TemperatureIRBricklet, 18, args.execute, ['temperature'], [None])

	callbacks = {
	'ambient-temperature': ambient_temperature,
	'object-temperature': object_temperature,
	'ambient-temperature-reached': ambient_temperature_reached,
	'object-temperature-reached': object_temperature_reached
	}

	dispatch_generic(ctx, 'temperature-ir-bricklet', callbacks, argv)

class TemperatureIRV2Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 2; re[3] = 1; re[5] = 1; re[6] = 2; re[7] = 1; re[9] = 3; re[10] = 1; re[234] = 1; re[235] = 1; re[236] = 1; re[237] = 3; re[238] = 1; re[239] = 3; re[240] = 1; re[242] = 1; re[243] = 3; re[248] = 3; re[249] = 1; re[255] = 1
		cf = self.callback_formats
		cf[4] = 'h'; cf[8] = 'h'


def call_temperature_ir_v2_bricklet(ctx, argv):
	prog_prefix = 'call temperature-ir-v2-bricklet <uid>'

	def get_ambient_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-ambient-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, TemperatureIRV2Bricklet, 1, (), '', 'h', args.execute, False, ['temperature'], [None])

	def set_ambient_temperature_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-ambient-temperature-callback-configuration')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')
		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, TemperatureIRV2Bricklet, 2, (args.period, args.value_has_to_change, args.option, args.min, args.max), 'I ! c h h', '', None, args.expect_response, [], [])

	def get_ambient_temperature_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-ambient-temperature-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, TemperatureIRV2Bricklet, 3, (), '', 'I ! c h h', args.execute, False, ['period', 'value-has-to-change', 'option', 'min', 'max'], [None, None, {'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def get_object_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-object-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, TemperatureIRV2Bricklet, 5, (), '', 'h', args.execute, False, ['temperature'], [None])

	def set_object_temperature_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-object-temperature-callback-configuration')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')
		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, TemperatureIRV2Bricklet, 6, (args.period, args.value_has_to_change, args.option, args.min, args.max), 'I ! c h h', '', None, args.expect_response, [], [])

	def get_object_temperature_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-object-temperature-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, TemperatureIRV2Bricklet, 7, (), '', 'I ! c h h', args.execute, False, ['period', 'value-has-to-change', 'option', 'min', 'max'], [None, None, {'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def set_emissivity(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-emissivity')

		parser.add_argument('emissivity', type=convert_int, help='int', metavar='<emissivity>')

		args = parser.parse_args(argv)

		device_call(ctx, TemperatureIRV2Bricklet, 9, (args.emissivity,), 'H', '', None, args.expect_response, [], [])

	def get_emissivity(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-emissivity')

		args = parser.parse_args(argv)

		device_call(ctx, TemperatureIRV2Bricklet, 10, (), '', 'H', args.execute, False, ['emissivity'], [None])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, TemperatureIRV2Bricklet, 234, (), '', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def set_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-bootloader-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'bootloader-mode-firmware-wait-for-reboot': 3, 'bootloader-mode-firmware': 1, 'bootloader-mode-firmware-wait-for-erase-and-reboot': 4, 'bootloader-mode-bootloader-wait-for-reboot': 2, 'bootloader-mode-bootloader': 0}), help='int (bootloader-mode-bootloader: 0, bootloader-mode-firmware: 1, bootloader-mode-bootloader-wait-for-reboot: 2, bootloader-mode-firmware-wait-for-reboot: 3, bootloader-mode-firmware-wait-for-erase-and-reboot: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, TemperatureIRV2Bricklet, 235, (args.mode,), 'B', 'B', args.execute, False, ['status'], [{0: 'bootloader-status-ok', 1: 'bootloader-status-invalid-mode', 2: 'bootloader-status-no-change', 3: 'bootloader-status-entry-function-not-present', 4: 'bootloader-status-device-identifier-incorrect', 5: 'bootloader-status-crc-mismatch'}])

	def get_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-bootloader-mode')

		args = parser.parse_args(argv)

		device_call(ctx, TemperatureIRV2Bricklet, 236, (), '', 'B', args.execute, False, ['mode'], [{0: 'bootloader-mode-bootloader', 1: 'bootloader-mode-firmware', 2: 'bootloader-mode-bootloader-wait-for-reboot', 3: 'bootloader-mode-firmware-wait-for-reboot', 4: 'bootloader-mode-firmware-wait-for-erase-and-reboot'}])

	def set_write_firmware_pointer(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-write-firmware-pointer')

		parser.add_argument('pointer', type=convert_int, help='int', metavar='<pointer>')

		args = parser.parse_args(argv)

		device_call(ctx, TemperatureIRV2Bricklet, 237, (args.pointer,), 'I', '', None, args.expect_response, [], [])

	def write_firmware(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-firmware')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, TemperatureIRV2Bricklet, 238, (args.data,), '64B', 'B', args.execute, False, ['status'], [None])

	def set_status_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'status-led-config-on': 1, 'status-led-config-show-heartbeat': 2, 'status-led-config-off': 0, 'status-led-config-show-status': 3}), help='int (status-led-config-off: 0, status-led-config-on: 1, status-led-config-show-heartbeat: 2, status-led-config-show-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, TemperatureIRV2Bricklet, 239, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_status_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, TemperatureIRV2Bricklet, 240, (), '', 'B', args.execute, False, ['config'], [{0: 'status-led-config-off', 1: 'status-led-config-on', 2: 'status-led-config-show-heartbeat', 3: 'status-led-config-show-status'}])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, TemperatureIRV2Bricklet, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, TemperatureIRV2Bricklet, 243, (), '', '', None, args.expect_response, [], [])

	def write_uid(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-uid')

		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')

		args = parser.parse_args(argv)

		device_call(ctx, TemperatureIRV2Bricklet, 248, (args.uid,), 'I', '', None, args.expect_response, [], [])

	def read_uid(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-uid')

		args = parser.parse_args(argv)

		device_call(ctx, TemperatureIRV2Bricklet, 249, (), '', 'I', args.execute, False, ['uid'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, TemperatureIRV2Bricklet, argv)

	functions = {
	'get-ambient-temperature': get_ambient_temperature,
	'set-ambient-temperature-callback-configuration': set_ambient_temperature_callback_configuration,
	'get-ambient-temperature-callback-configuration': get_ambient_temperature_callback_configuration,
	'get-object-temperature': get_object_temperature,
	'set-object-temperature-callback-configuration': set_object_temperature_callback_configuration,
	'get-object-temperature-callback-configuration': get_object_temperature_callback_configuration,
	'set-emissivity': set_emissivity,
	'get-emissivity': get_emissivity,
	'get-spitfp-error-count': get_spitfp_error_count,
	'set-bootloader-mode': set_bootloader_mode,
	'get-bootloader-mode': get_bootloader_mode,
	'set-write-firmware-pointer': set_write_firmware_pointer,
	'write-firmware': write_firmware,
	'set-status-led-config': set_status_led_config,
	'get-status-led-config': get_status_led_config,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'write-uid': write_uid,
	'read-uid': read_uid,
	'get-identity': get_identity
	}

	call_generic(ctx, 'temperature-ir-v2-bricklet', functions, argv)

def dispatch_temperature_ir_v2_bricklet(ctx, argv):
	prog_prefix = 'dispatch temperature-ir-v2-bricklet <uid>'

	def ambient_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' ambient-temperature')

		args = parser.parse_args(argv)

		device_dispatch(ctx, TemperatureIRV2Bricklet, 4, args.execute, ['temperature'], [None])

	def object_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' object-temperature')

		args = parser.parse_args(argv)

		device_dispatch(ctx, TemperatureIRV2Bricklet, 8, args.execute, ['temperature'], [None])

	callbacks = {
	'ambient-temperature': ambient_temperature,
	'object-temperature': object_temperature
	}

	dispatch_generic(ctx, 'temperature-ir-v2-bricklet', callbacks, argv)

class TemperatureV2Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 2; re[3] = 1; re[5] = 3; re[6] = 1; re[234] = 1; re[235] = 1; re[236] = 1; re[237] = 3; re[238] = 1; re[239] = 3; re[240] = 1; re[242] = 1; re[243] = 3; re[248] = 3; re[249] = 1; re[255] = 1
		cf = self.callback_formats
		cf[4] = 'h'


def call_temperature_v2_bricklet(ctx, argv):
	prog_prefix = 'call temperature-v2-bricklet <uid>'

	def get_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, TemperatureV2Bricklet, 1, (), '', 'h', args.execute, False, ['temperature'], [None])

	def set_temperature_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-temperature-callback-configuration')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')
		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, TemperatureV2Bricklet, 2, (args.period, args.value_has_to_change, args.option, args.min, args.max), 'I ! c h h', '', None, args.expect_response, [], [])

	def get_temperature_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-temperature-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, TemperatureV2Bricklet, 3, (), '', 'I ! c h h', args.execute, False, ['period', 'value-has-to-change', 'option', 'min', 'max'], [None, None, {'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def set_heater_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-heater-configuration')

		parser.add_argument('heater_config', type=create_symbol_converter(ctx, convert_int, {'heater-config-enabled': 1, 'heater-config-disabled': 0}), help='int (heater-config-disabled: 0, heater-config-enabled: 1)', metavar='<heater-config>')

		args = parser.parse_args(argv)

		device_call(ctx, TemperatureV2Bricklet, 5, (args.heater_config,), 'B', '', None, args.expect_response, [], [])

	def get_heater_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-heater-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, TemperatureV2Bricklet, 6, (), '', 'B', args.execute, False, ['heater-config'], [{0: 'heater-config-disabled', 1: 'heater-config-enabled'}])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, TemperatureV2Bricklet, 234, (), '', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def set_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-bootloader-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'bootloader-mode-firmware-wait-for-reboot': 3, 'bootloader-mode-firmware': 1, 'bootloader-mode-firmware-wait-for-erase-and-reboot': 4, 'bootloader-mode-bootloader-wait-for-reboot': 2, 'bootloader-mode-bootloader': 0}), help='int (bootloader-mode-bootloader: 0, bootloader-mode-firmware: 1, bootloader-mode-bootloader-wait-for-reboot: 2, bootloader-mode-firmware-wait-for-reboot: 3, bootloader-mode-firmware-wait-for-erase-and-reboot: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, TemperatureV2Bricklet, 235, (args.mode,), 'B', 'B', args.execute, False, ['status'], [{0: 'bootloader-status-ok', 1: 'bootloader-status-invalid-mode', 2: 'bootloader-status-no-change', 3: 'bootloader-status-entry-function-not-present', 4: 'bootloader-status-device-identifier-incorrect', 5: 'bootloader-status-crc-mismatch'}])

	def get_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-bootloader-mode')

		args = parser.parse_args(argv)

		device_call(ctx, TemperatureV2Bricklet, 236, (), '', 'B', args.execute, False, ['mode'], [{0: 'bootloader-mode-bootloader', 1: 'bootloader-mode-firmware', 2: 'bootloader-mode-bootloader-wait-for-reboot', 3: 'bootloader-mode-firmware-wait-for-reboot', 4: 'bootloader-mode-firmware-wait-for-erase-and-reboot'}])

	def set_write_firmware_pointer(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-write-firmware-pointer')

		parser.add_argument('pointer', type=convert_int, help='int', metavar='<pointer>')

		args = parser.parse_args(argv)

		device_call(ctx, TemperatureV2Bricklet, 237, (args.pointer,), 'I', '', None, args.expect_response, [], [])

	def write_firmware(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-firmware')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, TemperatureV2Bricklet, 238, (args.data,), '64B', 'B', args.execute, False, ['status'], [None])

	def set_status_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'status-led-config-on': 1, 'status-led-config-show-heartbeat': 2, 'status-led-config-off': 0, 'status-led-config-show-status': 3}), help='int (status-led-config-off: 0, status-led-config-on: 1, status-led-config-show-heartbeat: 2, status-led-config-show-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, TemperatureV2Bricklet, 239, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_status_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, TemperatureV2Bricklet, 240, (), '', 'B', args.execute, False, ['config'], [{0: 'status-led-config-off', 1: 'status-led-config-on', 2: 'status-led-config-show-heartbeat', 3: 'status-led-config-show-status'}])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, TemperatureV2Bricklet, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, TemperatureV2Bricklet, 243, (), '', '', None, args.expect_response, [], [])

	def write_uid(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-uid')

		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')

		args = parser.parse_args(argv)

		device_call(ctx, TemperatureV2Bricklet, 248, (args.uid,), 'I', '', None, args.expect_response, [], [])

	def read_uid(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-uid')

		args = parser.parse_args(argv)

		device_call(ctx, TemperatureV2Bricklet, 249, (), '', 'I', args.execute, False, ['uid'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, TemperatureV2Bricklet, argv)

	functions = {
	'get-temperature': get_temperature,
	'set-temperature-callback-configuration': set_temperature_callback_configuration,
	'get-temperature-callback-configuration': get_temperature_callback_configuration,
	'set-heater-configuration': set_heater_configuration,
	'get-heater-configuration': get_heater_configuration,
	'get-spitfp-error-count': get_spitfp_error_count,
	'set-bootloader-mode': set_bootloader_mode,
	'get-bootloader-mode': get_bootloader_mode,
	'set-write-firmware-pointer': set_write_firmware_pointer,
	'write-firmware': write_firmware,
	'set-status-led-config': set_status_led_config,
	'get-status-led-config': get_status_led_config,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'write-uid': write_uid,
	'read-uid': read_uid,
	'get-identity': get_identity
	}

	call_generic(ctx, 'temperature-v2-bricklet', functions, argv)

def dispatch_temperature_v2_bricklet(ctx, argv):
	prog_prefix = 'dispatch temperature-v2-bricklet <uid>'

	def temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' temperature')

		args = parser.parse_args(argv)

		device_dispatch(ctx, TemperatureV2Bricklet, 4, args.execute, ['temperature'], [None])

	callbacks = {
	'temperature': temperature
	}

	dispatch_generic(ctx, 'temperature-v2-bricklet', callbacks, argv)

class ThermalImagingBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 1; re[3] = 1; re[4] = 3; re[5] = 1; re[6] = 3; re[7] = 1; re[8] = 3; re[9] = 1; re[10] = 2; re[11] = 1; re[234] = 1; re[235] = 1; re[236] = 1; re[237] = 3; re[238] = 1; re[239] = 3; re[240] = 1; re[242] = 1; re[243] = 3; re[248] = 3; re[249] = 1; re[255] = 1
		cf = self.callback_formats
		cf[12] = 'H 62B'; cf[13] = 'H 31H'
		hlc = self.high_level_callbacks
		hlc[-12] = [('stream_chunk_offset', 'stream_chunk_data'), {'fixed_length': 4800, 'single_chunk': False}, None]; hlc[-13] = [('stream_chunk_offset', 'stream_chunk_data'), {'fixed_length': 4800, 'single_chunk': False}, None]

def call_thermal_imaging_bricklet(ctx, argv):
	prog_prefix = 'call thermal-imaging-bricklet <uid>'

	def get_high_contrast_image_low_level(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-high-contrast-image-low-level')

		args = parser.parse_args(argv)

		device_call(ctx, ThermalImagingBricklet, 1, (), '', 'H 62B', args.execute, False, ['image-chunk-offset', 'image-chunk-data'], [None, None])

	def get_high_contrast_image(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-high-contrast-image')

		args = parser.parse_args(argv)

		device_stream_call(ctx, ThermalImagingBricklet, 1, 'out', (), (), ('stream_data',), (), ('stream_chunk_offset', 'stream_chunk_data'), '', 'H 62B', args.execute, False, ['image'], [None], None, 62, 65535, False, False, 4800)

	def get_temperature_image_low_level(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-temperature-image-low-level')

		args = parser.parse_args(argv)

		device_call(ctx, ThermalImagingBricklet, 2, (), '', 'H 31H', args.execute, False, ['image-chunk-offset', 'image-chunk-data'], [None, None])

	def get_temperature_image(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-temperature-image')

		args = parser.parse_args(argv)

		device_stream_call(ctx, ThermalImagingBricklet, 2, 'out', (), (), ('stream_data',), (), ('stream_chunk_offset', 'stream_chunk_data'), '', 'H 31H', args.execute, False, ['image'], [None], None, 31, 65535, False, False, 4800)

	def get_statistics(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-statistics')

		args = parser.parse_args(argv)

		device_call(ctx, ThermalImagingBricklet, 3, (), '', '4H 4H B B 2!', args.execute, False, ['spotmeter-statistics', 'temperatures', 'resolution', 'ffc-status', 'temperature-warning'], [None, None, {0: 'resolution-0-to-6553-kelvin', 1: 'resolution-0-to-655-kelvin'}, {0: 'ffc-status-never-commanded', 1: 'ffc-status-imminent', 2: 'ffc-status-in-progress', 3: 'ffc-status-complete'}, None])

	def set_resolution(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-resolution')

		parser.add_argument('resolution', type=create_symbol_converter(ctx, convert_int, {'resolution-0-to-6553-kelvin': 0, 'resolution-0-to-655-kelvin': 1}), help='int (resolution-0-to-6553-kelvin: 0, resolution-0-to-655-kelvin: 1)', metavar='<resolution>')

		args = parser.parse_args(argv)

		device_call(ctx, ThermalImagingBricklet, 4, (args.resolution,), 'B', '', None, args.expect_response, [], [])

	def get_resolution(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-resolution')

		args = parser.parse_args(argv)

		device_call(ctx, ThermalImagingBricklet, 5, (), '', 'B', args.execute, False, ['resolution'], [{0: 'resolution-0-to-6553-kelvin', 1: 'resolution-0-to-655-kelvin'}])

	def set_spotmeter_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-spotmeter-config')

		parser.add_argument('region_of_interest', type=create_array_converter(ctx, convert_int, '0', 4), help=get_array_type_name(ctx, 'int', 4), metavar='<region-of-interest>')

		args = parser.parse_args(argv)

		device_call(ctx, ThermalImagingBricklet, 6, (args.region_of_interest,), '4B', '', None, args.expect_response, [], [])

	def get_spotmeter_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spotmeter-config')

		args = parser.parse_args(argv)

		device_call(ctx, ThermalImagingBricklet, 7, (), '', '4B', args.execute, False, ['region-of-interest'], [None])

	def set_high_contrast_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-high-contrast-config')

		parser.add_argument('region_of_interest', type=create_array_converter(ctx, convert_int, '0', 4), help=get_array_type_name(ctx, 'int', 4), metavar='<region-of-interest>')
		parser.add_argument('dampening_factor', type=convert_int, help='int', metavar='<dampening-factor>')
		parser.add_argument('clip_limit', type=create_array_converter(ctx, convert_int, '0', 2), help=get_array_type_name(ctx, 'int', 2), metavar='<clip-limit>')
		parser.add_argument('empty_counts', type=convert_int, help='int', metavar='<empty-counts>')

		args = parser.parse_args(argv)

		device_call(ctx, ThermalImagingBricklet, 8, (args.region_of_interest, args.dampening_factor, args.clip_limit, args.empty_counts), '4B H 2H H', '', None, args.expect_response, [], [])

	def get_high_contrast_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-high-contrast-config')

		args = parser.parse_args(argv)

		device_call(ctx, ThermalImagingBricklet, 9, (), '', '4B H 2H H', args.execute, False, ['region-of-interest', 'dampening-factor', 'clip-limit', 'empty-counts'], [None, None, None, None])

	def set_image_transfer_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-image-transfer-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'image-transfer-manual-high-contrast-image': 0, 'image-transfer-callback-high-contrast-image': 2, 'image-transfer-manual-temperature-image': 1, 'image-transfer-callback-temperature-image': 3}), help='int (image-transfer-manual-high-contrast-image: 0, image-transfer-manual-temperature-image: 1, image-transfer-callback-high-contrast-image: 2, image-transfer-callback-temperature-image: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, ThermalImagingBricklet, 10, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_image_transfer_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-image-transfer-config')

		args = parser.parse_args(argv)

		device_call(ctx, ThermalImagingBricklet, 11, (), '', 'B', args.execute, False, ['config'], [{0: 'image-transfer-manual-high-contrast-image', 1: 'image-transfer-manual-temperature-image', 2: 'image-transfer-callback-high-contrast-image', 3: 'image-transfer-callback-temperature-image'}])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, ThermalImagingBricklet, 234, (), '', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def set_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-bootloader-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'bootloader-mode-firmware-wait-for-reboot': 3, 'bootloader-mode-firmware': 1, 'bootloader-mode-firmware-wait-for-erase-and-reboot': 4, 'bootloader-mode-bootloader-wait-for-reboot': 2, 'bootloader-mode-bootloader': 0}), help='int (bootloader-mode-bootloader: 0, bootloader-mode-firmware: 1, bootloader-mode-bootloader-wait-for-reboot: 2, bootloader-mode-firmware-wait-for-reboot: 3, bootloader-mode-firmware-wait-for-erase-and-reboot: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, ThermalImagingBricklet, 235, (args.mode,), 'B', 'B', args.execute, False, ['status'], [{0: 'bootloader-status-ok', 1: 'bootloader-status-invalid-mode', 2: 'bootloader-status-no-change', 3: 'bootloader-status-entry-function-not-present', 4: 'bootloader-status-device-identifier-incorrect', 5: 'bootloader-status-crc-mismatch'}])

	def get_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-bootloader-mode')

		args = parser.parse_args(argv)

		device_call(ctx, ThermalImagingBricklet, 236, (), '', 'B', args.execute, False, ['mode'], [{0: 'bootloader-mode-bootloader', 1: 'bootloader-mode-firmware', 2: 'bootloader-mode-bootloader-wait-for-reboot', 3: 'bootloader-mode-firmware-wait-for-reboot', 4: 'bootloader-mode-firmware-wait-for-erase-and-reboot'}])

	def set_write_firmware_pointer(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-write-firmware-pointer')

		parser.add_argument('pointer', type=convert_int, help='int', metavar='<pointer>')

		args = parser.parse_args(argv)

		device_call(ctx, ThermalImagingBricklet, 237, (args.pointer,), 'I', '', None, args.expect_response, [], [])

	def write_firmware(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-firmware')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, ThermalImagingBricklet, 238, (args.data,), '64B', 'B', args.execute, False, ['status'], [None])

	def set_status_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'status-led-config-on': 1, 'status-led-config-show-heartbeat': 2, 'status-led-config-off': 0, 'status-led-config-show-status': 3}), help='int (status-led-config-off: 0, status-led-config-on: 1, status-led-config-show-heartbeat: 2, status-led-config-show-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, ThermalImagingBricklet, 239, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_status_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, ThermalImagingBricklet, 240, (), '', 'B', args.execute, False, ['config'], [{0: 'status-led-config-off', 1: 'status-led-config-on', 2: 'status-led-config-show-heartbeat', 3: 'status-led-config-show-status'}])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, ThermalImagingBricklet, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, ThermalImagingBricklet, 243, (), '', '', None, args.expect_response, [], [])

	def write_uid(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-uid')

		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')

		args = parser.parse_args(argv)

		device_call(ctx, ThermalImagingBricklet, 248, (args.uid,), 'I', '', None, args.expect_response, [], [])

	def read_uid(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-uid')

		args = parser.parse_args(argv)

		device_call(ctx, ThermalImagingBricklet, 249, (), '', 'I', args.execute, False, ['uid'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, ThermalImagingBricklet, argv)

	functions = {
	'get-high-contrast-image-low-level': get_high_contrast_image_low_level,
	'get-high-contrast-image': get_high_contrast_image,
	'get-temperature-image-low-level': get_temperature_image_low_level,
	'get-temperature-image': get_temperature_image,
	'get-statistics': get_statistics,
	'set-resolution': set_resolution,
	'get-resolution': get_resolution,
	'set-spotmeter-config': set_spotmeter_config,
	'get-spotmeter-config': get_spotmeter_config,
	'set-high-contrast-config': set_high_contrast_config,
	'get-high-contrast-config': get_high_contrast_config,
	'set-image-transfer-config': set_image_transfer_config,
	'get-image-transfer-config': get_image_transfer_config,
	'get-spitfp-error-count': get_spitfp_error_count,
	'set-bootloader-mode': set_bootloader_mode,
	'get-bootloader-mode': get_bootloader_mode,
	'set-write-firmware-pointer': set_write_firmware_pointer,
	'write-firmware': write_firmware,
	'set-status-led-config': set_status_led_config,
	'get-status-led-config': get_status_led_config,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'write-uid': write_uid,
	'read-uid': read_uid,
	'get-identity': get_identity
	}

	call_generic(ctx, 'thermal-imaging-bricklet', functions, argv)

def dispatch_thermal_imaging_bricklet(ctx, argv):
	prog_prefix = 'dispatch thermal-imaging-bricklet <uid>'

	def high_contrast_image_low_level(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' high-contrast-image-low-level')

		args = parser.parse_args(argv)

		device_dispatch(ctx, ThermalImagingBricklet, 12, args.execute, ['image-chunk-offset', 'image-chunk-data'], [None, None])

	def high_contrast_image(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' high-contrast-image')

		args = parser.parse_args(argv)

		device_dispatch(ctx, ThermalImagingBricklet, -12, args.execute, ['image'], [None])

	def temperature_image_low_level(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' temperature-image-low-level')

		args = parser.parse_args(argv)

		device_dispatch(ctx, ThermalImagingBricklet, 13, args.execute, ['image-chunk-offset', 'image-chunk-data'], [None, None])

	def temperature_image(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' temperature-image')

		args = parser.parse_args(argv)

		device_dispatch(ctx, ThermalImagingBricklet, -13, args.execute, ['image'], [None])

	callbacks = {
	'high-contrast-image-low-level': high_contrast_image_low_level,
	'high-contrast-image': high_contrast_image,
	'temperature-image-low-level': temperature_image_low_level,
	'temperature-image': temperature_image
	}

	dispatch_generic(ctx, 'thermal-imaging-bricklet', callbacks, argv)

class ThermocoupleBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 2; re[3] = 1; re[4] = 2; re[5] = 1; re[6] = 2; re[7] = 1; re[10] = 3; re[11] = 1; re[12] = 1; re[255] = 1
		cf = self.callback_formats
		cf[8] = 'i'; cf[9] = 'i'; cf[13] = '! !'


def call_thermocouple_bricklet(ctx, argv):
	prog_prefix = 'call thermocouple-bricklet <uid>'

	def get_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, ThermocoupleBricklet, 1, (), '', 'i', args.execute, False, ['temperature'], [None])

	def set_temperature_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-temperature-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, ThermocoupleBricklet, 2, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_temperature_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-temperature-callback-period')

		args = parser.parse_args(argv)

		device_call(ctx, ThermocoupleBricklet, 3, (), '', 'I', args.execute, False, ['period'], [None])

	def set_temperature_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-temperature-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, ThermocoupleBricklet, 4, (args.option, args.min, args.max), 'c i i', '', None, args.expect_response, [], [])

	def get_temperature_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-temperature-callback-threshold')

		args = parser.parse_args(argv)

		device_call(ctx, ThermocoupleBricklet, 5, (), '', 'c i i', args.execute, False, ['option', 'min', 'max'], [{'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def set_debounce_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-debounce-period')

		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_call(ctx, ThermocoupleBricklet, 6, (args.debounce,), 'I', '', None, args.expect_response, [], [])

	def get_debounce_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-debounce-period')

		args = parser.parse_args(argv)

		device_call(ctx, ThermocoupleBricklet, 7, (), '', 'I', args.execute, False, ['debounce'], [None])

	def set_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-configuration')

		parser.add_argument('averaging', type=create_symbol_converter(ctx, convert_int, {'averaging-4': 4, 'averaging-16': 16, 'averaging-8': 8, 'averaging-1': 1, 'averaging-2': 2}), help='int (averaging-1: 1, averaging-2: 2, averaging-4: 4, averaging-8: 8, averaging-16: 16)', metavar='<averaging>')
		parser.add_argument('thermocouple_type', type=create_symbol_converter(ctx, convert_int, {'type-k': 3, 'type-j': 2, 'type-n': 4, 'type-g32': 9, 'type-b': 0, 'type-e': 1, 'type-s': 6, 'type-r': 5, 'type-t': 7, 'type-g8': 8}), help='int (type-b: 0, type-e: 1, type-j: 2, type-k: 3, type-n: 4, type-r: 5, type-s: 6, type-t: 7, type-g8: 8, type-g32: 9)', metavar='<thermocouple-type>')
		parser.add_argument('filter', type=create_symbol_converter(ctx, convert_int, {'filter-option-50hz': 0, 'filter-option-60hz': 1}), help='int (filter-option-50hz: 0, filter-option-60hz: 1)', metavar='<filter>')

		args = parser.parse_args(argv)

		device_call(ctx, ThermocoupleBricklet, 10, (args.averaging, args.thermocouple_type, args.filter), 'B B B', '', None, args.expect_response, [], [])

	def get_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, ThermocoupleBricklet, 11, (), '', 'B B B', args.execute, False, ['averaging', 'thermocouple-type', 'filter'], [{8: 'averaging-8', 1: 'averaging-1', 2: 'averaging-2', 4: 'averaging-4', 16: 'averaging-16'}, {0: 'type-b', 1: 'type-e', 2: 'type-j', 3: 'type-k', 4: 'type-n', 5: 'type-r', 6: 'type-s', 7: 'type-t', 8: 'type-g8', 9: 'type-g32'}, {0: 'filter-option-50hz', 1: 'filter-option-60hz'}])

	def get_error_state(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-error-state')

		args = parser.parse_args(argv)

		device_call(ctx, ThermocoupleBricklet, 12, (), '', '! !', args.execute, False, ['over-under', 'open-circuit'], [None, None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, ThermocoupleBricklet, argv)

	functions = {
	'get-temperature': get_temperature,
	'set-temperature-callback-period': set_temperature_callback_period,
	'get-temperature-callback-period': get_temperature_callback_period,
	'set-temperature-callback-threshold': set_temperature_callback_threshold,
	'get-temperature-callback-threshold': get_temperature_callback_threshold,
	'set-debounce-period': set_debounce_period,
	'get-debounce-period': get_debounce_period,
	'set-configuration': set_configuration,
	'get-configuration': get_configuration,
	'get-error-state': get_error_state,
	'get-identity': get_identity
	}

	call_generic(ctx, 'thermocouple-bricklet', functions, argv)

def dispatch_thermocouple_bricklet(ctx, argv):
	prog_prefix = 'dispatch thermocouple-bricklet <uid>'

	def temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' temperature')

		args = parser.parse_args(argv)

		device_dispatch(ctx, ThermocoupleBricklet, 8, args.execute, ['temperature'], [None])

	def temperature_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' temperature-reached')

		args = parser.parse_args(argv)

		device_dispatch(ctx, ThermocoupleBricklet, 9, args.execute, ['temperature'], [None])

	def error_state(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' error-state')

		args = parser.parse_args(argv)

		device_dispatch(ctx, ThermocoupleBricklet, 13, args.execute, ['over-under', 'open-circuit'], [None, None])

	callbacks = {
	'temperature': temperature,
	'temperature-reached': temperature_reached,
	'error-state': error_state
	}

	dispatch_generic(ctx, 'thermocouple-bricklet', callbacks, argv)

class ThermocoupleV2Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 2; re[3] = 1; re[5] = 3; re[6] = 1; re[7] = 1; re[234] = 1; re[235] = 1; re[236] = 1; re[237] = 3; re[238] = 1; re[239] = 3; re[240] = 1; re[242] = 1; re[243] = 3; re[248] = 3; re[249] = 1; re[255] = 1
		cf = self.callback_formats
		cf[4] = 'i'; cf[8] = '! !'


def call_thermocouple_v2_bricklet(ctx, argv):
	prog_prefix = 'call thermocouple-v2-bricklet <uid>'

	def get_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, ThermocoupleV2Bricklet, 1, (), '', 'i', args.execute, False, ['temperature'], [None])

	def set_temperature_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-temperature-callback-configuration')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')
		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, ThermocoupleV2Bricklet, 2, (args.period, args.value_has_to_change, args.option, args.min, args.max), 'I ! c i i', '', None, args.expect_response, [], [])

	def get_temperature_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-temperature-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, ThermocoupleV2Bricklet, 3, (), '', 'I ! c i i', args.execute, False, ['period', 'value-has-to-change', 'option', 'min', 'max'], [None, None, {'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def set_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-configuration')

		parser.add_argument('averaging', type=create_symbol_converter(ctx, convert_int, {'averaging-4': 4, 'averaging-16': 16, 'averaging-8': 8, 'averaging-1': 1, 'averaging-2': 2}), help='int (averaging-1: 1, averaging-2: 2, averaging-4: 4, averaging-8: 8, averaging-16: 16)', metavar='<averaging>')
		parser.add_argument('thermocouple_type', type=create_symbol_converter(ctx, convert_int, {'type-k': 3, 'type-j': 2, 'type-n': 4, 'type-g32': 9, 'type-b': 0, 'type-e': 1, 'type-s': 6, 'type-r': 5, 'type-t': 7, 'type-g8': 8}), help='int (type-b: 0, type-e: 1, type-j: 2, type-k: 3, type-n: 4, type-r: 5, type-s: 6, type-t: 7, type-g8: 8, type-g32: 9)', metavar='<thermocouple-type>')
		parser.add_argument('filter', type=create_symbol_converter(ctx, convert_int, {'filter-option-50hz': 0, 'filter-option-60hz': 1}), help='int (filter-option-50hz: 0, filter-option-60hz: 1)', metavar='<filter>')

		args = parser.parse_args(argv)

		device_call(ctx, ThermocoupleV2Bricklet, 5, (args.averaging, args.thermocouple_type, args.filter), 'B B B', '', None, args.expect_response, [], [])

	def get_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, ThermocoupleV2Bricklet, 6, (), '', 'B B B', args.execute, False, ['averaging', 'thermocouple-type', 'filter'], [{8: 'averaging-8', 1: 'averaging-1', 2: 'averaging-2', 4: 'averaging-4', 16: 'averaging-16'}, {0: 'type-b', 1: 'type-e', 2: 'type-j', 3: 'type-k', 4: 'type-n', 5: 'type-r', 6: 'type-s', 7: 'type-t', 8: 'type-g8', 9: 'type-g32'}, {0: 'filter-option-50hz', 1: 'filter-option-60hz'}])

	def get_error_state(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-error-state')

		args = parser.parse_args(argv)

		device_call(ctx, ThermocoupleV2Bricklet, 7, (), '', '! !', args.execute, False, ['over-under', 'open-circuit'], [None, None])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, ThermocoupleV2Bricklet, 234, (), '', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def set_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-bootloader-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'bootloader-mode-firmware-wait-for-reboot': 3, 'bootloader-mode-firmware': 1, 'bootloader-mode-firmware-wait-for-erase-and-reboot': 4, 'bootloader-mode-bootloader-wait-for-reboot': 2, 'bootloader-mode-bootloader': 0}), help='int (bootloader-mode-bootloader: 0, bootloader-mode-firmware: 1, bootloader-mode-bootloader-wait-for-reboot: 2, bootloader-mode-firmware-wait-for-reboot: 3, bootloader-mode-firmware-wait-for-erase-and-reboot: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, ThermocoupleV2Bricklet, 235, (args.mode,), 'B', 'B', args.execute, False, ['status'], [{0: 'bootloader-status-ok', 1: 'bootloader-status-invalid-mode', 2: 'bootloader-status-no-change', 3: 'bootloader-status-entry-function-not-present', 4: 'bootloader-status-device-identifier-incorrect', 5: 'bootloader-status-crc-mismatch'}])

	def get_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-bootloader-mode')

		args = parser.parse_args(argv)

		device_call(ctx, ThermocoupleV2Bricklet, 236, (), '', 'B', args.execute, False, ['mode'], [{0: 'bootloader-mode-bootloader', 1: 'bootloader-mode-firmware', 2: 'bootloader-mode-bootloader-wait-for-reboot', 3: 'bootloader-mode-firmware-wait-for-reboot', 4: 'bootloader-mode-firmware-wait-for-erase-and-reboot'}])

	def set_write_firmware_pointer(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-write-firmware-pointer')

		parser.add_argument('pointer', type=convert_int, help='int', metavar='<pointer>')

		args = parser.parse_args(argv)

		device_call(ctx, ThermocoupleV2Bricklet, 237, (args.pointer,), 'I', '', None, args.expect_response, [], [])

	def write_firmware(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-firmware')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, ThermocoupleV2Bricklet, 238, (args.data,), '64B', 'B', args.execute, False, ['status'], [None])

	def set_status_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'status-led-config-on': 1, 'status-led-config-show-heartbeat': 2, 'status-led-config-off': 0, 'status-led-config-show-status': 3}), help='int (status-led-config-off: 0, status-led-config-on: 1, status-led-config-show-heartbeat: 2, status-led-config-show-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, ThermocoupleV2Bricklet, 239, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_status_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, ThermocoupleV2Bricklet, 240, (), '', 'B', args.execute, False, ['config'], [{0: 'status-led-config-off', 1: 'status-led-config-on', 2: 'status-led-config-show-heartbeat', 3: 'status-led-config-show-status'}])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, ThermocoupleV2Bricklet, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, ThermocoupleV2Bricklet, 243, (), '', '', None, args.expect_response, [], [])

	def write_uid(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-uid')

		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')

		args = parser.parse_args(argv)

		device_call(ctx, ThermocoupleV2Bricklet, 248, (args.uid,), 'I', '', None, args.expect_response, [], [])

	def read_uid(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-uid')

		args = parser.parse_args(argv)

		device_call(ctx, ThermocoupleV2Bricklet, 249, (), '', 'I', args.execute, False, ['uid'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, ThermocoupleV2Bricklet, argv)

	functions = {
	'get-temperature': get_temperature,
	'set-temperature-callback-configuration': set_temperature_callback_configuration,
	'get-temperature-callback-configuration': get_temperature_callback_configuration,
	'set-configuration': set_configuration,
	'get-configuration': get_configuration,
	'get-error-state': get_error_state,
	'get-spitfp-error-count': get_spitfp_error_count,
	'set-bootloader-mode': set_bootloader_mode,
	'get-bootloader-mode': get_bootloader_mode,
	'set-write-firmware-pointer': set_write_firmware_pointer,
	'write-firmware': write_firmware,
	'set-status-led-config': set_status_led_config,
	'get-status-led-config': get_status_led_config,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'write-uid': write_uid,
	'read-uid': read_uid,
	'get-identity': get_identity
	}

	call_generic(ctx, 'thermocouple-v2-bricklet', functions, argv)

def dispatch_thermocouple_v2_bricklet(ctx, argv):
	prog_prefix = 'dispatch thermocouple-v2-bricklet <uid>'

	def temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' temperature')

		args = parser.parse_args(argv)

		device_dispatch(ctx, ThermocoupleV2Bricklet, 4, args.execute, ['temperature'], [None])

	def error_state(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' error-state')

		args = parser.parse_args(argv)

		device_dispatch(ctx, ThermocoupleV2Bricklet, 8, args.execute, ['over-under', 'open-circuit'], [None, None])

	callbacks = {
	'temperature': temperature,
	'error-state': error_state
	}

	dispatch_generic(ctx, 'thermocouple-v2-bricklet', callbacks, argv)

class TiltBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 2; re[3] = 2; re[4] = 1; re[255] = 1
		cf = self.callback_formats
		cf[5] = 'B'


def call_tilt_bricklet(ctx, argv):
	prog_prefix = 'call tilt-bricklet <uid>'

	def get_tilt_state(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-tilt-state')

		args = parser.parse_args(argv)

		device_call(ctx, TiltBricklet, 1, (), '', 'B', args.execute, False, ['state'], [{0: 'tilt-state-closed', 1: 'tilt-state-open', 2: 'tilt-state-closed-vibrating'}])

	def enable_tilt_state_callback(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' enable-tilt-state-callback')

		args = parser.parse_args(argv)

		device_call(ctx, TiltBricklet, 2, (), '', '', None, args.expect_response, [], [])

	def disable_tilt_state_callback(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' disable-tilt-state-callback')

		args = parser.parse_args(argv)

		device_call(ctx, TiltBricklet, 3, (), '', '', None, args.expect_response, [], [])

	def is_tilt_state_callback_enabled(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' is-tilt-state-callback-enabled')

		args = parser.parse_args(argv)

		device_call(ctx, TiltBricklet, 4, (), '', '!', args.execute, False, ['enabled'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, TiltBricklet, argv)

	functions = {
	'get-tilt-state': get_tilt_state,
	'enable-tilt-state-callback': enable_tilt_state_callback,
	'disable-tilt-state-callback': disable_tilt_state_callback,
	'is-tilt-state-callback-enabled': is_tilt_state_callback_enabled,
	'get-identity': get_identity
	}

	call_generic(ctx, 'tilt-bricklet', functions, argv)

def dispatch_tilt_bricklet(ctx, argv):
	prog_prefix = 'dispatch tilt-bricklet <uid>'

	def tilt_state(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' tilt-state')

		args = parser.parse_args(argv)

		device_dispatch(ctx, TiltBricklet, 5, args.execute, ['state'], [{0: 'tilt-state-closed', 1: 'tilt-state-open', 2: 'tilt-state-closed-vibrating'}])

	callbacks = {
	'tilt-state': tilt_state
	}

	dispatch_generic(ctx, 'tilt-bricklet', callbacks, argv)

class UVLightBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 2; re[3] = 1; re[4] = 2; re[5] = 1; re[6] = 2; re[7] = 1; re[255] = 1
		cf = self.callback_formats
		cf[8] = 'I'; cf[9] = 'I'


def call_uv_light_bricklet(ctx, argv):
	prog_prefix = 'call uv-light-bricklet <uid>'

	def get_uv_light(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-uv-light')

		args = parser.parse_args(argv)

		device_call(ctx, UVLightBricklet, 1, (), '', 'I', args.execute, False, ['uv-light'], [None])

	def set_uv_light_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-uv-light-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, UVLightBricklet, 2, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_uv_light_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-uv-light-callback-period')

		args = parser.parse_args(argv)

		device_call(ctx, UVLightBricklet, 3, (), '', 'I', args.execute, False, ['period'], [None])

	def set_uv_light_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-uv-light-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, UVLightBricklet, 4, (args.option, args.min, args.max), 'c I I', '', None, args.expect_response, [], [])

	def get_uv_light_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-uv-light-callback-threshold')

		args = parser.parse_args(argv)

		device_call(ctx, UVLightBricklet, 5, (), '', 'c I I', args.execute, False, ['option', 'min', 'max'], [{'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def set_debounce_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-debounce-period')

		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_call(ctx, UVLightBricklet, 6, (args.debounce,), 'I', '', None, args.expect_response, [], [])

	def get_debounce_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-debounce-period')

		args = parser.parse_args(argv)

		device_call(ctx, UVLightBricklet, 7, (), '', 'I', args.execute, False, ['debounce'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, UVLightBricklet, argv)

	functions = {
	'get-uv-light': get_uv_light,
	'set-uv-light-callback-period': set_uv_light_callback_period,
	'get-uv-light-callback-period': get_uv_light_callback_period,
	'set-uv-light-callback-threshold': set_uv_light_callback_threshold,
	'get-uv-light-callback-threshold': get_uv_light_callback_threshold,
	'set-debounce-period': set_debounce_period,
	'get-debounce-period': get_debounce_period,
	'get-identity': get_identity
	}

	call_generic(ctx, 'uv-light-bricklet', functions, argv)

def dispatch_uv_light_bricklet(ctx, argv):
	prog_prefix = 'dispatch uv-light-bricklet <uid>'

	def uv_light(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' uv-light')

		args = parser.parse_args(argv)

		device_dispatch(ctx, UVLightBricklet, 8, args.execute, ['uv-light'], [None])

	def uv_light_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' uv-light-reached')

		args = parser.parse_args(argv)

		device_dispatch(ctx, UVLightBricklet, 9, args.execute, ['uv-light'], [None])

	callbacks = {
	'uv-light': uv_light,
	'uv-light-reached': uv_light_reached
	}

	dispatch_generic(ctx, 'uv-light-bricklet', callbacks, argv)

class UVLightV2Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 2; re[3] = 1; re[5] = 1; re[6] = 2; re[7] = 1; re[9] = 1; re[10] = 2; re[11] = 1; re[13] = 3; re[14] = 1; re[234] = 1; re[235] = 1; re[236] = 1; re[237] = 3; re[238] = 1; re[239] = 3; re[240] = 1; re[242] = 1; re[243] = 3; re[248] = 3; re[249] = 1; re[255] = 1
		cf = self.callback_formats
		cf[4] = 'i'; cf[8] = 'i'; cf[12] = 'i'


def call_uv_light_v2_bricklet(ctx, argv):
	prog_prefix = 'call uv-light-v2-bricklet <uid>'

	def get_uva(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-uva')

		args = parser.parse_args(argv)

		device_call(ctx, UVLightV2Bricklet, 1, (), '', 'i', args.execute, False, ['uva'], [None])

	def set_uva_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-uva-callback-configuration')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')
		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, UVLightV2Bricklet, 2, (args.period, args.value_has_to_change, args.option, args.min, args.max), 'I ! c i i', '', None, args.expect_response, [], [])

	def get_uva_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-uva-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, UVLightV2Bricklet, 3, (), '', 'I ! c i i', args.execute, False, ['period', 'value-has-to-change', 'option', 'min', 'max'], [None, None, {'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def get_uvb(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-uvb')

		args = parser.parse_args(argv)

		device_call(ctx, UVLightV2Bricklet, 5, (), '', 'i', args.execute, False, ['uvb'], [None])

	def set_uvb_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-uvb-callback-configuration')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')
		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, UVLightV2Bricklet, 6, (args.period, args.value_has_to_change, args.option, args.min, args.max), 'I ! c i i', '', None, args.expect_response, [], [])

	def get_uvb_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-uvb-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, UVLightV2Bricklet, 7, (), '', 'I ! c i i', args.execute, False, ['period', 'value-has-to-change', 'option', 'min', 'max'], [None, None, {'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def get_uvi(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-uvi')

		args = parser.parse_args(argv)

		device_call(ctx, UVLightV2Bricklet, 9, (), '', 'i', args.execute, False, ['uvi'], [None])

	def set_uvi_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-uvi-callback-configuration')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')
		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, UVLightV2Bricklet, 10, (args.period, args.value_has_to_change, args.option, args.min, args.max), 'I ! c i i', '', None, args.expect_response, [], [])

	def get_uvi_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-uvi-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, UVLightV2Bricklet, 11, (), '', 'I ! c i i', args.execute, False, ['period', 'value-has-to-change', 'option', 'min', 'max'], [None, None, {'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def set_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-configuration')

		parser.add_argument('integration_time', type=create_symbol_converter(ctx, convert_int, {'integration-time-800ms': 4, 'integration-time-200ms': 2, 'integration-time-100ms': 1, 'integration-time-400ms': 3, 'integration-time-50ms': 0}), help='int (integration-time-50ms: 0, integration-time-100ms: 1, integration-time-200ms: 2, integration-time-400ms: 3, integration-time-800ms: 4)', metavar='<integration-time>')

		args = parser.parse_args(argv)

		device_call(ctx, UVLightV2Bricklet, 13, (args.integration_time,), 'B', '', None, args.expect_response, [], [])

	def get_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, UVLightV2Bricklet, 14, (), '', 'B', args.execute, False, ['integration-time'], [{0: 'integration-time-50ms', 1: 'integration-time-100ms', 2: 'integration-time-200ms', 3: 'integration-time-400ms', 4: 'integration-time-800ms'}])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, UVLightV2Bricklet, 234, (), '', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def set_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-bootloader-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'bootloader-mode-firmware-wait-for-reboot': 3, 'bootloader-mode-firmware': 1, 'bootloader-mode-firmware-wait-for-erase-and-reboot': 4, 'bootloader-mode-bootloader-wait-for-reboot': 2, 'bootloader-mode-bootloader': 0}), help='int (bootloader-mode-bootloader: 0, bootloader-mode-firmware: 1, bootloader-mode-bootloader-wait-for-reboot: 2, bootloader-mode-firmware-wait-for-reboot: 3, bootloader-mode-firmware-wait-for-erase-and-reboot: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, UVLightV2Bricklet, 235, (args.mode,), 'B', 'B', args.execute, False, ['status'], [{0: 'bootloader-status-ok', 1: 'bootloader-status-invalid-mode', 2: 'bootloader-status-no-change', 3: 'bootloader-status-entry-function-not-present', 4: 'bootloader-status-device-identifier-incorrect', 5: 'bootloader-status-crc-mismatch'}])

	def get_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-bootloader-mode')

		args = parser.parse_args(argv)

		device_call(ctx, UVLightV2Bricklet, 236, (), '', 'B', args.execute, False, ['mode'], [{0: 'bootloader-mode-bootloader', 1: 'bootloader-mode-firmware', 2: 'bootloader-mode-bootloader-wait-for-reboot', 3: 'bootloader-mode-firmware-wait-for-reboot', 4: 'bootloader-mode-firmware-wait-for-erase-and-reboot'}])

	def set_write_firmware_pointer(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-write-firmware-pointer')

		parser.add_argument('pointer', type=convert_int, help='int', metavar='<pointer>')

		args = parser.parse_args(argv)

		device_call(ctx, UVLightV2Bricklet, 237, (args.pointer,), 'I', '', None, args.expect_response, [], [])

	def write_firmware(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-firmware')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, UVLightV2Bricklet, 238, (args.data,), '64B', 'B', args.execute, False, ['status'], [None])

	def set_status_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'status-led-config-on': 1, 'status-led-config-show-heartbeat': 2, 'status-led-config-off': 0, 'status-led-config-show-status': 3}), help='int (status-led-config-off: 0, status-led-config-on: 1, status-led-config-show-heartbeat: 2, status-led-config-show-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, UVLightV2Bricklet, 239, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_status_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, UVLightV2Bricklet, 240, (), '', 'B', args.execute, False, ['config'], [{0: 'status-led-config-off', 1: 'status-led-config-on', 2: 'status-led-config-show-heartbeat', 3: 'status-led-config-show-status'}])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, UVLightV2Bricklet, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, UVLightV2Bricklet, 243, (), '', '', None, args.expect_response, [], [])

	def write_uid(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-uid')

		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')

		args = parser.parse_args(argv)

		device_call(ctx, UVLightV2Bricklet, 248, (args.uid,), 'I', '', None, args.expect_response, [], [])

	def read_uid(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-uid')

		args = parser.parse_args(argv)

		device_call(ctx, UVLightV2Bricklet, 249, (), '', 'I', args.execute, False, ['uid'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, UVLightV2Bricklet, argv)

	functions = {
	'get-uva': get_uva,
	'set-uva-callback-configuration': set_uva_callback_configuration,
	'get-uva-callback-configuration': get_uva_callback_configuration,
	'get-uvb': get_uvb,
	'set-uvb-callback-configuration': set_uvb_callback_configuration,
	'get-uvb-callback-configuration': get_uvb_callback_configuration,
	'get-uvi': get_uvi,
	'set-uvi-callback-configuration': set_uvi_callback_configuration,
	'get-uvi-callback-configuration': get_uvi_callback_configuration,
	'set-configuration': set_configuration,
	'get-configuration': get_configuration,
	'get-spitfp-error-count': get_spitfp_error_count,
	'set-bootloader-mode': set_bootloader_mode,
	'get-bootloader-mode': get_bootloader_mode,
	'set-write-firmware-pointer': set_write_firmware_pointer,
	'write-firmware': write_firmware,
	'set-status-led-config': set_status_led_config,
	'get-status-led-config': get_status_led_config,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'write-uid': write_uid,
	'read-uid': read_uid,
	'get-identity': get_identity
	}

	call_generic(ctx, 'uv-light-v2-bricklet', functions, argv)

def dispatch_uv_light_v2_bricklet(ctx, argv):
	prog_prefix = 'dispatch uv-light-v2-bricklet <uid>'

	def uva(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' uva')

		args = parser.parse_args(argv)

		device_dispatch(ctx, UVLightV2Bricklet, 4, args.execute, ['uva'], [None])

	def uvb(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' uvb')

		args = parser.parse_args(argv)

		device_dispatch(ctx, UVLightV2Bricklet, 8, args.execute, ['uvb'], [None])

	def uvi(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' uvi')

		args = parser.parse_args(argv)

		device_dispatch(ctx, UVLightV2Bricklet, 12, args.execute, ['uvi'], [None])

	callbacks = {
	'uva': uva,
	'uvb': uvb,
	'uvi': uvi
	}

	dispatch_generic(ctx, 'uv-light-v2-bricklet', callbacks, argv)

class VoltageBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 1; re[3] = 2; re[4] = 1; re[5] = 2; re[6] = 1; re[7] = 2; re[8] = 1; re[9] = 2; re[10] = 1; re[11] = 2; re[12] = 1; re[255] = 1
		cf = self.callback_formats
		cf[13] = 'H'; cf[14] = 'H'; cf[15] = 'H'; cf[16] = 'H'


def call_voltage_bricklet(ctx, argv):
	prog_prefix = 'call voltage-bricklet <uid>'

	def get_voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-voltage')

		args = parser.parse_args(argv)

		device_call(ctx, VoltageBricklet, 1, (), '', 'H', args.execute, False, ['voltage'], [None])

	def get_analog_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-analog-value')

		args = parser.parse_args(argv)

		device_call(ctx, VoltageBricklet, 2, (), '', 'H', args.execute, False, ['value'], [None])

	def set_voltage_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-voltage-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, VoltageBricklet, 3, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_voltage_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-voltage-callback-period')

		args = parser.parse_args(argv)

		device_call(ctx, VoltageBricklet, 4, (), '', 'I', args.execute, False, ['period'], [None])

	def set_analog_value_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-analog-value-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, VoltageBricklet, 5, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_analog_value_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-analog-value-callback-period')

		args = parser.parse_args(argv)

		device_call(ctx, VoltageBricklet, 6, (), '', 'I', args.execute, False, ['period'], [None])

	def set_voltage_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-voltage-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, VoltageBricklet, 7, (args.option, args.min, args.max), 'c H H', '', None, args.expect_response, [], [])

	def get_voltage_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-voltage-callback-threshold')

		args = parser.parse_args(argv)

		device_call(ctx, VoltageBricklet, 8, (), '', 'c H H', args.execute, False, ['option', 'min', 'max'], [{'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def set_analog_value_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-analog-value-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, VoltageBricklet, 9, (args.option, args.min, args.max), 'c H H', '', None, args.expect_response, [], [])

	def get_analog_value_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-analog-value-callback-threshold')

		args = parser.parse_args(argv)

		device_call(ctx, VoltageBricklet, 10, (), '', 'c H H', args.execute, False, ['option', 'min', 'max'], [{'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def set_debounce_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-debounce-period')

		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_call(ctx, VoltageBricklet, 11, (args.debounce,), 'I', '', None, args.expect_response, [], [])

	def get_debounce_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-debounce-period')

		args = parser.parse_args(argv)

		device_call(ctx, VoltageBricklet, 12, (), '', 'I', args.execute, False, ['debounce'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, VoltageBricklet, argv)

	functions = {
	'get-voltage': get_voltage,
	'get-analog-value': get_analog_value,
	'set-voltage-callback-period': set_voltage_callback_period,
	'get-voltage-callback-period': get_voltage_callback_period,
	'set-analog-value-callback-period': set_analog_value_callback_period,
	'get-analog-value-callback-period': get_analog_value_callback_period,
	'set-voltage-callback-threshold': set_voltage_callback_threshold,
	'get-voltage-callback-threshold': get_voltage_callback_threshold,
	'set-analog-value-callback-threshold': set_analog_value_callback_threshold,
	'get-analog-value-callback-threshold': get_analog_value_callback_threshold,
	'set-debounce-period': set_debounce_period,
	'get-debounce-period': get_debounce_period,
	'get-identity': get_identity
	}

	call_generic(ctx, 'voltage-bricklet', functions, argv)

def dispatch_voltage_bricklet(ctx, argv):
	prog_prefix = 'dispatch voltage-bricklet <uid>'

	def voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' voltage')

		args = parser.parse_args(argv)

		device_dispatch(ctx, VoltageBricklet, 13, args.execute, ['voltage'], [None])

	def analog_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' analog-value')

		args = parser.parse_args(argv)

		device_dispatch(ctx, VoltageBricklet, 14, args.execute, ['value'], [None])

	def voltage_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' voltage-reached')

		args = parser.parse_args(argv)

		device_dispatch(ctx, VoltageBricklet, 15, args.execute, ['voltage'], [None])

	def analog_value_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' analog-value-reached')

		args = parser.parse_args(argv)

		device_dispatch(ctx, VoltageBricklet, 16, args.execute, ['value'], [None])

	callbacks = {
	'voltage': voltage,
	'analog-value': analog_value,
	'voltage-reached': voltage_reached,
	'analog-value-reached': analog_value_reached
	}

	dispatch_generic(ctx, 'voltage-bricklet', callbacks, argv)

class VoltageCurrentBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 1; re[3] = 1; re[4] = 3; re[5] = 1; re[6] = 3; re[7] = 1; re[8] = 2; re[9] = 1; re[10] = 2; re[11] = 1; re[12] = 2; re[13] = 1; re[14] = 2; re[15] = 1; re[16] = 2; re[17] = 1; re[18] = 2; re[19] = 1; re[20] = 2; re[21] = 1; re[255] = 1
		cf = self.callback_formats
		cf[22] = 'i'; cf[23] = 'i'; cf[24] = 'i'; cf[25] = 'i'; cf[26] = 'i'; cf[27] = 'i'


def call_voltage_current_bricklet(ctx, argv):
	prog_prefix = 'call voltage-current-bricklet <uid>'

	def get_current(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-current')

		args = parser.parse_args(argv)

		device_call(ctx, VoltageCurrentBricklet, 1, (), '', 'i', args.execute, False, ['current'], [None])

	def get_voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-voltage')

		args = parser.parse_args(argv)

		device_call(ctx, VoltageCurrentBricklet, 2, (), '', 'i', args.execute, False, ['voltage'], [None])

	def get_power(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-power')

		args = parser.parse_args(argv)

		device_call(ctx, VoltageCurrentBricklet, 3, (), '', 'i', args.execute, False, ['power'], [None])

	def set_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-configuration')

		parser.add_argument('averaging', type=create_symbol_converter(ctx, convert_int, {'averaging-256': 5, 'averaging-512': 6, 'averaging-64': 3, 'averaging-16': 2, 'averaging-1024': 7, 'averaging-4': 1, 'averaging-1': 0, 'averaging-128': 4}), help='int (averaging-1: 0, averaging-4: 1, averaging-16: 2, averaging-64: 3, averaging-128: 4, averaging-256: 5, averaging-512: 6, averaging-1024: 7)', metavar='<averaging>')
		parser.add_argument('voltage_conversion_time', type=convert_int, help='int', metavar='<voltage-conversion-time>')
		parser.add_argument('current_conversion_time', type=convert_int, help='int', metavar='<current-conversion-time>')

		args = parser.parse_args(argv)

		device_call(ctx, VoltageCurrentBricklet, 4, (args.averaging, args.voltage_conversion_time, args.current_conversion_time), 'B B B', '', None, args.expect_response, [], [])

	def get_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, VoltageCurrentBricklet, 5, (), '', 'B B B', args.execute, False, ['averaging', 'voltage-conversion-time', 'current-conversion-time'], [{0: 'averaging-1', 1: 'averaging-4', 2: 'averaging-16', 3: 'averaging-64', 4: 'averaging-128', 5: 'averaging-256', 6: 'averaging-512', 7: 'averaging-1024'}, None, None])

	def set_calibration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-calibration')

		parser.add_argument('gain_multiplier', type=convert_int, help='int', metavar='<gain-multiplier>')
		parser.add_argument('gain_divisor', type=convert_int, help='int', metavar='<gain-divisor>')

		args = parser.parse_args(argv)

		device_call(ctx, VoltageCurrentBricklet, 6, (args.gain_multiplier, args.gain_divisor), 'H H', '', None, args.expect_response, [], [])

	def get_calibration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-calibration')

		args = parser.parse_args(argv)

		device_call(ctx, VoltageCurrentBricklet, 7, (), '', 'H H', args.execute, False, ['gain-multiplier', 'gain-divisor'], [None, None])

	def set_current_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-current-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, VoltageCurrentBricklet, 8, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_current_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-current-callback-period')

		args = parser.parse_args(argv)

		device_call(ctx, VoltageCurrentBricklet, 9, (), '', 'I', args.execute, False, ['period'], [None])

	def set_voltage_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-voltage-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, VoltageCurrentBricklet, 10, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_voltage_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-voltage-callback-period')

		args = parser.parse_args(argv)

		device_call(ctx, VoltageCurrentBricklet, 11, (), '', 'I', args.execute, False, ['period'], [None])

	def set_power_callback_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-power-callback-period')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')

		args = parser.parse_args(argv)

		device_call(ctx, VoltageCurrentBricklet, 12, (args.period,), 'I', '', None, args.expect_response, [], [])

	def get_power_callback_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-power-callback-period')

		args = parser.parse_args(argv)

		device_call(ctx, VoltageCurrentBricklet, 13, (), '', 'I', args.execute, False, ['period'], [None])

	def set_current_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-current-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, VoltageCurrentBricklet, 14, (args.option, args.min, args.max), 'c i i', '', None, args.expect_response, [], [])

	def get_current_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-current-callback-threshold')

		args = parser.parse_args(argv)

		device_call(ctx, VoltageCurrentBricklet, 15, (), '', 'c i i', args.execute, False, ['option', 'min', 'max'], [{'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def set_voltage_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-voltage-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, VoltageCurrentBricklet, 16, (args.option, args.min, args.max), 'c i i', '', None, args.expect_response, [], [])

	def get_voltage_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-voltage-callback-threshold')

		args = parser.parse_args(argv)

		device_call(ctx, VoltageCurrentBricklet, 17, (), '', 'c i i', args.execute, False, ['option', 'min', 'max'], [{'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def set_power_callback_threshold(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-power-callback-threshold')

		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, VoltageCurrentBricklet, 18, (args.option, args.min, args.max), 'c i i', '', None, args.expect_response, [], [])

	def get_power_callback_threshold(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-power-callback-threshold')

		args = parser.parse_args(argv)

		device_call(ctx, VoltageCurrentBricklet, 19, (), '', 'c i i', args.execute, False, ['option', 'min', 'max'], [{'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def set_debounce_period(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-debounce-period')

		parser.add_argument('debounce', type=convert_int, help='int', metavar='<debounce>')

		args = parser.parse_args(argv)

		device_call(ctx, VoltageCurrentBricklet, 20, (args.debounce,), 'I', '', None, args.expect_response, [], [])

	def get_debounce_period(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-debounce-period')

		args = parser.parse_args(argv)

		device_call(ctx, VoltageCurrentBricklet, 21, (), '', 'I', args.execute, False, ['debounce'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, VoltageCurrentBricklet, argv)

	functions = {
	'get-current': get_current,
	'get-voltage': get_voltage,
	'get-power': get_power,
	'set-configuration': set_configuration,
	'get-configuration': get_configuration,
	'set-calibration': set_calibration,
	'get-calibration': get_calibration,
	'set-current-callback-period': set_current_callback_period,
	'get-current-callback-period': get_current_callback_period,
	'set-voltage-callback-period': set_voltage_callback_period,
	'get-voltage-callback-period': get_voltage_callback_period,
	'set-power-callback-period': set_power_callback_period,
	'get-power-callback-period': get_power_callback_period,
	'set-current-callback-threshold': set_current_callback_threshold,
	'get-current-callback-threshold': get_current_callback_threshold,
	'set-voltage-callback-threshold': set_voltage_callback_threshold,
	'get-voltage-callback-threshold': get_voltage_callback_threshold,
	'set-power-callback-threshold': set_power_callback_threshold,
	'get-power-callback-threshold': get_power_callback_threshold,
	'set-debounce-period': set_debounce_period,
	'get-debounce-period': get_debounce_period,
	'get-identity': get_identity
	}

	call_generic(ctx, 'voltage-current-bricklet', functions, argv)

def dispatch_voltage_current_bricklet(ctx, argv):
	prog_prefix = 'dispatch voltage-current-bricklet <uid>'

	def current(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' current')

		args = parser.parse_args(argv)

		device_dispatch(ctx, VoltageCurrentBricklet, 22, args.execute, ['current'], [None])

	def voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' voltage')

		args = parser.parse_args(argv)

		device_dispatch(ctx, VoltageCurrentBricklet, 23, args.execute, ['voltage'], [None])

	def power(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' power')

		args = parser.parse_args(argv)

		device_dispatch(ctx, VoltageCurrentBricklet, 24, args.execute, ['power'], [None])

	def current_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' current-reached')

		args = parser.parse_args(argv)

		device_dispatch(ctx, VoltageCurrentBricklet, 25, args.execute, ['current'], [None])

	def voltage_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' voltage-reached')

		args = parser.parse_args(argv)

		device_dispatch(ctx, VoltageCurrentBricklet, 26, args.execute, ['voltage'], [None])

	def power_reached(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' power-reached')

		args = parser.parse_args(argv)

		device_dispatch(ctx, VoltageCurrentBricklet, 27, args.execute, ['power'], [None])

	callbacks = {
	'current': current,
	'voltage': voltage,
	'power': power,
	'current-reached': current_reached,
	'voltage-reached': voltage_reached,
	'power-reached': power_reached
	}

	dispatch_generic(ctx, 'voltage-current-bricklet', callbacks, argv)

class VoltageCurrentV2Bricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 1; re[2] = 2; re[3] = 1; re[5] = 1; re[6] = 2; re[7] = 1; re[9] = 1; re[10] = 2; re[11] = 1; re[13] = 3; re[14] = 1; re[15] = 3; re[16] = 1; re[234] = 1; re[235] = 1; re[236] = 1; re[237] = 3; re[238] = 1; re[239] = 3; re[240] = 1; re[242] = 1; re[243] = 3; re[248] = 3; re[249] = 1; re[255] = 1
		cf = self.callback_formats
		cf[4] = 'i'; cf[8] = 'i'; cf[12] = 'i'


def call_voltage_current_v2_bricklet(ctx, argv):
	prog_prefix = 'call voltage-current-v2-bricklet <uid>'

	def get_current(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-current')

		args = parser.parse_args(argv)

		device_call(ctx, VoltageCurrentV2Bricklet, 1, (), '', 'i', args.execute, False, ['current'], [None])

	def set_current_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-current-callback-configuration')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')
		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, VoltageCurrentV2Bricklet, 2, (args.period, args.value_has_to_change, args.option, args.min, args.max), 'I ! c i i', '', None, args.expect_response, [], [])

	def get_current_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-current-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, VoltageCurrentV2Bricklet, 3, (), '', 'I ! c i i', args.execute, False, ['period', 'value-has-to-change', 'option', 'min', 'max'], [None, None, {'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def get_voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-voltage')

		args = parser.parse_args(argv)

		device_call(ctx, VoltageCurrentV2Bricklet, 5, (), '', 'i', args.execute, False, ['voltage'], [None])

	def set_voltage_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-voltage-callback-configuration')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')
		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, VoltageCurrentV2Bricklet, 6, (args.period, args.value_has_to_change, args.option, args.min, args.max), 'I ! c i i', '', None, args.expect_response, [], [])

	def get_voltage_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-voltage-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, VoltageCurrentV2Bricklet, 7, (), '', 'I ! c i i', args.execute, False, ['period', 'value-has-to-change', 'option', 'min', 'max'], [None, None, {'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def get_power(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-power')

		args = parser.parse_args(argv)

		device_call(ctx, VoltageCurrentV2Bricklet, 9, (), '', 'i', args.execute, False, ['power'], [None])

	def set_power_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-power-callback-configuration')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')
		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, VoltageCurrentV2Bricklet, 10, (args.period, args.value_has_to_change, args.option, args.min, args.max), 'I ! c i i', '', None, args.expect_response, [], [])

	def get_power_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-power-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, VoltageCurrentV2Bricklet, 11, (), '', 'I ! c i i', args.execute, False, ['period', 'value-has-to-change', 'option', 'min', 'max'], [None, None, {'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def set_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-configuration')

		parser.add_argument('averaging', type=create_symbol_converter(ctx, convert_int, {'averaging-256': 5, 'averaging-512': 6, 'averaging-64': 3, 'averaging-16': 2, 'averaging-1024': 7, 'averaging-4': 1, 'averaging-1': 0, 'averaging-128': 4}), help='int (averaging-1: 0, averaging-4: 1, averaging-16: 2, averaging-64: 3, averaging-128: 4, averaging-256: 5, averaging-512: 6, averaging-1024: 7)', metavar='<averaging>')
		parser.add_argument('voltage_conversion_time', type=create_symbol_converter(ctx, convert_int, {'conversion-time-1-1ms': 4, 'conversion-time-588us': 3, 'conversion-time-332us': 2, 'conversion-time-140us': 0, 'conversion-time-4-156ms': 6, 'conversion-time-8-244ms': 7, 'conversion-time-204us': 1, 'conversion-time-2-116ms': 5}), help='int (conversion-time-140us: 0, conversion-time-204us: 1, conversion-time-332us: 2, conversion-time-588us: 3, conversion-time-1-1ms: 4, conversion-time-2-116ms: 5, conversion-time-4-156ms: 6, conversion-time-8-244ms: 7)', metavar='<voltage-conversion-time>')
		parser.add_argument('current_conversion_time', type=create_symbol_converter(ctx, convert_int, {'conversion-time-1-1ms': 4, 'conversion-time-588us': 3, 'conversion-time-332us': 2, 'conversion-time-140us': 0, 'conversion-time-4-156ms': 6, 'conversion-time-8-244ms': 7, 'conversion-time-204us': 1, 'conversion-time-2-116ms': 5}), help='int (conversion-time-140us: 0, conversion-time-204us: 1, conversion-time-332us: 2, conversion-time-588us: 3, conversion-time-1-1ms: 4, conversion-time-2-116ms: 5, conversion-time-4-156ms: 6, conversion-time-8-244ms: 7)', metavar='<current-conversion-time>')

		args = parser.parse_args(argv)

		device_call(ctx, VoltageCurrentV2Bricklet, 13, (args.averaging, args.voltage_conversion_time, args.current_conversion_time), 'B B B', '', None, args.expect_response, [], [])

	def get_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, VoltageCurrentV2Bricklet, 14, (), '', 'B B B', args.execute, False, ['averaging', 'voltage-conversion-time', 'current-conversion-time'], [{0: 'averaging-1', 1: 'averaging-4', 2: 'averaging-16', 3: 'averaging-64', 4: 'averaging-128', 5: 'averaging-256', 6: 'averaging-512', 7: 'averaging-1024'}, None, None])

	def set_calibration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-calibration')

		parser.add_argument('voltage_multiplier', type=convert_int, help='int', metavar='<voltage-multiplier>')
		parser.add_argument('voltage_divisor', type=convert_int, help='int', metavar='<voltage-divisor>')
		parser.add_argument('current_multiplier', type=convert_int, help='int', metavar='<current-multiplier>')
		parser.add_argument('current_divisor', type=convert_int, help='int', metavar='<current-divisor>')

		args = parser.parse_args(argv)

		device_call(ctx, VoltageCurrentV2Bricklet, 15, (args.voltage_multiplier, args.voltage_divisor, args.current_multiplier, args.current_divisor), 'H H H H', '', None, args.expect_response, [], [])

	def get_calibration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-calibration')

		args = parser.parse_args(argv)

		device_call(ctx, VoltageCurrentV2Bricklet, 16, (), '', 'H H H H', args.execute, False, ['voltage-multiplier', 'voltage-divisor', 'current-multiplier', 'current-divisor'], [None, None, None, None])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, VoltageCurrentV2Bricklet, 234, (), '', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def set_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-bootloader-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'bootloader-mode-firmware-wait-for-reboot': 3, 'bootloader-mode-firmware': 1, 'bootloader-mode-firmware-wait-for-erase-and-reboot': 4, 'bootloader-mode-bootloader-wait-for-reboot': 2, 'bootloader-mode-bootloader': 0}), help='int (bootloader-mode-bootloader: 0, bootloader-mode-firmware: 1, bootloader-mode-bootloader-wait-for-reboot: 2, bootloader-mode-firmware-wait-for-reboot: 3, bootloader-mode-firmware-wait-for-erase-and-reboot: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, VoltageCurrentV2Bricklet, 235, (args.mode,), 'B', 'B', args.execute, False, ['status'], [{0: 'bootloader-status-ok', 1: 'bootloader-status-invalid-mode', 2: 'bootloader-status-no-change', 3: 'bootloader-status-entry-function-not-present', 4: 'bootloader-status-device-identifier-incorrect', 5: 'bootloader-status-crc-mismatch'}])

	def get_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-bootloader-mode')

		args = parser.parse_args(argv)

		device_call(ctx, VoltageCurrentV2Bricklet, 236, (), '', 'B', args.execute, False, ['mode'], [{0: 'bootloader-mode-bootloader', 1: 'bootloader-mode-firmware', 2: 'bootloader-mode-bootloader-wait-for-reboot', 3: 'bootloader-mode-firmware-wait-for-reboot', 4: 'bootloader-mode-firmware-wait-for-erase-and-reboot'}])

	def set_write_firmware_pointer(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-write-firmware-pointer')

		parser.add_argument('pointer', type=convert_int, help='int', metavar='<pointer>')

		args = parser.parse_args(argv)

		device_call(ctx, VoltageCurrentV2Bricklet, 237, (args.pointer,), 'I', '', None, args.expect_response, [], [])

	def write_firmware(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-firmware')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, VoltageCurrentV2Bricklet, 238, (args.data,), '64B', 'B', args.execute, False, ['status'], [None])

	def set_status_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'status-led-config-on': 1, 'status-led-config-show-heartbeat': 2, 'status-led-config-off': 0, 'status-led-config-show-status': 3}), help='int (status-led-config-off: 0, status-led-config-on: 1, status-led-config-show-heartbeat: 2, status-led-config-show-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, VoltageCurrentV2Bricklet, 239, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_status_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, VoltageCurrentV2Bricklet, 240, (), '', 'B', args.execute, False, ['config'], [{0: 'status-led-config-off', 1: 'status-led-config-on', 2: 'status-led-config-show-heartbeat', 3: 'status-led-config-show-status'}])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, VoltageCurrentV2Bricklet, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, VoltageCurrentV2Bricklet, 243, (), '', '', None, args.expect_response, [], [])

	def write_uid(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-uid')

		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')

		args = parser.parse_args(argv)

		device_call(ctx, VoltageCurrentV2Bricklet, 248, (args.uid,), 'I', '', None, args.expect_response, [], [])

	def read_uid(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-uid')

		args = parser.parse_args(argv)

		device_call(ctx, VoltageCurrentV2Bricklet, 249, (), '', 'I', args.execute, False, ['uid'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, VoltageCurrentV2Bricklet, argv)

	functions = {
	'get-current': get_current,
	'set-current-callback-configuration': set_current_callback_configuration,
	'get-current-callback-configuration': get_current_callback_configuration,
	'get-voltage': get_voltage,
	'set-voltage-callback-configuration': set_voltage_callback_configuration,
	'get-voltage-callback-configuration': get_voltage_callback_configuration,
	'get-power': get_power,
	'set-power-callback-configuration': set_power_callback_configuration,
	'get-power-callback-configuration': get_power_callback_configuration,
	'set-configuration': set_configuration,
	'get-configuration': get_configuration,
	'set-calibration': set_calibration,
	'get-calibration': get_calibration,
	'get-spitfp-error-count': get_spitfp_error_count,
	'set-bootloader-mode': set_bootloader_mode,
	'get-bootloader-mode': get_bootloader_mode,
	'set-write-firmware-pointer': set_write_firmware_pointer,
	'write-firmware': write_firmware,
	'set-status-led-config': set_status_led_config,
	'get-status-led-config': get_status_led_config,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'write-uid': write_uid,
	'read-uid': read_uid,
	'get-identity': get_identity
	}

	call_generic(ctx, 'voltage-current-v2-bricklet', functions, argv)

def dispatch_voltage_current_v2_bricklet(ctx, argv):
	prog_prefix = 'dispatch voltage-current-v2-bricklet <uid>'

	def current(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' current')

		args = parser.parse_args(argv)

		device_dispatch(ctx, VoltageCurrentV2Bricklet, 4, args.execute, ['current'], [None])

	def voltage(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' voltage')

		args = parser.parse_args(argv)

		device_dispatch(ctx, VoltageCurrentV2Bricklet, 8, args.execute, ['voltage'], [None])

	def power(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' power')

		args = parser.parse_args(argv)

		device_dispatch(ctx, VoltageCurrentV2Bricklet, 12, args.execute, ['power'], [None])

	callbacks = {
	'current': current,
	'voltage': voltage,
	'power': power
	}

	dispatch_generic(ctx, 'voltage-current-v2-bricklet', callbacks, argv)

class XMC1400BreakoutBricklet(Device):
	def __init__(self, uid, ipcon):
		Device.__init__(self, uid, ipcon)

		re = self.response_expected
		re[1] = 3; re[2] = 1; re[3] = 3; re[4] = 1; re[5] = 1; re[6] = 1; re[7] = 2; re[8] = 1; re[10] = 1; re[11] = 2; re[12] = 1; re[234] = 1; re[235] = 1; re[236] = 1; re[237] = 3; re[238] = 1; re[239] = 3; re[240] = 1; re[242] = 1; re[243] = 3; re[248] = 3; re[249] = 1; re[255] = 1
		cf = self.callback_formats
		cf[9] = '8H'; cf[13] = 'I'


def call_xmc1400_breakout_bricklet(ctx, argv):
	prog_prefix = 'call xmc1400-breakout-bricklet <uid>'

	def set_gpio_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-gpio-config')

		parser.add_argument('port', type=convert_int, help='int', metavar='<port>')
		parser.add_argument('pin', type=convert_int, help='int', metavar='<pin>')
		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'gpio-mode-output-open-drain': 9, 'gpio-mode-input-sampling': 3, 'gpio-mode-input-inverted-tristate': 4, 'gpio-mode-input-inverted-pull-down': 5, 'gpio-mode-input-pull-down': 1, 'gpio-mode-output-push-pull': 8, 'gpio-mode-input-inverted-pull-up': 6, 'gpio-mode-input-pull-up': 2, 'gpio-mode-input-inverted-sampling': 7, 'gpio-mode-input-tristate': 0}), help='int (gpio-mode-input-tristate: 0, gpio-mode-input-pull-down: 1, gpio-mode-input-pull-up: 2, gpio-mode-input-sampling: 3, gpio-mode-input-inverted-tristate: 4, gpio-mode-input-inverted-pull-down: 5, gpio-mode-input-inverted-pull-up: 6, gpio-mode-input-inverted-sampling: 7, gpio-mode-output-push-pull: 8, gpio-mode-output-open-drain: 9)', metavar='<mode>')
		parser.add_argument('input_hysteresis', type=create_symbol_converter(ctx, convert_int, {'gpio-input-hysteresis-standard': 0, 'gpio-input-hysteresis-large': 4}), help='int (gpio-input-hysteresis-standard: 0, gpio-input-hysteresis-large: 4)', metavar='<input-hysteresis>')
		parser.add_argument('output_level', type=convert_bool, help='bool', metavar='<output-level>')

		args = parser.parse_args(argv)

		device_call(ctx, XMC1400BreakoutBricklet, 1, (args.port, args.pin, args.mode, args.input_hysteresis, args.output_level), 'B B B B !', '', None, args.expect_response, [], [])

	def get_gpio_input(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-gpio-input')

		parser.add_argument('port', type=convert_int, help='int', metavar='<port>')
		parser.add_argument('pin', type=convert_int, help='int', metavar='<pin>')

		args = parser.parse_args(argv)

		device_call(ctx, XMC1400BreakoutBricklet, 2, (args.port, args.pin), 'B B', '!', args.execute, False, ['value'], [None])

	def set_adc_channel_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-adc-channel-config')

		parser.add_argument('channel', type=convert_int, help='int', metavar='<channel>')
		parser.add_argument('enable', type=convert_bool, help='bool', metavar='<enable>')

		args = parser.parse_args(argv)

		device_call(ctx, XMC1400BreakoutBricklet, 3, (args.channel, args.enable), 'B !', '', None, args.expect_response, [], [])

	def get_adc_channel_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-adc-channel-config')

		parser.add_argument('channel', type=convert_int, help='int', metavar='<channel>')

		args = parser.parse_args(argv)

		device_call(ctx, XMC1400BreakoutBricklet, 4, (args.channel,), 'B', '!', args.execute, False, ['enable'], [None])

	def get_adc_channel_value(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-adc-channel-value')

		parser.add_argument('channel', type=convert_int, help='int', metavar='<channel>')

		args = parser.parse_args(argv)

		device_call(ctx, XMC1400BreakoutBricklet, 5, (args.channel,), 'B', 'H', args.execute, False, ['value'], [None])

	def get_adc_values(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-adc-values')

		args = parser.parse_args(argv)

		device_call(ctx, XMC1400BreakoutBricklet, 6, (), '', '8H', args.execute, False, ['values'], [None])

	def set_adc_values_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-adc-values-callback-configuration')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')

		args = parser.parse_args(argv)

		device_call(ctx, XMC1400BreakoutBricklet, 7, (args.period, args.value_has_to_change), 'I !', '', None, args.expect_response, [], [])

	def get_adc_values_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-adc-values-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, XMC1400BreakoutBricklet, 8, (), '', 'I !', args.execute, False, ['period', 'value-has-to-change'], [None, None])

	def get_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-count')

		args = parser.parse_args(argv)

		device_call(ctx, XMC1400BreakoutBricklet, 10, (), '', 'I', args.execute, False, ['count'], [None])

	def set_count_callback_configuration(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-count-callback-configuration')

		parser.add_argument('period', type=convert_int, help='int', metavar='<period>')
		parser.add_argument('value_has_to_change', type=convert_bool, help='bool', metavar='<value-has-to-change>')
		parser.add_argument('option', type=create_symbol_converter(ctx, create_char_converter(ctx), {'threshold-option-inside': 'i', 'threshold-option-smaller': '<', 'threshold-option-outside': 'o', 'threshold-option-greater': '>', 'threshold-option-off': 'x'}), help='char (threshold-option-off: x, threshold-option-outside: o, threshold-option-inside: i, threshold-option-smaller: <, threshold-option-greater: >)', metavar='<option>')
		parser.add_argument('min', type=convert_int, help='int', metavar='<min>')
		parser.add_argument('max', type=convert_int, help='int', metavar='<max>')

		args = parser.parse_args(argv)

		device_call(ctx, XMC1400BreakoutBricklet, 11, (args.period, args.value_has_to_change, args.option, args.min, args.max), 'I ! c I I', '', None, args.expect_response, [], [])

	def get_count_callback_configuration(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-count-callback-configuration')

		args = parser.parse_args(argv)

		device_call(ctx, XMC1400BreakoutBricklet, 12, (), '', 'I ! c I I', args.execute, False, ['period', 'value-has-to-change', 'option', 'min', 'max'], [None, None, {'i': 'threshold-option-inside', 'x': 'threshold-option-off', '<': 'threshold-option-smaller', 'o': 'threshold-option-outside', '>': 'threshold-option-greater'}, None, None])

	def get_spitfp_error_count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-spitfp-error-count')

		args = parser.parse_args(argv)

		device_call(ctx, XMC1400BreakoutBricklet, 234, (), '', 'I I I I', args.execute, False, ['error-count-ack-checksum', 'error-count-message-checksum', 'error-count-frame', 'error-count-overflow'], [None, None, None, None])

	def set_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' set-bootloader-mode')

		parser.add_argument('mode', type=create_symbol_converter(ctx, convert_int, {'bootloader-mode-firmware-wait-for-reboot': 3, 'bootloader-mode-firmware': 1, 'bootloader-mode-firmware-wait-for-erase-and-reboot': 4, 'bootloader-mode-bootloader-wait-for-reboot': 2, 'bootloader-mode-bootloader': 0}), help='int (bootloader-mode-bootloader: 0, bootloader-mode-firmware: 1, bootloader-mode-bootloader-wait-for-reboot: 2, bootloader-mode-firmware-wait-for-reboot: 3, bootloader-mode-firmware-wait-for-erase-and-reboot: 4)', metavar='<mode>')

		args = parser.parse_args(argv)

		device_call(ctx, XMC1400BreakoutBricklet, 235, (args.mode,), 'B', 'B', args.execute, False, ['status'], [{0: 'bootloader-status-ok', 1: 'bootloader-status-invalid-mode', 2: 'bootloader-status-no-change', 3: 'bootloader-status-entry-function-not-present', 4: 'bootloader-status-device-identifier-incorrect', 5: 'bootloader-status-crc-mismatch'}])

	def get_bootloader_mode(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-bootloader-mode')

		args = parser.parse_args(argv)

		device_call(ctx, XMC1400BreakoutBricklet, 236, (), '', 'B', args.execute, False, ['mode'], [{0: 'bootloader-mode-bootloader', 1: 'bootloader-mode-firmware', 2: 'bootloader-mode-bootloader-wait-for-reboot', 3: 'bootloader-mode-firmware-wait-for-reboot', 4: 'bootloader-mode-firmware-wait-for-erase-and-reboot'}])

	def set_write_firmware_pointer(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-write-firmware-pointer')

		parser.add_argument('pointer', type=convert_int, help='int', metavar='<pointer>')

		args = parser.parse_args(argv)

		device_call(ctx, XMC1400BreakoutBricklet, 237, (args.pointer,), 'I', '', None, args.expect_response, [], [])

	def write_firmware(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' write-firmware')

		parser.add_argument('data', type=create_array_converter(ctx, convert_int, '0', 64), help=get_array_type_name(ctx, 'int', 64), metavar='<data>')

		args = parser.parse_args(argv)

		device_call(ctx, XMC1400BreakoutBricklet, 238, (args.data,), '64B', 'B', args.execute, False, ['status'], [None])

	def set_status_led_config(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' set-status-led-config')

		parser.add_argument('config', type=create_symbol_converter(ctx, convert_int, {'status-led-config-on': 1, 'status-led-config-show-heartbeat': 2, 'status-led-config-off': 0, 'status-led-config-show-status': 3}), help='int (status-led-config-off: 0, status-led-config-on: 1, status-led-config-show-heartbeat: 2, status-led-config-show-status: 3)', metavar='<config>')

		args = parser.parse_args(argv)

		device_call(ctx, XMC1400BreakoutBricklet, 239, (args.config,), 'B', '', None, args.expect_response, [], [])

	def get_status_led_config(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-status-led-config')

		args = parser.parse_args(argv)

		device_call(ctx, XMC1400BreakoutBricklet, 240, (), '', 'B', args.execute, False, ['config'], [{0: 'status-led-config-off', 1: 'status-led-config-on', 2: 'status-led-config-show-heartbeat', 3: 'status-led-config-show-status'}])

	def get_chip_temperature(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' get-chip-temperature')

		args = parser.parse_args(argv)

		device_call(ctx, XMC1400BreakoutBricklet, 242, (), '', 'h', args.execute, False, ['temperature'], [None])

	def reset(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' reset')

		args = parser.parse_args(argv)

		device_call(ctx, XMC1400BreakoutBricklet, 243, (), '', '', None, args.expect_response, [], [])

	def write_uid(ctx, argv):
		parser = ParserWithExpectResponse(ctx, prog_prefix + ' write-uid')

		parser.add_argument('uid', type=convert_int, help='int', metavar='<uid>')

		args = parser.parse_args(argv)

		device_call(ctx, XMC1400BreakoutBricklet, 248, (args.uid,), 'I', '', None, args.expect_response, [], [])

	def read_uid(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' read-uid')

		args = parser.parse_args(argv)

		device_call(ctx, XMC1400BreakoutBricklet, 249, (), '', 'I', args.execute, False, ['uid'], [None])

	def get_identity(ctx, argv):
		common_get_identity(ctx, prog_prefix, XMC1400BreakoutBricklet, argv)

	functions = {
	'set-gpio-config': set_gpio_config,
	'get-gpio-input': get_gpio_input,
	'set-adc-channel-config': set_adc_channel_config,
	'get-adc-channel-config': get_adc_channel_config,
	'get-adc-channel-value': get_adc_channel_value,
	'get-adc-values': get_adc_values,
	'set-adc-values-callback-configuration': set_adc_values_callback_configuration,
	'get-adc-values-callback-configuration': get_adc_values_callback_configuration,
	'get-count': get_count,
	'set-count-callback-configuration': set_count_callback_configuration,
	'get-count-callback-configuration': get_count_callback_configuration,
	'get-spitfp-error-count': get_spitfp_error_count,
	'set-bootloader-mode': set_bootloader_mode,
	'get-bootloader-mode': get_bootloader_mode,
	'set-write-firmware-pointer': set_write_firmware_pointer,
	'write-firmware': write_firmware,
	'set-status-led-config': set_status_led_config,
	'get-status-led-config': get_status_led_config,
	'get-chip-temperature': get_chip_temperature,
	'reset': reset,
	'write-uid': write_uid,
	'read-uid': read_uid,
	'get-identity': get_identity
	}

	call_generic(ctx, 'xmc1400-breakout-bricklet', functions, argv)

def dispatch_xmc1400_breakout_bricklet(ctx, argv):
	prog_prefix = 'dispatch xmc1400-breakout-bricklet <uid>'

	def adc_values(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' adc-values')

		args = parser.parse_args(argv)

		device_dispatch(ctx, XMC1400BreakoutBricklet, 9, args.execute, ['values'], [None])

	def count(ctx, argv):
		parser = ParserWithExecute(ctx, prog_prefix + ' count')

		args = parser.parse_args(argv)

		device_dispatch(ctx, XMC1400BreakoutBricklet, 13, args.execute, ['count'], [None])

	callbacks = {
	'adc-values': adc_values,
	'count': count
	}

	dispatch_generic(ctx, 'xmc1400-breakout-bricklet', callbacks, argv)

call_devices = {
'dc-brick': call_dc_brick,
'hat-brick': call_hat_brick,
'hat-zero-brick': call_hat_zero_brick,
'imu-brick': call_imu_brick,
'imu-v2-brick': call_imu_v2_brick,
'master-brick': call_master_brick,
'red-brick': call_red_brick,
'servo-brick': call_servo_brick,
'silent-stepper-brick': call_silent_stepper_brick,
'stepper-brick': call_stepper_brick,
'accelerometer-bricklet': call_accelerometer_bricklet,
'accelerometer-v2-bricklet': call_accelerometer_v2_bricklet,
'air-quality-bricklet': call_air_quality_bricklet,
'ambient-light-bricklet': call_ambient_light_bricklet,
'ambient-light-v2-bricklet': call_ambient_light_v2_bricklet,
'ambient-light-v3-bricklet': call_ambient_light_v3_bricklet,
'analog-in-bricklet': call_analog_in_bricklet,
'analog-in-v2-bricklet': call_analog_in_v2_bricklet,
'analog-in-v3-bricklet': call_analog_in_v3_bricklet,
'analog-out-bricklet': call_analog_out_bricklet,
'analog-out-v2-bricklet': call_analog_out_v2_bricklet,
'analog-out-v3-bricklet': call_analog_out_v3_bricklet,
'barometer-bricklet': call_barometer_bricklet,
'barometer-v2-bricklet': call_barometer_v2_bricklet,
'can-bricklet': call_can_bricklet,
'can-v2-bricklet': call_can_v2_bricklet,
'co2-bricklet': call_co2_bricklet,
'co2-v2-bricklet': call_co2_v2_bricklet,
'color-bricklet': call_color_bricklet,
'color-v2-bricklet': call_color_v2_bricklet,
'compass-bricklet': call_compass_bricklet,
'current12-bricklet': call_current12_bricklet,
'current25-bricklet': call_current25_bricklet,
'distance-ir-bricklet': call_distance_ir_bricklet,
'distance-ir-v2-bricklet': call_distance_ir_v2_bricklet,
'distance-us-bricklet': call_distance_us_bricklet,
'distance-us-v2-bricklet': call_distance_us_v2_bricklet,
'dmx-bricklet': call_dmx_bricklet,
'dual-button-bricklet': call_dual_button_bricklet,
'dual-button-v2-bricklet': call_dual_button_v2_bricklet,
'dual-relay-bricklet': call_dual_relay_bricklet,
'dust-detector-bricklet': call_dust_detector_bricklet,
'e-paper-296x128-bricklet': call_e_paper_296x128_bricklet,
'energy-monitor-bricklet': call_energy_monitor_bricklet,
'gps-bricklet': call_gps_bricklet,
'gps-v2-bricklet': call_gps_v2_bricklet,
'hall-effect-bricklet': call_hall_effect_bricklet,
'hall-effect-v2-bricklet': call_hall_effect_v2_bricklet,
'humidity-bricklet': call_humidity_bricklet,
'humidity-v2-bricklet': call_humidity_v2_bricklet,
'industrial-analog-out-bricklet': call_industrial_analog_out_bricklet,
'industrial-analog-out-v2-bricklet': call_industrial_analog_out_v2_bricklet,
'industrial-counter-bricklet': call_industrial_counter_bricklet,
'industrial-digital-in-4-bricklet': call_industrial_digital_in_4_bricklet,
'industrial-digital-in-4-v2-bricklet': call_industrial_digital_in_4_v2_bricklet,
'industrial-digital-out-4-bricklet': call_industrial_digital_out_4_bricklet,
'industrial-digital-out-4-v2-bricklet': call_industrial_digital_out_4_v2_bricklet,
'industrial-dual-0-20ma-bricklet': call_industrial_dual_0_20ma_bricklet,
'industrial-dual-0-20ma-v2-bricklet': call_industrial_dual_0_20ma_v2_bricklet,
'industrial-dual-analog-in-bricklet': call_industrial_dual_analog_in_bricklet,
'industrial-dual-analog-in-v2-bricklet': call_industrial_dual_analog_in_v2_bricklet,
'industrial-dual-relay-bricklet': call_industrial_dual_relay_bricklet,
'industrial-quad-relay-bricklet': call_industrial_quad_relay_bricklet,
'industrial-quad-relay-v2-bricklet': call_industrial_quad_relay_v2_bricklet,
'io16-bricklet': call_io16_bricklet,
'io16-v2-bricklet': call_io16_v2_bricklet,
'io4-bricklet': call_io4_bricklet,
'io4-v2-bricklet': call_io4_v2_bricklet,
'isolator-bricklet': call_isolator_bricklet,
'joystick-bricklet': call_joystick_bricklet,
'joystick-v2-bricklet': call_joystick_v2_bricklet,
'laser-range-finder-bricklet': call_laser_range_finder_bricklet,
'laser-range-finder-v2-bricklet': call_laser_range_finder_v2_bricklet,
'lcd-128x64-bricklet': call_lcd_128x64_bricklet,
'lcd-16x2-bricklet': call_lcd_16x2_bricklet,
'lcd-20x4-bricklet': call_lcd_20x4_bricklet,
'led-strip-bricklet': call_led_strip_bricklet,
'led-strip-v2-bricklet': call_led_strip_v2_bricklet,
'line-bricklet': call_line_bricklet,
'linear-poti-bricklet': call_linear_poti_bricklet,
'linear-poti-v2-bricklet': call_linear_poti_v2_bricklet,
'load-cell-bricklet': call_load_cell_bricklet,
'load-cell-v2-bricklet': call_load_cell_v2_bricklet,
'moisture-bricklet': call_moisture_bricklet,
'motion-detector-bricklet': call_motion_detector_bricklet,
'motion-detector-v2-bricklet': call_motion_detector_v2_bricklet,
'motorized-linear-poti-bricklet': call_motorized_linear_poti_bricklet,
'multi-touch-bricklet': call_multi_touch_bricklet,
'multi-touch-v2-bricklet': call_multi_touch_v2_bricklet,
'nfc-bricklet': call_nfc_bricklet,
'nfc-rfid-bricklet': call_nfc_rfid_bricklet,
'oled-128x64-bricklet': call_oled_128x64_bricklet,
'oled-128x64-v2-bricklet': call_oled_128x64_v2_bricklet,
'oled-64x48-bricklet': call_oled_64x48_bricklet,
'one-wire-bricklet': call_one_wire_bricklet,
'outdoor-weather-bricklet': call_outdoor_weather_bricklet,
'particulate-matter-bricklet': call_particulate_matter_bricklet,
'piezo-buzzer-bricklet': call_piezo_buzzer_bricklet,
'piezo-speaker-bricklet': call_piezo_speaker_bricklet,
'piezo-speaker-v2-bricklet': call_piezo_speaker_v2_bricklet,
'ptc-bricklet': call_ptc_bricklet,
'ptc-v2-bricklet': call_ptc_v2_bricklet,
'real-time-clock-bricklet': call_real_time_clock_bricklet,
'real-time-clock-v2-bricklet': call_real_time_clock_v2_bricklet,
'remote-switch-bricklet': call_remote_switch_bricklet,
'remote-switch-v2-bricklet': call_remote_switch_v2_bricklet,
'rgb-led-button-bricklet': call_rgb_led_button_bricklet,
'rgb-led-bricklet': call_rgb_led_bricklet,
'rgb-led-matrix-bricklet': call_rgb_led_matrix_bricklet,
'rgb-led-v2-bricklet': call_rgb_led_v2_bricklet,
'rotary-encoder-bricklet': call_rotary_encoder_bricklet,
'rotary-encoder-v2-bricklet': call_rotary_encoder_v2_bricklet,
'rotary-poti-bricklet': call_rotary_poti_bricklet,
'rotary-poti-v2-bricklet': call_rotary_poti_v2_bricklet,
'rs232-bricklet': call_rs232_bricklet,
'rs232-v2-bricklet': call_rs232_v2_bricklet,
'rs485-bricklet': call_rs485_bricklet,
'segment-display-4x7-bricklet': call_segment_display_4x7_bricklet,
'segment-display-4x7-v2-bricklet': call_segment_display_4x7_v2_bricklet,
'solid-state-relay-bricklet': call_solid_state_relay_bricklet,
'solid-state-relay-v2-bricklet': call_solid_state_relay_v2_bricklet,
'sound-intensity-bricklet': call_sound_intensity_bricklet,
'sound-pressure-level-bricklet': call_sound_pressure_level_bricklet,
'temperature-bricklet': call_temperature_bricklet,
'temperature-ir-bricklet': call_temperature_ir_bricklet,
'temperature-ir-v2-bricklet': call_temperature_ir_v2_bricklet,
'temperature-v2-bricklet': call_temperature_v2_bricklet,
'thermal-imaging-bricklet': call_thermal_imaging_bricklet,
'thermocouple-bricklet': call_thermocouple_bricklet,
'thermocouple-v2-bricklet': call_thermocouple_v2_bricklet,
'tilt-bricklet': call_tilt_bricklet,
'uv-light-bricklet': call_uv_light_bricklet,
'uv-light-v2-bricklet': call_uv_light_v2_bricklet,
'voltage-bricklet': call_voltage_bricklet,
'voltage-current-bricklet': call_voltage_current_bricklet,
'voltage-current-v2-bricklet': call_voltage_current_v2_bricklet,
'xmc1400-breakout-bricklet': call_xmc1400_breakout_bricklet
}

dispatch_devices = {
'dc-brick': dispatch_dc_brick,
'hat-brick': dispatch_hat_brick,
'hat-zero-brick': dispatch_hat_zero_brick,
'imu-brick': dispatch_imu_brick,
'imu-v2-brick': dispatch_imu_v2_brick,
'master-brick': dispatch_master_brick,
'red-brick': dispatch_red_brick,
'servo-brick': dispatch_servo_brick,
'silent-stepper-brick': dispatch_silent_stepper_brick,
'stepper-brick': dispatch_stepper_brick,
'accelerometer-bricklet': dispatch_accelerometer_bricklet,
'accelerometer-v2-bricklet': dispatch_accelerometer_v2_bricklet,
'air-quality-bricklet': dispatch_air_quality_bricklet,
'ambient-light-bricklet': dispatch_ambient_light_bricklet,
'ambient-light-v2-bricklet': dispatch_ambient_light_v2_bricklet,
'ambient-light-v3-bricklet': dispatch_ambient_light_v3_bricklet,
'analog-in-bricklet': dispatch_analog_in_bricklet,
'analog-in-v2-bricklet': dispatch_analog_in_v2_bricklet,
'analog-in-v3-bricklet': dispatch_analog_in_v3_bricklet,
'analog-out-bricklet': dispatch_analog_out_bricklet,
'analog-out-v2-bricklet': dispatch_analog_out_v2_bricklet,
'analog-out-v3-bricklet': dispatch_analog_out_v3_bricklet,
'barometer-bricklet': dispatch_barometer_bricklet,
'barometer-v2-bricklet': dispatch_barometer_v2_bricklet,
'can-bricklet': dispatch_can_bricklet,
'can-v2-bricklet': dispatch_can_v2_bricklet,
'co2-bricklet': dispatch_co2_bricklet,
'co2-v2-bricklet': dispatch_co2_v2_bricklet,
'color-bricklet': dispatch_color_bricklet,
'color-v2-bricklet': dispatch_color_v2_bricklet,
'compass-bricklet': dispatch_compass_bricklet,
'current12-bricklet': dispatch_current12_bricklet,
'current25-bricklet': dispatch_current25_bricklet,
'distance-ir-bricklet': dispatch_distance_ir_bricklet,
'distance-ir-v2-bricklet': dispatch_distance_ir_v2_bricklet,
'distance-us-bricklet': dispatch_distance_us_bricklet,
'distance-us-v2-bricklet': dispatch_distance_us_v2_bricklet,
'dmx-bricklet': dispatch_dmx_bricklet,
'dual-button-bricklet': dispatch_dual_button_bricklet,
'dual-button-v2-bricklet': dispatch_dual_button_v2_bricklet,
'dual-relay-bricklet': dispatch_dual_relay_bricklet,
'dust-detector-bricklet': dispatch_dust_detector_bricklet,
'e-paper-296x128-bricklet': dispatch_e_paper_296x128_bricklet,
'energy-monitor-bricklet': dispatch_energy_monitor_bricklet,
'gps-bricklet': dispatch_gps_bricklet,
'gps-v2-bricklet': dispatch_gps_v2_bricklet,
'hall-effect-bricklet': dispatch_hall_effect_bricklet,
'hall-effect-v2-bricklet': dispatch_hall_effect_v2_bricklet,
'humidity-bricklet': dispatch_humidity_bricklet,
'humidity-v2-bricklet': dispatch_humidity_v2_bricklet,
'industrial-analog-out-bricklet': dispatch_industrial_analog_out_bricklet,
'industrial-analog-out-v2-bricklet': dispatch_industrial_analog_out_v2_bricklet,
'industrial-counter-bricklet': dispatch_industrial_counter_bricklet,
'industrial-digital-in-4-bricklet': dispatch_industrial_digital_in_4_bricklet,
'industrial-digital-in-4-v2-bricklet': dispatch_industrial_digital_in_4_v2_bricklet,
'industrial-digital-out-4-bricklet': dispatch_industrial_digital_out_4_bricklet,
'industrial-digital-out-4-v2-bricklet': dispatch_industrial_digital_out_4_v2_bricklet,
'industrial-dual-0-20ma-bricklet': dispatch_industrial_dual_0_20ma_bricklet,
'industrial-dual-0-20ma-v2-bricklet': dispatch_industrial_dual_0_20ma_v2_bricklet,
'industrial-dual-analog-in-bricklet': dispatch_industrial_dual_analog_in_bricklet,
'industrial-dual-analog-in-v2-bricklet': dispatch_industrial_dual_analog_in_v2_bricklet,
'industrial-dual-relay-bricklet': dispatch_industrial_dual_relay_bricklet,
'industrial-quad-relay-bricklet': dispatch_industrial_quad_relay_bricklet,
'industrial-quad-relay-v2-bricklet': dispatch_industrial_quad_relay_v2_bricklet,
'io16-bricklet': dispatch_io16_bricklet,
'io16-v2-bricklet': dispatch_io16_v2_bricklet,
'io4-bricklet': dispatch_io4_bricklet,
'io4-v2-bricklet': dispatch_io4_v2_bricklet,
'isolator-bricklet': dispatch_isolator_bricklet,
'joystick-bricklet': dispatch_joystick_bricklet,
'joystick-v2-bricklet': dispatch_joystick_v2_bricklet,
'laser-range-finder-bricklet': dispatch_laser_range_finder_bricklet,
'laser-range-finder-v2-bricklet': dispatch_laser_range_finder_v2_bricklet,
'lcd-128x64-bricklet': dispatch_lcd_128x64_bricklet,
'lcd-16x2-bricklet': dispatch_lcd_16x2_bricklet,
'lcd-20x4-bricklet': dispatch_lcd_20x4_bricklet,
'led-strip-bricklet': dispatch_led_strip_bricklet,
'led-strip-v2-bricklet': dispatch_led_strip_v2_bricklet,
'line-bricklet': dispatch_line_bricklet,
'linear-poti-bricklet': dispatch_linear_poti_bricklet,
'linear-poti-v2-bricklet': dispatch_linear_poti_v2_bricklet,
'load-cell-bricklet': dispatch_load_cell_bricklet,
'load-cell-v2-bricklet': dispatch_load_cell_v2_bricklet,
'moisture-bricklet': dispatch_moisture_bricklet,
'motion-detector-bricklet': dispatch_motion_detector_bricklet,
'motion-detector-v2-bricklet': dispatch_motion_detector_v2_bricklet,
'motorized-linear-poti-bricklet': dispatch_motorized_linear_poti_bricklet,
'multi-touch-bricklet': dispatch_multi_touch_bricklet,
'multi-touch-v2-bricklet': dispatch_multi_touch_v2_bricklet,
'nfc-bricklet': dispatch_nfc_bricklet,
'nfc-rfid-bricklet': dispatch_nfc_rfid_bricklet,
'oled-128x64-bricklet': dispatch_oled_128x64_bricklet,
'oled-128x64-v2-bricklet': dispatch_oled_128x64_v2_bricklet,
'oled-64x48-bricklet': dispatch_oled_64x48_bricklet,
'one-wire-bricklet': dispatch_one_wire_bricklet,
'outdoor-weather-bricklet': dispatch_outdoor_weather_bricklet,
'particulate-matter-bricklet': dispatch_particulate_matter_bricklet,
'piezo-buzzer-bricklet': dispatch_piezo_buzzer_bricklet,
'piezo-speaker-bricklet': dispatch_piezo_speaker_bricklet,
'piezo-speaker-v2-bricklet': dispatch_piezo_speaker_v2_bricklet,
'ptc-bricklet': dispatch_ptc_bricklet,
'ptc-v2-bricklet': dispatch_ptc_v2_bricklet,
'real-time-clock-bricklet': dispatch_real_time_clock_bricklet,
'real-time-clock-v2-bricklet': dispatch_real_time_clock_v2_bricklet,
'remote-switch-bricklet': dispatch_remote_switch_bricklet,
'remote-switch-v2-bricklet': dispatch_remote_switch_v2_bricklet,
'rgb-led-button-bricklet': dispatch_rgb_led_button_bricklet,
'rgb-led-bricklet': dispatch_rgb_led_bricklet,
'rgb-led-matrix-bricklet': dispatch_rgb_led_matrix_bricklet,
'rgb-led-v2-bricklet': dispatch_rgb_led_v2_bricklet,
'rotary-encoder-bricklet': dispatch_rotary_encoder_bricklet,
'rotary-encoder-v2-bricklet': dispatch_rotary_encoder_v2_bricklet,
'rotary-poti-bricklet': dispatch_rotary_poti_bricklet,
'rotary-poti-v2-bricklet': dispatch_rotary_poti_v2_bricklet,
'rs232-bricklet': dispatch_rs232_bricklet,
'rs232-v2-bricklet': dispatch_rs232_v2_bricklet,
'rs485-bricklet': dispatch_rs485_bricklet,
'segment-display-4x7-bricklet': dispatch_segment_display_4x7_bricklet,
'segment-display-4x7-v2-bricklet': dispatch_segment_display_4x7_v2_bricklet,
'solid-state-relay-bricklet': dispatch_solid_state_relay_bricklet,
'solid-state-relay-v2-bricklet': dispatch_solid_state_relay_v2_bricklet,
'sound-intensity-bricklet': dispatch_sound_intensity_bricklet,
'sound-pressure-level-bricklet': dispatch_sound_pressure_level_bricklet,
'temperature-bricklet': dispatch_temperature_bricklet,
'temperature-ir-bricklet': dispatch_temperature_ir_bricklet,
'temperature-ir-v2-bricklet': dispatch_temperature_ir_v2_bricklet,
'temperature-v2-bricklet': dispatch_temperature_v2_bricklet,
'thermal-imaging-bricklet': dispatch_thermal_imaging_bricklet,
'thermocouple-bricklet': dispatch_thermocouple_bricklet,
'thermocouple-v2-bricklet': dispatch_thermocouple_v2_bricklet,
'tilt-bricklet': dispatch_tilt_bricklet,
'uv-light-bricklet': dispatch_uv_light_bricklet,
'uv-light-v2-bricklet': dispatch_uv_light_v2_bricklet,
'voltage-bricklet': dispatch_voltage_bricklet,
'voltage-current-bricklet': dispatch_voltage_current_bricklet,
'voltage-current-v2-bricklet': dispatch_voltage_current_v2_bricklet,
'xmc1400-breakout-bricklet': dispatch_xmc1400_breakout_bricklet
}

device_identifier_symbols = {
11: 'dc-brick',
111: 'hat-brick',
112: 'hat-zero-brick',
16: 'imu-brick',
18: 'imu-v2-brick',
13: 'master-brick',
17: 'red-brick',
14: 'servo-brick',
19: 'silent-stepper-brick',
15: 'stepper-brick',
250: 'accelerometer-bricklet',
2130: 'accelerometer-v2-bricklet',
297: 'air-quality-bricklet',
21: 'ambient-light-bricklet',
259: 'ambient-light-v2-bricklet',
2131: 'ambient-light-v3-bricklet',
219: 'analog-in-bricklet',
251: 'analog-in-v2-bricklet',
295: 'analog-in-v3-bricklet',
220: 'analog-out-bricklet',
256: 'analog-out-v2-bricklet',
2115: 'analog-out-v3-bricklet',
221: 'barometer-bricklet',
2117: 'barometer-v2-bricklet',
270: 'can-bricklet',
2107: 'can-v2-bricklet',
262: 'co2-bricklet',
2147: 'co2-v2-bricklet',
243: 'color-bricklet',
2128: 'color-v2-bricklet',
2153: 'compass-bricklet',
23: 'current12-bricklet',
24: 'current25-bricklet',
25: 'distance-ir-bricklet',
2125: 'distance-ir-v2-bricklet',
229: 'distance-us-bricklet',
299: 'distance-us-v2-bricklet',
285: 'dmx-bricklet',
230: 'dual-button-bricklet',
2119: 'dual-button-v2-bricklet',
26: 'dual-relay-bricklet',
260: 'dust-detector-bricklet',
2146: 'e-paper-296x128-bricklet',
2152: 'energy-monitor-bricklet',
222: 'gps-bricklet',
276: 'gps-v2-bricklet',
240: 'hall-effect-bricklet',
2132: 'hall-effect-v2-bricklet',
27: 'humidity-bricklet',
283: 'humidity-v2-bricklet',
258: 'industrial-analog-out-bricklet',
2116: 'industrial-analog-out-v2-bricklet',
293: 'industrial-counter-bricklet',
223: 'industrial-digital-in-4-bricklet',
2100: 'industrial-digital-in-4-v2-bricklet',
224: 'industrial-digital-out-4-bricklet',
2124: 'industrial-digital-out-4-v2-bricklet',
228: 'industrial-dual-0-20ma-bricklet',
2120: 'industrial-dual-0-20ma-v2-bricklet',
249: 'industrial-dual-analog-in-bricklet',
2121: 'industrial-dual-analog-in-v2-bricklet',
284: 'industrial-dual-relay-bricklet',
225: 'industrial-quad-relay-bricklet',
2102: 'industrial-quad-relay-v2-bricklet',
28: 'io16-bricklet',
2114: 'io16-v2-bricklet',
29: 'io4-bricklet',
2111: 'io4-v2-bricklet',
2122: 'isolator-bricklet',
210: 'joystick-bricklet',
2138: 'joystick-v2-bricklet',
255: 'laser-range-finder-bricklet',
2144: 'laser-range-finder-v2-bricklet',
298: 'lcd-128x64-bricklet',
211: 'lcd-16x2-bricklet',
212: 'lcd-20x4-bricklet',
231: 'led-strip-bricklet',
2103: 'led-strip-v2-bricklet',
241: 'line-bricklet',
213: 'linear-poti-bricklet',
2139: 'linear-poti-v2-bricklet',
253: 'load-cell-bricklet',
2104: 'load-cell-v2-bricklet',
232: 'moisture-bricklet',
233: 'motion-detector-bricklet',
292: 'motion-detector-v2-bricklet',
267: 'motorized-linear-poti-bricklet',
234: 'multi-touch-bricklet',
2129: 'multi-touch-v2-bricklet',
286: 'nfc-bricklet',
246: 'nfc-rfid-bricklet',
263: 'oled-128x64-bricklet',
2112: 'oled-128x64-v2-bricklet',
264: 'oled-64x48-bricklet',
2123: 'one-wire-bricklet',
288: 'outdoor-weather-bricklet',
2110: 'particulate-matter-bricklet',
214: 'piezo-buzzer-bricklet',
242: 'piezo-speaker-bricklet',
2145: 'piezo-speaker-v2-bricklet',
226: 'ptc-bricklet',
2101: 'ptc-v2-bricklet',
268: 'real-time-clock-bricklet',
2106: 'real-time-clock-v2-bricklet',
235: 'remote-switch-bricklet',
289: 'remote-switch-v2-bricklet',
282: 'rgb-led-button-bricklet',
271: 'rgb-led-bricklet',
272: 'rgb-led-matrix-bricklet',
2127: 'rgb-led-v2-bricklet',
236: 'rotary-encoder-bricklet',
294: 'rotary-encoder-v2-bricklet',
215: 'rotary-poti-bricklet',
2140: 'rotary-poti-v2-bricklet',
254: 'rs232-bricklet',
2108: 'rs232-v2-bricklet',
277: 'rs485-bricklet',
237: 'segment-display-4x7-bricklet',
2137: 'segment-display-4x7-v2-bricklet',
244: 'solid-state-relay-bricklet',
296: 'solid-state-relay-v2-bricklet',
238: 'sound-intensity-bricklet',
290: 'sound-pressure-level-bricklet',
216: 'temperature-bricklet',
217: 'temperature-ir-bricklet',
291: 'temperature-ir-v2-bricklet',
2113: 'temperature-v2-bricklet',
278: 'thermal-imaging-bricklet',
266: 'thermocouple-bricklet',
2109: 'thermocouple-v2-bricklet',
239: 'tilt-bricklet',
265: 'uv-light-bricklet',
2118: 'uv-light-v2-bricklet',
218: 'voltage-bricklet',
227: 'voltage-current-bricklet',
2105: 'voltage-current-v2-bricklet',
279: 'xmc1400-breakout-bricklet'
}

def command_call(ctx, argv):
	if listen_mode:
		prefix = ''
	else:
		prefix = 'tinkerforge '

	# FIXME: add description
	parser = Parser(ctx, 'call', epilog="try '{0}call <device> --help' for device specific help.".format(prefix))
	device_choices = sorted(call_devices.keys())

	class ListDevicesAction(argparse.Action):
		def __call__(self, parser, namespace, values, option_string=None):
			ctx.output(line_separator.join(device_choices) + group_terminator)
			raise ParserExit()

	parser.add_argument('--list-devices', action=ListDevicesAction, nargs=0, help='show list of devices and exit')
	parser.add_argument('--timeout', default=2500, type=convert_int, help='maximum time (msec) to wait for response, default: 2500', metavar='<timeout>')
	parser.add_argument('device', choices=device_choices, help='{' + ', '.join(device_choices) + '}', metavar='<device>')
	parser.add_argument('args', nargs=argparse.REMAINDER, help='device specific arguments', metavar='<args>')

	args = parser.parse_args(argv)

	ctx.timeout = args.timeout

	call_devices[args.device](ctx, args.args)

def command_dispatch(ctx, argv):
	if listen_mode:
		prefix = ''
	else:
		prefix = 'tinkerforge '

	# FIXME: add description
	parser = Parser(ctx, 'dispatch', epilog="try '{0}dispatch <device> --help' for device specific help.".format(prefix))
	device_choices = sorted(dispatch_devices.keys())

	class ListDevicesAction(argparse.Action):
		def __call__(self, parser, namespace, values, option_string=None):
			ctx.output(line_separator.join(device_choices) + group_terminator)
			raise ParserExit()

	parser.add_argument('--list-devices', action=ListDevicesAction, nargs=0, help='show list of devices and exit')
	parser.add_argument('--duration', default=-1, type=create_symbol_converter(ctx, int, {'exit-after-first': 0, 'forever': -1}), help='time (msec) to dispatch incoming enumerate callbacks (exit-after-first: 0, forever: -1), default: forever', metavar='<duration>')
	parser.add_argument('device', choices=device_choices, help='{' + ', '.join(device_choices) + '}', metavar='<device>')
	parser.add_argument('args', nargs=argparse.REMAINDER, help='device specific arguments', metavar='<args>')

	args = parser.parse_args(argv)

	ctx.duration = args.duration

	dispatch_devices[args.device](ctx, args.args)

def command_enumerate(ctx, argv):
	# FIXME: add description
	parser = Parser(ctx, 'enumerate')

	enumeration_type_symbols = {
	'available': IPConnection.ENUMERATION_TYPE_AVAILABLE,
	'connected': IPConnection.ENUMERATION_TYPE_CONNECTED,
	'disconnected': IPConnection.ENUMERATION_TYPE_DISCONNECTED,
	'all': -1
	}

	parser.add_argument('--duration', default=250, type=create_symbol_converter(ctx, int, {'exit-after-first': 0, 'forever': -1}), help='time (msec) to dispatch incoming enumerate responses (exit-after-first: 0, forever: -1), default: 250', metavar='<duration>')
	parser.add_argument('--types', default=[IPConnection.ENUMERATION_TYPE_AVAILABLE], type=create_array_converter(ctx, create_symbol_converter(ctx, int, enumeration_type_symbols, strict=True), None, -3), help='array of enumeration types to dispatch (available: 0, connected: 1, disconnected: 2, all: -1), default: available', metavar='<types>')

	if enable_execute:
		parser.add_argument('--execute', type=str, help='shell command line to execute for each incoming response', metavar='<command>')

	namespace = argparse.Namespace()

	if not enable_execute:
		setattr(namespace, 'execute', None)

	args = parser.parse_args(argv, namespace)

	if dry_run:
		return

	names = ['uid', 'connected-uid', 'position', 'hardware-version', 'firmware-version', 'device-identifier', 'enumeration-type']
	enumeration_type_symbols = {
	IPConnection.ENUMERATION_TYPE_AVAILABLE: 'available',
	IPConnection.ENUMERATION_TYPE_CONNECTED: 'connected',
	IPConnection.ENUMERATION_TYPE_DISCONNECTED: 'disconnected'
	}
	symbols = [None, None, None, None, None, device_identifier_symbols, enumeration_type_symbols]
	is_first_callback = [True]

	def fix_position(values):
		if values[2] == '\0':
			values = list(values)
			values[2] = 'x'
			values = tuple(values)

		return values

	if args.execute != None:
		def callback(*values):
			if -1 in args.types or values[6] in args.types:
				values = format_escaped_output(ctx, format_symbolic_output(ctx, fix_position(values), symbols))

				execute_response(ctx, args.execute, names, values)
				return True
	else:
		def callback(*values):
			if -1 in args.types or values[6] in args.types:
				if not listen_mode:
					if is_first_callback[0]:
						is_first_callback[0] = False
					else:
						ctx.output(ctx.group_separator)

				values = format_escaped_output(ctx, format_symbolic_output(ctx, fix_position(values), symbols))

				output_response(ctx, names, values)
				return True

	def function(ipcon):
		if args.duration == 0:
			exit_flag = [False]

			def callback_wrapper(*args, **kwargs):
				if not exit_flag[0] and callback(*args, **kwargs):
					exit_flag[0] = True

			ipcon.register_callback(IPConnection.CALLBACK_ENUMERATE, callback_wrapper)
			ipcon.enumerate()

			while not exit_flag[0] and not ctx.abort:
				time.sleep(0.1)

				if ctx.async_exception != None:
					raise ctx.async_exception
		elif args.duration < 0:
			ipcon.register_callback(IPConnection.CALLBACK_ENUMERATE, callback)
			ipcon.enumerate()

			while not ctx.abort:
				time.sleep(1)

				if ctx.async_exception != None:
					raise ctx.async_exception
		else:
			ipcon.register_callback(IPConnection.CALLBACK_ENUMERATE, callback)
			ipcon.enumerate()

			# FIXME: if duration is large then it would be better to sleep
			#        in multiple steps here
			time.sleep(args.duration / 1000.0)

			# FIXME: only checking for an exception after the complete sleep
			#        is not good, sleep in shorter steps here to check for
			#        exception more often
			if ctx.async_exception != None:
				raise ctx.async_exception

	connect_ipcon_and_call(ctx, function)

def command_listen(ctx, argv):
	# FIXME: add description
	parser = Parser(ctx, 'listen', epilog="in listen mode some command line options are disabled by default for incoming commands.\n\nthe --host and --port options are disabled by default so incoming commands can only connect to the host and port given to the listen command. use --enable-host and --enable-port to enable these options for incoming commands.\n\nthe --execute option for getter calls and callback dispatching is disabled by default so incoming command cannot execute other commands. use --enable-execute to enable this option for incoming commands.\n\nno group separator is included in the output and the --group-separator option is ignored.\n\nincoming commands have to be terminated by \\n. the output is also terminated by \\n.")

	parser.add_argument('--address', default='0.0.0.0', type=str, help='IP address to listen to, default: 0.0.0.0', metavar='<address>')
	parser.add_argument('--port', default=4217, type=convert_int, help='port number to listen to, default: 4217', metavar='<port>')
	parser.add_argument('--enable-host', action='store_true', help='enables --host option to override IP address or hostname to connect to')
	parser.add_argument('--enable-port', action='store_true', help='enables --port option to override port number to connect to')
	parser.add_argument('--enable-execute', action='store_true', help='enables --execute option for getters and callbacks')

	args = parser.parse_args(argv)

	global listen_mode
	listen_mode = True

	global enable_host
	enable_host = args.enable_host

	global enable_port
	enable_port = args.enable_port

	global enable_execute
	enable_execute = args.enable_execute

	global line_separator
	line_separator = '\t'

	try:
		server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
		server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
		server_socket.bind((args.address, args.port))
		server_socket.listen(10)
	except socket.error as e:
		raise FatalError(str(e), ERROR_SOCKET_ERROR)
	except Exception as e:
		raise FatalError(str(e), ERROR_OTHER_EXCEPTION)

	def client_loop():
		pending_data = ''

		try:
			client_socket, client_address = server_socket.accept()
		except socket.error:
			return

		print('{0} connected'.format(client_address[0]))

		while True:
			try:
				data = client_socket.recv(1024)
			except socket.error as e:
				print('{0} disconnected by socket error: {1}'.format(client_address[0], str(e)))
				return
			except Exception as e:
				print('{0} disconnected by exception: {1}'.format(client_address[0], str(e)))
				return

			if len(data) == 0:
				print('{0} disconnected'.format(client_address[0]))
				return

			if sys.hexversion >= 0x03000000:
				try:
					data = data.decode('utf-8')
				except UnicodeDecodeError as e:
					print('{0} sent invalid utf-8 data, disconnecting: {1}'.format(client_address[0], str(e)))
					return

			pending_data += data

			while len(pending_data) > 0:
				i = pending_data.find(group_terminator)

				if i < 0:
					break

				command = pending_data[:i]
				pending_data = pending_data[i + len(group_terminator):]

				print('{0} sent {1}'.format(client_address[0], repr(command + group_terminator)))

				client_ctx = ctx.duplicate()

				def output_to_socket(string):
					if client_ctx.abort:
						return

					if sys.hexversion >= 0x03000000:
						try:
							string = string.encode('utf-8')
						except UnicodeDecodeError as e:
							print('utf-8 encoding error while sending {0} to {1}, disconnecting: {2}'.format(repr(string), client_address[0], str(e)))

							client_ctx.abort = True
							return

					try:
						client_socket.sendall(string)
					except socket.error as e:
						print('socket error while sending {0} to {1}, disconnecting: {2}'.format(repr(string), client_address[0], str(e)))

						client_ctx.abort = True
						return
					except Exception as e:
						print('exception while sending {0} to {1}, disconnecting: {2}'.format(repr(string), client_address[0], str(e)))

						client_ctx.abort = True
						return

					print('{0} sent to {1}'.format(repr(string), client_address[0]))

				client_ctx.output = output_to_socket

				try:
					parse(client_ctx, shlex.split(command))
				except ParserExit:
					pass
				except FatalError as e:
					output_to_socket('error {0}: {1}{2}'.format(e.exit_code, e.message, group_terminator))

				if client_ctx.abort:
					return

	while True:
		ready, _, _ = select.select([server_socket], [], [])

		if server_socket not in ready:
			continue

		try:
			client_thread = threading.Thread(name='Client-Processor', target=client_loop)
			client_thread.daemon = True
			client_thread.start()
		except Exception as e:
			raise FatalError(str(e), ERROR_OTHER_EXCEPTION)

def parse(ctx, argv):
	global dry_run
	dry_run = os.getenv('TINKERFORGE_SHELL_BINDINGS_DRY_RUN', 0) != 0

	if listen_mode:
		prefix = ''
	else:
		prefix = 'tinkerforge '

	# FIXME: add description
	parser = Parser(ctx, '', epilog="try '{0}<command> --help' for command specific help.".format(prefix))
	command_choices = ['call', 'dispatch', 'enumerate']

	if not listen_mode:
		command_choices.append('listen')

	if ctx.host != None:
		host_default = ctx.host
	else:
		host_default = 'localhost'

	if ctx.port != None:
		port_default = ctx.port
	else:
		port_default = 4223

	if ctx.item_separator != None:
		item_separator_default = ctx.item_separator
	else:
		item_separator_default = ','

	if item_separator_default == ',':
		item_separator_help_suffix = ' (comma)'
	else:
		item_separator_help_suffix = ''

	if ctx.array_ellipsis != None:
		array_ellipsis_default = ctx.array_ellipsis
	else:
		array_ellipsis_default = '..'

	if array_ellipsis_default == '..':
		array_ellipsis_help_suffix = ' (two dots)'
	else:
		array_ellipsis_help_suffix = ''

	if ctx.no_escaped_input != None:
		no_escaped_input_default = ctx.no_escaped_input
	else:
		no_escaped_input_default = False

	if ctx.no_escaped_output != None:
		no_escaped_output_default = ctx.no_escaped_output
	else:
		no_escaped_output_default = False

	if ctx.no_symbolic_input != None:
		no_symbolic_input_default = ctx.no_symbolic_input
	else:
		no_symbolic_input_default = False

	if ctx.no_symbolic_output != None:
		no_symbolic_output_default = ctx.no_symbolic_output
	else:
		no_symbolic_output_default = False

	namespace = argparse.Namespace()

	parser.add_argument('--version', action='version', version='2.1.23')

	if enable_host:
		parser.add_argument('--host', default=host_default, type=str, help='IP address or hostname to connect to, default: {0}'.format(host_default), metavar='<host>')
	else:
		setattr(namespace, 'host', host_default)

	if enable_port:
		parser.add_argument('--port', default=port_default, type=convert_int, help='port number to connect to, default: {0}'.format(port_default), metavar='<port>')
	else:
		setattr(namespace, 'port', port_default)

	parser.add_argument('--secret', default='', type=str, help='secret for authentication', metavar='<secret>')
	parser.add_argument('--item-separator', default=item_separator_default, type=str, help='separator for array items, default: {0}{1}'.format(item_separator_default, item_separator_help_suffix), metavar='<item-separator>')

	if not listen_mode:
		parser.add_argument('--group-separator', default='\n', type=str, help='separator for output groups, default: \\n (newline)', metavar='<group-separator>')
	else:
		setattr(namespace, 'group_separator', '\n')

	parser.add_argument('--array-ellipsis', default=array_ellipsis_default, type=str, help='ellipsis for arrays, default: {0}{1}'.format(array_ellipsis_default, array_ellipsis_help_suffix), metavar='<array-ellipsis>')
	parser.add_argument('--no-escaped-input', const=True, default=no_escaped_input_default, action='store_const', help='disable escaped input of values')
	parser.add_argument('--no-escaped-output', const=True, default=no_escaped_output_default, action='store_const', help='disable escaped output of values')
	parser.add_argument('--no-symbolic-input', const=True, default=no_symbolic_input_default, action='store_const', help='disable symbolic input of values')
	parser.add_argument('--no-symbolic-output', const=True, default=no_symbolic_output_default, action='store_const', help='disable symbolic output of values')
	parser.add_argument('command', choices=command_choices, help='{' + ', '.join(command_choices) + '}', metavar='<command>')
	parser.add_argument('args', nargs=argparse.REMAINDER, help='command specific arguments', metavar='<args>')

	args = parser.parse_args(argv, namespace)

	ctx.host = args.host
	ctx.port = args.port
	ctx.secret = args.secret
	ctx.item_separator = args.item_separator
	ctx.group_separator = args.group_separator
	ctx.array_ellipsis = args.array_ellipsis
	ctx.no_escaped_input = args.no_escaped_input
	ctx.no_escaped_output = args.no_escaped_output
	ctx.no_symbolic_input = args.no_symbolic_input
	ctx.no_symbolic_output = args.no_symbolic_output

	if not ctx.no_escaped_input:
		try:
			ctx.item_separator = ctx.item_separator.decode('string-escape')
		except ValueError:
			parser.error('argument --item-separator: invalid escape sequence: %r' % ctx.item_separator)

		try:
			ctx.group_separator = ctx.group_separator.decode('string-escape')
		except ValueError:
			parser.error('argument --group-separator: invalid escape sequence: %r' % ctx.group_separator)

		try:
			ctx.array_ellipsis = ctx.array_ellipsis.decode('string-escape')
		except ValueError:
			parser.error('argument --array-ellipsis: invalid escape sequence: %r' % ctx.array_ellipsis)

	commands = {
	'call': command_call,
	'dispatch': command_dispatch,
	'enumerate': command_enumerate
	}

	if not listen_mode:
		commands['listen'] = command_listen

	commands[args.command](ctx, args.args)

def terminate(signal=None, frame=None):
	sys.exit(ERROR_INTERRUPTED)

def main():
	signal.signal(signal.SIGINT, terminate)
	signal.signal(signal.SIGTERM, terminate)

	ctx = Context()

	try:
		parse(ctx, sys.argv[1:])
	except KeyboardInterrupt:
		sys.exit(ERROR_INTERRUPTED)
	except ParserExit:
		sys.exit(0)
	except FatalError as e:
		if ctx.current_parser != None:
			prog = ctx.current_parser.prog
		else:
			prog = 'tinkerforge'

		sys.stderr.write('{0}: error: {1}\n'.format(prog, e.message))
		sys.exit(e.exit_code)

if __name__ == '__main__':
	main()
